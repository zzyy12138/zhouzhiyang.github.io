<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>EZLippi-浮生志</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.ezlippi.com/"/>
  <updated>2018-04-24T14:39:21.366Z</updated>
  <id>http://www.ezlippi.com/</id>
  
  <author>
    <name>EZLippi</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Elasticsearch translog文件介绍</title>
    <link href="http://www.ezlippi.com//blog/2018/04/elasticsearch-translog.html"/>
    <id>http://www.ezlippi.com//blog/2018/04/elasticsearch-translog.html</id>
    <published>2018-04-24T07:38:32.000Z</published>
    <updated>2018-04-24T14:39:21.366Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍Elasticsearch的索引工作机制,它是如何利用translog来保证数据的安全,以及我们在生产环境中如何优化translog的参数来最大化性能,主要会介绍到elastic中常见的2个操作:refresh和flush，以及这2个接口是如何保证数据能够被检索到的。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://www.ezlippi.com/categories/JVM/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
      <category term="Elasticsearch" scheme="http://www.ezlippi.com/tags/Elasticsearch/"/>
    
      <category term="translog" scheme="http://www.ezlippi.com/tags/translog/"/>
    
  </entry>
  
  <entry>
    <title>MySQL常用参数列表</title>
    <link href="http://www.ezlippi.com//blog/2018/04/mysql-settings.html"/>
    <id>http://www.ezlippi.com//blog/2018/04/mysql-settings.html</id>
    <published>2018-04-12T07:38:32.000Z</published>
    <updated>2018-04-12T13:53:46.196Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;收集一些常用的MySQL参数，方便日后使用。&lt;br&gt;
    
    </summary>
    
      <category term="MySQL" scheme="http://www.ezlippi.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="http://www.ezlippi.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>慎用java的finalize方法</title>
    <link href="http://www.ezlippi.com//blog/2018/04/final-reference.html"/>
    <id>http://www.ezlippi.com//blog/2018/04/final-reference.html</id>
    <published>2018-04-04T07:38:32.000Z</published>
    <updated>2018-04-04T07:02:18.322Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们通常用构造器来创建对象,而Finalize正好相反,构造方法执行对象的初始化操作,finalize方法执行对象的销毁操作.&lt;br&gt;那我们什么时候需要使用finalize方法呢,我们都知道Java里垃圾回收器可以回收对象使用的内存空间,但是对象可能会&lt;br&gt;持有很多资源比如Socket、文件句柄等,垃圾收集器无法回收这些资源,因此你需要使用finalize方法帮助GC回收这些&lt;br&gt;资源,比如关闭打开的文件或者网元资源,删除临时文件等.&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://www.ezlippi.com/categories/JVM/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM解惑:消失的异常堆栈</title>
    <link href="http://www.ezlippi.com//blog/2018/02/the-missing-stacktrace.html"/>
    <id>http://www.ezlippi.com//blog/2018/02/the-missing-stacktrace.html</id>
    <published>2018-02-04T07:38:32.000Z</published>
    <updated>2018-02-04T08:29:14.443Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在分析日志的时候发现有个日志捕捉了NullPointerException，但是没有异常堆栈信息,只有&lt;code&gt;java.lang.NullPointerException&lt;/code&gt;这一条信息,无法知道是从哪里抛出来的, 经过分析是JIT编译器对异常进行了优化，当代码中的某个位置抛出同一个异常很多次后,JIT服务端编译器(C2)会将其优化成抛出一个事先编译好的、类型匹配的异常,异常堆栈信息就看不到了。&lt;br&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://www.ezlippi.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加在线联系功能</title>
    <link href="http://www.ezlippi.com//blog/2018/01/next-chat.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/next-chat.html</id>
    <published>2018-01-29T12:38:32.000Z</published>
    <updated>2018-01-29T14:23:57.207Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.ezlippi.com/categories/hexo/"/>
    
    
      <category term="Hexo" scheme="http://www.ezlippi.com/tags/Hexo/"/>
    
      <category term="Chat" scheme="http://www.ezlippi.com/tags/Chat/"/>
    
  </entry>
  
  <entry>
    <title>JVM调优:CardTable简介</title>
    <link href="http://www.ezlippi.com//blog/2018/01/jvm-card-table-turning.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/jvm-card-table-turning.html</id>
    <published>2018-01-27T16:38:32.000Z</published>
    <updated>2018-01-28T08:16:30.445Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;网上关于JVM调优的文章很多,这篇文章主要介绍JVM里Card Table的作用。我们知道JVM GC可以分为MinorGC、MajorGC和FullGC,对于Mirnor GC来讲它的耗时主要由两个因素决定:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;复制活跃对象的时间&lt;/li&gt;
&lt;li&gt;扫描card table(老年代对象引用新生代对象)的时间&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>btrace动态追踪技术解析</title>
    <link href="http://www.ezlippi.com//blog/2018/01/btrace-introduce.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/btrace-introduce.html</id>
    <published>2018-01-26T05:38:32.000Z</published>
    <updated>2018-01-25T15:45:41.529Z</updated>
    
    <summary type="html">
    
      &lt;p&gt; 开发环境定位问题手段较多,可以加日志、远程调试hotswap等,但在生产环境就没这么方便了,服务上线后就不能随便重启,比如某个接口有时候返回的数据异常,日志又没打印详情,这时候又想知道方法的入参是什么、是否调用了内部某个方法，或者接口响应时间较长想排查具体在哪个方法上调用比较耗时，这些场景都需要用到动态追踪的技术,btrace就是一个能帮助你分析和监控JVM的工具,采用了动态attach到目标JVM的方法,非侵入式监控,主要使用了JVMT(JVM Tool Interface)和Instrumentation技术,国内介绍btrace的文章并不多,最近正好要在部门内分享btrace的使用心得,因此整理了这篇文档,希望能够把btrace里的技术讲清楚。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="Instrumention" scheme="http://www.ezlippi.com/tags/Instrumention/"/>
    
  </entry>
  
  <entry>
    <title>性能测试Gatling入门教程</title>
    <link href="http://www.ezlippi.com//blog/2018/01/gatling.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/gatling.html</id>
    <published>2018-01-23T05:38:32.000Z</published>
    <updated>2018-01-23T13:56:02.895Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Gatling 是一个功能强大的负载测试工具。它是为易用性、可维护性和高性能而设计的,它能生成丰富多彩的报告，包含测试案例中收集的所有指标,该功能似乎比 JMeter更好,因此我在实际压力测试中选用Gatling。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="Gatling" scheme="http://www.ezlippi.com/tags/Gatling/"/>
    
  </entry>
  
  <entry>
    <title>使用JMH微基准测试一切</title>
    <link href="http://www.ezlippi.com//blog/2018/01/jmh-test-guide.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/jmh-test-guide.html</id>
    <published>2018-01-20T05:38:32.000Z</published>
    <updated>2018-01-20T08:51:20.083Z</updated>
    
    <summary type="html">
    
      &lt;p&gt; 引用江南白衣的一句话:没有测试数据证明的论断，都是可疑的，诚意推荐JMH。这篇文章简要介绍怎么使用JMH来做基准测试,可以作为JMH的入门教程。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JMH" scheme="http://www.ezlippi.com/tags/JMH/"/>
    
  </entry>
  
  <entry>
    <title>JVM安全点介绍</title>
    <link href="http://www.ezlippi.com//blog/2018/01/safepoint.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/safepoint.html</id>
    <published>2018-01-15T05:38:32.000Z</published>
    <updated>2018-01-24T13:01:55.507Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h2&gt;&lt;p&gt;学习JVM到一定程度后肯定会接触到safepoint(安全点)的概念,特别是在处理GC问题的时候,这篇文章主要介绍下安全点(safepoint)的概念及如何在JVM环境中开启安全点日志来分析系统的性能.&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Log4j升级到Log4j2</title>
    <link href="http://www.ezlippi.com//blog/2018/01/slf4j-log4j2.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/slf4j-log4j2.html</id>
    <published>2018-01-11T05:38:32.000Z</published>
    <updated>2018-01-21T15:05:10.650Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我们的系统一直用的是公司统一的日志类来打印日志,看了下内部实现,仅仅是对Slf4j门面+Log4j这套做了一些封装,加入了扩展的能力，各个模块在扩展点文件中配置日志路径、级别和包名,由工具类动态生成日志配置文件，由于一直没出问题所以没太关注,但是最近有个环境经常出现响应慢、Full GC频繁的问题,我在分析线程堆栈时发现了2个问题:一个是Log4j打日志有一定概率会出现死锁;另一个是有个缓存类调用非常频繁,很多线程都卡在打印日志那里,分析了下发现Log4j里每个Logger对象一把锁,同一个类里面打印日志的方法只能串行执行,效率非常低，经过研究对比了几个日志框架之后决定先把我们组的日志框架迁移到Log4j2,后面在部门内推广使用。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="Logger" scheme="http://www.ezlippi.com/tags/Logger/"/>
    
  </entry>
  
  <entry>
    <title>Linux性能问题定位总结</title>
    <link href="http://www.ezlippi.com//blog/2018/01/linux-perf-turning.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/linux-perf-turning.html</id>
    <published>2018-01-08T05:38:32.000Z</published>
    <updated>2018-01-08T14:00:46.764Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;当一个系统出现前台响应慢、接口返回慢等情况时,可以考虑分析是否存在性能瓶颈了，性能瓶颈可以分为2种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;CPU高(这里指长期使用率超过75%)，包括用户态CPU+内核态CPU，这类问题比较常见，通过结合TOP命令和抓取线程堆栈可以找到耗资源最多的线程，然后分析调用堆栈进行优化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;CPU使用率不高,但是系统还是响应慢&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
      <category term="Linux" scheme="http://www.ezlippi.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>理解GC日志</title>
    <link href="http://www.ezlippi.com//blog/2018/01/understand-gc-log.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/understand-gc-log.html</id>
    <published>2018-01-07T05:38:32.000Z</published>
    <updated>2018-01-07T13:11:16.690Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;给CMS GC搭配&lt;code&gt;-XX:+PrintGCDetails&lt;/code&gt;和&lt;code&gt;-XX:+PrintGCTimeStamps&lt;/code&gt;可以打印出很多关于GC的信息.理解GC日志信息可以帮助日常的性能调优以达到最优的性能。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JIT引起系统Load高分析</title>
    <link href="http://www.ezlippi.com//blog/2018/01/linux-high-load.html"/>
    <id>http://www.ezlippi.com//blog/2018/01/linux-high-load.html</id>
    <published>2018-01-06T05:38:32.000Z</published>
    <updated>2018-01-07T10:45:23.824Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;有个应用在启动的初期系统的load会飚的很高,导致监控系统报了告警，经过分析是JVM对热点代码做JIT即时编译导致CPU使用率很高，而此时Web容器收到了大量的请求但是系统处理请求较慢导致业务的线程池满出现异常,这篇文章主要分析load高的可能原因以及JIT编译的一些基础知识。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="JVM" scheme="http://www.ezlippi.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>BTrace使用教程</title>
    <link href="http://www.ezlippi.com//blog/2017/12/btrace-guide.html"/>
    <id>http://www.ezlippi.com//blog/2017/12/btrace-guide.html</id>
    <published>2017-12-10T05:38:32.000Z</published>
    <updated>2017-12-10T09:55:47.790Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;线下的应用遇到问题时我们可以通过改代码加日志追踪或者通过远程调试来获取运行时的程序细节,但如果应用一开始没有开启远程调试的端口,那你要修改JVM参数添加调试的参数然后重启应用,这种对于线上应用来说就不适用了,线上应用不允许随便修改代码也无法远程调试。BTrace就是一个可以在不改代码、不重启应用的情况下，动态的查看程序运行细节的工具。这篇文章主要介绍BTrace的使用场景以及如果用BTrace来输出程序的执行细节。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="WeakReference" scheme="http://www.ezlippi.com/tags/WeakReference/"/>
    
  </entry>
  
  <entry>
    <title>Java内存泄露的例子</title>
    <link href="http://www.ezlippi.com//blog/2017/12/java-memory-leak-example.html"/>
    <id>http://www.ezlippi.com//blog/2017/12/java-memory-leak-example.html</id>
    <published>2017-12-08T05:38:32.000Z</published>
    <updated>2017-12-07T16:10:53.964Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在定位JVM性能问题时可能会遇到内存泄露导致JVM OutOfMemory的情况,在使用Tomcat容器时如果设置了reloadable=”true”这个参数,在频繁热部署应用时也有可能会遇到内存溢出的情况。Tomcat的热部署原理是检测到WEB-INF/classes或者WEB-INF/lib目录下的文件发生了变更后会把应用先停止然后再启动,由于Tomcat默认给每个应用分配一个WebAppClassLoader,热替换的原理就是创建一个新的ClassLoader来加载类,由于JVM中一个类的唯一性由它的class文件和它的类加载器来决定,因此重新加载类可以达到热替换的目的。当热部署的次数比较多会导致JVM加载的类比较多,如果之前的类由于某种原因(比如内存泄露)没有及时卸载就可能导致永久代或者MetaSpace的OutOfMemory。这篇文章通过一个Demo来简要介绍下ThreadLocal和ClassLoader导致内存泄露最终OutOfMemory的场景。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="WeakReference" scheme="http://www.ezlippi.com/tags/WeakReference/"/>
    
  </entry>
  
  <entry>
    <title>Java ThreadLocal原理分析</title>
    <link href="http://www.ezlippi.com//blog/2017/12/threadlocal.html"/>
    <id>http://www.ezlippi.com//blog/2017/12/threadlocal.html</id>
    <published>2017-12-05T05:38:32.000Z</published>
    <updated>2017-12-07T16:11:21.426Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;大家或多或少听说过ThreadLocal这个词,我们创建的对象默认是所有线程可以访问的,多线程并发修改对象时就会可能出现数据不一致的问题,使用ThreadLocal创建的对象只能被当前线程访问，每个线程保存一个对象的副本,在多线程操作时是线程安全的。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="WeakReference" scheme="http://www.ezlippi.com/tags/WeakReference/"/>
    
  </entry>
  
  <entry>
    <title>WeakHashMap原理分析</title>
    <link href="http://www.ezlippi.com//blog/2017/11/java-weak-reference.html"/>
    <id>http://www.ezlippi.com//blog/2017/11/java-weak-reference.html</id>
    <published>2017-11-28T05:38:32.000Z</published>
    <updated>2017-11-28T15:26:11.709Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在比较简单的应用场景下我们常用HashMap来缓存一些数据,比如建立Socket连接时需要保存Socket关联的用户,这个信息无法直接添加到Socket对象的属性中,那就可以通过Map来保存这些元数据信息。但这样子会产生一个问题，对象元数据的生命周期需要与套接字(Socket)的生命周期挂钩，除非你准确地知道应用程序什么时候不再需要这个套接字，并记住从Map中删除相应的映射，否则，Socket和User对象将会永远留在Map中，远远超过了套接字的生命周期，而且HashMap会对key和value持有一个强引用，这会阻止Socket和User对象被垃圾收集，到最后时间长了可能导致JVM OutOfMemory。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="WeakReference" scheme="http://www.ezlippi.com/tags/WeakReference/"/>
    
  </entry>
  
  <entry>
    <title>Java ClassLoader loader constraints分析</title>
    <link href="http://www.ezlippi.com//blog/2017/11/java-classloader-constraint.html"/>
    <id>http://www.ezlippi.com//blog/2017/11/java-classloader-constraint.html</id>
    <published>2017-11-12T05:38:32.000Z</published>
    <updated>2017-11-13T15:02:49.351Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在和Web容器打交道的时候大家有时候会遇到&lt;code&gt;java.lang.LinkageError: loader constraint violation: loader (instance of &amp;lt;bootloader&amp;gt;) previously initiated loading for a different type with name ...&lt;/code&gt;这个错误，网上的教程都是说类加载冲突了,把从pom文件里把servlet和el这些依赖的scope改为provided，或者将Tomcat webapp类加载器的delegate属性改为true，让Tomcat的CommonClassLoader来加载,但是始终找不到一篇文章来具体分析这个错误。这篇文章从原理和实践的角度来介绍为什么要这么做。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="ClassLoader" scheme="http://www.ezlippi.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务源码分析</title>
    <link href="http://www.ezlippi.com//blog/2017/10/spring-transation-sourcecode.html"/>
    <id>http://www.ezlippi.com//blog/2017/10/spring-transation-sourcecode.html</id>
    <published>2017-10-10T05:38:32.000Z</published>
    <updated>2017-10-10T14:56:22.645Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;事务管理能保证一系列操作以原子的方式执行,Spring框架提供了非常完善的事务支持,Spring事务管理主要围绕着TransactionDefinition,&lt;br&gt;AbstractPlatformTransactionManager,TransactionSynchronizationManager,DataSourceTransactionManager这几个类.&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="Spring" scheme="http://www.ezlippi.com/tags/Spring/"/>
    
      <category term="Transaction" scheme="http://www.ezlippi.com/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>为什么不推荐使用-XX:+DisableExplicitGC</title>
    <link href="http://www.ezlippi.com//blog/2017/10/why-not-expliclitgc.html"/>
    <id>http://www.ezlippi.com//blog/2017/10/why-not-expliclitgc.html</id>
    <published>2017-10-09T05:38:32.000Z</published>
    <updated>2017-10-09T13:44:21.659Z</updated>
    
    <summary type="html">
    
      &lt;h3 id=&quot;System-gc-与NIO框架&quot;&gt;&lt;a href=&quot;#System-gc-与NIO框架&quot; class=&quot;headerlink&quot; title=&quot;System.gc()与NIO框架&quot;&gt;&lt;/a&gt;System.gc()与NIO框架&lt;/h3&gt;&lt;p&gt;System.gc()默认会触发一次Full Gc,如果在代码中不小心调用了System.gc()会导致JVM间歇性的暂停,但有些NIO框架&lt;br&gt;比如Netty框架经常会使用DirectByteBuffer来分配堆外内存,在分配之前会显式的调用System.gc(),如果开启了DisableExplicitGC&lt;br&gt;这个参数,会导致System.gc()调用变成一个空调用,没有任何作用,反而会导致Netty框架无法申请到足够的堆外内存,从而产生&lt;br&gt;java.lang.OutOfMemoryError: Direct buffer memory.&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="Jvm" scheme="http://www.ezlippi.com/tags/Jvm/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis多数据源配置实现读写分离</title>
    <link href="http://www.ezlippi.com//blog/2017/09/mybatis-multidatasource.html"/>
    <id>http://www.ezlippi.com//blog/2017/09/mybatis-multidatasource.html</id>
    <published>2017-09-29T05:38:32.000Z</published>
    <updated>2017-09-29T14:53:10.612Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;常见的数据库连接池有C3P0、DBCP和阿里巴巴的druid,后两个在实际场景中用的比较多,这个案例简单介绍Spring+Druid+MyBatis&lt;br&gt;实现多数据源配置,基本原理是继承自Spring提供的AbstractRoutingDataSource这个抽象类,把所有的DataSource放到Map里面,&lt;br&gt;然后重写determineCurrentLookupKey()这个方法,Spring的AbstractRoutingDataSource在获取数据库连接时会先调用&lt;br&gt;determineCurrentLookupKey()方法来找到数据库的key值,然后从Map中找到对应的DataSource获取数据库连接。&lt;/p&gt;
    
    </summary>
    
      <category term="Database" scheme="http://www.ezlippi.com/categories/Database/"/>
    
    
      <category term="MyBatis" scheme="http://www.ezlippi.com/tags/MyBatis/"/>
    
      <category term="DataBase" scheme="http://www.ezlippi.com/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 缓存介绍</title>
    <link href="http://www.ezlippi.com//blog/2017/08/mybatis-cache.html"/>
    <id>http://www.ezlippi.com//blog/2017/08/mybatis-cache.html</id>
    <published>2017-08-07T05:38:32.000Z</published>
    <updated>2017-08-07T14:32:51.315Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一级缓存&quot;&gt;&lt;a href=&quot;#一级缓存&quot; class=&quot;headerlink&quot; title=&quot;一级缓存&quot;&gt;&lt;/a&gt;一级缓存&lt;/h2&gt;&lt;p&gt;一级缓存是本地缓存，和BaseExecutor关联,BaseExecutor有三个实现类，SimpleExecutor、ReuseExecutor和BatchExecutor,&lt;br&gt;SqlSession初始化时会创建Executor的实例，Mybatis默认使用的是SimpleExecutor,初始化代码如下所示:&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.ezlippi.com/tags/MyBatis/"/>
    
      <category term="DataBase" scheme="http://www.ezlippi.com/tags/DataBase/"/>
    
      <category term="Dao" scheme="http://www.ezlippi.com/tags/Dao/"/>
    
  </entry>
  
  <entry>
    <title>单元测试框架PowerMock教程</title>
    <link href="http://www.ezlippi.com//blog/2017/08/powermock-introduction.html"/>
    <id>http://www.ezlippi.com//blog/2017/08/powermock-introduction.html</id>
    <published>2017-08-06T05:38:32.000Z</published>
    <updated>2017-08-06T11:52:48.118Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Mockito 是一个针对 Java 的单元测试模拟框架，它与 EasyMock 和 jMock 很相似，都是为了简化单元测试过程中测试上下文的搭建而开发的工具。&lt;/p&gt;
&lt;p&gt;PowerMock 也是一个单元测试模拟框架，它是在其它单元测试模拟框架的基础上做出的扩展。通过提供定制的类加载器以及一些字节码篡改技巧的应用，PowerMock 现了对静态方法、构造方法、私有方法以及 Final 方法的模拟支持，对静态初始化过程的移除等强大的功能。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="Junit" scheme="http://www.ezlippi.com/tags/Junit/"/>
    
      <category term="PowerMock" scheme="http://www.ezlippi.com/tags/PowerMock/"/>
    
      <category term="Mock" scheme="http://www.ezlippi.com/tags/Mock/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch Java客户端介绍</title>
    <link href="http://www.ezlippi.com//blog/2017/03/elasticsearch-java-client.html"/>
    <id>http://www.ezlippi.com//blog/2017/03/elasticsearch-java-client.html</id>
    <published>2017-03-10T05:38:32.000Z</published>
    <updated>2017-03-11T14:17:23.308Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍ElasticSearch客户端，包括Transport客户端、Jest客户端和Spring Data ElasticSearch,首先来看几个基本概念。&lt;/p&gt;
&lt;h2 id=&quot;ElasticSearch&quot;&gt;&lt;a href=&quot;#ElasticSearch&quot; class=&quot;headerlink&quot; title=&quot;ElasticSearch&quot;&gt;&lt;/a&gt;ElasticSearch&lt;/h2&gt;&lt;p&gt;官方的介绍:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ElasticSearch是一个分布式的、基于Json的检索引擎，具有水平扩展、高可靠性和易于管理等优点。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了更好的理解ealsticsearch的作用，我们可以看下Github的搜索页面:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/elasticsearch_github.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们在输入框输入一个单词，会列出许多查询结果，搜索引擎和数据库的区别就是相关性，&lt;br&gt;我们可以看到elasticsearch的项目排在第一位，很有可能别人在搜索这个关键词时想要访问这个项目。对于不同的应用影响排名的因素可能各不一样。&lt;/p&gt;
&lt;p&gt;如果你想建立一个像这样的搜索引擎，首先你的安装elasticsearch,elasticsearch很容易安装，你只需要先安装好Java虚拟机就可以了。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="DataBase" scheme="http://www.ezlippi.com/tags/DataBase/"/>
    
      <category term="ElasticSearch" scheme="http://www.ezlippi.com/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis教程</title>
    <link href="http://www.ezlippi.com//blog/2017/02/mybatis-intorduction.html"/>
    <id>http://www.ezlippi.com//blog/2017/02/mybatis-intorduction.html</id>
    <published>2017-02-12T05:38:32.000Z</published>
    <updated>2017-03-11T15:43:23.549Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;MyBatis是一个优秀的ORM(对象关系映射)框架，和Hibernate不太一样，Hibernate不用你编写一行SQL语句，而MyBatis需要手写SQL语句，优点就是能够灵活调试SQL语句。这篇文章主要对MyBatis的几个核心概念进行介绍，以及如何在项目中使用MyBatis。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
      <category term="MyBatis" scheme="http://www.ezlippi.com/tags/MyBatis/"/>
    
      <category term="ORM" scheme="http://www.ezlippi.com/tags/ORM/"/>
    
      <category term="DataBase" scheme="http://www.ezlippi.com/tags/DataBase/"/>
    
  </entry>
  
  <entry>
    <title>SED教程</title>
    <link href="http://www.ezlippi.com//blog/2017/02/sed-introduction.html"/>
    <id>http://www.ezlippi.com//blog/2017/02/sed-introduction.html</id>
    <published>2017-02-08T05:38:32.000Z</published>
    <updated>2017-03-11T15:48:16.878Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;SED是一个简单强大的文本处理工具，作为标准命令被收集到UNIX系的OS中，它将指定的文本逐行读入，根据给定的条件进行处理。把sed当做单行脚本使用，紧跟着-e选项，就能把处理的内容作为脚本记述下来，如果用-f选项，就可以读取事先准备的脚本文件。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="http://www.ezlippi.com/categories/Linux/"/>
    
    
      <category term="SED" scheme="http://www.ezlippi.com/tags/SED/"/>
    
  </entry>
  
  <entry>
    <title>Hexo博客添加站内搜索</title>
    <link href="http://www.ezlippi.com//blog/2017/02/hexo-search.html"/>
    <id>http://www.ezlippi.com//blog/2017/02/hexo-search.html</id>
    <published>2017-02-02T11:38:32.000Z</published>
    <updated>2017-02-05T13:54:08.011Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。&lt;br&gt;
    
    </summary>
    
      <category term="hexo" scheme="http://www.ezlippi.com/categories/hexo/"/>
    
    
      <category term="jekyll" scheme="http://www.ezlippi.com/tags/jekyll/"/>
    
      <category term="blog" scheme="http://www.ezlippi.com/tags/blog/"/>
    
      <category term="hexo" scheme="http://www.ezlippi.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>优秀的程序员都在用谷歌</title>
    <link href="http://www.ezlippi.com//blog/2017/02/ss-proxy-guide.html"/>
    <id>http://www.ezlippi.com//blog/2017/02/ss-proxy-guide.html</id>
    <published>2017-02-02T05:38:32.000Z</published>
    <updated>2017-02-05T14:34:53.525Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;众所周知，百度在搜索技术资料方面简直是个白痴，而且GitHub的博客屏蔽了百度蜘蛛的抓取，在公司内每次看到有人用百度来搜索资料我都会建议他改用谷歌搜索，在搜索资料时一个好的搜索引擎是不需要你查看第三页的内容的，大部分情况前几个搜索结果就能解决你的问题。&lt;br&gt;
    
    </summary>
    
      <category term="google" scheme="http://www.ezlippi.com/categories/google/"/>
    
    
      <category term="google" scheme="http://www.ezlippi.com/tags/google/"/>
    
      <category term="hosts" scheme="http://www.ezlippi.com/tags/hosts/"/>
    
  </entry>
  
  <entry>
    <title>Maven生命周期和插件</title>
    <link href="http://www.ezlippi.com//blog/2016/08/maven-lifecycle-introduction.html"/>
    <id>http://www.ezlippi.com//blog/2016/08/maven-lifecycle-introduction.html</id>
    <published>2016-08-02T05:38:32.000Z</published>
    <updated>2016-08-07T14:06:18.092Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Maven有几个核心的概念，包括坐标、依赖、仓库，这几个概念比较容易理解，Maven另外两个重要的概念是生命周期和插件，你在工作中可能会经常使用maven clean install这样的命令来打包项目，但是你有没有仔细想过这两个命令会执行哪些操作。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="maven" scheme="http://www.ezlippi.com/tags/maven/"/>
    
      <category term="lifecycle" scheme="http://www.ezlippi.com/tags/lifecycle/"/>
    
      <category term="plugins" scheme="http://www.ezlippi.com/tags/plugins/"/>
    
  </entry>
  
  <entry>
    <title>利用Jacoco计算单元测试覆盖率</title>
    <link href="http://www.ezlippi.com//blog/2016/06/Jacoco-coverage.html"/>
    <id>http://www.ezlippi.com//blog/2016/06/Jacoco-coverage.html</id>
    <published>2016-06-26T05:10:05.000Z</published>
    <updated>2016-06-28T15:10:09.305Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;随着敏捷开发的流行，编写单元测试已经成为业界共识。TDD(测试驱动开发)的思想也强调了测试的重要性，怎么去衡量我们的测试代码的质量呢，常见的办法就是计算测试的覆盖率，常见的Java的覆盖率计算工具有JCov、Cobertura和Jacoco，三者都支持对class文件离线插桩，JCov和Jacoco还支持动态插桩，单元测试和集成测试都无法在模拟真实的运行环境，存在一定的局限性。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="单元测试" scheme="http://www.ezlippi.com/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
      <category term="覆盖率" scheme="http://www.ezlippi.com/tags/%E8%A6%86%E7%9B%96%E7%8E%87/"/>
    
  </entry>
  
  <entry>
    <title>Java NIO 基本概念</title>
    <link href="http://www.ezlippi.com//blog/2016/06/java-nio-concept.html"/>
    <id>http://www.ezlippi.com//blog/2016/06/java-nio-concept.html</id>
    <published>2016-06-04T11:16:21.000Z</published>
    <updated>2016-06-04T13:23:26.234Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;学Java的都会接触到IO，传统的IO是基于字节流和字符流的，数据只能单向传输，JDK1.5引入了NIO，主要包含三个核心概念，Selector,Buffer和Channel。NIO中数据都是通过缓冲区来操作，缓冲区中数据可以移动，可以通过buffer.flip()来改变读写模式，比如调用channel.read(buffer)从文件中写入数据到buffer,之后调用buffer.flip(),再调用Buffer.get()就可以读取buffer里的数据。&lt;br&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.ezlippi.com/categories/Java/"/>
    
    
      <category term="NIO" scheme="http://www.ezlippi.com/tags/NIO/"/>
    
      <category term="Java" scheme="http://www.ezlippi.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Android APK签名详解</title>
    <link href="http://www.ezlippi.com//blog/2016/03/android-apk-signing.html"/>
    <id>http://www.ezlippi.com//blog/2016/03/android-apk-signing.html</id>
    <published>2016-03-23T11:16:21.000Z</published>
    <updated>2016-03-25T02:27:04.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;App为什么需要签名？&quot;&gt;&lt;a href=&quot;#App为什么需要签名？&quot; class=&quot;headerlink&quot; title=&quot;App为什么需要签名？&quot;&gt;&lt;/a&gt;App为什么需要签名？&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;对Apk的完整性和发布机构唯一性的校验&lt;/li&gt;
&lt;li&gt;签名之后无法阻止APK被人修改，但修改后再签名就和原先的签名不一致，可以避免有些人用相同包名的APK来替换已有的应用&lt;/li&gt;
&lt;li&gt;相同签名的升级软件可以覆盖安装旧版本的软件&lt;/li&gt;
&lt;li&gt;签名的私钥在开发者那里，公钥打包在APK内，不同公钥对应不同私钥，通过比较公钥可以判断私钥是否一致&lt;/li&gt;
&lt;li&gt;允许代码和数据共享。android中提供了一个基于签名的Permission标签。通过允许的设置，我们可以实现对不同App之间的访问和共享，如下：&lt;/li&gt;
&lt;/ol&gt;
&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;AndroidManifest.xml：&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;permission&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;android:protectionLevel&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;normal&quot;&lt;/span&gt; /&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;其中protectionLevel标签有4种值：normal(缺省值),dangerous, signature,signatureOrSystem。normal是低风险的，所有的App不能访问和共享此App。dangerous是高风险的，所有的App都能访问和共享此App。signature是指具有相同签名的App可以访问和共享此App。&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.ezlippi.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.ezlippi.com/tags/Android/"/>
    
      <category term="APK" scheme="http://www.ezlippi.com/tags/APK/"/>
    
      <category term="签名" scheme="http://www.ezlippi.com/tags/%E7%AD%BE%E5%90%8D/"/>
    
  </entry>
  
  <entry>
    <title>Android反编译(逆向)教程</title>
    <link href="http://www.ezlippi.com//blog/2016/03/android-apk-classy.html"/>
    <id>http://www.ezlippi.com//blog/2016/03/android-apk-classy.html</id>
    <published>2016-03-20T10:16:21.000Z</published>
    <updated>2016-03-20T11:44:57.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在网上搜索Android反编译教程，搜出来的文章要么是抄袭的，要么是太过与简单，经过自己的实践和摸索，我在这里记录下如下反编译一个Apk并修改一些资源文件，比如App名字、启动界面等，然后重新打包成apk,你可以参照这个教程修改游戏里的金币(估计没这么简单)。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.ezlippi.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://www.ezlippi.com/tags/Android/"/>
    
      <category term="逆向" scheme="http://www.ezlippi.com/tags/%E9%80%86%E5%90%91/"/>
    
      <category term="反编译" scheme="http://www.ezlippi.com/tags/%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Jekyll迁移到Hexo搭建个人博客</title>
    <link href="http://www.ezlippi.com//blog/2016/02/jekyll-to-hexo.html"/>
    <id>http://www.ezlippi.com//blog/2016/02/jekyll-to-hexo.html</id>
    <published>2016-02-26T16:00:00.000Z</published>
    <updated>2017-03-11T15:45:07.440Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;个人博客以前由jekyll搭建，主要问题是目录、Rss、sitemap无法自动生成，根据DRY的原则在网上找了下答案，最终发现了用Hexo来搭建博客的方法，配置完之后一劳永逸，目录、Rss和sitemap都是自动生成，解决了我之前的困惑。&lt;/p&gt;
&lt;h2 id=&quot;从Jekyll迁移到Hexo&quot;&gt;&lt;a href=&quot;#从Jekyll迁移到Hexo&quot; class=&quot;headerlink&quot; title=&quot;从Jekyll迁移到Hexo&quot;&gt;&lt;/a&gt;从Jekyll迁移到Hexo&lt;/h2&gt;&lt;h3 id=&quot;安装Hexo&quot;&gt;&lt;a href=&quot;#安装Hexo&quot; class=&quot;headerlink&quot; title=&quot;安装Hexo&quot;&gt;&lt;/a&gt;安装Hexo&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;安装&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir hexo  &lt;span class=&quot;comment&quot;&gt;#创建一个文件夹&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; hexo&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install -g hexo-cli&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm install hexo --save&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Hexo" scheme="http://www.ezlippi.com/categories/Hexo/"/>
    
    
      <category term="jekyll" scheme="http://www.ezlippi.com/tags/jekyll/"/>
    
      <category term="hexo" scheme="http://www.ezlippi.com/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>Git操作手册|命令速查表</title>
    <link href="http://www.ezlippi.com//blog/2016/02/git-guide.html"/>
    <id>http://www.ezlippi.com//blog/2016/02/git-guide.html</id>
    <published>2016-02-19T16:00:00.000Z</published>
    <updated>2016-02-29T12:30:22.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。&lt;br&gt;本文分为以下几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Git与SVN差异&lt;/li&gt;
&lt;li&gt;Git常用命令&lt;/li&gt;
&lt;li&gt;Git进阶指南&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Git" scheme="http://www.ezlippi.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://www.ezlippi.com/tags/Git/"/>
    
      <category term="VCS" scheme="http://www.ezlippi.com/tags/VCS/"/>
    
  </entry>
  
  <entry>
    <title>解决百度爬虫无法抓取github pages</title>
    <link href="http://www.ezlippi.com//blog/2016/02/baidu-spider-forbidden.html"/>
    <id>http://www.ezlippi.com//blog/2016/02/baidu-spider-forbidden.html</id>
    <published>2016-02-17T16:00:00.000Z</published>
    <updated>2016-02-29T12:30:58.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;由于Github Pages禁止了百度爬虫，导致自己的博客无法被百度索引到，使用七牛云和又拍云做镜像存储能解决问题，但是要求域名要备案，由于我的域名从Godaddy上购买的，国内备案手续太复杂，故放弃了CDN的办法，琢磨了一段时间找到了Gitcafe的解决办法。&lt;/p&gt;
&lt;h2 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h2&gt;&lt;p&gt;既然不想放弃Github，唯一的办法就是不让百度爬虫直接抓取GIthub的内容，而是抓取自己网站的一个镜像，将网站的内容镜像到&lt;a href=&quot;www.gitcafe.com&quot;&gt;gitcafe&lt;/a&gt;,步骤如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Unix/Linux" scheme="http://www.ezlippi.com/categories/Unix-Linux/"/>
    
    
      <category term="github" scheme="http://www.ezlippi.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下Apache服务器的配置</title>
    <link href="http://www.ezlippi.com//blog/2016/01/apache-configuration-in-ubuntu.html"/>
    <id>http://www.ezlippi.com//blog/2016/01/apache-configuration-in-ubuntu.html</id>
    <published>2016-01-19T16:00:00.000Z</published>
    <updated>2016-02-29T13:53:50.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装Apache&quot;&gt;&lt;a href=&quot;#安装Apache&quot; class=&quot;headerlink&quot; title=&quot;安装Apache&quot;&gt;&lt;/a&gt;安装Apache&lt;/h2&gt;
    
    </summary>
    
      <category term="Unix/Linux" scheme="http://www.ezlippi.com/categories/Unix-Linux/"/>
    
    
      <category term="web" scheme="http://www.ezlippi.com/tags/web/"/>
    
      <category term="linux" scheme="http://www.ezlippi.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>终端复用软件之tmux简介</title>
    <link href="http://www.ezlippi.com//blog/2016/01/tmux-guide.html"/>
    <id>http://www.ezlippi.com//blog/2016/01/tmux-guide.html</id>
    <published>2016-01-18T17:05:13.000Z</published>
    <updated>2016-03-01T06:00:44.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;  Tmux是一个优秀的终端复用软件，支持多标签，也支持窗口内部面板的分割，更重要的是，Tmux提供了窗体随时保存和恢复的功能。想象一下假如你在公司的服务器上开了许多窗口调试程序，回到家时通过SSH连接公司电脑又要打开一堆繁琐的窗口，而且还忘记了当时调试到哪一步了，那Tmux可以帮你解决这个难题，当SSH连接断开重新连接后能够恢复到原来的工作环境。&lt;/p&gt;
    
    </summary>
    
      <category term="Unix/Linux" scheme="http://www.ezlippi.com/categories/Unix-Linux/"/>
    
    
      <category term="shell" scheme="http://www.ezlippi.com/tags/shell/"/>
    
      <category term="linux" scheme="http://www.ezlippi.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>提高效率的Android Studio插件</title>
    <link href="http://www.ezlippi.com//blog/2015/09/android-studio-plugins.html"/>
    <id>http://www.ezlippi.com//blog/2015/09/android-studio-plugins.html</id>
    <published>2015-09-08T16:00:00.000Z</published>
    <updated>2016-02-29T13:14:18.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这里记录那些可以显著提升Android开发效率的Studio插件，好的插件和快捷键可以提高效率，缩短开发周期。这里介绍的插件大部分都可以通过Studio的插件市场下载安装，安装方法如下：&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="http://www.ezlippi.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
      <category term="studio" scheme="http://www.ezlippi.com/tags/studio/"/>
    
  </entry>
  
  <entry>
    <title>Volley源码分析</title>
    <link href="http://www.ezlippi.com//blog/2015/08/volley-source-code.html"/>
    <id>http://www.ezlippi.com//blog/2015/08/volley-source-code.html</id>
    <published>2015-08-26T16:00:00.000Z</published>
    <updated>2016-02-29T13:54:57.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;说到Android的网络库，比较常用的就是Volley和okHttp了，最近重温了下Volley的源码，感觉应该写点什么．Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架，适合数据量小通信比较频繁的情形．&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
      <category term="android" scheme="http://www.ezlippi.com/categories/java/android/"/>
    
    
      <category term="network,　异步, Volley, android" scheme="http://www.ezlippi.com/tags/network-%E5%BC%82%E6%AD%A5-Volley-android/"/>
    
  </entry>
  
  <entry>
    <title>Zsh-Linux下最好的Shell简介</title>
    <link href="http://www.ezlippi.com//blog/2015/08/linux-zsh.html"/>
    <id>http://www.ezlippi.com//blog/2015/08/linux-zsh.html</id>
    <published>2015-08-22T16:00:00.000Z</published>
    <updated>2016-02-29T13:12:52.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;没听过Shell?Shell是Unix/Linux系统下的外壳，负责外界和Linux内核的交互，将用户输入的命令转换成内核能懂的语言，执行相应的指令，然后将输出返回给用户．&lt;br&gt;
    
    </summary>
    
      <category term="Unix/Linux" scheme="http://www.ezlippi.com/categories/Unix-Linux/"/>
    
    
      <category term="shell" scheme="http://www.ezlippi.com/tags/shell/"/>
    
      <category term="linux" scheme="http://www.ezlippi.com/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Latex中英文环境设置</title>
    <link href="http://www.ezlippi.com//blog/2015/08/latex-fonts-settings.html"/>
    <id>http://www.ezlippi.com//blog/2015/08/latex-fonts-settings.html</id>
    <published>2015-08-21T16:00:00.000Z</published>
    <updated>2016-02-29T13:12:29.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Latex默认是不支持中文的,后来有人开发了XeLatex来支持非英文字符,xetex是一种使用Unicode的TeX排版引擎,并默认其输入文件为UTF-8编码，也即,英文字符与非英文字符不再有区别，原生支持系统字体，这意味着我们无需再额外编译字体, 故可以在不进行额外配置的情况下直接使用操作系统中安装的字体。&lt;br&gt;
    
    </summary>
    
      <category term="Latex" scheme="http://www.ezlippi.com/categories/Latex/"/>
    
    
      <category term="Latex" scheme="http://www.ezlippi.com/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>Dagger依赖注入浅析</title>
    <link href="http://www.ezlippi.com//blog/2015/08/dagger-dependency-injection.html"/>
    <id>http://www.ezlippi.com//blog/2015/08/dagger-dependency-injection.html</id>
    <published>2015-08-12T16:00:00.000Z</published>
    <updated>2016-02-29T13:11:57.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最早接触依赖注入这个概念是在使用Spring框架的时候，一开始没太在意它，后面开发项目的过程中发现使用依赖注入可以降低代码的耦合性,Spring的依赖注入是通过反射机制实现的，而Dagger依赖注入是在编译期生成辅助的类，这些类继承特定父类或实现特定接口，程序在运行时 Dagger 加载这些辅助类，调用相应接口完成依赖生成和注入.&lt;/p&gt;
    
    </summary>
    
      <category term="gradle" scheme="http://www.ezlippi.com/categories/gradle/"/>
    
    
      <category term="java, gradle" scheme="http://www.ezlippi.com/tags/java-gradle/"/>
    
  </entry>
  
  <entry>
    <title>彻底理解Gradle的任务</title>
    <link href="http://www.ezlippi.com//blog/2015/07/gradle-tasks-guide.html"/>
    <id>http://www.ezlippi.com//blog/2015/07/gradle-tasks-guide.html</id>
    <published>2015-07-26T16:00:00.000Z</published>
    <updated>2016-02-29T13:10:22.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;在Gradle的build文件中，任务是构建活动最基本的单元，它是许多构建指令的集合，下面我将仔细介绍Gradle任务的细节。&lt;br&gt;
    
    </summary>
    
      <category term="gradle" scheme="http://www.ezlippi.com/categories/gradle/"/>
    
    
      <category term="java, gradle" scheme="http://www.ezlippi.com/tags/java-gradle/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate缓存配置笔记</title>
    <link href="http://www.ezlippi.com//blog/2015/07/hibernate-cache-guide.html"/>
    <id>http://www.ezlippi.com//blog/2015/07/hibernate-cache-guide.html</id>
    <published>2015-07-23T16:00:00.000Z</published>
    <updated>2016-02-29T13:57:50.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Hibernate中提供了两级Cache，第一级别的缓存是Session级别的缓存，这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或群集范围的缓存,这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。 Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="cache" scheme="http://www.ezlippi.com/tags/cache/"/>
    
      <category term="hibernate" scheme="http://www.ezlippi.com/tags/hibernate/"/>
    
  </entry>
  
  <entry>
    <title>Java Lambda简明教程</title>
    <link href="http://www.ezlippi.com//blog/2015/06/java-lambda-expression.html"/>
    <id>http://www.ezlippi.com//blog/2015/06/java-lambda-expression.html</id>
    <published>2015-06-02T16:00:00.000Z</published>
    <updated>2016-02-29T13:03:46.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;许多热门的编程语言如今都有一个叫做lambda或者闭包的语言特性，包括比较经典的函数式编程语言Lisp,Scheme,也有稍微年轻的语言比如JavaScript,Python,Ruby,Groovy,Scale,C#,甚至C++也有Lambda表达式。一些语言是运行在java虚拟机上，作为虚拟机最具代表的语言java当然也不想落后。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
      <category term="lambda" scheme="http://www.ezlippi.com/categories/java/lambda/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>安卓开发者必备的42个链接</title>
    <link href="http://www.ezlippi.com//blog/2015/05/android-links.html"/>
    <id>http://www.ezlippi.com//blog/2015/05/android-links.html</id>
    <published>2015-05-18T16:00:00.000Z</published>
    <updated>2016-03-18T10:09:39.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;官方网站&lt;/p&gt;&lt;br&gt;&lt;p&gt;1、&lt;a  href=&quot;http://developer.android.com/develop/index.html&quot; class=&quot;external&quot; rel=&quot;nofollow&quot; target=&quot;_blank&quot;&gt;谷歌安卓开发者页面 &lt;/a&gt;&lt;/p&gt;&lt;br&gt;&lt;p&gt;这里是主站点，在这您可以找到一切资源帮助您开始安卓开发。此站包含了很多关于学习基础知识的资源，完整的API引用，以及你开始开发所需的各种工具。此站共分为五个部分：&lt;/p&gt;&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://www.ezlippi.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>Android自定义视图教程</title>
    <link href="http://www.ezlippi.com//blog/2015/05/define-custom-view.html"/>
    <id>http://www.ezlippi.com//blog/2015/05/define-custom-view.html</id>
    <published>2015-05-16T16:00:00.000Z</published>
    <updated>2016-03-18T10:11:51.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Android的UI元素都是基于View(屏幕中单个元素)和ViewGroup(元素的集合),Android有许多自带的组件和布局，比如Button、TextView、RelativeLayout。在app开发过程中我们需要自定义视图组件来满足我们的需求。通过继承自View或者View的子类，覆写onDraw或者onTouchEvent等方法来覆盖视图的行为。&lt;br&gt;
    
    </summary>
    
      <category term="android" scheme="http://www.ezlippi.com/categories/android/"/>
    
    
      <category term="android, view" scheme="http://www.ezlippi.com/tags/android-view/"/>
    
  </entry>
  
  <entry>
    <title>Gradle系列教程之依赖管理</title>
    <link href="http://www.ezlippi.com//blog/2015/05/gradle-dependency-management.html"/>
    <id>http://www.ezlippi.com//blog/2015/05/gradle-dependency-management.html</id>
    <published>2015-05-04T16:00:00.000Z</published>
    <updated>2016-03-18T10:27:11.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这一章我将介绍Gradle对依赖管理的强大支持，学习依赖分组和定位不同类型仓库。依赖管理看起来很容易，但是当出现依赖解析冲突时就会很棘手，复杂的依赖关系可能导致构建中依赖一个库的多个版本。Gradle通过分析依赖树得到依赖报告，你将很容易找到一个指定的依赖的来源。&lt;/p&gt;
&lt;p&gt;Gradle有自己的依赖管理实现，除了支持ant和Maven的特性外，Gradle关心的是性能、可靠性和复用性。&lt;br&gt;
    
    </summary>
    
      <category term="Gradle" scheme="http://www.ezlippi.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://www.ezlippi.com/tags/Gradle/"/>
    
      <category term="项目构建" scheme="http://www.ezlippi.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Gradle系列教程之任务管理</title>
    <link href="http://www.ezlippi.com//blog/2015/04/gradle-task-management.html"/>
    <id>http://www.ezlippi.com//blog/2015/04/gradle-task-management.html</id>
    <published>2015-04-29T16:00:00.000Z</published>
    <updated>2016-03-18T10:23:01.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Gradle有两个最基本的概念：project和task,Gradle里面的所有东西都基于这两个概念。project通常指一个项目，而task指构建过程中的任务。一次构建可以有1到n个project，每个project有1到n个task，这篇文章主要介绍Gradle任务的创建和管理。&lt;br&gt;
    
    </summary>
    
      <category term="Gradle" scheme="http://www.ezlippi.com/categories/Gradle/"/>
    
    
      <category term="Gradle" scheme="http://www.ezlippi.com/tags/Gradle/"/>
    
      <category term="项目构建" scheme="http://www.ezlippi.com/tags/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机简介</title>
    <link href="http://www.ezlippi.com//blog/2015/04/java-virtual-mechine.html"/>
    <id>http://www.ezlippi.com//blog/2015/04/java-virtual-mechine.html</id>
    <published>2015-04-17T16:00:00.000Z</published>
    <updated>2016-02-29T12:55:09.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机是整个Java平台的基础，是Java语言用于实现与硬件、操作系统无关的关键，Java虚拟机类似一个微型的计算机，它有自己的指令集和运行时的内存区域。java虚拟机和java语言并没有必然的联系，它只与特定的二进制文件–class文件相关联，只要符合java虚拟机规范的class文件都能在虚拟机上运行。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="javas" scheme="http://www.ezlippi.com/tags/javas/"/>
    
      <category term="虚拟机" scheme="http://www.ezlippi.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>android实用小技巧</title>
    <link href="http://www.ezlippi.com//blog/2015/04/android-tips.html"/>
    <id>http://www.ezlippi.com//blog/2015/04/android-tips.html</id>
    <published>2015-04-16T01:52:18.000Z</published>
    <updated>2016-03-18T11:03:23.000Z</updated>
    
    <summary type="html">
    
      本文是一篇译文,讲述的是Android开发过程中遇到的一些实用的小技巧,或者一些实用的API,作者介绍的非常全面，推荐大家收藏起来，平常写Android程序也用的上。
    
    </summary>
    
    
      <category term="android, tips" scheme="http://www.ezlippi.com/tags/android-tips/"/>
    
  </entry>
  
  <entry>
    <title>网络传输基础</title>
    <link href="http://www.ezlippi.com//blog/2015/04/web-transmission-basis.html"/>
    <id>http://www.ezlippi.com//blog/2015/04/web-transmission-basis.html</id>
    <published>2015-04-15T16:00:00.000Z</published>
    <updated>2016-02-29T12:54:16.000Z</updated>
    
    <summary type="html">
    
      理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。因此更好的方法是将数据流分割
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="web" scheme="http://www.ezlippi.com/tags/web/"/>
    
      <category term="网络传输" scheme="http://www.ezlippi.com/tags/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93/"/>
    
  </entry>
  
  <entry>
    <title>优化java代码建议(1)</title>
    <link href="http://www.ezlippi.com//blog/2015/04/java-code-opt-one.html"/>
    <id>http://www.ezlippi.com//blog/2015/04/java-code-opt-one.html</id>
    <published>2015-04-12T13:05:13.000Z</published>
    <updated>2016-02-29T12:53:26.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;假设你要统计一个地区的人口平均年龄，你可能写出下面这段代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static void main(String[] args){
   //人口数量50万
   int peopleNum = 50 * 10000;
   List&amp;lt;Integer&amp;gt; heights = new ArrayList&amp;lt;&amp;gt;(peopleNum);

   for(int i =0; i &amp;lt; peopleNum; i++){
       heights.add(new Random().nextInt(300));
   }
   //计算时间
   long start = System.currentTimeMillis();
   System.out.println(&amp;quot;平均高度是： &amp;quot; + average(heights));
   System.out.println(&amp;quot;运行时间： &amp;quot; + (System.currentTimeMillis() - start) + &amp;quot;ms&amp;quot;);
   }

   //计算平均值
   public static int average(List&amp;lt;Integer&amp;gt; list){
   int sum = 0;
   //遍历求和
   for(int i : list){
       sum += i;
   }
   return sum/list.size();
   }
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>一些强大的Vim插件</title>
    <link href="http://www.ezlippi.com//blog/2015/03/vim-plugins.html"/>
    <id>http://www.ezlippi.com//blog/2015/03/vim-plugins.html</id>
    <published>2015-03-20T01:20:26.000Z</published>
    <updated>2016-02-29T12:52:50.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;除了一些常用的插件比如ctags，taglist，bufexplorer,winmamager之外，这里介绍一些很强大的插件。&lt;/p&gt;
&lt;p&gt;1.&lt;em&gt;Vundle&lt;/em&gt; &lt;a href=&quot;https://github.com/gmarik/Vundle.vim&quot;&gt;Github主页&lt;/a&gt;，一个强大的插件管理器&lt;br&gt;
    
    </summary>
    
      <category term="other" scheme="http://www.ezlippi.com/categories/other/"/>
    
    
      <category term="Vim" scheme="http://www.ezlippi.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio多渠道打包和代码混淆教程</title>
    <link href="http://www.ezlippi.com//blog/2015/03/android-studio-prefrence.html"/>
    <id>http://www.ezlippi.com//blog/2015/03/android-studio-prefrence.html</id>
    <published>2015-03-17T16:00:00.000Z</published>
    <updated>2016-03-21T12:03:57.000Z</updated>
    
    <summary type="html">
    
      Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的内部领域特定（DSL）语言。
    
    </summary>
    
      <category term="android" scheme="http://www.ezlippi.com/categories/android/"/>
    
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>在Ubuntu下安装和编译LaTex</title>
    <link href="http://www.ezlippi.com//blog/2015/03/install-texlive-in-ubuntu.html"/>
    <id>http://www.ezlippi.com//blog/2015/03/install-texlive-in-ubuntu.html</id>
    <published>2015-03-14T16:00:00.000Z</published>
    <updated>2016-03-18T09:21:28.000Z</updated>
    
    <summary type="html">
    
      LaTeX 是由美国计算机学家Lamport博士于1985年开发成功的,它是当今世界上最流行和使用最为广泛,以 TeX 为引擎的高质量格式化排版系统。
    
    </summary>
    
      <category term="other" scheme="http://www.ezlippi.com/categories/other/"/>
    
      <category term="programming" scheme="http://www.ezlippi.com/categories/other/programming/"/>
    
    
      <category term="编程" scheme="http://www.ezlippi.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="学习" scheme="http://www.ezlippi.com/tags/%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>利用github-pages建立个人博客</title>
    <link href="http://www.ezlippi.com//blog/2015/03/github-pages-blog.html"/>
    <id>http://www.ezlippi.com//blog/2015/03/github-pages-blog.html</id>
    <published>2015-02-28T16:00:00.000Z</published>
    <updated>2016-03-21T11:53:41.000Z</updated>
    
    <summary type="html">
    
      Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。
    
    </summary>
    
      <category term="other" scheme="http://www.ezlippi.com/categories/other/"/>
    
      <category term="programming" scheme="http://www.ezlippi.com/categories/other/programming/"/>
    
    
      <category term="blog" scheme="http://www.ezlippi.com/tags/blog/"/>
    
  </entry>
  
  <entry>
    <title>谈谈缓存和基本的缓存算法</title>
    <link href="http://www.ezlippi.com//blog/2015/02/cache.html"/>
    <id>http://www.ezlippi.com//blog/2015/02/cache.html</id>
    <published>2015-02-03T16:00:00.000Z</published>
    <updated>2016-03-18T10:06:41.000Z</updated>
    
    <summary type="html">
    
      很久很久以前，在还没有缓存的时候……用户经常是去请求一个对象，而这个对象是从数据库去取，然后，这个对象变得越来越大，这个用户每次的请求时间也越来越长了，这也把数据库弄得很痛苦，他无时不刻不在工作。所以，这个事情就把用户和数据库弄得很生气，接着就有可能发生下面两件事情
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="cache" scheme="http://www.ezlippi.com/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>C代码优化小贴士</title>
    <link href="http://www.ezlippi.com//blog/2014/12/c-code-opt.html"/>
    <id>http://www.ezlippi.com//blog/2014/12/c-code-opt.html</id>
    <published>2014-12-26T16:00:00.000Z</published>
    <updated>2016-03-18T10:02:05.000Z</updated>
    
    <summary type="html">
    
      虽然对于优化C代码有很多有效的指导方针，但是对于彻底地了解编译器和你工作的机器依然无法取代，通常，加快程序的速度也会加大代码量。这些增加的代码也会影响一个程序的复杂度和可读性，这是不可接受的，比如你在一些小型的设备上编程，例如：移动设备、PDA……，这些有着严格的内存限制，于是，在优化的座右铭是:写代码在内存和速度都应该优化。
    
    </summary>
    
      <category term="c" scheme="http://www.ezlippi.com/categories/c/"/>
    
    
      <category term="编程语言" scheme="http://www.ezlippi.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>skip list跳跃表实现</title>
    <link href="http://www.ezlippi.com//blog/2014/12/skip-list.html"/>
    <id>http://www.ezlippi.com//blog/2014/12/skip-list.html</id>
    <published>2014-12-17T16:00:00.000Z</published>
    <updated>2016-02-29T12:38:16.000Z</updated>
    
    <summary type="html">
    
      skip—list原理
    
    </summary>
    
      <category term="algorithm" scheme="http://www.ezlippi.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://www.ezlippi.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>值得推荐的C/C++框架和库</title>
    <link href="http://www.ezlippi.com//blog/2014/12/c-open-project.html"/>
    <id>http://www.ezlippi.com//blog/2014/12/c-open-project.html</id>
    <published>2014-12-12T16:00:00.000Z</published>
    <updated>2016-03-03T02:22:37.000Z</updated>
    
    <summary type="html">
    
      Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。
    
    </summary>
    
      <category term="c/c++" scheme="http://www.ezlippi.com/categories/c-c/"/>
    
    
      <category term="开源" scheme="http://www.ezlippi.com/tags/%E5%BC%80%E6%BA%90/"/>
    
      <category term="C" scheme="http://www.ezlippi.com/tags/C/"/>
    
      <category term="C++" scheme="http://www.ezlippi.com/tags/C/"/>
    
      <category term="OpenSource" scheme="http://www.ezlippi.com/tags/OpenSource/"/>
    
      <category term="框架" scheme="http://www.ezlippi.com/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>谈谈如何提高web服务器并发性能</title>
    <link href="http://www.ezlippi.com//blog/2014/12/improve-webServer-performance.html"/>
    <id>http://www.ezlippi.com//blog/2014/12/improve-webServer-performance.html</id>
    <published>2014-12-04T16:00:00.000Z</published>
    <updated>2016-02-29T12:37:40.000Z</updated>
    
    <summary type="html">
    
      任何一名web工程师都希望自己做的web应用能被越来越多的人使用，如果我们所做的web应用随着用户的增多而宕机了，那么越来越多的人就会变得越来越少了，为了让我们的web应用能有更多人使用，我们就得提升web应用服务端的并发能力。
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="并发， 服务器" scheme="http://www.ezlippi.com/tags/%E5%B9%B6%E5%8F%91%EF%BC%8C-%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>计算机算法--图算法介绍</title>
    <link href="http://www.ezlippi.com//blog/2014/11/graph.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/graph.html</id>
    <published>2014-11-28T16:00:00.000Z</published>
    <updated>2016-02-29T12:37:34.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;图的定义：&quot;&gt;&lt;a href=&quot;#图的定义：&quot; class=&quot;headerlink&quot; title=&quot;图的定义：&quot;&gt;&lt;/a&gt;图的定义：&lt;/h2&gt;&lt;p&gt;图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。&lt;/p&gt;
&lt;p&gt;图的种类：地图，电路图，调度图，事物，网络，程序结构&lt;br&gt;
    
    </summary>
    
      <category term="algorithm" scheme="http://www.ezlippi.com/categories/algorithm/"/>
    
    
      <category term="algorithm" scheme="http://www.ezlippi.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>也谈如何构建高性能服务端程序</title>
    <link href="http://www.ezlippi.com//blog/2014/11/web-server.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/web-server.html</id>
    <published>2014-11-18T16:00:00.000Z</published>
    <updated>2016-02-29T12:36:33.000Z</updated>
    
    <summary type="html">
    
      可以想象，如果让一个人一遍一遍的从 1+2+3+4+...+99+100=？ 这样去算，他加到最后发现等于5050，而这个过程耗费了他大量的时间，耗费了大量的脑力，在此期间，他可能把所有精力都放在这个计算上面而无暇顾及其他事情。等到他累得满头大汗，加完了结果，他告诉你是 5050。没过多久，你又让他做同样的事情，我相信这家伙会不加思索的再次告诉你 5050。为什么？你会笑我说，人又不是傻子，这为同学肯定记得这个结果是5050啊。
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="web" scheme="http://www.ezlippi.com/tags/web/"/>
    
      <category term="服务器" scheme="http://www.ezlippi.com/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>leveldb原理剖析</title>
    <link href="http://www.ezlippi.com//blog/2014/11/leveldb.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/leveldb.html</id>
    <published>2014-11-17T16:00:00.000Z</published>
    <updated>2016-03-18T08:50:46.000Z</updated>
    
    <summary type="html">
    
      google开源库
    
    </summary>
    
      <category term="algorithm" scheme="http://www.ezlippi.com/categories/algorithm/"/>
    
    
      <category term="数据库" scheme="http://www.ezlippi.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>java中内部类</title>
    <link href="http://www.ezlippi.com//blog/2014/11/java-inner-class.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/java-inner-class.html</id>
    <published>2014-11-13T16:00:00.000Z</published>
    <updated>2016-02-29T13:22:15.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在想一个问题，Java语言为什么要设计内部类呢，经过查阅相关的书籍后在这里总结一下。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;从多继承的角度来分析&quot;&gt;&lt;a href=&quot;#从多继承的角度来分析&quot; class=&quot;headerlink&quot; title=&quot;从多继承的角度来分析&quot;&gt;&lt;/a&gt;从多继承的角度来分析&lt;/h2&gt;&lt;p&gt;C++作为比较早期的面向对象编程语言，摸着石头过河，不幸的当了炮灰，比如多重继承，在使用的过程中会出现死亡菱形的情况，而Java的设计者意识到了这个问题，所以Java是不支持多重继承的，想要扩展功能可以使用interface，但是后来Java的设计者意识到多重继承也不是一无是处，比如说当你的父类和实现的接口有相同签名的方法时，接口的方法会覆盖父类的方法，怎么办呢，这个时候内部类就应运而生了。&lt;/p&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="接口" scheme="http://www.ezlippi.com/tags/%E6%8E%A5%E5%8F%A3/"/>
    
      <category term="继承" scheme="http://www.ezlippi.com/tags/%E7%BB%A7%E6%89%BF/"/>
    
      <category term="复用" scheme="http://www.ezlippi.com/tags/%E5%A4%8D%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>java同步容器与并发容器</title>
    <link href="http://www.ezlippi.com//blog/2014/11/java-concurrent-collections.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/java-concurrent-collections.html</id>
    <published>2014-11-07T16:00:00.000Z</published>
    <updated>2016-03-21T11:58:24.000Z</updated>
    
    <summary type="html">
    
      在编程的时候经常会用到容器，当容器被多线程读取的时候我们就要考虑线程安全的问题，哪些容器是线程是线程安全的，容器的哪些操作又是线程安全的，这些安全机制是怎么实现的，本文将一一介绍。
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java中NIO与传统IO</title>
    <link href="http://www.ezlippi.com//blog/2014/11/java-nio.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/java-nio.html</id>
    <published>2014-10-31T16:00:00.000Z</published>
    <updated>2016-03-01T05:17:06.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;感性认识：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的&lt;/strong&gt;socket IO中，&lt;strong&gt;需要为每个连接创建一个线程&lt;/strong&gt;，当并发的连接数量非常巨大时，&lt;strong&gt;线程所占用的栈内存和CPU线程切换的开销&lt;/strong&gt;将非常巨大。使用&lt;strong&gt;NIO&lt;/strong&gt;，不再需要为每个线程创建单独的线程，可以用一个&lt;strong&gt;含有限数量线程的线程池&lt;/strong&gt;，甚至一个线程来为任意数量的连接服务。由于线程数量小于连接数量，所以每个线程进行IO操作时就不能阻塞，如果阻塞的话，有些连接就得不到处理，NIO提供了这种非阻塞的能力。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="NIO" scheme="http://www.ezlippi.com/tags/NIO/"/>
    
      <category term="IO" scheme="http://www.ezlippi.com/tags/IO/"/>
    
      <category term="阻塞" scheme="http://www.ezlippi.com/tags/%E9%98%BB%E5%A1%9E/"/>
    
  </entry>
  
  <entry>
    <title>如何评价『黑客与画家』</title>
    <link href="http://www.ezlippi.com//blog/2014/11/how-to-evaluate-the-hackers-and-painters.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/how-to-evaluate-the-hackers-and-painters.html</id>
    <published>2014-10-31T16:00:00.000Z</published>
    <updated>2016-02-29T12:35:55.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;传送门：&lt;a href=&quot;http://t.cn/zlg4njc&quot;&gt;黑客与画家:硅谷创业之父Paul Graham文集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一本好的书，让我们收获的不单单是某种技巧，或者某种方法论，&lt;br&gt;&lt;strong&gt;他教给我们的是一种严密的思维方式，是一种学会把自己的眼光放得更加长远的决策习惯，他促使我们养成独立思考的习惯。&lt;/strong&gt;&lt;br&gt;他没有送给我们一条大鱼，却把捕捉大鱼的方法交给了我们， &lt;strong&gt;授人以鱼，不如授人以渔&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="book" scheme="http://www.ezlippi.com/categories/book/"/>
    
    
      <category term="book" scheme="http://www.ezlippi.com/tags/book/"/>
    
  </entry>
  
  <entry>
    <title>Android消息推送方式</title>
    <link href="http://www.ezlippi.com//blog/2014/11/android-push.html"/>
    <id>http://www.ezlippi.com//blog/2014/11/android-push.html</id>
    <published>2014-10-31T16:00:00.000Z</published>
    <updated>2016-03-01T05:16:43.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;当我们开发需要和服务器交互的应用程序时，基本上都需要获取服务器端的数据，比如《地震及时通》就需要及时获取服务器上最新的地震信息。要获取服务器上不定时更新的信息一般来说有两种方法，第一种是客户端使用&lt;strong&gt;Pull（拉）&lt;/strong&gt;的方式，隔一段时间就去服务器上获取信息，看是否有更新的信息出现。第二种就是服务器使用&lt;strong&gt;Push（推送）&lt;/strong&gt;的方式，当服务器端有新信息了，则把最新的信息Push到客户端上。&lt;br&gt;虽然Pull和Push两种方式都能实现获取服务器端更新信息的功能，但是明显来说&lt;strong&gt;Push is better than pull&lt;/strong&gt;。&lt;br&gt;&lt;strong&gt;因为Pull方式更费客户端的网络流量，更主要的是费电量。&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="消息推送" scheme="http://www.ezlippi.com/tags/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Androidpn 消息推送总结</title>
    <link href="http://www.ezlippi.com//blog/2014/10/androidDP-project.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/androidDP-project.html</id>
    <published>2014-10-30T16:00:00.000Z</published>
    <updated>2016-02-29T12:35:27.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Androidpn 开源项目托管地址：&lt;a href=&quot;http://sourceforge.net/projects/androidpn/&quot;&gt;http://sourceforge.net/projects/androidpn/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Androidpn 开源项目自身描述：This is an open source project to provide push notification support for Android, a xmpp based notification server and a client tool kit.&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
      <category term="消息推送" scheme="http://www.ezlippi.com/tags/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>XMPP协议分析-具体分析</title>
    <link href="http://www.ezlippi.com//blog/2014/10/xmpp-analise.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/xmpp-analise.html</id>
    <published>2014-10-30T16:00:00.000Z</published>
    <updated>2016-02-29T12:35:35.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;通过WireShark抓包来具体分析XMPP协议，下面用人人桌面版演示了，XMPP客户端从登录到获取新鲜事的过程，通过分析具体的数据包能够更容易的理解协议。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="xmpp" scheme="http://www.ezlippi.com/tags/xmpp/"/>
    
      <category term="jabber" scheme="http://www.ezlippi.com/tags/jabber/"/>
    
      <category term="openfire" scheme="http://www.ezlippi.com/tags/openfire/"/>
    
  </entry>
  
  <entry>
    <title>Smack开发手册</title>
    <link href="http://www.ezlippi.com//blog/2014/10/how%20to%20use%20smack.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/how to use smack.html</id>
    <published>2014-10-29T16:00:00.000Z</published>
    <updated>2016-02-29T12:35:22.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章翻译自Smack的官方文档，&lt;a href=&quot;http://www.igniterealtime.org/builds/smack/docs/latest/documentation/&quot;&gt;http://www.igniterealtime.org/builds/smack/docs/latest/documentation/&lt;/a&gt;，转载请注明出处。&lt;/p&gt;
&lt;p&gt;Smack是一个为使用XMPP服务器聊天和发送即时消息交流而提供的库。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
      <category term="消息推送， server， client" scheme="http://www.ezlippi.com/tags/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%EF%BC%8C-server%EF%BC%8C-client/"/>
    
  </entry>
  
  <entry>
    <title>AndroidPN消息推送</title>
    <link href="http://www.ezlippi.com//blog/2014/10/androidDP-introduction.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/androidDP-introduction.html</id>
    <published>2014-10-29T16:00:00.000Z</published>
    <updated>2016-02-29T12:35:13.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Androidpn是韩国Sehwan No写的开源消息推送项目，很多大公司都用这个消息推送方式构建自己的消息推送服务，缺点是导致客户端比较耗电。通信机制分别由客户端和服务器完成。&lt;/p&gt;
&lt;p&gt;客户端采用基于java的XMPP协议包asmack（该包依赖于openfire下的开源项目smack）。通过该协议包提供的XMPPConnetcion类与服务器建立持久连接，并通过该连接进行用户注册和登录认证，以及接受服务器消息。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
      <category term="消息推送， server， client" scheme="http://www.ezlippi.com/tags/%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%EF%BC%8C-server%EF%BC%8C-client/"/>
    
  </entry>
  
  <entry>
    <title>XMPP协议分析-原理</title>
    <link href="http://www.ezlippi.com//blog/2014/10/xmpp.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/xmpp.html</id>
    <published>2014-10-27T16:00:00.000Z</published>
    <updated>2016-02-29T12:35:07.000Z</updated>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XMPP协议简介&quot;&gt;&lt;a href=&quot;#XMPP协议简介&quot; class=&quot;headerlink&quot; title=&quot;XMPP协议简介&quot;&gt;&lt;/a&gt;XMPP协议简介&lt;/h1&gt;&lt;p&gt;XMPP协议（Extensible Messaging and PresenceProtocol，可扩展消息处理现场协议）是一种基于XML的协议，目的是为了解决及时通信标准而提出来的，最早是在Jabber上实现的。它继承了在XML环境中灵活的发展性。因此，基于XMPP的应用具有超强的可扩展性。并且XML很易穿过防火墙，所以用XMPP构建的应用不易受到防火墙的阻碍。利用XMPP作为通用的传输机制，不同组织内的不同应用都可以进行有效的通信。&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="xmpp" scheme="http://www.ezlippi.com/tags/xmpp/"/>
    
      <category term="jabber" scheme="http://www.ezlippi.com/tags/jabber/"/>
    
      <category term="openfire" scheme="http://www.ezlippi.com/tags/openfire/"/>
    
  </entry>
  
  <entry>
    <title>使用Jfreechart生成曲线显示到JSP中</title>
    <link href="http://www.ezlippi.com//blog/2014/10/jsp-jfreechart.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/jsp-jfreechart.html</id>
    <published>2014-10-21T16:00:00.000Z</published>
    <updated>2016-02-29T12:34:59.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;项目中需要弄一个服务器，从数据库中读取数据，然后根据http请求显示制定的数据在曲线中，这里用到一个曲线库，&lt;a href=&quot;http://www.jfree.org/jfreechart/&quot;&gt;Jfreechart&lt;/a&gt;，用java写的，用来生成柱状图，饼状图，时间序列等。&lt;br&gt;整个流程如下：&lt;br&gt;&lt;img src=&quot;/images/images/chart.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="jsp，servlet，html，jfreechart" scheme="http://www.ezlippi.com/tags/jsp%EF%BC%8Cservlet%EF%BC%8Chtml%EF%BC%8Cjfreechart/"/>
    
  </entry>
  
  <entry>
    <title>当我们打开网页时发生了什么</title>
    <link href="http://www.ezlippi.com//blog/2014/10/how-http-works.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/how-http-works.html</id>
    <published>2014-10-10T16:00:00.000Z</published>
    <updated>2016-02-29T12:34:49.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;简单地来说，当我们在浏览器上输入URL的敲下回车的时候。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;浏览器需要查找域名[domain]的IP，从不同的缓存直至DNS服 务器。&lt;/li&gt;
&lt;li&gt;浏览器会给web服务器发送一个HTTP请求&lt;/li&gt;
&lt;li&gt;服务器“处理”请求&lt;/li&gt;
&lt;li&gt;服务器发回一个HTTP响应&lt;/li&gt;
&lt;li&gt;浏览器渲染HTML到页面。&lt;br&gt;比如我们从&lt;a href=&quot;http://www.joes-hardware.com:80/power-tools.html&quot;&gt;http://www.joes-hardware.com:80/power-tools.html&lt;/a&gt;获取资源的时候，整个过程如下图所示：&lt;br&gt;&lt;img src=&quot;/images/images/http/1.jpeg&quot; alt=&quot;&quot;&gt;&lt;br&gt;开始时我们输入的是URI(统一资源标识符,Uniform Resource Identifier)，我们用的比较多的是URI的一个子集叫统一资源定位符(URL,Uniform Resource Locator)。
    
    </summary>
    
      <category term="web" scheme="http://www.ezlippi.com/categories/web/"/>
    
    
      <category term="http" scheme="http://www.ezlippi.com/tags/http/"/>
    
      <category term="dns" scheme="http://www.ezlippi.com/tags/dns/"/>
    
      <category term="web" scheme="http://www.ezlippi.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>值得推荐的android开源框架</title>
    <link href="http://www.ezlippi.com//blog/2014/10/android-opensource.html"/>
    <id>http://www.ezlippi.com//blog/2014/10/android-opensource.html</id>
    <published>2014-09-30T16:00:00.000Z</published>
    <updated>2016-02-29T12:34:42.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、volley&quot;&gt;&lt;a href=&quot;#1、volley&quot; class=&quot;headerlink&quot; title=&quot;1、volley&quot;&gt;&lt;/a&gt;1、volley&lt;/h2&gt;&lt;p&gt;项目地址&lt;a href=&quot;https://github.com/smanikandan14/Volley-demo&quot;&gt;https://github.com/smanikandan14/Volley-demo&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;(1)  JSON，图像等的异步下载；&lt;/li&gt;
&lt;li&gt;(2)  网络请求的排序（scheduling）&lt;/li&gt;
&lt;li&gt;(3)  网络请求的优先级处理&lt;/li&gt;
&lt;li&gt;(4)  缓存&lt;/li&gt;
&lt;li&gt;(5)  多级别取消请求&lt;/li&gt;
&lt;li&gt;(6)  和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）
    
    </summary>
    
      <category term="Android" scheme="http://www.ezlippi.com/categories/Android/"/>
    
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
      <category term="开源" scheme="http://www.ezlippi.com/tags/%E5%BC%80%E6%BA%90/"/>
    
  </entry>
  
  <entry>
    <title>关于返回 Null 值的问题</title>
    <link href="http://www.ezlippi.com//blog/2014/09/returning-null.html"/>
    <id>http://www.ezlippi.com//blog/2014/09/returning-null.html</id>
    <published>2014-09-17T16:00:00.000Z</published>
    <updated>2016-02-29T12:34:35.000Z</updated>
    
    <summary type="html">
    
      我感觉返回null值是有问题的，它大量的被使用在一个方法有不同的返回类型时。返回一个Null对象在某些情况下是合适的，但并不适合当你需要向客户端传送两种不同的东西的情形。
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
      <category term="reprints" scheme="http://www.ezlippi.com/categories/java/reprints/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="技巧" scheme="http://www.ezlippi.com/tags/%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>为什么 jdk 中把 String 类设计成 final</title>
    <link href="http://www.ezlippi.com//blog/2014/08/why-jdk-string-is-final.html"/>
    <id>http://www.ezlippi.com//blog/2014/08/why-jdk-string-is-final.html</id>
    <published>2014-08-28T16:00:00.000Z</published>
    <updated>2016-02-29T12:34:27.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;最佳答案：&quot;&gt;&lt;a href=&quot;#最佳答案：&quot; class=&quot;headerlink&quot; title=&quot;最佳答案：&quot;&gt;&lt;/a&gt;最佳答案：&lt;/h2&gt;&lt;p&gt;主要是为了 “ 效率 ” 和 “ 安全性 ” 的缘故。&lt;br&gt;若 String 允许被继承, 由于它的高度被使用率, 可能会降低程序的性能，所以 String 被定义成 final。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
      <category term="reprints" scheme="http://www.ezlippi.com/categories/java/reprints/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="final" scheme="http://www.ezlippi.com/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>处理并发之二：libevent的eventbuffer</title>
    <link href="http://www.ezlippi.com//blog/2014/08/libevent.html"/>
    <id>http://www.ezlippi.com//blog/2014/08/libevent.html</id>
    <published>2014-08-23T16:00:00.000Z</published>
    <updated>2016-02-29T12:34:20.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt; bufferevent这个结构体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct bufferevent {
    struct event_base *ev_base;  
    const struct bufferevent_ops *be_ops;  
    struct event ev_read;  
    struct event ev_write;  
    struct evbuffer *input;  
    struct evbuffer *output;                                                                                  
    bufferevent_data_cb readcb;                                                                                                                 bufferevent_data_cb writecb;                                                                                         bufferevent_event_cb errorcb;  
    }  
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="c" scheme="http://www.ezlippi.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://www.ezlippi.com/tags/c/"/>
    
      <category term="concurrent" scheme="http://www.ezlippi.com/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>处理并发之一：LINUX Epoll机制介绍</title>
    <link href="http://www.ezlippi.com//blog/2014/08/linux-epoll.html"/>
    <id>http://www.ezlippi.com//blog/2014/08/linux-epoll.html</id>
    <published>2014-08-22T16:00:00.000Z</published>
    <updated>2016-03-18T08:43:00.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Epoll可是当前在Linux下开发大规模并发网络程序的热门人选，Epoll 在Linux2.6内核中正式引入，和select相似，其实都I/O多路复用技术而已，并没有什么神秘的。&lt;/p&gt;
&lt;p&gt;其实在Linux下设计并发网络程序，向来不缺少方法，比如典型的Apache模型（Process Per Connection，简称PPC），TPC（Thread Per Connection）模型，以及select模型和poll模型，那为何还要再引入Epoll这个东东呢？那还是有得说说的…&lt;br&gt;
    
    </summary>
    
      <category term="c" scheme="http://www.ezlippi.com/categories/c/"/>
    
    
      <category term="c++" scheme="http://www.ezlippi.com/tags/c/"/>
    
      <category term="concurrent" scheme="http://www.ezlippi.com/tags/concurrent/"/>
    
  </entry>
  
  <entry>
    <title>java编程的78条黄金法则</title>
    <link href="http://www.ezlippi.com//blog/2014/08/78-golden-rules-of-the-java-programming.html"/>
    <id>http://www.ezlippi.com//blog/2014/08/78-golden-rules-of-the-java-programming.html</id>
    <published>2014-08-15T16:00:00.000Z</published>
    <updated>2016-02-29T12:34:04.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;整理自网络，如果你知道原作者，请通知我。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;创建和销毁对象&quot;&gt;&lt;a href=&quot;#创建和销毁对象&quot; class=&quot;headerlink&quot; title=&quot;创建和销毁对象&quot;&gt;&lt;/a&gt;创建和销毁对象&lt;/h2&gt;&lt;p&gt;1、考虑用静态工厂方法（返回类的实例的静态方法）代替构造器&lt;br&gt;&lt;br&gt;2、遇到多个构造器参数时要考虑用构造器&lt;br&gt;&lt;br&gt;3、用私有构造器或者枚举类型强化Singleton属性&lt;br&gt;&lt;br&gt;4、通过私有构造器强化不可实例化的能力&lt;br&gt;&lt;br&gt;5、避免创建不必要的对象&lt;br&gt;&lt;br&gt;6、消除过期的对象引用&lt;br&gt;&lt;br&gt;7、避免使用终结（final）方法&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
      <category term="reprints" scheme="http://www.ezlippi.com/categories/java/reprints/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java并发和多线程</title>
    <link href="http://www.ezlippi.com//blog/2014/08/java-multithread.html"/>
    <id>http://www.ezlippi.com//blog/2014/08/java-multithread.html</id>
    <published>2014-08-01T16:00:00.000Z</published>
    <updated>2016-02-29T12:33:57.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;注：本文的内容翻译自&lt;a href=&quot;http://tutorials.jenkov.com/java-concurrency/deadlock.html&quot;&gt;http://tutorials.jenkov.com/java-concurrency/deadlock.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。&lt;/p&gt;
&lt;p&gt;随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="多线程" scheme="http://www.ezlippi.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Android UI线程和子线程、Service通信</title>
    <link href="http://www.ezlippi.com//blog/2014/07/android-UI-Thread.html"/>
    <id>http://www.ezlippi.com//blog/2014/07/android-UI-Thread.html</id>
    <published>2014-07-18T16:00:00.000Z</published>
    <updated>2016-02-29T12:33:50.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;关于Service最基本的用法自然就是如何启动一个Service了，启动Service的方法和启动Activity很类似，都需要借助Intent来实现，下面我们就通过一个具体的例子来看一下。&lt;/p&gt;
&lt;p&gt;新建一个Android项目，项目名就叫ServiceTest，这里我选择使用4.0的API。&lt;/p&gt;
&lt;p&gt;然后新建一个MyService继承自Service，并重写父类的onCreate()、onStartCommand()和onDestroy()方法，如下所示：&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>从android.os.NetworkOnMainThreadException引发的思考</title>
    <link href="http://www.ezlippi.com//blog/2014/07/android-networkOnMainThreadException.html"/>
    <id>http://www.ezlippi.com//blog/2014/07/android-networkOnMainThreadException.html</id>
    <published>2014-07-17T16:00:00.000Z</published>
    <updated>2016-02-29T12:33:37.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;最近在写一个网络通信的程序，运行的时候抛出了这样一个异常，&lt;code&gt;android.os.NetworkOnMainThreadException&lt;/code&gt;，找了很久没发现原因，后来查了下资料才知道是android的UI线程不能直接进行网络访问的操作。&lt;br&gt;
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="android" scheme="http://www.ezlippi.com/tags/android/"/>
    
  </entry>
  
  <entry>
    <title>使用jekyll在Github上搭建博客</title>
    <link href="http://www.ezlippi.com//blog/2014/07/use-jekyll-build-blog-on-github.html"/>
    <id>http://www.ezlippi.com//blog/2014/07/use-jekyll-build-blog-on-github.html</id>
    <published>2014-07-14T16:00:00.000Z</published>
    <updated>2016-02-29T12:33:07.000Z</updated>
    
    <summary type="html">
    
      使用jekyll在Github上搭建博客
    
    </summary>
    
      <category term="jekyll" scheme="http://www.ezlippi.com/categories/jekyll/"/>
    
      <category term="reprints" scheme="http://www.ezlippi.com/categories/jekyll/reprints/"/>
    
    
      <category term="jekyll" scheme="http://www.ezlippi.com/tags/jekyll/"/>
    
      <category term="github" scheme="http://www.ezlippi.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>一个合格的程序员应该读过哪些书</title>
    <link href="http://www.ezlippi.com//blog/2014/07/qualified-programmer-should-read-what-books.html"/>
    <id>http://www.ezlippi.com//blog/2014/07/qualified-programmer-should-read-what-books.html</id>
    <published>2014-07-14T16:00:00.000Z</published>
    <updated>2016-02-29T12:32:57.000Z</updated>
    
    <summary type="html">
    
      如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本，你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西
    
    </summary>
    
      <category term="other" scheme="http://www.ezlippi.com/categories/other/"/>
    
      <category term="programming" scheme="http://www.ezlippi.com/categories/other/programming/"/>
    
      <category term="reprints" scheme="http://www.ezlippi.com/categories/other/programming/reprints/"/>
    
    
      <category term="书籍" scheme="http://www.ezlippi.com/tags/%E4%B9%A6%E7%B1%8D/"/>
    
      <category term="程序" scheme="http://www.ezlippi.com/tags/%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 语法 (简体中文版)</title>
    <link href="http://www.ezlippi.com//blog/2014/07/markdown-syntax.html"/>
    <id>http://www.ezlippi.com//blog/2014/07/markdown-syntax.html</id>
    <published>2014-07-10T16:00:00.000Z</published>
    <updated>2016-03-18T07:31:33.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;NOTE:&lt;/strong&gt; This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document
    
    </summary>
    
      <category term="jekyll" scheme="http://www.ezlippi.com/categories/jekyll/"/>
    
    
      <category term="jekyll" scheme="http://www.ezlippi.com/tags/jekyll/"/>
    
      <category term="markdown" scheme="http://www.ezlippi.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>markdown 快速入门</title>
    <link href="http://www.ezlippi.com//blog/2014/07/markdown-basics.html"/>
    <id>http://www.ezlippi.com//blog/2014/07/markdown-basics.html</id>
    <published>2014-07-09T16:00:00.000Z</published>
    <updated>2016-03-18T07:29:21.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;Markdown: Basics （快速入门） / (&lt;a href=&quot;./markdown-syntax.html&quot;&gt;点击查看完整语法说明&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;Getting the Gist of Markdown’s Formatting Syntax&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="jekyll" scheme="http://www.ezlippi.com/categories/jekyll/"/>
    
    
      <category term="jekyll" scheme="http://www.ezlippi.com/tags/jekyll/"/>
    
      <category term="markdown" scheme="http://www.ezlippi.com/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>C语言高级编程指南</title>
    <link href="http://www.ezlippi.com//blog/2014/07/c-advaced-programming.html"/>
    <id>http://www.ezlippi.com//blog/2014/07/c-advaced-programming.html</id>
    <published>2014-07-04T16:00:00.000Z</published>
    <updated>2016-03-18T08:32:35.000Z</updated>
    
    <summary type="html">
    
      &lt;h2 id=&quot;整形溢出和提升&quot;&gt;&lt;a href=&quot;#整形溢出和提升&quot; class=&quot;headerlink&quot; title=&quot;整形溢出和提升&quot;&gt;&lt;/a&gt;整形溢出和提升&lt;/h2&gt;&lt;p&gt;大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,&lt;br&gt;你觉得输出结果是什么:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int main(int argc, char** argv) {
    long i = -1;

    if (i &amp;lt; sizeof(i)) {
         printf(&amp;quot;OK\n&amp;quot;);
    }
    else {
         printf(&amp;quot;error\n&amp;quot;);
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="c" scheme="http://www.ezlippi.com/categories/c/"/>
    
      <category term="programming" scheme="http://www.ezlippi.com/categories/c/programming/"/>
    
    
      <category term="c" scheme="http://www.ezlippi.com/tags/c/"/>
    
      <category term="programming" scheme="http://www.ezlippi.com/tags/programming/"/>
    
  </entry>
  
  <entry>
    <title>Java编程Tips</title>
    <link href="http://www.ezlippi.com//blog/2014/06/26-methods-to-improve-java-performance.html"/>
    <id>http://www.ezlippi.com//blog/2014/06/26-methods-to-improve-java-performance.html</id>
    <published>2014-06-17T16:00:00.000Z</published>
    <updated>2016-02-29T12:32:17.000Z</updated>
    
    <summary type="html">
    
      Java编程中“为了性能”尽量要做到的一些地方
    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="java" scheme="http://www.ezlippi.com/tags/java/"/>
    
      <category term="性能" scheme="http://www.ezlippi.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>在雨中</title>
    <link href="http://www.ezlippi.com//blog/2014/06//blog/2014/06/15/in-the-rain.html.html"/>
    <id>http://www.ezlippi.com//blog/2014/06//blog/2014/06/15/in-the-rain.html.html</id>
    <published>2014-06-14T17:05:13.000Z</published>
    <updated>2015-08-21T07:35:33.000Z</updated>
    
    <summary type="html">
    
      &lt;p&gt;我的个人博客上线了．&lt;/p&gt;

    
    </summary>
    
      <category term="java" scheme="http://www.ezlippi.com/categories/java/"/>
    
    
      <category term="Life" scheme="http://www.ezlippi.com/tags/Life/"/>
    
      <category term="生活" scheme="http://www.ezlippi.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
