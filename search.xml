<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Elasticsearch translog文件介绍]]></title>
      <url>http://www.ezlippi.com/blog/2018/04/elasticsearch-translog.html</url>
      <content type="html"><![CDATA[<p>这篇文章主要介绍Elasticsearch的索引工作机制,它是如何利用translog来保证数据的安全,以及我们在生产环境中如何优化translog的参数来最大化性能,主要会介绍到elastic中常见的2个操作:refresh和flush，以及这2个接口是如何保证数据能够被检索到的。</p>
<a id="more"></a>
<h2 id="数据持久化"><a href="#数据持久化" class="headerlink" title="数据持久化"></a>数据持久化</h2><p>我们把数据写到磁盘后,还要调用fsync才能把数据刷到磁盘中,如果不这样做在系统掉电的时候就会导致数据丢失,这个原理相信大家都清楚,elasticsearch为了高可靠性必须把所有的修改持久化到磁盘中。</p>
<p>elastic底层采用的是lucene这个库来实现倒排索引的功能,在lucene的概念里每一条记录称为document(文档),lucene使用segment(分段)来存储数据,用commit point来记录所有segment的元数据，一条记录要被搜索到,必须写入到segment中,这一点非常重要,后面会介绍为什么elastic搜索是near-realtime(接近实时的)而不是实时的。</p>
<p>elastic使用translog来记录所有的操作,我们称之为write-ahead-log，我们新增了一条记录时，es会把数据写到translog和in-memory buffer(内存缓存区)中,如下图所示:</p>
<p><img src="/images/images/es/1.png" alt=""></p>
<p>内存缓存区和translog就是near-realtime的关键所在，前面我们讲过新增的索引必须写入到segment后才能被搜索到，因此我们把数据写入到内存缓冲区之后并不能被搜索到,如果希望该文档能立刻被搜索，需要手动调用refresh操作。</p>
<h2 id="refresh操作"><a href="#refresh操作" class="headerlink" title="refresh操作"></a>refresh操作</h2><p>默认情况下,es每隔一秒钟执行一次refresh，可以通过参数<code>index.refresh_interval</code>来修改这个刷新间隔，执行refresh操作具体做了哪些事情呢?</p>
<ul>
<li>所有在内存缓冲区中的文档被写入到一个新的segment中,但是没有调用fsync,因此内存中的数据可能丢失</li>
<li>segment被打开使得里面的文档能够被搜索到</li>
<li>清空内存缓冲区</li>
</ul>
<p>执行refresh后的状态如下图所示:</p>
<p><img src="/images/images/es/2.png" alt=""></p>
<p>refresh的开销比较大,我在自己环境上测试10W条记录的场景下refresh一次大概要14ms,因此在批量构建索引时可以把refresh间隔设置成-1来临时关闭refresh,等到索引都提交完成之后再打开refresh,可以通过如下接口修改这个参数:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT <span class="string">'localhost:9200/test/_settings'</span> <span class="_">-d</span> <span class="string">'&#123;</span><br><span class="line">    "index" : &#123;</span><br><span class="line">        "refresh_interval" : "-1"</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>另外当你在做批量索引时,可以考虑把副本数设置成0，因为document从主分片(primary shard)复制到从分片(replica shard)时,从分片也要执行相同的分析、索引和合并过程,这样的开销比较大，你可以在构建索引之后再开启副本，这样只需要把数据从主分片拷贝到从分片:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT <span class="string">'localhost:9200/my_index/_settings'</span> <span class="_">-d</span> <span class="string">' &#123;</span><br><span class="line">    "index" : &#123;</span><br><span class="line">        "number_of_replicas" : 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>执行完批量索引之后,把刷新间隔改回来:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">curl -XPUT <span class="string">'localhost:9200/my_index/_settings'</span> <span class="_">-d</span> <span class="string">'&#123;</span><br><span class="line">    "index" : &#123;</span><br><span class="line">        "refresh_interval" : "1s"</span><br><span class="line">    &#125; </span><br><span class="line">&#125;'</span></span><br></pre></td></tr></table></figure>
<p>你还可以强制执行一次refresh以及索引分段的合并:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST <span class="string">'localhost:9200/my_index/_refresh'</span></span><br><span class="line">curl -XPOST <span class="string">'localhost:9200/my_index/_forcemerge?max_num_segments=5'</span></span><br></pre></td></tr></table></figure>
<h2 id="flush操作"><a href="#flush操作" class="headerlink" title="flush操作"></a>flush操作</h2><p>随着translog文件越来越大时要考虑把内存中的数据刷新到磁盘中，这个过程称为flush，flush过程主要做了如下操作:</p>
<ul>
<li>把所有在内存缓冲区中的文档写入到一个新的segment中</li>
<li>清空内存缓冲区</li>
<li>往磁盘里写入commit point信息</li>
<li>文件系统的page cache(segments) fsync到磁盘</li>
<li>删除旧的translog文件，因此此时内存中的segments已经写入到磁盘中,就不需要translog来保障数据安全了</li>
</ul>
<p>flush之后的状态如下所示:</p>
<p><img src="/images/images/es/4.png" alt=""></p>
<p>es有几个条件来决定是否flush到磁盘,不同版本的es参数有所不同，大家可以参考es对应版本的文档来查看这几个参数:<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-translog.html" target="_blank" rel="external">es translog</a>,这里介绍下1.7版本的flush参数:</p>
<ul>
<li>index.translog.flush_threshold_ops,执行多少次操作后执行一次flush，默认无限制</li>
<li>index.translog.flush_threshold_size，translog的大小超过这个参数后flush，默认512mb</li>
<li>index.translog.flush_threshold_period,多长时间强制flush一次,默认30m</li>
<li>index.translog.interval,es多久去检测一次translog是否满足flush条件</li>
</ul>
<p>上面的参数是es多久执行一次flush操作,在系统恢复过程中es会比较translog和segments中的数据来保证数据的完整性,为了数据安全es默认每隔5秒钟会把translog刷新(fsync)到磁盘中,也就是说系统掉电的情况下es最多会丢失5秒钟的数据,如果你对数据安全比较敏感,可以把这个间隔减小或者改为每次请求之后都把translog fsync到磁盘,但是会占用更多资源；这个间隔是通过下面2个参数来控制的:</p>
<ul>
<li>index.translog.sync_interval 控制translog多久fsync到磁盘,最小为100ms</li>
<li>index.translog.durability translog是每5秒钟刷新一次还是每次请求都fsync，这个参数有2个取值:request(每次请求都执行fsync,es要等translog fsync到磁盘后才会返回成功)和async(默认值,translog每隔5秒钟fsync一次)</li>
</ul>
<p>读者需要弄清楚flush和fsync的区别,flush是把内存中的数据(包括translog和segments)都刷到磁盘,而fsync只是把translog刷新的磁盘(确保数据不丢失)。<br>最后附上一个实用的elastic配置文件<a href="https://github.com/EZLippi/Profiles/blob/master/java/elasticsearch.yml" target="_blank" rel="external">https://github.com/EZLippi/Profiles/blob/master/java/elasticsearch.yml</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MySQL常用参数列表]]></title>
      <url>http://www.ezlippi.com/blog/2018/04/mysql-settings.html</url>
      <content type="html"><![CDATA[<p>收集一些常用的MySQL参数，方便日后使用。<br><a id="more"></a></p>
<h2 id="全局参数"><a href="#全局参数" class="headerlink" title="全局参数"></a>全局参数</h2><h3 id="通用配置"><a href="#通用配置" class="headerlink" title="通用配置"></a>通用配置</h3><ol>
<li><p>max_connections</p>
<p> MySQL能创建的最大连接数，如果数据库的并发量比较大，建议调高此值，以增加并行连接数量，当然连接数越多，由于MySQL会为每个连接创建连接缓冲区，连接数越多会消耗更多内存</p>
</li>
<li><p>open_files_limit</p>
<p> MySQL打开的文件描述符限制，默认最小1024</p>
</li>
<li><p>port<br> = 3306 守护进程监听端口</p>
</li>
<li><p>socket<br> = /tmp/mysql.sock 本地sock文件</p>
</li>
<li><p>basedir<br> = /opt/mysql57 mysql安装目录</p>
</li>
<li><p>datadir<br> = /opt/mysql57/var mysql数据目录</p>
</li>
<li><p>back_log<br> = 600 参数值指定到来的TCP/IP连接的侦听队列的大小</p>
</li>
<li><p>max_connect_errors<br> = 6000 允许每个客户端最多尝试登录次数</p>
</li>
<li><p>skip-name-resolve<br> 跳过域名解析，只使用ip</p>
</li>
<li><p>default-storage-engine<br>= InnoDB 默认存储引擎</p>
</li>
</ol>
<h3 id="缓冲区参数"><a href="#缓冲区参数" class="headerlink" title="缓冲区参数"></a>缓冲区参数</h3><ol>
<li><p>key_buffer_size<br> key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度。</p>
</li>
<li><p>query_cache_size<br> 使用查询缓冲，MySQL将查询结果存放在缓冲区中，今后对于同样的SELECT语句（区分大小写），将直接从缓冲区中读取结果。</p>
</li>
<li><p>record_buffer_size<br> 每个进行一个顺序扫描的线程为其扫描的每张表分配这个大小的一个缓冲区。如果你做很多顺序扫描，你可能想要增加该值。</p>
</li>
<li><p>wait_timeout<br> 指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。</p>
</li>
</ol>
<h2 id="innodb引擎相关配置"><a href="#innodb引擎相关配置" class="headerlink" title="innodb引擎相关配置"></a>innodb引擎相关配置</h2><ol>
<li><p>sync_binlog</p>
<p> 二进制日志文件binlog的刷新写入方式，这个参数不仅影响到Binlog日志对MySQL所带来的性能损耗，而且还影响到MySQL中数据的完整性。参数设置说明如下：<br> 1) sync_binlog=0，<br> 当事务提交之后，MySQL不做fsync之类的磁盘同步指令刷新binlog_cache中的信息到磁盘，而让文件系统自行决定什么时候来做同步，或者cache满了之后才同步到磁盘。如果没刷新到磁盘前系统宕机，则会丢失最后的binlog内容，但是此参数性能最佳<br> 2) sync_binlog=n，<br> 当每进行n次事务提交之后，MySQL将进行一次fsync之类的磁盘同步指令来将binlog_cache中的数据强制写入磁盘。</p>
</li>
<li><p>innodb_flush_logs_at_trx_commit </p>
<p> InnoDB引擎事务日志文件的刷新写入方式，这个参数对InnoDB引擎的写入性能来说非常重要，有以下3种设置：<br> 1) =1时，在每个事务提交时，日志缓冲被写到日志文件，对日志文件做到磁盘操作的刷新。最安全的方式，但是速度最慢。<br> 2) =2时，在每个事务提交时，日志缓冲被写到文件，但不对日志文件做到磁盘操作的刷新。只有操作系统崩溃或掉电才会删除最后一秒的事务，不然不会丢失事务。<br> 3) =0时， 日志缓冲每秒一次地被写到日志文件，并且对日志文件做到磁盘操作的刷新。任何mysqld进程的崩溃会删除崩溃前最后一秒的事务</p>
</li>
<li><p>innodb_flush_method</p>
<p> 这个参数控制着innodb数据文件及redo og的打开、刷写模式，有以下3种设置：<br> 1) 默认是fdatasync，调用fsync()去刷数据文件与redo log的buffer<br> 2) 为O_DSYNC时，innodb会使用O_SYNC方式打开和刷写redo log,使用fsync()刷写数据文件，通常比较慢。<br> 3) 为O_DIRECT时，innodb使用O_DIRECT打开数据文件，使用fsync()刷写数据文件跟redo log，在Linux上使用Direct IO，可以显著提高速度，特别是在RAID系统上，避免额外的数据复制和double buffering（mysql buffering 和OS buffering）。</p>
<p> 任何数据库，只要涉及到持久化，就与上面这三个方面的参数有极大关系，包括NOSQL与内存数据库，有时NOSQL与内存数据库之所以比MYSQL快，与这方面的设置也有很大关系</p>
<p> 其实，在大部分场景下，如果某个产品宣称自己的写读tps超过其他存储n倍，一般来说都是从k-v这个角度入手进行优化的，主要入手的点是树的数据结构优化和锁的细化，一般都能在一些特定的场景获得5-10倍的性能提升。</p>
</li>
<li><p>innodb_buffer_pool_size </p>
<p> 这是Innodb最重要的一个配置参数，这个参数控制Innodb本身的缓大小，也影响到，多少数据能在缓存中。建议该参数的配置在物理内存的70％－80％之间。</p>
</li>
<li><p>innodb_io_capacity</p>
<p> 这个参数控制Innodb checkpoint时的IO能力，一般可以按一块SAS 15000转的磁盘200个计算，6块盘的SAS做的Raid10这个值可以配到600即可。如果是普通的SATA一块盘只能按100算。(innodb-plugin, Percona有这个参数) </p>
</li>
<li><p>innodb_log_file_size</p>
<p> 在高写入负载尤其是数据集很大的时候，这个值非常重要，值越高性能越好，不过可能会增加数据恢复的时候。我设置为128M。</p>
</li>
</ol>
<h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件:"></a>日志文件:</h2><h3 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h3><ol>
<li>log-error=”filename.log”</li>
</ol>
<p>可以通过如下sql语句查询error日志配置路径:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">'log_error%'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h3><ol>
<li><p>参数配置:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">log</span>-output=FILE</span><br><span class="line">general-log=1</span><br><span class="line">general_<span class="built_in">log</span>_file=<span class="string">"filename.log"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过sql语句查询日志路径:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">'general_log%'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><ol>
<li><p>参数配置</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">slow-query-log = 1</span><br><span class="line">slow-query-log-file = /usr/loval/var/mysql/mysql-slow.log</span><br><span class="line">long_query_time = 1 <span class="comment">#设置满请求时间</span></span><br><span class="line"><span class="built_in">log</span>-queries-not-using-indexes</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过sql语句查询慢查询日志配置:</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; SHOW VARIABLES LIKE <span class="string">'slow_query_log%'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="二进制日志"><a href="#二进制日志" class="headerlink" title="二进制日志"></a>二进制日志</h3><ol>
<li>log-bin=mysql-bin    表示启用二进制日志记录，服务器记录了所有改变数据语句的二进制日志，用于备份和复制。</li>
<li>binlog_format=mixed  设置binlog格式,可选如下三种:<ul>
<li>Row,日志中会记录成每一行数据被修改的形式,缺点是会产生大量的日志</li>
<li>Statement,每一条会修改数据的SQL都会记录到master的bin-log中,如果sql语句包含函数可能会导致主从数据库的数据不一致，比如调用NOW()函数获取时间</li>
<li>Mixed,MySQL会根据执行的每一条具体的SQL语句来区分对待记录的日志形式,也就是在 statement和row之间选择一种。</li>
</ul>
</li>
</ol>
<h2 id="操作系统优化"><a href="#操作系统优化" class="headerlink" title="操作系统优化"></a>操作系统优化</h2><h3 id="网络优化"><a href="#网络优化" class="headerlink" title="网络优化"></a>网络优化</h3><p>修改/etc/sysctl.conf文件</p>
<pre><code>1. 增加SYN队列长度:net.ipv4.tcp_max_syn_backlog = 65535
2. socket资源回收优化
net.ipv4.tcp_tw_recycle = 1    处理TIME-WAIT状态的Socket快速回收
net.ipv4.tcp_tw_reuse = 1    允许将处于TIME-WAIT状态的Socket重新用于新的连接
net.ipv4.tcp_fin_timeout = 30    处于FIN_WAIT-2状态的时间
</code></pre><h3 id="打开文件数限制"><a href="#打开文件数限制" class="headerlink" title="打开文件数限制"></a>打开文件数限制</h3><p>通过ulimit -a查看限制,修改/etc/security/limits.conf，增加打开文件句柄限制</p>
<pre><code>* soft nofile 65536
* hard nofile 65535
</code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ol>
<li><a href="https://blog.csdn.net/jiao_fuyou/article/details/15810229" target="_blank" rel="external">影响MySQL之IO性能最重要的几个参数</a></li>
<li><a href="https://www.jianshu.com/p/8cef22b6917f" target="_blank" rel="external">mysql参考配置以及参数解释</a> </li>
<li><a href="https://blog.csdn.net/hytfly/article/details/53426630" target="_blank" rel="external">Linux内核tcp调优方案</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[慎用java的finalize方法]]></title>
      <url>http://www.ezlippi.com/blog/2018/04/final-reference.html</url>
      <content type="html"><![CDATA[<p>我们通常用构造器来创建对象,而Finalize正好相反,构造方法执行对象的初始化操作,finalize方法执行对象的销毁操作.<br>那我们什么时候需要使用finalize方法呢,我们都知道Java里垃圾回收器可以回收对象使用的内存空间,但是对象可能会<br>持有很多资源比如Socket、文件句柄等,垃圾收集器无法回收这些资源,因此你需要使用finalize方法帮助GC回收这些<br>资源,比如关闭打开的文件或者网元资源,删除临时文件等.</p>
<a id="more"></a>
<h2 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h2><p>Object类是所有类的父类,如果你去查看java.lang.Object类的源码,你会发现里面有个finalize方法,这个方法没有默认实现,需要子类根据实际情况重写这个方法,但是如果不恰当使用finalize方法可能会造成很大的负面影响,比如下面的例子:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">           Thread.yield();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String str[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            Finalizer force = <span class="keyword">new</span> Finalizer();</span><br><span class="line">        &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当我们运行上述代码时,可以看到创建大量的Finalizer对象,运行一段时间后一般出现以下两种结果:</p>
<ol>
<li>JVM异常退出并且生成了内存镜像Dump</li>
<li>JVM抛出了一个异常:Out of Memory:GC OverHead limit exceeded.</li>
</ol>
<p>不管上述两种情况,JVM都崩溃了,那到底执行finalize方法时发生了什么.Jvm会给每个实现了finalize方法的实例创建一个监听,这个称为Finalizer,每次调用对象的finalize方法时,JVM会创建一个<code>java.lang.ref.Finalizer</code>对象,这个Finalizer对象会持有这个对象的引用,由于这些对象被Finilizer对象引用了,当对象数量较多时,就会导致Eden区空间满了,经历多次youngGC后可能对象就进入到老年代了.<br><code>java.lang.ref.Finalizer</code>类继承自<code>java.lang.ref.FinalReference</code>,也是Refence的一种,因此Finalizer类里也有一个引用队列,这个引用队列是JVM和垃圾回收器打交道的唯一途径,当垃圾回收器需要回收该对象时,会把该对象放到引用队列中,这样java.lang.ref.Finalizer类就可以从队列中取出该对象,执行对象的finalize方法,并清除和该对象的引用关系.需要注意的是只有finalize方法实现不为空时JVM才会执行上述操作,JVM在类的加载过程中会标记该类是否为finalize类.</p>
<h2 id="GC怎么处理这些对象呢"><a href="#GC怎么处理这些对象呢" class="headerlink" title="GC怎么处理这些对象呢"></a>GC怎么处理这些对象呢</h2><p>当老年代空间达到了OldGC条件时,JVM执行一次OldGC,当OldGC执行后JVM检测到这些对象只被Finalizer对象引用,这些对象会被标记成要被清除的对象,GC会把所有的Finalizer对象放入到一个引用队列:<code>java.lang.ref.Finalizer.ReferenceQueue</code>.</p>
<h2 id="Finalizer对象怎么被清理的呢"><a href="#Finalizer对象怎么被清理的呢" class="headerlink" title="Finalizer对象怎么被清理的呢"></a>Finalizer对象怎么被清理的呢</h2><p>JVM默认会创建一个finalizer线程来处理Finalizer对象,如果你去抓取线程堆栈的话可以看到这个线程的堆栈,如下所示:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"Finalizer"</span> daemon prio=10 tid=0x0962d000 nid=0x4836 runnable [0xafaa8000]</span><br><span class="line">   java.lang.Thread.State: RUNNABLE</span><br><span class="line">        at java.lang.Thread.yield(Native Method)</span><br><span class="line">        at finalizer.finalize(finalizer.java:5)</span><br><span class="line">        at java.lang.ref.Finalizer.invokeFinalizeMethod(Native Method)</span><br><span class="line">        at java.lang.ref.Finalizer.runFinalizer(Finalizer.java:83)</span><br><span class="line">        at java.lang.ref.Finalizer.access<span class="variable">$100</span>(Finalizer.java:14)</span><br><span class="line">        at java.lang.ref.Finalizer<span class="variable">$FinalizerThread</span>.run(Finalizer.java:160)</span><br></pre></td></tr></table></figure></p>
<p>这个线程唯一的职责就是不断的从<code>java.lang.ref.Finalizer.ReferenceQueue</code>队列中取对象,当一个对象进入到队列中,finalizer线程就执行对象的finalize方法并且把对象从队列中删除,因此在下一次GC周期中可以看到这个对象和Finalizer对象都被清除了.</p>
<p>大部分场景finalizer线程清理finalizer队列是比较快的,但是一旦你在finalize方法里执行一些耗时的操作,可能导致内存无法及时释放进而导致内存溢出的错误,在实际场景还是推荐尽量少用finalize方法.</p>
<h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Finalizer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"finalize"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String str[])</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                Finalizer force = <span class="keyword">new</span> Finalizer();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//让线程阻塞住,方便分析内存使用情况</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行main方法后使用jmap命令查看内存使用情况,可以看到<code>java.lang.ref.Finalizer</code>和Finalizer的实例都创建了10000个:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo 8700|head -n 10</span><br><span class="line"></span><br><span class="line"> num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:           646        3398408  [I</span><br><span class="line">   2:          1851        1511144  [B</span><br><span class="line">   3:          6081         808864  [C</span><br><span class="line">   4:         10175         407000  java.lang.ref.Finalizer</span><br><span class="line">   5:         10000         160000  Finalizer</span><br><span class="line">   6:          4328         103872  java.lang.String</span><br><span class="line">   7:           601          64208  java.lang.Class</span><br><span class="line">   8:           683          40952  [Ljava.lang.Object;</span><br><span class="line">   9:           785          31400  java.util.TreeMap<span class="variable">$Entry</span></span><br><span class="line">  10:           248          14144  [Ljava.lang.String;</span><br></pre></td></tr></table></figure></p>
<p>接下来使用jmap -histo:live 8700|head -n 10命令强制触发一次GC,结果和前面的分析一致,Finalizer对象都放到引用队列中,并依次调用了对象的finalize方法,内存中java.lang.ref.Finalizer和Finalizer对象依然存在,不过这一java.lang.ref.Finalizer<br>不再引用Finalizer对象,下一次GC周期时两者都属于垃圾对象:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo:live 8700|head -n 10</span><br><span class="line"></span><br><span class="line"> num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:         10175         407000  java.lang.ref.Finalizer</span><br><span class="line">   2:          3043         372608  [C</span><br><span class="line">   3:           605         273624  [B</span><br><span class="line">   4:         10000         160000  Finalizer</span><br><span class="line">   5:          2883          69192  java.lang.String</span><br><span class="line">   6:           601          64208  java.lang.Class</span><br><span class="line">   7:           631          37008  [Ljava.lang.Object;</span><br></pre></td></tr></table></figure>
<p>再触发一次jmap -histo:live 8700|head -n 10，可以看到两者都被回收了:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ jmap -histo:live 8700|head -n 10</span><br><span class="line"></span><br><span class="line"> num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          3059         373224  [C</span><br><span class="line">   2:           498         138064  [B</span><br><span class="line">   3:          2899          69576  java.lang.String</span><br><span class="line">   4:           602          64312  java.lang.Class</span><br><span class="line">   5:           631          37008  [Ljava.lang.Object;</span><br><span class="line">   6:           785          31400  java.util.TreeMap<span class="variable">$Entry</span></span><br><span class="line">   7:           227          11256  [Ljava.lang.String;</span><br></pre></td></tr></table></figure>
<p>最后我们来总结一下:</p>
<ol>
<li>finalize对象至少经历两次GC才能被回收,因为只有在FinalizerThread执行完了finalize对象的finalize方法的情况下才有可能被下次GC回收，而有可能期间已经经历过多次GC了，但是一直还没执行finalize对象的finalize方法;</li>
<li>CPU资源不足的场景FinalizerThread线程可能因为优先级较低而一直没有执行对象的finalize方法,可能导致大部分对象进入到老年代,进而触发老年代GC,设置触发Full GC.</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM解惑:消失的异常堆栈]]></title>
      <url>http://www.ezlippi.com/blog/2018/02/the-missing-stacktrace.html</url>
      <content type="html"><![CDATA[<p>最近在分析日志的时候发现有个日志捕捉了NullPointerException，但是没有异常堆栈信息,只有<code>java.lang.NullPointerException</code>这一条信息,无法知道是从哪里抛出来的, 经过分析是JIT编译器对异常进行了优化，当代码中的某个位置抛出同一个异常很多次后,JIT服务端编译器(C2)会将其优化成抛出一个事先编译好的、类型匹配的异常,异常堆栈信息就看不到了。<br><a id="more"></a></p>
<p>引用R大的一段话:</p>
<blockquote>
<p>HotSpot VM有个许多人觉得“匪夷所思”的优化，叫做fast throw：有些特定的隐式异常类型（NullPointerException、ArithmeticException（ / 0）之类）如果在代码里某个特定位置被抛出过多次的话，HotSpot Server Compiler（C2）会透明的决定用fast throw来优化这个抛出异常的地方——直接抛出一个事先分配好的、类型匹配的异常对象。这个对象的message和stack trace都被清空。抛出这个异常的速度是非常快，不但不用额外分配内存，而且也不用爬栈；但反面就是可能正好是需要知道哪里出问题的时候看不到stack trace了。从Sun JDK5开始要避免C2做这个优化还得额外传个VM参数：-XX:-OmitStackTraceInFastThrow。</p>
</blockquote>
<h2 id="问题重现"><a href="#问题重现" class="headerlink" title="问题重现"></a>问题重现</h2><p>既然知道这是JIT编译优化导致的,那就很容易写代码来重现,测试代码如下,使用的是JDK1.8.0_25:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">200000</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ((Object)<span class="keyword">null</span>).getClass();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">               System.out.println(i + <span class="string">":"</span> + e.getStackTrace().length);</span><br><span class="line">               <span class="keyword">if</span> (e.getStackTrace().length == <span class="number">0</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"stackTrace omit after "</span> + i + <span class="string">" times"</span>);</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">                   <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果是在调用115712次后JIT做了编译优化,在第115713次时异常堆栈看不到了,stackTrace长度为0:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">115711:1</span><br><span class="line">115712:1</span><br><span class="line">115713:0</span><br><span class="line">stackTrace omit after 115713 <span class="built_in">times</span></span><br><span class="line">java.lang.NullPointerException</span><br></pre></td></tr></table></figure></p>
<h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>JVM提供了<font color="#ff0000"><code>-XX:-OmitStackTraceInFastThrow</code></font>这个虚拟机参数来告诉JIT编译器禁用这种异常fastThrow的优化,当然如果你使用-Xint参数后虚拟机运行在解释器模式也不会出现这个问题，但是禁用JIT会对整体的性能有影响,因此不建议使用-Xint参数,如果想看到具体的异常堆栈,推荐使用<code>-XX:-OmitStackTraceInFastThrow</code>参数。</p>
<p>那JVM为什么要对异常进行优化呢，这里就牵扯到另一个问题了,如果你在系统响应慢的时候分析过线程堆栈,可能遇到过线程耗在调用fillInStackTrace()这个native方法的时间非常长,fillInStackTrace()方法用来爬取线程的调用堆栈,我之前就遇到过Log4j打印日志非常慢的问题,结果抓取线程堆栈后发现线程都是卡在fillInStackTrace()这个native方法，如果有些使用场景不需要完整的调用堆栈时,建议重写fillInStackTrace()，让它直接return this，可以一定程度的提高系统的吞吐量。</p>
<h2 id="fillInStackTrace优化"><a href="#fillInStackTrace优化" class="headerlink" title="fillInStackTrace优化"></a>fillInStackTrace优化</h2><p>我们知道所有的Exception和Error都是Throwable的子类，构造子类实例前都先调用父类的实例构造方法，我们看下Throwable类的源码就会发现在构造方法里调用了fillInStackTrace()方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a new throwable with &#123;<span class="doctag">@code</span> null&#125; as its detail message.</span><br><span class="line"> * The cause is not initialized, and may subsequently be initialized by a</span><br><span class="line"> * call to &#123;<span class="doctag">@link</span> #initCause&#125;.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;The &#123;<span class="doctag">@link</span> #fillInStackTrace()&#125; method is called to initialize</span><br><span class="line"> * the stack trace data in the newly created throwable.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Throwable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fillInStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Throwable <span class="title">fillInStackTrace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stackTrace != <span class="keyword">null</span> || backtrace != <span class="keyword">null</span> ) &#123;</span><br><span class="line">		<span class="comment">//这里调用native的fillInStackTrace方法</span></span><br><span class="line">        fillInStackTrace(<span class="number">0</span>);</span><br><span class="line">        stackTrace = UNASSIGNED_STACK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到当stackTrace不为null时需要调用native的fillInStackTrace()方法，那什么时候stackTrace变量为null呢，通过追踪源码可以发现Throwable类有多个重载的构造方法,其中有个方法可以传递一个writableStackTrace参数,当这个参数为false的时候stackTrace就为null，这时候就不会调用native的fillInStackTrace()方法去爬取线程堆栈，当然你也可以<font color="#ff0000">重写fillInStackTrace()方法</font>，让他直接返回this,这样也可以避免爬栈,但是还是建议大家谨慎使用，毕竟需求时刻在变，说不定什么时候就需要这个堆栈来定位问题了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Throwable</span><span class="params">(String message, Throwable cause,</span><br><span class="line">                    <span class="keyword">boolean</span> enableSuppression,</span><br><span class="line">                    <span class="keyword">boolean</span> writableStackTrace)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (writableStackTrace) &#123;</span><br><span class="line">        fillInStackTrace();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        stackTrace = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    detailMessage = message;</span><br><span class="line">    <span class="keyword">this</span>.cause = cause;</span><br><span class="line">    <span class="keyword">if</span> (!enableSuppression)</span><br><span class="line">        suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面提到了Log4j打印日志慢的问题,那Log4j打印日志为什么也涉及到这个fillInStackTrace方法呢，对Log4j有研究过的同学应该知道如果Log4j配置文件里配置了<font color="#ff0000">%C(类全限定包名)、%F(文件名)、%M(打印日志的方法名称)和%L(行号)</font>这几个用于定位调用者信息的pattern时,Log4J会先抛出一个异常出来，然后从异常堆栈中来获取调用者的信息,既然是抛异常出来必然涉及到调用native的fillInStackTrace方法来爬取线程堆栈,因此开启这些参数对系统的性能是有影响的。</p>
<h2 id="用Btrace定位异常的抛出者"><a href="#用Btrace定位异常的抛出者" class="headerlink" title="用Btrace定位异常的抛出者"></a>用Btrace定位异常的抛出者</h2><p>前面写了一篇博文介绍怎么用Btrace来定位线上问题,为了证实前面的论断,我写了个btrace脚本来定位NullPointerException的抛出堆栈,如果你的系统禁用了Exception fastSlow,但是你想定位具体哪个方法抛出了某个异常,也可以参考下面这个脚本：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//btrace不能保存全局变量,可以保存在ThreadLocal</span></span><br><span class="line">    <span class="meta">@TLS</span> <span class="keyword">static</span> Throwable currentException;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//这里有两个重载方法是因为空指针异常有两个重载的构造方法</span></span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"java.lang.NullPointerException"</span>, method = <span class="string">"&lt;init&gt;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceNullPointerException</span><span class="params">(@Self Throwable self)</span> </span>&#123;</span><br><span class="line">        currentException = self;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//匹配带参数的构造方法</span></span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"java.lang.NullPointerException"</span>, method = <span class="string">"&lt;init&gt;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceNullPointerException</span><span class="params">(@Self Throwable self, String message)</span> </span>&#123;</span><br><span class="line">        currentException = self;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//异常构造完成后打印异常堆栈</span></span><br><span class="line">    <span class="meta">@OnMethod</span>(clazz = <span class="string">"java.lang.NullPointerException"</span>, method = <span class="string">"&lt;init&gt;"</span>,</span><br><span class="line">            location = <span class="meta">@Location</span> (Kind.RETURN))</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onThrowReturn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentException != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Threads.jstack(currentException);</span><br><span class="line">            println(<span class="string">"====================="</span>);</span><br><span class="line">            currentException = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行文章最开始的Main方法后,使用jps获取java进程pid，然后使用<font color="#ff0000">Btrace $pid 脚本名称</font> 来启动监控任务,可以发现在一段时间后不会打印异常堆栈了,因为JIT已经对代码做了优化，抛出了一个事先编译好的类型匹配的异常,因此也就不会调用NullPointerException的构造方法:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">DEBUG: received com.sun.btrace.comm.MessageCommand@e93f3d5</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">DEBUG: received com.sun.btrace.comm.MessageCommand@4cee7fa0</span><br><span class="line">        Main.main(Main.java:5)</span><br><span class="line">DEBUG: received com.sun.btrace.comm.MessageCommand@7a26928a</span><br><span class="line">=====================</span><br><span class="line">DEBUG: received com.sun.btrace.comm.MessageCommand@601cbd8c</span><br><span class="line">java.lang.NullPointerException</span><br><span class="line">DEBUG: received com.sun.btrace.comm.MessageCommand@7180e701</span><br><span class="line">        Main.main(Main.java:5)</span><br><span class="line">输出115712条信息后没有堆栈信息了...</span><br></pre></td></tr></table></figure>
<p>参考文章:</p>
<ol>
<li><a href="https://stackoverflow.com/questions/1076191/nullpointerexception-stack-trace-not-available-without-debug-agent" target="_blank" rel="external">NullPointerException stack trace not available without debug agent
</a></li>
<li><a href="https://bugs.java.com/bugdatabase/view_bug.do?bug_id=4292742" target="_blank" rel="external">JDK-4292742 : NullPointerException with no stack trace</a></li>
<li><a href="http://calvin1978.blogcn.com/articles/btrace1.html" target="_blank" rel="external">Btrace入门到熟练小工完全指南</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客添加在线联系功能]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/next-chat.html</url>
      <content type="html"><![CDATA[<p>Hexo博客如何添加在线联系功能呢,发现了一个不错的网站可以提供在线联系的服务，当有用户在网页上给你留言后会通过邮件或者微信通知你，可以及时的解答用户的疑问。</p>
<a id="more"></a>
<p>最终的效果可以参考我博客的右下角,有个聊天的按钮,效果如下所示:<br><img src="/images/images/chat-style.png" alt=""><br>配置方法如下:<br>首先到<a href="http://dashboard.daovoice.io/get-started?invite_code=d1b06a58" target="_blank" rel="external">DaoVoice</a>上注册一个账号,注册完成后会得到一个app_id，获取appid的步骤如下图所示:<br><img src="/images/images/daovoice.png" alt=""><br>以next主题为例,打开/themes/next/layout/_partials/head.swig文件添加如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">if</span> theme.daovoice %&#125;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">i,s,o,g,r,a,m</span>)</span>&#123;i[<span class="string">"DaoVoiceObject"</span>]=r;i[r]=i[r]||<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;(i[r].q=i[r].q||[]).push(<span class="built_in">arguments</span>)&#125;,i[r].l=<span class="number">1</span>*<span class="keyword">new</span> <span class="built_in">Date</span>();a=s.createElement(o),m=s.getElementsByTagName(o)[<span class="number">0</span>];a.async=<span class="number">1</span>;a.src=g;a.charset=<span class="string">"utf-8"</span>;m.parentNode.insertBefore(a,m)&#125;)(<span class="built_in">window</span>,<span class="built_in">document</span>,<span class="string">"script"</span>,(<span class="string">'https:'</span> == <span class="built_in">document</span>.location.protocol ? <span class="string">'https:'</span> : <span class="string">'http:'</span>) + <span class="string">"//widget.daovoice.io/widget/0f81ff2f.js"</span>,<span class="string">"daovoice"</span>)</span><br><span class="line">  daovoice(<span class="string">'init'</span>, &#123;</span><br><span class="line">      app_id: <span class="string">"&#123;&#123;theme.daovoice_app_id&#125;&#125;"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  daovoice(<span class="string">'update'</span>);</span><br><span class="line">  <span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure></p>
<p>接着打开主题配置文件_config.yml，添加如下代码：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Online contact </span><br><span class="line">daovoice: true</span><br><span class="line">daovoice_app_id: 这里输入前面获取的app_id</span><br></pre></td></tr></table></figure></p>
<p>最后执行hexo cl &amp;&amp; hexo g &amp;&amp; hexo s就能看到效果了。</p>
<p>需要注意的是,next主题下聊天的按钮会和其他按钮重叠到一起，可以到聊天设置，修改下按钮的位置:<br><img src="/images/images/chat.png" alt=""><br>最后到右上角选择管理员，微信绑定,可以绑定你的微信号，关注公众号后打开小程序，就可以实时收发消息，有新的消息也会通过微信通知，设置页面如下:<br><img src="/images/images/wechat.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM调优:CardTable简介]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/jvm-card-table-turning.html</url>
      <content type="html"><![CDATA[<p>网上关于JVM调优的文章很多,这篇文章主要介绍JVM里Card Table的作用。我们知道JVM GC可以分为MinorGC、MajorGC和FullGC,对于Mirnor GC来讲它的耗时主要由两个因素决定:</p>
<ol>
<li>复制活跃对象的时间</li>
<li>扫描card table(老年代对象引用新生代对象)的时间</li>
</ol>
<a id="more"></a>
<p>Java虚拟机用了一个叫做CardTable(卡表)的数据结构来标记老年代的某一块内存区域中的对象是否持有新生代对象的引用,卡表的数量取决于老年代的大小和每张卡对应的内存大小，每张卡在卡表中对应一个比特位,当老年代中的某个对象持有了新生代对象的引用时,JVM就把这个对象对应的Card所在的位置标记为dirty(bit位设置为1)，这样在Minor GC时就不用扫描整个老年代，而是扫描Card为Dirty对应的那些内存区域。<br><img src="/images/images/cardtable.png" alt=""><br>这样子可以提高效率减少MinorGC的停顿时间。</p>
<p>在JVM中,一个Card的大小是512字节,在多个线程并行收集时,JVM通过ParGCCardsPerStrideChunk参数设置每个线程每次扫描的Card数量，默认是256，相当于是把老年代分成许多strides，每个线程每次扫描一个stride，每个stride大小为512*256 = 128K，如果你的老年代大小为4G,那总共有4G/128K=32K个Strides。多线程在扫描这么多的strides时就涉及到调度和分配的问题,stride数量太多就会导致线程在stride之间切换的开销增加，进而导致GC暂停时间增长。因此JVM提供了ParGCCardsPerStrideChunk这个参数来配置每个stride对应的card数量，这个数量要根据实际的业务场景进行调优,网上一般流传3个魔术数字:32768、4K和8K。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:ParGCCardsPerStrideChunk=4096</span><br></pre></td></tr></table></figure></p>
<p>这个值不能设置的太大，因为GC线程需要扫描这个stride中老年代对象持有的新生代对象的引用，如果只有少量引用新生代的对象那就导致浪费了很多时间在根本不需要扫描的对象上。</p>
<p>参考文档:</p>
<ol>
<li><a href="http://blog.ragozin.info/2012/03/secret-hotspot-option-improving-gc.html" target="_blank" rel="external">Secret HotSpot option improving GC pauses on large heaps</a></li>
<li><a href="https://discuss.pivotal.io/hc/en-us/articles/206529497-Advanced-JVM-and-GC-tuning" target="_blank" rel="external">Advanced JVM and GC tuning</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[btrace动态追踪技术解析]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/btrace-introduce.html</url>
      <content type="html"><![CDATA[<p> 开发环境定位问题手段较多,可以加日志、远程调试hotswap等,但在生产环境就没这么方便了,服务上线后就不能随便重启,比如某个接口有时候返回的数据异常,日志又没打印详情,这时候又想知道方法的入参是什么、是否调用了内部某个方法，或者接口响应时间较长想排查具体在哪个方法上调用比较耗时，这些场景都需要用到动态追踪的技术,btrace就是一个能帮助你分析和监控JVM的工具,采用了动态attach到目标JVM的方法,非侵入式监控,主要使用了JVMT(JVM Tool Interface)和Instrumentation技术,国内介绍btrace的文章并不多,最近正好要在部门内分享btrace的使用心得,因此整理了这篇文档,希望能够把btrace里的技术讲清楚。</p>
<a id="more"></a>
<h2 id="btrace工作流程"><a href="#btrace工作流程" class="headerlink" title="btrace工作流程"></a>btrace工作流程</h2><p>btrace主要采用了Java Compiler API、ASM字节码修改技术、JVMT(JVM Tool Interface)和jdk1.6开始提供的Instrumentation技术,Java Compiler API用于在运行时把java源码编码成class文件;通过ASM字节码修改框架来实现对类的修改,通过tools.jar里提供的attach接口将btrace-agent 动态attach到目标JVM，实现非侵入式监控,btrace-agent会在目标JVM中创建一个Socket服务端,用于实现和btrace-client JVM的通信, btrace-agent会根据你的追踪脚本来生成字节码修改工具类,注册到ClassFileTransformer上,当JVM加载类时会调用ClassFileTransformer的transfrom方法(首次建立连接时会获取所有加载的类触发一次transform),btrace-agent会在transform()方法内对类的字节码进行修改,从而达到追踪的目标。</p>
<p>整个btrace的流程图如下所示:<br><img src="/images/images/btrace.png" alt=""></p>
<h2 id="Instrumentation技术简介"><a href="#Instrumentation技术简介" class="headerlink" title="Instrumentation技术简介"></a>Instrumentation技术简介</h2><p>instrumentation技术提供了在运行时修改类的字节码的入口,你可以在启动脚本中通过-javaagent:jarpath[=options]选项添加到虚拟机参数中,jarpath是agent jar的路径,可以提供一些参数给agent，agent需要自己解析传递进来的参数,agent jar包的manifest文件必须包含Premain-Class属性，这个值定义了agent class的入口,JVM在初始化后会调用agent-class的premain方法,premain方法的定义如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果agent class没有实现上述方法,JVM会尝试调用下面这个重载方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>同时你也可以在agent class中添加一个agentmain方法，这个方法主要是用于在JVM启动之后动态attach到目标JVM后调用的,如果agent是通过命令行参数加载的,则agentmain方法不会被调用;如果agent class无法加载或者agent class没有合适的premain方法,又或者premain方法内部抛出了未捕捉到的异常,JVM会退出。</p>
<p>如果需要在JVM启动之后动态attach agent到目标JVM，需要在agent jar包manifest文件包含Agent-Class属性，值为agent-class的全限定名称,agent class必须实agentmain方法，和premain方法类似，JVM会先尝试调用下面的agentmain方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs, Instrumentation inst)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>如果找不到上面的方法则尝试调用下面的重载方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">agentmain</span><span class="params">(String agentArgs)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="btrace源码分析"><a href="#btrace源码分析" class="headerlink" title="btrace源码分析"></a>btrace源码分析</h2><h3 id="btrace-client启动过程"><a href="#btrace-client启动过程" class="headerlink" title="btrace-client启动过程"></a>btrace-client启动过程</h3><p>使用btrace时需要给btrace脚本传递目标进程的pid以及用于追踪的脚本(java源码),这部分代码的入口在com.sun.btrace.client.Main类的main方法,btrace客户端启动后会先调用Java编译api将追踪的脚本编译成class文件,编译之后attach btrace-agent到目标进程,代码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.sun.btrace.client.Main</span></span><br><span class="line">Client client = <span class="keyword">new</span> Client(port, OUTPUT_FILE, PROBE_DESC_PATH,</span><br><span class="line">    DEBUG, TRACK_RETRANSFORM, TRUSTED, DUMP_CLASSES, DUMP_DIR, statsdDef);</span><br><span class="line"><span class="keyword">if</span> (! <span class="keyword">new</span> File(fileName).exists()) &#123;</span><br><span class="line">    errorExit(<span class="string">"File not found: "</span> + fileName, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">byte</span>[] code = client.compile(fileName, classPath, includePath);</span><br><span class="line"><span class="keyword">if</span> (code == <span class="keyword">null</span>) &#123;</span><br><span class="line">    errorExit(<span class="string">"BTrace compilation failed"</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">client.attach(pid, <span class="keyword">null</span>, classPath);</span><br></pre></td></tr></table></figure></p>
<p>上面的includePath是通过-cp启动参数传递给btrace客户端进程的,用于把-cp指定的路径动态添加到目标虚拟机的bootClasspath上,attach方法先找到btrace-agent.jar的路径,然后继续:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.sun.btrace.client.Client</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(String pid, String sysCp, String bootCp)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	String agentPath = <span class="string">"/btrace-agent.jar"</span>;</span><br><span class="line">	String tmp = Client.class.getClassLoader().getResource(<span class="string">"com/sun/btrace"</span>).toString();</span><br><span class="line">	tmp = tmp.substring(<span class="number">0</span>, tmp.indexOf(<span class="string">'!'</span>));</span><br><span class="line">	tmp = tmp.substring(<span class="string">"jar:"</span>.length(), tmp.lastIndexOf(<span class="string">'/'</span>));</span><br><span class="line">	agentPath = tmp + agentPath;</span><br><span class="line">	agentPath = <span class="keyword">new</span> File(<span class="keyword">new</span> URI(agentPath)).getAbsolutePath();</span><br><span class="line">	attach(pid, agentPath, sysCp, bootCp);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>attach方法里先把tools.jar的路径找出来,这个路径后面要添加到systemClassPath(appClassLoader的加载路径)上，tools.jar是JDK的一个工具类库,包括javac、attach以及监控jvm的工具集比如jstack、jmap、jstat的入口都在这里面,如果没有tools.jar就无法执行这些命令,然后通过VirtualMachine的attach方法获取到目标虚拟机，最后调用loadAgent方法将btrace-agent动态加载,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//com.sun.btrace.client.Client</span></span><br><span class="line">VirtualMachine vm = <span class="keyword">null</span>;</span><br><span class="line">vm = VirtualMachine.attach(pid);</span><br><span class="line">String toolsPath = getToolsJarPath(</span><br><span class="line">    serverVmProps.getProperty(<span class="string">"java.class.path"</span>),</span><br><span class="line">    serverVmProps.getProperty(<span class="string">"java.home"</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">if</span> (sysCp == <span class="keyword">null</span>) &#123;</span><br><span class="line">    sysCp = toolsPath;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sysCp = sysCp + File.pathSeparator + toolsPath;</span><br><span class="line">&#125;</span><br><span class="line">agentArgs += <span class="string">",systemClassPath="</span> + sysCp;</span><br><span class="line">vm.loadAgent(agentPath, agentArgs);</span><br></pre></td></tr></table></figure></p>
<h3 id="btrace-agent初始化过程"><a href="#btrace-agent初始化过程" class="headerlink" title="btrace-agent初始化过程"></a>btrace-agent初始化过程</h3><p>前面将btrace-agent.jar attach到目标jvm后,jvm会调用btrace-agent.jar的Manifest文件中的Agent-Class的agentMain方法,manifest文件内容如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Premain-Class: com.sun.btrace.agent.Main</span><br><span class="line">Agent-Class: com.sun.btrace.agent.Main</span><br><span class="line">Can-Redefine-Classes: true</span><br><span class="line">Can-Retransform-Classes: true</span><br><span class="line">Boot-Class-Path: btrace-boot.jar</span><br></pre></td></tr></table></figure></p>
<p>上面几个参数的作用简单讲一下:</p>
<ol>
<li>Premain-Class,前面提到过,包含了premain方法的类的全限定类名,JVM启动时调用premain-class的premain方法,如果是通过-javaagent参数传递的,该参数为必须项</li>
<li>Agent-Class，和Premain-Class类似，动态attach到JVM时是必须参数</li>
<li>Boot-Class-Path,可选参数，表示需要添加给bootstrap ClassLoader进行加载的路径,如果有多个路径通过空格进行分割</li>
<li>Can-Redefine-Classes,可选参数,该agent是否需要重定义类,默认为false</li>
<li>Can-Retransform-Classes,可选参数，该agent是否需要对字节码修改,默认为false</li>
</ol>
<p>agentMain方法首先解析btrace-client传递进来的参数,启动追踪脚本,然后会启动一个socket服务端用来和btrace-client进行通信,JVM在调用agentMain方法时会传递一个Instrumentation对象进来,Btrace就是通过Instrumentation来做文章，下面代码的最后面agent给Instrumentation添加了一个BTraceTransformer，这个BTraceTransformer继承自java.lang.instrument.ClassFileTransformer类，用于对类的字节码进行修改,agentMain的主要代码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String args, <span class="keyword">final</span> Instrumentation inst)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//把Instrumentation引用赋值给inst变量</span></span><br><span class="line">    Main.inst = inst;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		loadArgs(args);</span><br><span class="line">		<span class="comment">//解析参数</span></span><br><span class="line">		parseArgs();</span><br><span class="line">		<span class="comment">//启动脚本</span></span><br><span class="line">		<span class="keyword">int</span> startedScripts = startScripts();</span><br><span class="line">		<span class="comment">//另起线程启动socketServer监听客户端连接</span></span><br><span class="line">		Thread agentThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		            <span class="meta">@Override</span></span><br><span class="line">		            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		                BTraceRuntime.enter();</span><br><span class="line">		                <span class="keyword">try</span> &#123;</span><br><span class="line">		                    startServer();</span><br><span class="line">		                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		                    BTraceRuntime.leave();</span><br><span class="line">		                &#125;</span><br><span class="line">		            &#125;</span><br><span class="line">		        &#125;);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="comment">//添加transformer到Instrumentation</span></span><br><span class="line">	        inst.addTransformer(transformer, <span class="keyword">true</span>);</span><br><span class="line">	    &#125;</span><br></pre></td></tr></table></figure></p>
<p>startScripts()方法内部调用了loadBTraceScript()来加载btrace脚本,然后初始化ClientContext和FileClient对象,最后调用handleNewClient()方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">loadBTraceScript</span><span class="params">(String filePath, <span class="keyword">boolean</span> traceToStdOut)</span> </span>&#123;</span><br><span class="line">	SharedSettings clientSettings = <span class="keyword">new</span> SharedSettings();</span><br><span class="line">    clientSettings.from(settings);</span><br><span class="line">    clientSettings.setClientName(scriptName);</span><br><span class="line">	ClientContext ctx = <span class="keyword">new</span> ClientContext(inst, transformer, clientSettings);</span><br><span class="line">    Client client = <span class="keyword">new</span> FileClient(ctx, traceScript);</span><br><span class="line">    <span class="keyword">if</span> (client.isInitialized()) &#123;</span><br><span class="line">        handleNewClient(client).get();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>handleNewClient方法内部会调用<strong>client.retransformLoaded()</strong>来将所有的类进行替换,替换时先获取JVM加载的所有类,然后过滤那些不可修改的以及不在候选范围内的类,也就是说只会对匹配到的类进行替换，比如替换你的Btrace脚本的OnMethod方法里引用的clazz,通过ASM插入一些追踪的代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">retransformLoaded</span><span class="params">()</span> <span class="keyword">throws</span> UnmodifiableClassException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (runtime != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">if</span> (probe.isTransforming() &amp;&amp; settings.isRetransformStartup()) &#123;</span><br><span class="line">	        ArrayList&lt;Class&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	        ClassCache cc = ClassCache.getInstance();</span><br><span class="line">	        <span class="keyword">for</span> (Class c : inst.getAllLoadedClasses()) &#123;</span><br><span class="line">	            <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">	                cc.get(c);</span><br><span class="line">	                <span class="keyword">if</span> (inst.isModifiableClass(c) &amp;&amp;  isCandidate(c)) &#123;</span><br><span class="line">	                    debugPrint(<span class="string">"candidate "</span> + c + <span class="string">" added"</span>);</span><br><span class="line">	                    list.add(c);</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	        list.trimToSize();</span><br><span class="line">	        <span class="keyword">int</span> size = list.size();</span><br><span class="line">	        <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	            Class[] classes = <span class="keyword">new</span> Class[size];</span><br><span class="line">	            list.toArray(classes);</span><br><span class="line">				<span class="comment">//调用BTraceTransformer执行修改</span></span><br><span class="line">	            inst.retransformClasses(classes);   </span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在FileClient初始化过程中会去编译btrace追踪脚本,首先调用readScript()把文件转换成字节数组,然后调用init方法,init方法内部把字节数组封装成一个InstrumentCommand对象,最后调用loadClass()方法来完成btrace脚本的加载,loadClass()方法内部创建了一个BTraceProbePersisted,一个Probe相当于是一个探针,探测具体方法的调用,最后把probe注册到BTraceTransformer上,BTraceTransformer对象里会保存所有的Probe列表:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">FileClient(ClientContext ctx, File scriptFile) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">super</span>(ctx);</span><br><span class="line">        <span class="keyword">if</span> (!init(readScript(scriptFile))) &#123;</span><br><span class="line">            debug.warning(<span class="string">"Unable to load BTrace script "</span> + scriptFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(<span class="keyword">byte</span>[] code)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InstrumentCommand cmd = <span class="keyword">new</span> InstrumentCommand(code, <span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">boolean</span> ret = loadClass(cmd, canLoadPack) != <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">            <span class="keyword">super</span>.initialize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> Class <span class="title">loadClass</span><span class="params">(InstrumentCommand instr, <span class="keyword">boolean</span> canLoadPack)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	<span class="comment">//从InstrumentCommand对象中获取字节数组</span></span><br><span class="line">    String[] args = instr.getArguments();</span><br><span class="line">    <span class="keyword">this</span>.btraceCode = instr.getCode();</span><br><span class="line">	<span class="comment">//创建BTraceProbePersisted</span></span><br><span class="line">    probe = load(btraceCode, canLoadPack);</span><br><span class="line">    <span class="keyword">this</span>.runtime = <span class="keyword">new</span> BTraceRuntime(probe.getClassName(), args, <span class="keyword">this</span>, debug, inst);</span><br><span class="line">	<span class="comment">//最后调用register方法把probe注册到transformer上</span></span><br><span class="line">    <span class="keyword">return</span> probe.register(runtime, transformer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>最后来看下probe的register()方法的实现,主要是调用BTraceTransformer.register()方法注册一个probe，然后调用了BTraceProbeSupport的defineClass来加载追踪脚本,实际上是通过Unsafe类来加载的，也就是说追踪脚本类是由JVM的启动类加载器加载的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Class <span class="title">register</span><span class="params">(BTraceRuntime rt, BTraceTransformer t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] code = dataHolder;</span><br><span class="line">        Class clz = delegate.defineClass(rt, code);</span><br><span class="line">		<span class="comment">//调用BTraceTransformer.register()方法注册一个probe</span></span><br><span class="line">        t.register(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.transformer = t;</span><br><span class="line">        <span class="keyword">this</span>.rt = rt;</span><br><span class="line">        <span class="keyword">return</span> clz;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Class <span class="title">defineClassImpl</span><span class="params">(<span class="keyword">byte</span>[] code, <span class="keyword">boolean</span> mustBeBootstrap)</span> </span>&#123;</span><br><span class="line">    ClassLoader loader = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (! mustBeBootstrap) &#123;</span><br><span class="line">        loader = <span class="keyword">new</span> ClassLoader(<span class="keyword">null</span>) &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    Class cl = unsafe.defineClass(className, code, <span class="number">0</span>, code.length, loader, <span class="keyword">null</span>);</span><br><span class="line">    unsafe.ensureClassInitialized(cl);</span><br><span class="line">    <span class="keyword">return</span> cl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="ClassFileTransformer实现修改类"><a href="#ClassFileTransformer实现修改类" class="headerlink" title="ClassFileTransformer实现修改类"></a>ClassFileTransformer实现修改类</h3><p>最后我们来看一下最为关键的BTraceTransformer类的实现,JDK 1.6提供的Instrument技术新增了java.lang.instrument.ClassFileTransformer接口,所有的要加载到JVM中的transformer都要实现这个接口,并重写transform()方法,JVM在加载类的时候会把该类对应的ClassLoader和字节数组传递给transform()方法,实现类可以修改字节数字并把修改后的值返回,需要特别注意的是btrace先会过滤掉classLoader为null(由引导类加载器加载的类,大部分为JVM的核心类库)和系统类加载器加载的类,主要是出于保护JVM核心功能的目的,通过ASM来实现对类的修改:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="keyword">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">    <span class="keyword">if</span> (probes.isEmpty()) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    className = className != <span class="keyword">null</span> ? className : <span class="string">"&lt;anonymous&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((loader == <span class="keyword">null</span> || loader.equals(ClassLoader.getSystemClassLoader())) &amp;&amp; isSensitiveClass(className)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filter.matchClass(className) == Filter.Result.FALSE) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> entered = BTraceRuntime.enter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        BTraceClassReader cr = InstrumentUtils.newClassReader(loader, classfileBuffer);</span><br><span class="line">        BTraceClassWriter cw = InstrumentUtils.newClassWriter(cr);</span><br><span class="line">        <span class="keyword">for</span>(BTraceProbe p : probes) &#123;</span><br><span class="line">            cw.addInstrumentor(p, loader);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] transformed = cw.instrument();</span><br><span class="line">        <span class="keyword">if</span> (transformed == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// no instrumentation necessary</span></span><br><span class="line">            <span class="keyword">return</span> classfileBuffer;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> transformed;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="keyword">throw</span> th;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (entered) &#123;</span><br><span class="line">            BTraceRuntime.leave();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面总结了btrace的工作流程,需要注意的是,btrace监控退出后，原先所有的class都不会被恢复，你的所有的监控代码依然一直在运行,同时为了减少对目标JVM的影响,btrace对追踪脚本做了较多限制,比如不能创建新对象和数组,不能捕捉和抛出异常等,btrace-client在编译完追踪脚本之后会进行校验,校验的详细内容在com.sun.btrace.compilerVerifier类中，感兴趣的同学可以看看, 在btrace-agent端也会通过com.sun.btrace.runtime.instr.MethodInstrumentor类及其子类进行校验,尽量保证我们监控代码的安全。</p>
<p>参考文档:</p>
<ol>
<li><a href="https://docs.oracle.com/javase/6/docs/jdk/api/attach/spec/com/sun/tools/attach/VirtualMachine.html" target="_blank" rel="external">VirtualMachine</a></li>
<li><a href="https://docs.oracle.com/javase/6/docs/api/java/lang/instrument/package-summary.html" target="_blank" rel="external">instrument</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-jpda2/" target="_blank" rel="external">JVMTI 和 Agent 实现</a></li>
<li><a href="http://agapple.iteye.com/blog/1005918" target="_blank" rel="external">btrace一些你不知道的事</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[性能测试Gatling入门教程]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/gatling.html</url>
      <content type="html"><![CDATA[<p>Gatling 是一个功能强大的负载测试工具。它是为易用性、可维护性和高性能而设计的,它能生成丰富多彩的报告，包含测试案例中收集的所有指标,该功能似乎比 JMeter更好,因此我在实际压力测试中选用Gatling。</p>
<a id="more"></a>
<h3 id="Gatling安装"><a href="#Gatling安装" class="headerlink" title="Gatling安装"></a>Gatling安装</h3><p>从Gatling<a href="https://gatling.io/" target="_blank" rel="external">官网</a>下载后解压即可,执行bin目录下的gatling.bat或者gatling.sh即可运行,要先安装好jdk配置好环境变量。</p>
<h3 id="快速教程"><a href="#快速教程" class="headerlink" title="快速教程"></a>快速教程</h3><p>推荐使用Intelj idea + maven archetype插件来搭建开发环境,Gatling采用了Scala DSL语言,首先要配置好Scala环境，在Idea的插件库搜索Scala并安装，然后从<br>Scala<a href="https://www.scala-lang.org/download/" target="_blank" rel="external">官网</a>下载scala SDK,打开Idea的project structure，找到Global Library那一栏，点加号添加下载的Scala SDK.</p>
<p>执行Maven命令创建项目骨架:</p>
<pre><code>mvn archetype:generate -DinteractiveMode=false -DarchetypeGroupId=io.gatling.highcharts -DarchetypeArtifactId=gatling-highcharts-maven-archetype -DgroupId=com.ezlippi  -DartifactId=gatling.test  -Dversion=1.0
</code></pre><p> 生成如下项目结构：在src/test/scala目录下新建一个继承Simulation类的测试类,在里面写测试方法:</p>
 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">OpenApiSimulation</span> <span class="keyword">extends</span> <span class="title">Simulation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">val</span> httpConf = http</span><br><span class="line">    .baseURL(<span class="string">"https://someUrl"</span>)</span><br><span class="line">    .acceptHeader(<span class="string">"application/json"</span>)</span><br><span class="line">    .contentTypeHeader(<span class="string">"application/json"</span>)</span><br><span class="line">    .userAgentHeader(<span class="string">"Mozilla/5.0 (Windows NT 5.1; rv:31.0) Gecko/20100101 Firefox/31.0"</span>)</span><br><span class="line"></span><br><span class="line"> <span class="comment">//forever表示一直执行,具体写法可以参考：https://gatling.io/docs/2.3/general/simulation_setup/</span></span><br><span class="line">  <span class="keyword">val</span> scn = scenario(<span class="string">"com.ezlippi.OpenApiSimulation"</span>)</span><br><span class="line">      .forever(exec(http(<span class="string">"request_1"</span>)</span><br><span class="line">        .get(<span class="string">""</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">//只执行一次</span></span><br><span class="line"><span class="comment">//  val scn = scenario("com.ezlippi.OpenApiSimulation")</span></span><br><span class="line"><span class="comment">//      .exec(http("request_1").get("/646df17616081148d3e679"))</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//立刻注入100个用户</span></span><br><span class="line">  <span class="keyword">val</span> injectStrategy = atOnceUsers(<span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">  setUp(</span><br><span class="line">    scn.inject(injectStrategy)</span><br><span class="line">  ).protocols(httpConf).maxDuration(<span class="type">Duration</span>.apply(<span class="number">10</span>, <span class="type">TimeUnit</span>.<span class="type">MINUTES</span>))</span><br></pre></td></tr></table></figure>
<h2 id="执行测试脚本"><a href="#执行测试脚本" class="headerlink" title="执行测试脚本"></a>执行测试脚本</h2><p> 如果通过maven命令执行测试脚本，需要在pom文件中配置gatling-maven-plugin，simulationClass表示要执行的测试类,resultsFolder是测试报告存放的路径，<br> disableCompiler执行的时候是否禁止编译,因为我写完测试类后就右键编译把scala文件编译好了，执行maven命令时没必要再次编译,插件配置如下:<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 测试脚本 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">simulationClass</span>&gt;</span>com.ezlippi.OpenApiSimulation<span class="tag">&lt;/<span class="name">simulationClass</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 结果输出地址 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">resultsFolder</span>&gt;</span>gatling<span class="tag">&lt;/<span class="name">resultsFolder</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">disableCompiler</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disableCompiler</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p> 然后执行mvn gatling:execute就可以执行用例了,输出结果如下:<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">================================================================================</span><br><span class="line">2018-01-22 21:34:27                                           0s elapsed</span><br><span class="line">---- com.ezlippi.OpenApiSimulation ---------------------------------------------</span><br><span class="line">[                                                                          ]  0%</span><br><span class="line">          waiting: 100    / active: 0      / <span class="keyword">done</span>:0     </span><br><span class="line">---- Requests ------------------------------------------------------------------</span><br><span class="line">&gt; Global                                                   (OK=0      KO=0     )</span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">================================================================================</span><br><span class="line">2018-01-22 21:34:32                                           4s elapsed</span><br><span class="line">---- com.ezlippi.OpenApiSimulation ---------------------------------------------</span><br><span class="line">[--------------------------------------------------------------------------]  0%</span><br><span class="line">          waiting: 0      / active: 100    / <span class="keyword">done</span>:0     </span><br><span class="line">---- Requests ------------------------------------------------------------------</span><br><span class="line">&gt; Global                                                   (OK=4789   KO=0     )</span><br><span class="line">&gt; request_1                                                (OK=4789   KO=0     )</span><br><span class="line">================================================================================</span><br></pre></td></tr></table></figure></p>
<h2 id="查看测试报告"><a href="#查看测试报告" class="headerlink" title="查看测试报告"></a>查看测试报告</h2><p> 打开gatling目录已时间戳结尾的文件夹下的index.html文件就可以查看报告了，结果非常明显。</p>
<h2 id="直接通过maven配置"><a href="#直接通过maven配置" class="headerlink" title="直接通过maven配置"></a>直接通过maven配置</h2><p> 如果通过archetype插件创建项目骨架失败了，那可以直接新建maven工程，然后添加如下内容到pom文件中:<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"> <span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">	<span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ezlippi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.7<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scala.version</span>&gt;</span>2.11.7<span class="tag">&lt;/<span class="name">scala.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">gatling.version</span>&gt;</span>2.1.7<span class="tag">&lt;/<span class="name">gatling.version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">scala-maven-plugin.version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">scala-maven-plugin.version</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;gatling.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-recorder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;gatling.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling.highcharts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-charts-highcharts<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;gatling.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scala.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling.highcharts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-charts-highcharts<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-app<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-recorder<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.scala-lang<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-library<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">testSourceDirectory</span>&gt;</span>src/test/scala<span class="tag">&lt;/<span class="name">testSourceDirectory</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;scala-maven-plugin.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">pluginManagement</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">args</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">arg</span>&gt;</span>-target:jvm-1.7<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">arg</span>&gt;</span>-deprecation<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">arg</span>&gt;</span>-feature<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">arg</span>&gt;</span>-unchecked<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">arg</span>&gt;</span>-language:implicitConversions<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">								<span class="tag">&lt;<span class="name">arg</span>&gt;</span>-language:postfixOps<span class="tag">&lt;/<span class="name">arg</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;/<span class="name">args</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.gatling<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>gatling-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 测试脚本 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">simulationClass</span>&gt;</span>com.ezlippi.OpenApiSimulation<span class="tag">&lt;/<span class="name">simulationClass</span>&gt;</span></span><br><span class="line">					<span class="comment">&lt;!-- 结果输出地址 --&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">resultsFolder</span>&gt;</span>gatling<span class="tag">&lt;/<span class="name">resultsFolder</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">disableCompiler</span>&gt;</span>true<span class="tag">&lt;/<span class="name">disableCompiler</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">id</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">goal</span>&gt;</span>copy-dependencies<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.basedir&#125;/dependencies<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">overWriteReleases</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteReleases</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">overWriteSnapshots</span>&gt;</span>false<span class="tag">&lt;/<span class="name">overWriteSnapshots</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">overWriteIfNewer</span>&gt;</span>true<span class="tag">&lt;/<span class="name">overWriteIfNewer</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">includeScope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">includeScope</span>&gt;</span></span><br><span class="line">							<span class="tag">&lt;<span class="name">includeScope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">includeScope</span>&gt;</span></span><br><span class="line">						<span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">					<span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">				<span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p> 在src/test/resources目录下添加logback的配置文件logback.xml,内容如下:<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%-5level] %logger&#123;15&#125; - %msg%n%rEx<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">immediateFlush</span>&gt;</span>false<span class="tag">&lt;/<span class="name">immediateFlush</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"WARN"</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p> 然后执行mvn gatling:execute就大功告成了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用JMH微基准测试一切]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/jmh-test-guide.html</url>
      <content type="html"><![CDATA[<p> 引用江南白衣的一句话:没有测试数据证明的论断，都是可疑的，诚意推荐JMH。这篇文章简要介绍怎么使用JMH来做基准测试,可以作为JMH的入门教程。</p>
<a id="more"></a>
<h3 id="使用Maven搭建基准测试项目骨架"><a href="#使用Maven搭建基准测试项目骨架" class="headerlink" title="使用Maven搭建基准测试项目骨架"></a>使用Maven搭建基准测试项目骨架</h3><p>JMH官方推荐使用Maven来搭建基准测试的骨架,使用也很简单，使用如下命令来生成maven项目:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mvn archetype:generate \</span><br><span class="line">          -DinteractiveMode=<span class="literal">false</span> \</span><br><span class="line">          -DarchetypeGroupId=org.openjdk.jmh \</span><br><span class="line">          -DarchetypeArtifactId=jmh-java-benchmark-archetype \</span><br><span class="line">          -DgroupId=org.sample \</span><br><span class="line">          -DartifactId=<span class="built_in">test</span> \</span><br><span class="line">          -Dversion=1.0</span><br></pre></td></tr></table></figure>
<p>上面的maven命令使用了jmh-java-benchmark-archetype来生成java语言的基准测试骨架，如果使用其他语言可以将这个参数对应替换,所有可选参数参考<a href="http://central.maven.org/maven2/org/openjdk/jmh/" target="_blank" rel="external">jmh</a>,生成的项目groupId是org.sample,artifaceId是test，执行完之后会在当前目录下生成一个test目录，切换到test目录下执行<code>mvn clean install</code>就会生成benchmarks.jar,再使用<code>java -jar benchmarks.jar</code>就可以执行基准测试了。</p>
<h3 id="JMH参数配置"><a href="#JMH参数配置" class="headerlink" title="JMH参数配置"></a>JMH参数配置</h3><p>如果你想直接在已有maven项目中集成JMH，那也很简单,手动在POM文件中添加以下两个依赖就行了,<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.openjdk.jmh<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.19<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从maven archetype插件生成的pom文件来看，这个工程使用了maven-shade-plugin来将所有的依赖打包到同一个jar包中,并在Manifest文件中配置了Main-Class属性，这样就能直接通过java -jar命令来执行了，其实通过maven-assembly-plugin也可以达到同样的效果,如下所示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">archive</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">mainClass</span>&gt;</span>org.openjdk.jmh.Mainp<span class="tag">&lt;/<span class="name">mainClass</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">archive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!-- this is used for inheritance merges --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span> <span class="comment">&lt;!-- bind to the packaging phase --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到jar包的入口在<code>org.openjdk.jmh.Mainp</code>这个类，查看这个类的源码可以发现这个类会从<code>/META-INF/BenchmarkList</code>文件中读取基准测试列表。在工作中你可能经常听过别人说不要logger中使用字符串拼接来打印日志，而是使用占位符或者使用logger.isDebugEnable()语句来判断,这三种写法的性能差异到底有多大,我们就来测试一下。</p>
<p>本文出于演示的目的来讲解JMH的使用,直接使用了官方的例子，使用slf4j+logback的组合来打印日志,首先在POM文件中添加依赖:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在resources目录下添加logback.xml文件，如下所示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"CONSOLE"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%highlight(%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger - %msg%n)<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"STDOUT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.ConsoleAppender"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">encoder</span>&gt;</span><span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span><span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"CONSOLE"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>接下来就在MyBenchmark类中写测试代码了,三个方法分别对应三种不同的打印日志的写法,如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.sample;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.openjdk.jmh.annotations.Benchmark;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyBenchmark</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(MyBenchmark.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConcatenatingStrings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String x = <span class="string">""</span>, y = <span class="string">""</span>, z = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            x += i; y += i; z += i;</span><br><span class="line"></span><br><span class="line">            logger.debug(<span class="string">"Concatenating strings "</span> + x + y + z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testVariableArguments</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String x = <span class="string">""</span>, y = <span class="string">""</span>, z = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            x += i;</span><br><span class="line">            y += i;</span><br><span class="line">            z += i;</span><br><span class="line">            logger.debug(<span class="string">"Variable arguments &#123;&#125; &#123;&#125; &#123;&#125;"</span>, x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Benchmark</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIfDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String x = <span class="string">""</span>, y = <span class="string">""</span>, z = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            x += i; y += i; z += i;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled())</span><br><span class="line">                logger.debug(<span class="string">"If debug enabled &#123;&#125; &#123;&#125; &#123;&#125;"</span>, x, y, z);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后使用maven命令打包并执行:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mvn clean install</span><br><span class="line">$ java -jar target/benchmarks.jar</span><br></pre></td></tr></table></figure></p>
<p>最后三种不同写法的性能对比如下所示：</p>
<table>
<thead>
<tr>
<th style="text-align:left">迭代次数</th>
<th style="text-align:left">字符串拼接</th>
<th style="text-align:left">占位符</th>
<th style="text-align:left">isDebugEnabled</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Iteration 1</td>
<td style="text-align:left">57108,635 ops/s</td>
<td style="text-align:left">97921,939 ops/s</td>
<td style="text-align:left">104993,368 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 2</td>
<td style="text-align:left">58441,293 ops/s</td>
<td style="text-align:left">98036,051 ops/s</td>
<td style="text-align:left">104839,216 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 3</td>
<td style="text-align:left">58231,243 ops/s</td>
<td style="text-align:left">97457,222 ops/s</td>
<td style="text-align:left">106601,803 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 4</td>
<td style="text-align:left">58538,842 ops/s</td>
<td style="text-align:left">100861,562 ops/s</td>
<td style="text-align:left">104643,717 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 5</td>
<td style="text-align:left">57297,787 ops/s</td>
<td style="text-align:left">100405,656 ops/s</td>
<td style="text-align:left">104706,503 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 6</td>
<td style="text-align:left">57838,298 ops/s</td>
<td style="text-align:left">98912,545 ops/s</td>
<td style="text-align:left">105439,939 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 7</td>
<td style="text-align:left">56645,371 ops/s</td>
<td style="text-align:left">100543,188 ops/s</td>
<td style="text-align:left">102893,089 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 8</td>
<td style="text-align:left">56569,236 ops/s</td>
<td style="text-align:left">102239,005 ops/s</td>
<td style="text-align:left">104730,682 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 9</td>
<td style="text-align:left">57349,754 ops/s</td>
<td style="text-align:left">94482,508 ops/s</td>
<td style="text-align:left">103492,227 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Iteration 10</td>
<td style="text-align:left">56894,075 ops/s</td>
<td style="text-align:left">101405,938 ops/s</td>
<td style="text-align:left">106790,525 ops/s</td>
</tr>
<tr>
<td style="text-align:left">Average</td>
<td style="text-align:left"><font color="#FF0000">57491,4534 ops/s</font></td>
<td style="text-align:left"><font color="#00FF00">99226,5614 ops/s</font></td>
<td style="text-align:left"><font color="#00FF00">104913,1069 ops/s</font></td>
</tr>
</tbody>
</table>
<p>最后的结果也很明显了,使用isDebugEnabled性能最佳,使用字符串拼接性能最差，使用占位符性能也还不错，但是占位符的代码可读性更好，因此在项目中推荐使用占位符打印日志。</p>
<p>参考文档:</p>
<ol>
<li><a href="http://openjdk.java.net/projects/code-tools/jmh/" target="_blank" rel="external">jmh官网</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JVM安全点介绍]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/safepoint.html</url>
      <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>学习JVM到一定程度后肯定会接触到safepoint(安全点)的概念,特别是在处理GC问题的时候,这篇文章主要介绍下安全点(safepoint)的概念及如何在JVM环境中开启安全点日志来分析系统的性能.</p>
<a id="more"></a>
<p>安全点就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比如GC.<br>这些特定的位置主要有几下几种:</p>
<ol>
<li>方法返回之前</li>
<li>调用某个方法之后</li>
<li>抛出异常的位置</li>
<li>循环的末尾</li>
</ol>
<p>为什么把这些位置设置为jvm的安全点呢,主要目的就是避免程序长时间无法进入safepoint,比如JVM在做GC之前要等所有的应用线程进入到安全点后VM线程才能分派GC任务 ,如果有线程一直没有进入到安全点,就会导致GC时JVM停顿时间延长,比如R大之前回复的这个<a href="http://hllvm.group.iteye.com/group/topic/38232" target="_blank" rel="external">例子</a>,这里面就是写了一个超大的循环导致线程一直没有进入到安全点,GC前停顿了8秒.</p>
<h2 id="safepoint的使用场景"><a href="#safepoint的使用场景" class="headerlink" title="safepoint的使用场景"></a>safepoint的使用场景</h2><ol>
<li>垃圾回收(这是最常见的场景)</li>
<li>取消偏向锁(JVM会使用偏向锁来优化锁的获取过程)</li>
<li>Class重定义(比如常见的hotswap和instrumentation)</li>
<li>Code Cache Flushing(JDK1.8在CodeCache满的情况下就可能出现)</li>
<li>线程堆栈转储(jstack命令)</li>
</ol>
<p>既然这样,线程怎么知道什么时候要进入到saftpoint呢,一般有抢占式和主动式两种,常见的做法就是设置一个状态位,让所有线程去检查这个状态,当检测到saftpoint标志时就停下来,可以看下OpenJdk里对safePoint的描述:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Begin the process of bringing the system to a safepoint.</span></span><br><span class="line">  <span class="comment">// Java threads can be in several different states and are</span></span><br><span class="line">  <span class="comment">// stopped by different mechanisms:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//  1. Running interpreted</span></span><br><span class="line">  <span class="comment">//     The interpeter dispatch table is changed to force it to</span></span><br><span class="line">  <span class="comment">//     check for a safepoint condition between bytecodes.</span></span><br><span class="line">  <span class="comment">//  2. Running in native code</span></span><br><span class="line">  <span class="comment">//     When returning from the native code, a Java thread must check</span></span><br><span class="line">  <span class="comment">//     the safepoint _state to see if we must block.  If the</span></span><br><span class="line">  <span class="comment">//     VM thread sees a Java thread in native, it does</span></span><br><span class="line">  <span class="comment">//     not wait for this thread to block.  The order of the memory</span></span><br><span class="line">  <span class="comment">//     writes and reads of both the safepoint state and the Java</span></span><br><span class="line">  <span class="comment">//     threads state is critical.  In order to guarantee that the</span></span><br><span class="line">  <span class="comment">//     memory writes are serialized with respect to each other,</span></span><br><span class="line">  <span class="comment">//     the VM thread issues a memory barrier instruction</span></span><br><span class="line">  <span class="comment">//     (on MP systems).  In order to avoid the overhead of issuing</span></span><br><span class="line">  <span class="comment">//     a memory barrier for each Java thread making native calls, each Java</span></span><br><span class="line">  <span class="comment">//     thread performs a write to a single memory page after changing</span></span><br><span class="line">  <span class="comment">//     the thread state.  The VM thread performs a sequence of</span></span><br><span class="line">  <span class="comment">//     mprotect OS calls which forces all previous writes from all</span></span><br><span class="line">  <span class="comment">//     Java threads to be serialized.  This is done in the</span></span><br><span class="line">  <span class="comment">//     os::serialize_thread_states() call.  This has proven to be</span></span><br><span class="line">  <span class="comment">//     much more efficient than executing a membar instruction</span></span><br><span class="line">  <span class="comment">//     on every call to native code.</span></span><br><span class="line">  <span class="comment">//  3. Running compiled Code</span></span><br><span class="line">  <span class="comment">//     Compiled code reads a global (Safepoint Polling) page that</span></span><br><span class="line">  <span class="comment">//     is set to fault if we are trying to get to a safepoint.</span></span><br><span class="line">  <span class="comment">//  4. Blocked</span></span><br><span class="line">  <span class="comment">//     A thread which is blocked will not be allowed to return from the</span></span><br><span class="line">  <span class="comment">//     block condition until the safepoint operation is complete.</span></span><br><span class="line">  <span class="comment">//  5. In VM or Transitioning between states</span></span><br><span class="line">  <span class="comment">//     If a Java thread is currently running in the VM or transitioning</span></span><br><span class="line">  <span class="comment">//     between states, the safepointing code will wait for the thread to</span></span><br><span class="line">  <span class="comment">//     block itself when it attempts transitions to a new state.</span></span><br></pre></td></tr></table></figure></p>
<p>大概意思就是线程执行代码有两种模式,一种是解释字节码运行,另一种是通过JIT编译成本地方法后执行:</p>
<ul>
<li>当线程处于解释执行时,当有safepoint请求的时候，解释器就会把指令跳转到去进行safepoint状态检查;</li>
<li><p>当Java线程正在执行native code的时候, 当VM thread看到一个Java线程在执行native code,它不需要等待这个Java线程进入阻塞状态，因为当Java线程从执行native code返回的时候,<br>Java线程会去检查safepoint看是否要block,但是检查这个sync_state状态的操作不是原子的,有可能线程1读到的状态是_not_synchronized这时候线程CPU被抢占,VM线程把sync_state状态改成了_synchronizing,然后读取所有线程的状态是是否处于block或者in native状态,是的话就可以开始GC,否则就要等待.如果线程1在读sync_state状态和写线程状态这两个操作不是原子的就会出问题,线程1以为不是saftpoint状态而VM Thread以为所有线程都Ok了,这时候开启GC就会出问题,一旦线程1获取CPU时间片就会开始执行java代码,这样子GC就出错了.</p>
<p>如何解决上面出现的状态不一致的问题呢,常见的方法就是加内存屏障,比如volatile语义就是通过内存屏障来实现,但是内存屏障的实现是一个重量级的操作,需要锁住总线或者CPU的Cache Line,而JVM不是采用的内存屏障来解决这个问题,而是采用了一个叫做serialization page的轻量级同步方法,所有线程都必须顺序的在serialization page内存页上更新自己的状态,当VM线程要执行GC时就把这个内存页设置为只读,其他线程就无法操作,关于serialization page可以参考这篇文章:<br><a href="http://hllvm.group.iteye.com/group/topic/38904" target="_blank" rel="external">关于memory_serialize_page的一些疑问</a></p>
</li>
</ul>
<h2 id="safepoint实战"><a href="#safepoint实战" class="headerlink" title="safepoint实战"></a>safepoint实战</h2><p>在生产环境推荐使用-XX:+PrintGCApplicationStoppedTime这个参数来打印JVM暂停的时间,如果在GC日志前面出现较大的停顿,那要考虑是不是代码里有大的循环操作,如下所示:<br>    Total time for which application threads were stopped: 8.8328410 seconds<br>    2018-01-23T21:07:21.277+0800: 24021.914: [GC (Allocation Failure)<br>同时在测试环境可以开启以下几个参数来打印安全点统计日志:</p>
<pre><code>-XX:+UnlockDiagnosticVMOptions
-XX:+LogVMOutput
-XX:LogFile=/dev/shm/vm.log
-XX:+PrintSafepointStatistics
-XX:PrintSafepointStatisticsCount=1    
</code></pre><p>-XX:LogFile用户把jvm的输出到某个日志中,推荐写入到/dev/shm这个内存映射文件目录下,输出的结果类似这样:</p>
<pre><code>RevokeBias                           [threads: total initially_running wait_to_block]    [time: spin block sync cleanup vmop] page_trap_count
24201.686: GenCollectForAllocation          [    1710          0              0    ]      [     0     0     0     5   900    ]  0
</code></pre><p>上面的输出参数解释如下:<br>第一段是时间戳，VM Operation的类型，以及线程概况:</p>
<ul>
<li>total: 安全点里的总线程数</li>
<li>initially_running: 安全点时开始时正在运行状态的线程数</li>
<li>wait_to_block: 在VM Operation开始前需要等待其暂停的线程数<br>第二段是到达安全点时的各个阶段以及执行操作所花的时间，其中最重要的是vmop</li>
<li>spin: 等待线程响应safepoint号召的时间</li>
<li>block: 暂停所有线程所用的时间</li>
<li>sync: 等于 spin+block，这是从开始到进入安全点所耗的时间，可用于判断进入安全点耗时</li>
<li>cleanup: 清理所用时间</li>
<li>vmop: 真正执行VM Operation的时间</li>
</ul>
<p>由于没有深入研究jvm源码,上面的研究只是停留在表面,希望后面继续学习和思考.<br>参考文档:</p>
<ol>
<li><a href="http://blog.ragozin.info/2012/10/safepoints-in-hotspot-jvm.html" target="_blank" rel="external">safepoints-in-hotspot-jvm.</a></li>
<li><a href="http://blog.csdn.net/iter_zc/article/details/41847887" target="_blank" rel="external">理解JVM的safepoint</a></li>
<li><a href="http://hllvm.group.iteye.com/group/topic/38232" target="_blank" rel="external">jvm迟迟进入不到安全点的例子</a></li>
<li><a href="http://hllvm.group.iteye.com/group/topic/38904" target="_blank" rel="external">关于memory_serialize_page的一些疑问</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Log4j升级到Log4j2]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/slf4j-log4j2.html</url>
      <content type="html"><![CDATA[<p>我们的系统一直用的是公司统一的日志类来打印日志,看了下内部实现,仅仅是对Slf4j门面+Log4j这套做了一些封装,加入了扩展的能力，各个模块在扩展点文件中配置日志路径、级别和包名,由工具类动态生成日志配置文件，由于一直没出问题所以没太关注,但是最近有个环境经常出现响应慢、Full GC频繁的问题,我在分析线程堆栈时发现了2个问题:一个是Log4j打日志有一定概率会出现死锁;另一个是有个缓存类调用非常频繁,很多线程都卡在打印日志那里,分析了下发现Log4j里每个Logger对象一把锁,同一个类里面打印日志的方法只能串行执行,效率非常低，经过研究对比了几个日志框架之后决定先把我们组的日志框架迁移到Log4j2,后面在部门内推广使用。</p>
<a id="more"></a>
<h3 id="Log4j死锁问题"><a href="#Log4j死锁问题" class="headerlink" title="Log4j死锁问题"></a>Log4j死锁问题</h3><p>在Log4j 1.x版本中同步打印日志的时候，在高并发场景下会出现死锁导致cpu使用率异常飙升，其原因是当线程写日志的时候需要获取到Logger和Appender，<code>org.apache.log4j.Logger</code>类继承于<code>org.apache.log4j.Category、Appender</code>继承于<code>org.apache.log4j.AppenderSkeleton</code>。通过Log4j 1.x中Category源码和Appender源码可以知道，当多线程并发时，可能会因为相互持有Logger和Appender发生死锁,而且同一个Logger对象只能串行打印日志,在高并发场景会容易引起性能问题。</p>
<p>看下打印日志的过程,调用Logger类打印日志的方法会调用Category的callAppenders()方法，这个方法会锁住Category对象,如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callAppenders</span><span class="params">(LoggingEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> writes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(Category c = <span class="keyword">this</span>; c != <span class="keyword">null</span>; c = c.parent) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(c) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c.aai != <span class="keyword">null</span>) &#123;</span><br><span class="line">                writes += c.aai.appendLoopOnAppenders(event);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!c.additive) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码最终会调用到AppenderSkeleton的doAppend()方法，可以看到doAppend()是个同步方法，也就是说打印一条日志要先后获取两个对象同步锁,在高并发的情况下，两次lock就很容易造成死锁，特别是在业务逻辑里面如果还有其他获取锁的逻辑死锁的概率就更高了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doAppend</span><span class="params">(LoggingEvent event)</span> </span>&#123;<span class="comment">//省略 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>整个流程如下所示:<br><img src="/images/pages/log4j/logger-trace.png" alt=""></p>
<h3 id="Log4j2的优点"><a href="#Log4j2的优点" class="headerlink" title="Log4j2的优点"></a>Log4j2的优点</h3><p>Log4j2是Log4j 1.x的升级版，与之前的版本Log4j 1.x相比、有重大的改进,主要变更点总结在下表:</p>
<table>
<thead>
<tr>
<th style="text-align:left">优化点</th>
<th style="text-align:left">说明 </th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">API实现分离</td>
<td style="text-align:left">Log4j2将API与实现分离开来,原先Log4j 1.x版本只需引入log4j的依赖,Log4j2版本需要引入log4j-api和log4j-core两个依赖</td>
</tr>
<tr>
<td style="text-align:left">自动加载新的配置</td>
<td style="text-align:left">Log4j 2.x 和Logback都新增了自动加载日志配置文件的功能，而且配置发生改变时不会丢失任何日志事件,可以在Configuretion中设置monitorInterval设置检查配置文件变更的时间间隔</td>
</tr>
<tr>
<td style="text-align:left">支持变量参数的占位符功能</td>
<td style="text-align:left">Log4j2和Slf4j一样,支持支持变量参数的占位符功能,对字符串打印和输出做了很多优化，新的Markers和flow tracing可以帮助追踪程序工作流</td>
</tr>
<tr>
<td style="text-align:left">性能较大提升</td>
<td style="text-align:left">Log4j2相对于Log4j 1.x，具有更快的执行速度,由于重写了内部的实现，在某些特定的场景上面，甚至可以比之前的速度快上10倍,比如内部的消息队列采用ArrayBlockingQueue，相对于原始的ArrayList和锁操作来说，管程类的消息队列拥有更好地性能</td>
</tr>
<tr>
<td style="text-align:left">异步性能</td>
<td style="text-align:left">Asynchronous Loggers是Log4j2新增的日志器，异步日志器在其内部实现采用了LMAX Disruptor（一个无锁的线程间通信库）技术，Disruptor主要通过环形数组结构、元素位置定位和精巧的无锁设计（CAS）实现了在高并发情形下的高性能</td>
</tr>
<tr>
<td style="text-align:left">死锁问题的解决</td>
<td style="text-align:left">log4j 2.x中充分利用Java5的并发支持，并且以最低级别执行锁定</td>
</tr>
</tbody>
</table>
<h3 id="Slf4j静态绑定介绍"><a href="#Slf4j静态绑定介绍" class="headerlink" title="Slf4j静态绑定介绍"></a>Slf4j静态绑定介绍</h3><p>Slf4j作为一个日志门面，提供统一的打印日志接口，使得用户能够很方便的使用和切换想要的logging实现框架;静态绑定的实现是通过提供一个适配层,每个日志实现框架如果要适配Slf4j的api，那就提供一个适配Slf4j门面的适配包,适配包里都有一个包名和类名都相同的类<code>org.slf4j.impl.StaticLoggerBinder</code>，这个类的功能就是调用具体的日志库;SLF4j的使用者只要把适配包和slf4j-api的jar包放入classpath中,打印日志时LoggerFactory调用StaticLoggerBinder类中的getLoggerFactory()方法返回相应的ILoggerFactory实例,最后通过ILoggerFactory实例获取Logger具体实例,如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LoggerFactoryBinder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> ILoggerFactory <span class="title">getLoggerFactory</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">getLoggerFactoryClassStr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ILoggerFactory</span> </span>&#123;</span><br><span class="line"> <span class="comment">//适配包里的getLogger方法会返回一个适配了slf4j接口的Logger	</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Logger <span class="title">getLogger</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面这个图片是官网提供的常见的一些log实现和绑定:<br><img src="/images/pages/log4j/loggers.png" alt=""></p>
<p>需要注意的是Slf4j在classpath下只支持一个适配包（slf4j-simple、slf4j-log4j12、slf4j-jdk14、logback-classic、log4j-slf4j-impl等）。如果在classpath下存在多个桥接包，Slf4j会随机加载一个,把加载出来的适配包打印出来,如下所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SLF4J: Class path contains multiple SLF4J bindings.</span><br><span class="line">SLF4J: Found binding <span class="keyword">in</span> [jar:file:/C:/Users/bjwanghanbing/.m2/repository/org/slf4j/slf4j-log4j12/1.7.6/slf4j-log4j12-1.7.6.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: Found binding <span class="keyword">in</span> [jar:file:/C:/Users/bjwanghanbing/.m2/repository/org/apache/logging/<span class="built_in">log</span>4j/<span class="built_in">log</span>4j-slf4j-impl/2.8.2/<span class="built_in">log</span>4j-slf4j-impl-2.8.2.jar!/org/slf4j/impl/StaticLoggerBinder.class]</span><br><span class="line">SLF4J: See http://www.slf4j.org/codes.html<span class="comment">#multiple_bindings for an explanation.</span></span><br><span class="line">SLF4J: Actual binding is of <span class="built_in">type</span> [org.slf4j.impl.Log4jLoggerFactory]</span><br></pre></td></tr></table></figure>
<h3 id="Log4j2与Slf4j集成"><a href="#Log4j2与Slf4j集成" class="headerlink" title="Log4j2与Slf4j集成"></a>Log4j2与Slf4j集成</h3><p>除了添加slf4j-api外，还需要添加与slf4j门面集成的适配器log4j-slf4j-impl，maven配置如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Slf4j门面 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>1.7.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 桥接：告诉Slf4j使用Log4j2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.8.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Log4j2配置"><a href="#Log4j2配置" class="headerlink" title="Log4j2配置"></a>Log4j2配置</h3><p>Log4j2的配置和Log4j 1.x版本有较大区别,可以参考log4j2的<a href="http://logging.apache.org/log4j/2.x/manual/configuration.html" target="_blank" rel="external">官方文档</a>，这里给出一个例子:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span></span><br><span class="line"><span class="comment">&lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Configuration后面的status，这个用于设置log4j2自身内部的信息输出，可以不设置，当设置成trace时，你会看到log4j2内部各种详细输出--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--monitorInterval：Log4j能够自动检测修改配置 文件和重新配置本身，设置间隔秒数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">monitorInterval</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--先定义所有的appender--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个输出控制台的配置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--输出日志的格式--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%p] [%t] [%C %L] %m%n"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">console</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;File name="log" fileName="log/log4j2.log" append="false"&gt;</span><br><span class="line">           &lt;PatternLayout pattern="%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n"/&gt;</span><br><span class="line">        &lt;/File&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--这个会打印出所有的info及以上级别的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">"RollingFileInfo"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;sys:user.home&#125;/log4j.log"</span></span><br><span class="line">                     <span class="attr">filePattern</span>=<span class="string">"$&#123;sys:user.home&#125;/$&#123;date:yyyy-MM&#125;/log4j-%d&#123;yyyy-MM-dd&#125;-%i.log"</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Filters</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">ThresholdFilter</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">onMatch</span>=<span class="string">"ACCEPT"</span> <span class="attr">onMismatch</span>=<span class="string">"DENY"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Filters</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- %d打印日期 %p打印日志级别 %t打印线程名称 %C全限定类路径 %L行号(效率较低) %m日志详情 %n换行--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%p] [%t] [%C %L] %m%n"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--基于时间的滚动策略，interval属性用来指定多久滚动一次--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">TimeBasedTriggeringPolicy</span>/&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--基于指定文件大小的滚动策略，size属性用来定义每个日志文件的大小--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"20 MB"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定同一个文件夹下最多有几个日志文件时开始删除最旧的，创建新的--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--异步Appender,默认用ArrayBlockingQueue来缓存日志,不需要使用disruptor三方件--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Async</span> <span class="attr">name</span>=<span class="string">"ASYNC"</span> <span class="attr">bufferSize</span>=<span class="string">"262144"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"RollingFileInfo"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Async</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appenders</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">loggers</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--异步Logger,需要引入disruptor-3.3.4.jar,</span><br><span class="line">        如果要全部都开启异步日志,要设置系统属性</span><br><span class="line">        log4j2.contextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</span><br><span class="line">        如果配置了log4j2.contextSelector系统属性,那在logger配置中不要使用asyncRoot和asyncLogger,否则会把异步和异步Logger混用,</span><br><span class="line">        就会导致有两个后台线程,参考:https://logging.apache.org/log4j/2.x/manual/async.html--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--过滤掉spring的一些无用的DEBUG信息--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--&lt;AsyncLogger name="org.springframework" level="info" includeLocation="true"&gt;</span><br><span class="line">            &lt;AppenderRef ref="Console"/&gt;</span><br><span class="line">         &lt;/AsyncLogger&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"info"</span> <span class="attr">includeLocation</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"ASYNC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://logging.apache.org/log4j/2.x/manual/configuration.html" target="_blank" rel="external">log4j2-configuration</a></p>
<p><a href="http://tech.lede.com/2017/08/28/rd/server/Log4j2Update/" target="_blank" rel="external">Log4j 2.x 日志升级的详细流程</a></p>
<p><a href="http://www.blogjava.net/DLevin/archive/2012/11/08/390991.html" target="_blank" rel="external">深入源码之SLF4J</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Linux性能问题定位总结]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/linux-perf-turning.html</url>
      <content type="html"><![CDATA[<p>当一个系统出现前台响应慢、接口返回慢等情况时,可以考虑分析是否存在性能瓶颈了，性能瓶颈可以分为2种：</p>
<ol>
<li><p>CPU高(这里指长期使用率超过75%)，包括用户态CPU+内核态CPU，这类问题比较常见，通过结合TOP命令和抓取线程堆栈可以找到耗资源最多的线程，然后分析调用堆栈进行优化</p>
</li>
<li><p>CPU使用率不高,但是系统还是响应慢</p>
</li>
</ol>
<a id="more"></a>
<p>这里主要介绍第二种场景，分析步骤如下:</p>
<h3 id="排查Java进程是否在Full-GC"><a href="#排查Java进程是否在Full-GC" class="headerlink" title="排查Java进程是否在Full GC"></a>排查Java进程是否在Full GC</h3><p>对于Java进程响应慢，先要排查系统是否在频繁Full GC,Full GC时JVM暂停时间较长,所有线程会被挂起。一般来讲如果是这种场景，通过top -Hp Java进程ID 命令可以发现某个线程的CPU使用率一直处于99%左右(线程名称vm thread),从GC日志可以看到JVM一直在执行CMS GC(JVM老年代GC)。</p>
<p>首先在GC日志中搜索<code>CMS-concurrent-mark-start</code>关键字,查看相邻两次CMS GC的时间间隔,如下所示:<br><img src="/images/pages/linux/linux01.png" alt=""></p>
<p>CMC GC基本上每分钟一次，GC频率太高，会导致JVM大部分时间都处理停顿状态, 每小时发生一次CMS GC就已经算频率高了，再来看GC停顿时间:<br><img src="/images/pages/linux/linux02.png" alt=""></p>
<p>从GC日志来看, GC发生时新生代的eden区和from区基本上已经满了，正常场景要执行Minor GC了，但是可以看到老年代CMS区总大小6291456K，使用了6291455K，基本上用完了。JVM有一个线程每隔2秒钟去检查老年代的大小，如果超过指定的阈值(阈值可以通过jvm参数指定:<code>-XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=75</code>),那就会触发一次CMS GC，从GC日志来看，在CMS GC期间又有新的在老年代创建对象的请求，此时又没有空间容纳新对象,就出现了<code>concurrent mode failure</code>这个错误,这个错误发生后JVM会放弃当前的CMS GC转而执行一次Full GC,Full GC会对新生代和老年代进行内存回收，大部分过程都是stop-the-world的，由GC日志可以看到整个JVM停顿了36.40秒。每隔一分钟执行一次Full GC，每次停顿36.4秒，可以想到JVM几乎一直不可用。GC回收之后新生代和老年代的内存使用率还是非常高,因此JVM一直在执行GC，如果JVM花费98%的时间都在GC并且回收的内存小于2%，那就会抛出Out-Of-Memort Error并退出jvm进程。</p>
<p>出现上图中的场景一般是有线程一直在创建对象,并且对象的创建速度高于回收速度,因此要分析这样子创建对象是否是合理的,如果是合理的，那要考虑调整JVM参数扩充内存。合不合理要根据业务场景来分析,一般是通过jmap命令获取当前jvm对象的直方图，找到哪些对象占了大部分的内存,并分析是否合理.</p>
<h3 id="分析内存和磁盘"><a href="#分析内存和磁盘" class="headerlink" title="分析内存和磁盘"></a>分析内存和磁盘</h3><p>如果排除了JVM Full GC的可能性,那要分析是否是内存和磁盘的问题了:</p>
<p>一般都是首先通过top命令查看当前系统的负载，系统的负载代表的时在队列中等待执行的任务数量,对于单核CPU，负载为1表示已经达到了系统的负荷,对于多核CPU如果负载高于CPU核心数量也是达到了负荷,但是一般到达0.5 * CPU核心数时就要关注了。</p>
<p>比如下面的场景,load average 在1分钟、5分钟和15分钟平均值分别是5.92 5.58 5.48,CPU核心数为12. CPU使用率不高，正常场景25%的CPU使用率负载不会这么高,这个时候很可能是内存和磁盘有性能瓶颈。<br><img src="/images/pages/linux/linux03.png" alt=""></p>
<p>需要注意的是,通过Top命令看到的只是表象，具体深层次的原因要通过vmstat和iostat两个命令来分析,分析过程如下:</p>
<p>使用<code>vmstat 1</code> 观察系统的负载情况,这个命令每隔1秒钟输出一次:<br><img src="/images/pages/linux/linux04.png" alt=""></p>
<ul>
<li><p>r列表示当前运行的任务数,如果超过cpu核心数那就会有任务要等待</p>
</li>
<li><p>b列表示当前正在阻塞等待的任务数，如果这个数量长期较大,表示执行的任务太多，cpu调度不过来</p>
</li>
<li><p>swapd列是分析内存的关键指标,swapd表示从内存交换的磁盘的空间大小,单位是Kb,当内存不时使操作系统会把一部分不使用的内存交换到交换空间(这个空间使用的是磁盘)，正常场景这个值应该是0，当前是交换了6.7G内存左右，说明内存已经严重不足了;</p>
</li>
<li><p>si指标表示swap in,内存交换到磁盘的次数,当前交换次数较多.</p>
</li>
<li><p>so指标表示swap out,从磁盘交换回内存次数,从图中可以看出系统一直在swap in 和swap out，说明内存一直不够<br>(<font color="#FF0000">这里需要注意的是,如果swapd小于100M并且swap in 和swap out一直为0，那系统也算正常</font>)</p>
</li>
<li><p>free列表示空闲内存的数量。</p>
</li>
</ul>
<p>再看一个正常环境的vmstat命令输出,swapd为79M, si和so一直为0，并且free内存充足。<br><img src="/images/pages/linux/linux05.png" alt=""></p>
<p>使用iostat -x 命令观察io的使用情况:<br><img src="/images/pages/linux/linux06.png" alt=""></p>
<p>每列指标的含义如下:</p>
<ul>
<li>rrqm/s: 每秒进行 merge 的读操作数目</li>
<li>wrqm/s: 每秒进行 merge 的写操作数目</li>
<li>r/s: 每秒完成的读 I/O 设备次数</li>
<li>w/s: 每秒完成的写 I/O 设备次数</li>
<li>rsec/s: 每秒读扇区数</li>
<li>wsec/s: 每秒写扇区数</li>
<li>rkB/s: 每秒读K字节数，是 rsect/s 的一半，因为每扇区大小为512字节。(需要计算) </li>
<li>wkB/s: 每秒写K字节数，是 wsect/s 的一半。(需要计算) </li>
<li>avgrq-sz: 平均每次设备I/O操作的数据大小 (扇区)</li>
<li>avgqu-sz: 平均I/O队列长度 </li>
<li>await: 平均每次设备I/O操作的等待时间 (毫秒)</li>
<li>svctm: 平均每次设备I/O操作的服务时间 (毫秒)（<font color="#FF0000">这个指标没有参考价值,可以忽略</font>）</li>
<li>%util: 一秒中有百分之多少的时间用于 I/O 操作，或者说一秒中有多少时间 I/O 队列是非空的。如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。idle小于70% IO压力就较大了,一般读取速度有较多的wait. </li>
</ul>
<p>从上面的图片来看,io不算忙碌,但是await高达86.67毫秒,也就是平均每个io请求要等待87毫米才处理完,从avgqu-sz来看队列中平均任务数才0.57，说明IO任务并不多，但是单个任务处理慢,一般就是磁盘处理速度慢。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[理解GC日志]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/understand-gc-log.html</url>
      <content type="html"><![CDATA[<p>给CMS GC搭配<code>-XX:+PrintGCDetails</code>和<code>-XX:+PrintGCTimeStamps</code>可以打印出很多关于GC的信息.理解GC日志信息可以帮助日常的性能调优以达到最优的性能。</p>
<a id="more"></a>
<p>下面就来看下gc日志的详情:</p>
<p>39.910: [GC 39.910: [ParNew: 261760K-&gt;0K(261952K), 0.2314667 secs] 262017K-&gt;26386K(1048384K), 0.2318679 secs]<br>上面是年轻代(ParNew)回收信息,年轻代总大小261952Kb,垃圾回收后使用量从261970Kb到0Kb,整个回收过程花费0.2318679秒。</p>
<p>40.146: [GC [1 CMS-initial-mark: 26386K(786432K)] 26404K(1048384K), 0.0074495 secs]<br>现在开始的是使用CMS收集器对老年代做的回收,老年代的容量是786432Kb，占用量是26386Kb时触发了老年代的收集。这是CMS过程的初始标记阶段,这个阶段会停止所有应用线程(stop-the-world)，该阶段单线程执行,主要做两件事情:</p>
<ol>
<li>标记GC根节点可以直接引用的对象；</li>
<li>遍历新生代对象,标记可达的老年代对象。</li>
</ol>
<p>40.154: [CMS-concurrent-mark-start]<br>这是并发标记过程的开始，在初始标记阶段停止的线程在这个阶段会重新启动,这个阶段应用线程和GC线程并行执行,多个GC线程并发标记活跃的对象。</p>
<p>40.683: [CMS-concurrent-mark: 0.521/0.529 secs]<br>并发标记阶段总共花费了0.521秒。因为该阶段是并发执行的,运行期间可能会在老年代产生新的垃圾，或者老年代的对象被新生代对象重新引用,这些对象都是要重新标记的，有以下几种场景:</p>
<ol>
<li>新生代对象晋升到老年代</li>
<li>新生代新创建对象引用了原先老年代未被标记的对象</li>
<li>直接在老年代分配的对象</li>
<li>老年代对象的引用关系发生变化<br>为了提高重新标记的效率,该阶段会把上述对象所存在的card标记为dirty，后续只需要扫描dirty card对应的对象。</li>
</ol>
<p>40.683: [CMS-concurrent-preclean-start]<br>预清理阶段的开始,这个阶段是并发执行的,可以通过参数<code>-XX:-CMSPrecleaningEnabled</code>关闭；这个阶段主要是处理前面介绍的4种常见，减少重新标记的开销,因为CMS设计的目的是减少应用的停顿时间,而重新标记是stop-the-word的,所以这一阶段减少重新标记的工作。</p>
<p>40.701: [CMS-concurrent-preclean: 0.017/0.018 secs]<br>并发预清理阶段花费0.017秒CPU时间,0.018秒系统时间。</p>
<p>40.704: [GC40.704: [Rescan (parallel) , 0.1790103 secs]40.883: [weak refs processing, 0.0100966 secs] [1 CMS-remark: 26386K(786432K)] 52644K(1048384K), 0.1897792 secs]<br>这个阶段主要处理并发标记清除阶段新产生的垃圾对象,这个阶段是Stop-the-world.主要做一下几件事情:</p>
<ol>
<li>遍历新生代对象，重新标记</li>
<li>根据GCRoots,重新标记</li>
<li>遍历老年代的Dirty card重新标记，这部分对象大部分在预清理阶段已经处理过。</li>
</ol>
<p>40.894: [CMS-concurrent-sweep-start]<br>清除死亡的(没有标记的)对象，这个阶段jvm应用线程并发执行。</p>
<p>41.020: [CMS-concurrent-sweep: 0.126/0.126 secs]<br>清除阶段会0.126秒.</p>
<p>41.020: [CMS-concurrent-reset-start]<br>Reset阶段</p>
<p>41.147: [CMS-concurrent-reset: 0.127/0.127 secs]<br>这个阶段,CMS的数据结构重新初始化,为下一次垃圾回收做准备。</p>
<p>上面这些是一个正常的CMS周期,不同版本的JVM可能会有细微差别,大体还是差不多,接下来我们来看一下其他的场景:</p>
<p>197.976: [GC 197.976: [ParNew: 260872K-&gt;260872K(261952K), 0.0000688 secs]197.976: [CMS197.981: [CMS-concurrent-sweep: 0.516/0.531 secs]<br>(concurrent mode failure): 402978K-&gt;248977K(786432K), 2.3728734 secs] 663850K-&gt;248977K(1048384K), 2.3733725 secs]<br>可以看出开始了新生代的收集,但是没有执行因为这时候又发生了CMS GC，CMS老年代又没有足够的空间来容纳新生代的对象，这样就出现了concurrent mode failure这样的字样,这个时候会放弃CMS GC周期转而执行一次Full GC。</p>
<p><code>concurrent mode failure</code>可以通过增加老年代的空间或者减少老年代GC的阈值来解决,可以把GC参数<code>CMSInitiatingOccupancyFraction</code>设置小一点,默认是92,这个参数只在第一次收集时才生效,后续jvm会自动调整,你要同时设置<code>UseCMSInitiatingOccupancyOnly=true</code>这个参数才一直生效,<code>CMSInitiatingOccupancyFraction</code>这个参数要选的比较合适才行，太小了会导致CMS GC太频繁,太大了就可能出现并发模式失败,有时候你会发现老年代明明有足够的空间还是出现了promotion failures，这是因为CMS GC产生了很多内存碎片,没有连续的内存区域来存储新生代的对象。CMS GC还有一种原因是<strong>晋升担保</strong>,cms收集器会计算新生代的对象是否能够成功晋升到老年代,如果晋升担保失败也是会触发一次CMS GC周期，最新版本的CMS晋升担保会根据新生代晋升到老年代对象的历史数据来决定这个担保的值。</p>
<p>283.736: [Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000615 secs] 826554K-&gt;826554K(1048384K), 0.0003259 secs]<br>Full GC。</p>
<p>283.736: [Full GC 283.736: [ParNew: 261599K-&gt;261599K(261952K), 0.0000288 secs]<br>新生代GC除了因为在新生代分配内存失败外,还可能是因为GC Locker导致,当JNI中的native方法需要访问JVM中的String或者数组时,需要调用GetStringCritical函数，到数据复制完成期间，必须保证原始数据不被修改，为了防止发生GC期间回收该字符串对象,如果期间发生了YoungGC会被标记成disabled,放弃这次GC，等线程执行完临界区的代码之后，执行ReleaseStringCritical方法,会弥补一次新生代GC，通过GC日志查看到的GC Cause就是GC Locker</p>
<p>2803.125: [GC 2803.125: [ParNew: 408832K-&gt;0K(409216K), 0.5371950 secs] 611130K-&gt;206985K(1048192K) icms_dc=4 , 0.5373720 secs]<br>2824.209: [GC 2824.209: [ParNew: 408832K-&gt;0K(409216K), 0.6755540 secs] 615806K-&gt;211897K(1048192K) icms_dc=4 , 0.6757740 secs]<br>CMS也可以运行在增量模式,通过jvm参数<code>-XX:+CMSIncrementalMode</code>开启增量模式;增量模式下,CMS收集器并不是一直占用执行权限,而是把CMS周期分成很多小的周期,每个小周期执行完后又把执行权限还给应用线程.</p>
<p>这两个阶段分别花费了737和675毫秒,在这两个周期中间,ICMS被标记出来,icms_dc=4表示4%的时间花在CMS的增量模式上，那增量模式共花费的时间可以这样计算:<br>0.04 * (2824.209 - 2803.125 - 0.537) = 821 ms</p>
<p>从JDK1.5开始,CMS多了一个阶段,叫做<code>concurrent-abortable-preclean</code>，可中断的预清理就当在并发预清理和重新标记中间,这个阶段也是用来减少重新标记花费的时长,这个阶段通过jvm参数<code>CMSScheduleRemarkEdenSizeThreshold</code>设置阈值,默认为2M，即新生代使用率超过2M才开启<code>concurrent-abortable-preclean</code>，这个阶段主要循环做2件事情:</p>
<ol>
<li>处理from和to区的对象,标记可达的老年代对象</li>
<li>和并发预清理一样，处理被标记为dirty card区的对象</li>
</ol>
<p>这个逻辑不会一直循环下去，打断这个循环的条件有三个：</p>
<ol>
<li>通过参数<code>CMSMaxAbortablePrecleanLoops</code>设置最多循环的次数，默认是0,没有循环次数限制;</li>
<li>执行这个逻辑的时间达到了<code>CMSMaxAbortablePrecleanTime</code>参数设置的阈值，默认是5s。</li>
<li>新生代Eden区的内存使用率达到了<code>CMSScheduleRemarkEdenPenetration</code>参数设置的阈值，默认50%，会退出循环。</li>
</ol>
<p>如果在循环退出之前，发生了一次YGC，对于后面的Remark阶段来说，大大减轻了扫描年轻代的负担。</p>
<p>7688.150: [CMS-concurrent-preclean-start]<br>7688.186: [CMS-concurrent-preclean: 0.034/0.035 secs]<br>7688.186: [CMS-concurrent-abortable-preclean-start]<br>7688.465: [GC 7688.465: [ParNew: 1040940K-&gt;1464K(1044544K), 0.0165840 secs] 1343593K-&gt;304365K(2093120K), 0.0167509 secs]<br>7690.093: [CMS-concurrent-abortable-preclean: 1.012/1.907 secs]<br>7690.095: [GC[YG occupancy: 522484 K (1044544 K)]7690.095: [Rescan (parallel) , 0.3665541 secs]7690.462: [weak refs processing, 0.0003850 secs] [1 CMS-remark: 302901K(1048576K)] 825385K(2093120K), 0.3670690 secs]<br>上面的日志信息，在并发预清理之后开启了可中断的预清理阶段,当新生代的使用率到达522484K(50%阈值)时,预清理被中断随后执行重新标记阶段。</p>
<p>参考文档:<br><a href="http://java.sun.com/docs/hotspot/gc5.0/gc_tuning_5.html" target="_blank" rel="external">http://java.sun.com/docs/hotspot/gc5.0/gc_tuning_5.html</a><br><a href="http://java.sun.com/docs/hotspot/gc1.4.2/" target="_blank" rel="external">http://java.sun.com/docs/hotspot/gc1.4.2/</a><br><a href="https://www.jianshu.com/p/2a1b2f17d3e4" target="_blank" rel="external">图解CMS垃圾回收机制</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[JIT引起系统Load高分析]]></title>
      <url>http://www.ezlippi.com/blog/2018/01/linux-high-load.html</url>
      <content type="html"><![CDATA[<p>有个应用在启动的初期系统的load会飚的很高,导致监控系统报了告警，经过分析是JVM对热点代码做JIT即时编译导致CPU使用率很高，而此时Web容器收到了大量的请求但是系统处理请求较慢导致业务的线程池满出现异常,这篇文章主要分析load高的可能原因以及JIT编译的一些基础知识。</p>
<a id="more"></a>
<h2 id="load高的可能原因"><a href="#load高的可能原因" class="headerlink" title="load高的可能原因"></a>load高的可能原因</h2><ol>
<li>长时间执行了耗费cpu的操作(usr使用率较高),比如死循环执行某个计算操作</li>
<li>等待竞争资源(比如锁、IO)致使请求处理慢,执行时间变长(sys占比高)</li>
<li>运行线程数见多,频繁上下文切换导致单个任务处理时间变长(sys占比高)</li>
<li>有大流量进入导致load身高</li>
</ol>
<h2 id="如何排查CPU占用升高的原因"><a href="#如何排查CPU占用升高的原因" class="headerlink" title="如何排查CPU占用升高的原因"></a>如何排查CPU占用升高的原因</h2><p>一般从以下三个方面考虑:</p>
<ol>
<li>业务代码执行,比如业务代码写了不合理的循环</li>
<li>框架和中间件的初始化过程</li>
<li>JVM或者web容器(Tomcat/Jetty/Jboss等)</li>
</ol>
<p>我们问题的背景是在启动的初期load较高,一段时间之后Load又降低下来，而且在多个主机上都出现了；根据这些特点首先排查了业务是否在启动过程做了一些复杂的操作,排查结果是没有；然后查了下接口调用日志发现在那个时间点收到了很多调用请求,联想到JIT的编译过程：JVM在启动初期通过解释字节码进行执行,当方法执行次数达到指定阈值后，触发JIT即时编译，JIT把字节码编译成机器码后执行，执行效率提高。这个时间点load飚高原因就是收到大量调用请求导致很多方法变成热点代码,JIT会启动对热点代码的编译,这个时候系统Load会升高导致请求处理较慢,最后就导致了业务线程池满。</p>
<h2 id="JIT分层编译相关概念"><a href="#JIT分层编译相关概念" class="headerlink" title="JIT分层编译相关概念"></a>JIT分层编译相关概念</h2><p>需要注意的是,jdk1.8默认开启了分层编译,在1.7版本你可以通过<code>-XX:+TieredCompilation</code>开启分层编译,关于分层编译网上介绍的文章不多,主要分为C1和C2编译器,C1又称为客户端编译,C2编译器称为服务端编译器,通过抓取jvm进程线程堆栈也可以发现C1和C2编译线程的足迹,整个JIT的编译级别有以下5种:</p>
<p>0：解释执行,这是最慢的一种方式<br>1：简单C1编译代码<br>2：受限的C1编译代码,不做性能分析，根据方法调用次数和方法内部循环次数来启动<br>3：完全C1编译代码,编译器收集分析信息之后做的编译<br>4：C2编译代码,编译最慢,编译后执行速度最快</p>
<p>编译级别的转换主要是根据方法调用计数器和回边计数器(方法内循环次数)以及<strong>C1和C2编译线程当前的负载情况</strong>来决定是否开启更高级别的编译,每个层次的阈值可以添加jvm启动参数<code>-XX:+PrintFlagsFinal</code>的输出来查看,比如我在jdk1.8.0_25时参数如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CompileThreshold = 10000                               </span><br><span class="line">IncreaseFirstTierCompileThresholdAt = 50                                  </span><br><span class="line">Tier2CompileThreshold = 0                                   </span><br><span class="line">Tier3CompileThreshold = 2000                               </span><br><span class="line">Tier4CompileThreshold = 15000</span><br></pre></td></tr></table></figure>
<p>可以看到层次2的阈值为0，层次3为2000,层次4(开启C2编译)为15000，根据当前的代码执行情况下一步采取的编译措施可能是如下几种:</p>
<ol>
<li>继续解释执行(可能编译线程负载很高)</li>
<li>解释器开始采样分析</li>
<li>根据分析数据用C1的层次3进行编译,后续可以继续优化</li>
<li>不分析直接用C1的层次2进行编译,后续再优化的可能性较低</li>
<li>不需要任何信息直接用C1的层次1进行编译</li>
</ol>
<p>如果server编译器队列满了，就会从server队列中取出方法，以级别2进行编译，在这个级别上，C1编译器使用方法调用计数器和回边计数器（但不需要性能分析的反馈信息）。这使得方法编译得更快，而方法也将在C1编译器收集分析信息之后被编译为级别3，最终当server编译器队列不太忙的时候被编译为级别4。</p>
<p>可以给jvm添加启动参数<code>-XX:+PrintCompilation</code>来查看jit的编译信息，每次进行jit编译后会输出编译的方法名称到控制台,下面这个列表是一个样例的编译输出:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">编译时间戳	编译ID	方法属性	编译层次 方法签名(大小)</span><br><span class="line">   <span class="number">180</span>    <span class="number">4</span>       <span class="number">1</span>       sun.instrument.TransformerManager::getSnapshotTransformerList (<span class="number">5</span> bytes)</span><br><span class="line">   <span class="number">180</span>    <span class="number">5</span>       <span class="number">3</span>       java.lang.String::lastIndexOf (<span class="number">13</span> bytes)</span><br><span class="line">   <span class="number">181</span>    <span class="number">6</span>       <span class="number">3</span>       java.lang.String::indexOf (<span class="number">7</span> bytes)</span><br><span class="line">   <span class="number">182</span>    <span class="number">7</span>       <span class="number">3</span>       java.lang.System::getSecurityManager (<span class="number">4</span> bytes)</span><br><span class="line">   <span class="number">183</span>    <span class="number">2</span>       <span class="number">4</span>       java.lang.String::hashCode (<span class="number">55</span> bytes)</span><br><span class="line">   <span class="number">183</span>    <span class="number">1</span>       <span class="number">4</span>       java.lang.Object::&lt;init&gt; (<span class="number">1</span> bytes)</span><br><span class="line">   <span class="number">184</span>    <span class="number">8</span>       <span class="number">4</span>       java.lang.String::length (<span class="number">6</span> bytes)</span><br><span class="line">   <span class="number">184</span>    <span class="number">3</span>       <span class="number">4</span>       java.lang.String::charAt (<span class="number">29</span> bytes)</span><br><span class="line">   <span class="number">185</span>    <span class="number">9</span>       <span class="number">3</span>       java.util.HashMap$Node::&lt;init&gt; (<span class="number">26</span> bytes)</span><br><span class="line">   <span class="number">185</span>   <span class="number">10</span>       <span class="number">4</span>       java.lang.Math::max (<span class="number">11</span> bytes)</span><br><span class="line">   <span class="number">185</span>   <span class="number">11</span>       <span class="number">4</span>       java.lang.String::indexOf (<span class="number">70</span> bytes)</span><br><span class="line">   <span class="number">186</span>   <span class="number">12</span>       <span class="number">4</span>       java.lang.AbstractStringBuilder::append (<span class="number">29</span> bytes)</span><br><span class="line">   <span class="number">188</span>   <span class="number">13</span>       <span class="number">3</span>       java.util.Arrays::copyOf (<span class="number">19</span> bytes)</span><br><span class="line">   <span class="number">189</span>   <span class="number">14</span>       <span class="number">3</span>       java.lang.String::equals (<span class="number">81</span> bytes)</span><br><span class="line">   <span class="number">190</span>   <span class="number">15</span>       <span class="number">1</span>       java.nio.Buffer::position (<span class="number">5</span> bytes)</span><br><span class="line">   <span class="number">190</span>   <span class="number">16</span>     n <span class="number">0</span>       java.lang.System::arraycopy (<span class="keyword">native</span>)   (<span class="keyword">static</span>)</span><br><span class="line">   <span class="number">190</span>   <span class="number">17</span>       <span class="number">3</span>       java.lang.String::startsWith (<span class="number">72</span> bytes)</span><br><span class="line">   <span class="number">190</span>   <span class="number">23</span>       <span class="number">4</span>       java.lang.AbstractStringBuilder::ensureCapacityInternal (<span class="number">16</span> bytes)</span><br><span class="line">   <span class="number">191</span>   <span class="number">19</span>       <span class="number">3</span>       sun.nio.cs.UTF_8$Encoder::encode (<span class="number">359</span> bytes)</span><br><span class="line">   <span class="number">192</span>   <span class="number">30</span>       <span class="number">3</span>       java.io.WinNTFileSystem::normalize (<span class="number">231</span> bytes)</span><br><span class="line">   <span class="number">192</span>   <span class="number">28</span>       <span class="number">4</span>       java.io.WinNTFileSystem::isSlash (<span class="number">18</span> bytes)</span><br><span class="line">   <span class="number">192</span>   <span class="number">29</span>  s    <span class="number">4</span>       java.lang.StringBuffer::append (<span class="number">13</span> bytes)</span><br><span class="line">   <span class="number">194</span>   <span class="number">24</span>       <span class="number">4</span>       java.lang.CharacterData::of (<span class="number">120</span> bytes)</span><br><span class="line">   <span class="number">194</span>   <span class="number">25</span>       <span class="number">4</span>       java.lang.CharacterDataLatin1::getProperties (<span class="number">11</span> bytes)</span><br><span class="line">   <span class="number">196</span>   <span class="number">27</span>       <span class="number">3</span>       java.lang.String::&lt;init&gt; (<span class="number">62</span> bytes)</span><br><span class="line">   <span class="number">196</span>   <span class="number">26</span>       <span class="number">3</span>       java.lang.Character::toLowerCase (<span class="number">6</span> bytes)</span><br><span class="line">   <span class="number">196</span>   <span class="number">20</span>       <span class="number">3</span>       java.lang.Math::min (<span class="number">11</span> bytes)</span><br><span class="line">   <span class="number">196</span>   <span class="number">18</span>   !   <span class="number">3</span>       sun.misc.URLClassPath$JarLoader::ensureOpen (<span class="number">32</span> bytes)</span><br><span class="line">   <span class="number">196</span>   <span class="number">21</span>       <span class="number">3</span>       java.util.jar.JarFile::getJarEntry (<span class="number">9</span> bytes)</span><br><span class="line">   <span class="number">197</span>   <span class="number">22</span>       <span class="number">3</span>       java.util.jar.JarFile::getEntry (<span class="number">22</span> bytes)</span><br><span class="line">  <span class="number">1195</span>   <span class="number">31</span>       <span class="number">3</span>       java.lang.String::replace (<span class="number">127</span> bytes)</span><br><span class="line">  <span class="number">1196</span>   <span class="number">34</span>       <span class="number">3</span>       java.lang.String::indexOf (<span class="number">166</span> bytes)</span><br><span class="line">  <span class="number">1196</span>   <span class="number">32</span>       <span class="number">3</span>       java.lang.String::startsWith (<span class="number">7</span> bytes)</span><br><span class="line">  <span class="number">1196</span>   <span class="number">35</span>  s!   <span class="number">3</span>       sun.misc.URLClassPath::getLoader (<span class="number">154</span> bytes)</span><br><span class="line">  <span class="number">1199</span>   <span class="number">44</span>       <span class="number">3</span>       java.util.HashMap::hash (<span class="number">20</span> bytes)</span><br><span class="line">  <span class="number">1199</span>   <span class="number">46</span>       <span class="number">3</span>       java.util.HashMap::putVal (<span class="number">300</span> bytes)</span><br><span class="line">  <span class="number">1200</span>   <span class="number">45</span>       <span class="number">3</span>       java.util.HashMap::put (<span class="number">13</span> bytes)</span><br><span class="line">  <span class="number">1200</span>   <span class="number">47</span>       <span class="number">3</span>       java.lang.String::&lt;init&gt; (<span class="number">10</span> bytes)</span><br></pre></td></tr></table></figure></p>
<p>可以看到大部分方法的编译级别是C1的级别3，有些方法比如<code>java.lang.String::indexOf</code>先经过级别3编译然后用C2进行编译。</p>
<p>方法属性的解释如下:</p>
<ul>
<li>同步方法用s标识</li>
<li>有异常处理的方法用!标识</li>
<li>阻塞方法用b标识</li>
<li>native方法用n标识</li>
</ul>
<p>关于分层编译的一些要点:</p>
<ul>
<li>最开始都是解释执行</li>
<li>理想情况下应转成level3编译</li>
<li>根据C1队列长度和C1编译线程数来调整编译的阈值</li>
<li>根据C2队列长度可能转向C2编译</li>
<li>根据C2队列长度、C2编译线程数调整level4编译阈值</li>
<li>如果方法非常小,没什么可以优化的空间，直接转level1编译</li>
<li>最常见的编译层次转换:0 -&gt; 3 -&gt; 4</li>
</ul>
<p>最后来看一下编译层次转换图:<br><img src="/images/jit.png" alt=""></p>
<h2 id="JIT相关JVM参数简介"><a href="#JIT相关JVM参数简介" class="headerlink" title="JIT相关JVM参数简介"></a>JIT相关JVM参数简介</h2><table>
<thead>
<tr>
<th style="text-align:left">选项</th>
<th style="text-align:left">默认值</th>
<th style="text-align:left">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CompileThreshold</td>
<td style="text-align:left">1000 or 1500/10000</td>
<td style="text-align:left">编译阈值,方法执行多少次后进行编译</td>
</tr>
<tr>
<td style="text-align:left">PrintCompilation</td>
<td style="text-align:left">false</td>
<td style="text-align:left">jit编译时输出日志</td>
</tr>
<tr>
<td style="text-align:left">InitialCodeCacheSize</td>
<td style="text-align:left">160K (varies)</td>
<td style="text-align:left">初始codecache大小</td>
</tr>
<tr>
<td style="text-align:left">ReservedCodeCacheSize</td>
<td style="text-align:left">32M/48M</td>
<td style="text-align:left">codecache最大值</td>
</tr>
<tr>
<td style="text-align:left">ExitOnFullCodeCache</td>
<td style="text-align:left">false</td>
<td style="text-align:left">codecache满了退出jvm</td>
</tr>
<tr>
<td style="text-align:left">UseCodeCacheFlushing</td>
<td style="text-align:left">false</td>
<td style="text-align:left">codecache满了时清空一半的codecache</td>
</tr>
<tr>
<td style="text-align:left">PrintFlagsFinal</td>
<td style="text-align:left">false</td>
<td style="text-align:left">打印所有的jvm选项</td>
</tr>
<tr>
<td style="text-align:left">PrintCodeCache</td>
<td style="text-align:left">false</td>
<td style="text-align:left">jvm退出时打印codecache</td>
</tr>
<tr>
<td style="text-align:left">PrintCodeCacheOnCompilation</td>
<td style="text-align:left">false</td>
<td style="text-align:left">编译时打印codecache使用情况</td>
</tr>
</tbody>
</table>
<h2 id="如何解决Jit引起的load高"><a href="#如何解决Jit引起的load高" class="headerlink" title="如何解决Jit引起的load高"></a>如何解决Jit引起的load高</h2><p>前面分析了这么多jit的相关知识,那针对这个场景怎么去解决前面出现的系统负载高的问题呢?根据JIT的特点,当方法执行次数到达某个阈值(server虚拟机默认是10000次)时会触发JIT编译,当应用的调用量很大时，大量的请求同时进入,多个方法同时触发JIT，会出现短期内load较高的情况,从而可能导致服务调用超时，因此问题出现具有随机性。我们决定采用提前触发编译的方法来解决服务发布后可能出现的load高的问题;具体做法就是在Web容器启动时循环调用热点方法,触发JIT编译，然后容器启动完成对外发布Rest服务。</p>
<p>这样做的缺点是侵入式，要增加代码，增加了启动时间，优点是实现成本较低，不影响业务。</p>
<h3 id="具体实施方案"><a href="#具体实施方案" class="headerlink" title="具体实施方案"></a>具体实施方案</h3><p>1）为了避免CodeCache满导致JIT停止编译或者CodeCacheFlushing的情况,先通过JMX获取到当前JIT的CodeCache大小(参考<a href="http://hellojava.info/?tag=reservedcodecachesize" target="_blank" rel="external">hellojava</a>中的方法来获取),再通过<code>jinfo -flag ReservedCodeCacheSize javaPid</code>命令获取当前jvm的ReservedCodeCacheSize参数大小,根据实际情况调整ReservedCodeCacheSize的大小,最后调整之后我们在jvm启动脚本中加上了如下两个参数:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-XX:ReservedCodeCacheSize=512m</span><br><span class="line">-XX:-UseCodeCacheFlushing(禁用CodeCacheFlushing机制)</span><br></pre></td></tr></table></figure></p>
<p>2) 编写预热代码</p>
<ol>
<li>编写WarmUpContextListener实现Spring的ApplicationContextAware接口，确保在Web容器启动完成前,调用需要预热的方法；</li>
<li>WarmUpContextListener读取预先配置好的参数,包括要调用的目标方法、请求参数、执行次数和超时时间;</li>
<li>新建线程池执行目标方法,执行N次触发JIT编译;</li>
<li>执行完成,关闭预热线程池;</li>
<li>Web容器启动完成,对外发布服务。</li>
</ol>
<p>经过以上两个步骤之后,我们的系统就没出现过因jit导致的负载高的场景。</p>
<p>在写这篇博客的过程中参考了以下资料，在此表示感谢。</p>
<ul>
<li><a href="https://stackoverflow.com/questions/41134037/whats-this-new-column-in-xxprintcompilation-output" target="_blank" rel="external">https://stackoverflow.com/questions/41134037/whats-this-new-column-in-xxprintcompilation-output</a></li>
<li><a href="https://stackoverflow.com/questions/35601841/how-does-the-jvm-decided-to-jit-compile-a-method-categorize-a-method-as-hot/35614237#35614237" target="_blank" rel="external">https://stackoverflow.com/questions/35601841/how-does-the-jvm-decided-to-jit-compile-a-method-categorize-a-method-as-hot/35614237#35614237</a></li>
<li><a href="http://blog.leanote.com/post/zenglingshu/%E4%B8%80%E4%B8%AART%E4%B8%8B%E9%99%8D%E7%9A%84%E5%A5%87%E6%80%AACase%5B%E8%BD%AC%5D" target="_blank" rel="external">Code Cache满导致接口性能变慢的排查过程</a></li>
<li><a href="http://hellojava.info/?tag=reservedcodecachesize" target="_blank" rel="external">一个RT下降的奇怪Case</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BTrace使用教程]]></title>
      <url>http://www.ezlippi.com/blog/2017/12/btrace-guide.html</url>
      <content type="html"><![CDATA[<p>线下的应用遇到问题时我们可以通过改代码加日志追踪或者通过远程调试来获取运行时的程序细节,但如果应用一开始没有开启远程调试的端口,那你要修改JVM参数添加调试的参数然后重启应用,这种对于线上应用来说就不适用了,线上应用不允许随便修改代码也无法远程调试。BTrace就是一个可以在不改代码、不重启应用的情况下，动态的查看程序运行细节的工具。这篇文章主要介绍BTrace的使用场景以及如果用BTrace来输出程序的执行细节。</p>
<a id="more"></a>
<h2 id="安装BTrace"><a href="#安装BTrace" class="headerlink" title="安装BTrace"></a>安装BTrace</h2><p>官方下载地址:<a href="https://github.com/btraceio/btrace/releases/tag/v1.3.10" target="_blank" rel="external">btrace</a><br>下载之后设置BTRACE_HOME环境变量,并把BTACE_HOME/bin添加到PATH环境变量中:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> BTRACE_HOME=/i/software/btrace-bin-1.3.9</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$BTRACE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>
<h2 id="Btrace的使用场景"><a href="#Btrace的使用场景" class="headerlink" title="Btrace的使用场景"></a>Btrace的使用场景</h2><ol>
<li><p>查看某一个方法中入参和返回值</p>
</li>
<li><p>查看某一个方法的响应时间</p>
</li>
<li><p>查看某一个方法中所有外部调用的响应时间，方便定位方法响应慢的具体位置及原因</p>
</li>
<li><p>打印方法调用的线程堆栈</p>
</li>
</ol>
<h2 id="如何使用BTrace"><a href="#如何使用BTrace" class="headerlink" title="如何使用BTrace"></a>如何使用BTrace</h2><p>使用起来比较简单，只需要执行<code>btrace {javaPid} {btrace脚本}</code>就行，如果要把输出调试信息到控制台,要加上-v 参数,-o 参数可以把结果输出到文件中。</p>
<h2 id="如何编写BTrace脚本"><a href="#如何编写BTrace脚本" class="headerlink" title="如何编写BTrace脚本"></a>如何编写BTrace脚本</h2><p>BTrace脚本编写比较简单,主要用到BTraceUtils工具类提供的方法,具体的教程可以参考<a href="https://www.gitbook.com/book/json-liu/btrace/details" target="_blank" rel="external">Btrace使用教程</a>,在编写脚本时,最好把BTrace提供的Jar包引入到Build Path上，方便在编译期发现语法错误，BTrace的三个jar包在安装包的build目录下,如果你用的是Maven来构建项目,可以添加如下依赖，把btrace的路径对应修改即可:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.tools.btrace<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>btrace-agent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>I:/software/btrace-bin-1.3.9/build/btrace-agent.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.tools.btrace<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>btrace-boot<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>I:/software/btrace-bin-1.3.9/build/btrace-boot.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.tools.btrace<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>btrace-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.9<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>system<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">systemPath</span>&gt;</span>I:/software/btrace-bin-1.3.9/build/btrace-client.jar<span class="tag">&lt;/<span class="name">systemPath</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我自己写了一个StringTableTest类，这个类有个intern方法，我想用btrace脚本来追踪intern方法的入参和返回值，并把调用堆栈打印出来,StringTableTest类源码如下所示，为了让BTrance能够追踪到该进程，我先让主线程休眠了10秒钟:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ezlippi;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringTableTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        StringTableTest test = <span class="keyword">new</span> StringTableTest();</span><br><span class="line">        <span class="keyword">long</span> ms = test.intern(<span class="number">1000000</span>);</span><br><span class="line">        System.out.println(ms);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">intern</span><span class="params">(<span class="keyword">int</span> times)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times; i++) &#123;</span><br><span class="line">            String.valueOf(i).intern();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis() - start;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BTrace脚本源码如下所示，第一个方法用于打印方法的参数、返回值和执行的时间点，第二个方法用于打印是否调用了StringTableTest的第22行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.ezlippi.performanace;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BTrace</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TraceMethodArgsAndReturn</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(</span><br><span class="line">            clazz=<span class="string">"com.ezlippi.StringTableTest"</span>,</span><br><span class="line">            method=<span class="string">"intern"</span>,</span><br><span class="line">            location=<span class="meta">@Location</span>(Kind.RETURN)</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span><span class="params">(<span class="keyword">int</span> sSrc,@Return <span class="keyword">long</span> result)</span></span>&#123;</span><br><span class="line">        println(<span class="string">"invoke StringTableTest.intern"</span>);</span><br><span class="line">        println(strcat(<span class="string">"input arg is:"</span>, str(sSrc)));</span><br><span class="line">        <span class="comment">// 打印函数返回结果result</span></span><br><span class="line">        println(strcat(<span class="string">"result is:"</span>,str(result)));</span><br><span class="line">		<span class="comment">//打印方法执行时间点</span></span><br><span class="line">        println(strcat(<span class="string">"time is:"</span>,str(timeMillis())));</span><br><span class="line">        <span class="comment">//打印线程堆栈</span></span><br><span class="line">        jstack();</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="meta">@OnMethod</span>(</span><br><span class="line">            clazz=<span class="string">"com.ezlippi.StringTableTest"</span>,</span><br><span class="line">            location=<span class="meta">@Location</span>(value=Kind.LINE,line=<span class="number">22</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">traceExecute</span><span class="params">(@ProbeClassName String pcn,@ProbeMethodName String pmn,<span class="keyword">int</span> line)</span></span>&#123;</span><br><span class="line">        println(strcat(strcat(strcat(<span class="string">"call "</span>,pcn),<span class="string">"."</span>),pmn));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果方法参数是原生数据类型,那traceExecute方法的参数类型要与之匹配，不用用对象类型，如果参数是对象，可以用AnyType来表示，对于返回值也是类似，如果返回值为对象类型，可以用Object表示。</p>
<p>首先执行StringTableTest的main方法，然后通过jps命令获取jvm进程的Pid，最后调用<code>btrace 13440 ./scripts/TraceMethodArgsAndReturn.java</code>就会打印执行结果,我的当前目录是在btrace的bin目录下，所有脚本放在scripts目录下，BTrace官方也提供了很多样例，在samples目录下,<br>我把整个过程写成了一个脚本start.sh，只需要先在IDEA里执行main方法后，执行start.sh即可:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">currentDir=<span class="string">"<span class="variable">$(dirname $0)</span>"</span></span><br><span class="line"><span class="built_in">export</span> BTRACE_HOME=<span class="variable">$currentDir</span>/../</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$BTRACE_HOME</span>/bin:<span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line">pid=<span class="string">"<span class="variable">$(jps | grep "StringTableTest"|cut -d " " -f1)</span>"</span></span><br><span class="line"></span><br><span class="line">btrace <span class="variable">$pid</span> <span class="variable">$currentDir</span>/scripts/TraceMethodArgsAndReturn.java</span><br></pre></td></tr></table></figure>
<p>最后输出结果如下所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">call com.ezlippi.StringTableTest.intern</span><br><span class="line">invoke StringTableTest.intern</span><br><span class="line">input arg is:1000000</span><br><span class="line">result is:628</span><br><span class="line">time is:1512899327404</span><br><span class="line">//线程堆栈</span><br><span class="line">com.ezlippi.StringTableTest.intern(StringTableTest.java:22)</span><br><span class="line">com.ezlippi.StringTableTest.main(StringTableTest.java:13)</span><br></pre></td></tr></table></figure>
<p>有了BTrace之后，最终线上应用的运行细节就更方便了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java内存泄露的例子]]></title>
      <url>http://www.ezlippi.com/blog/2017/12/java-memory-leak-example.html</url>
      <content type="html"><![CDATA[<p>在定位JVM性能问题时可能会遇到内存泄露导致JVM OutOfMemory的情况,在使用Tomcat容器时如果设置了reloadable=”true”这个参数,在频繁热部署应用时也有可能会遇到内存溢出的情况。Tomcat的热部署原理是检测到WEB-INF/classes或者WEB-INF/lib目录下的文件发生了变更后会把应用先停止然后再启动,由于Tomcat默认给每个应用分配一个WebAppClassLoader,热替换的原理就是创建一个新的ClassLoader来加载类,由于JVM中一个类的唯一性由它的class文件和它的类加载器来决定,因此重新加载类可以达到热替换的目的。当热部署的次数比较多会导致JVM加载的类比较多,如果之前的类由于某种原因(比如内存泄露)没有及时卸载就可能导致永久代或者MetaSpace的OutOfMemory。这篇文章通过一个Demo来简要介绍下ThreadLocal和ClassLoader导致内存泄露最终OutOfMemory的场景。</p>
<a id="more"></a>
<h2 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h2><p>在类使用完之后，满足下面的情形，会被卸载：</p>
<ol>
<li>该类在堆中的所有实例都已被回收，即在堆中不存在该类的实例对象。</li>
<li>加载该类的classLoader已经被回收。</li>
<li>该类对应的Class对象没有任何地方可以被引用，通过反射访问不到该Class对象。</li>
</ol>
<p>如果类满足卸载条件，JVM就在GC的时候，对类进行卸载，即在方法区清除类的信息。</p>
<h2 id="场景介绍"><a href="#场景介绍" class="headerlink" title="场景介绍"></a>场景介绍</h2><p>上一篇文章我介绍了ThreadLocal的原理,每个线程有个ThreadLocalMap，如果线程的生命周期比较长可能会导致ThreadLocalMap里的Entry没法被回收,那ThreadLocal的那个对象就一直被线程持有强引用,由于实例对象会持有Class对象的引用,Class对象又会持有加载它的ClassLoader的引用，这样就会导致Class无法被卸载了,当加载的类足够多时就可能出现永久代或者MetaSpace的内存溢出，如果该类有大对象，比如有比较大的字节数组,会导致Java堆区的内存溢出。</p>
<h2 id="源码介绍"><a href="#源码介绍" class="headerlink" title="源码介绍"></a>源码介绍</h2><p>这里定义了一个内部类Inner,Inner类有个静态的ThreadLocal对象,主要用于让线程持有Inner类的强引用导致Inner类无法被回收,定义了一个自定义的类加载器去加载Inner类，如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MemoryLeak</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//由于线程一直在运行,因此ThreadLocalMap里的Inner对象一直被Thread对象强引用</span></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">					<span class="comment">//每次都新建一个ClassLoader实例去加载Inner类</span></span><br><span class="line">                    CustomClassLoader classLoader = <span class="keyword">new</span> CustomClassLoader</span><br><span class="line">                            (<span class="string">"load1"</span>, MemoryLeak.class.getClassLoader(), <span class="string">"com.ezlippi.MemoryLeak$Inner"</span>, <span class="string">"com.ezlippi.MemoryLeak$Inner$1"</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Class&lt;?&gt; innerClass = classLoader.loadClass(<span class="string">"com.ezlippi.MemoryLeak$Inner"</span>);</span><br><span class="line">                        innerClass.newInstance();</span><br><span class="line">						<span class="comment">//帮助GC进行引用处理</span></span><br><span class="line">                        innerClass = <span class="keyword">null</span>;</span><br><span class="line">                        classLoader = <span class="keyword">null</span>;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException | InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//为了更快达到堆区</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span>  <span class="keyword">byte</span>[] MB = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> ThreadLocal&lt;Inner&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Inner&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> Inner <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">		<span class="comment">//调用ThreadLocal.get()才会调用initialValue()初始化一个Inner对象</span></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            threadLocal.get();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//源码省略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h2 id="堆区内存溢出"><a href="#堆区内存溢出" class="headerlink" title="堆区内存溢出"></a>堆区内存溢出</h2><p>为了触发堆区内存溢出，我在Inner类里面设置了一个1MB的字节数组,同时要在静态块中调用threadLocal.get()，只有调用才会触发initialValue()来初始化一个Inner对象,不然只是创建了一个空的ThreadLocal对象,ThreadLocalMap里并没有数据。</p>
<p>JVM参数如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms100m -Xmx100m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintClassHistogram -XX:+HeapDumpOnOutOfMemoryError</span><br></pre></td></tr></table></figure>
<p>最后执行了814次后JVM堆区内存溢出了,如下所示:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">Dumping heap to java_pid11824.hprof ...</span><br><span class="line">Heap dump file created [100661202 bytes <span class="keyword">in</span> 1.501 secs]</span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 30720K, used 30389K [0x00000000f9c00000, 0x00000000fbd50000, 0x00000000fbd50000)</span><br><span class="line">  eden space 27328K,  99% used [0x00000000f9c00000, 0x00000000fb6ad450, 0x00000000fb6b0000)</span><br><span class="line">  from space 3392K,  90% used [0x00000000fb6b0000, 0x00000000fb9b0030, 0x00000000fba00000)</span><br><span class="line">  to   space 3392K,   0% used [0x00000000fba00000, 0x00000000fba00000, 0x00000000fbd50000)</span><br><span class="line"> concurrent mark-sweep generation total 68288K, used 67600K [0x00000000fbd50000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3770K, capacity 5134K, committed 5248K, reserved 1056768K</span><br><span class="line">  class space    used 474K, capacity 578K, committed 640K, reserved 1048576K</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">"Thread-0"</span> java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at com.ezlippi.MemoryLeak<span class="variable">$Inner</span>.&lt;clinit&gt;(MemoryLeak.java:34)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(Unknown Source)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(Unknown Source)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Unknown Source)</span><br><span class="line">	at java.lang.Class.newInstance(Unknown Source)</span><br><span class="line">	at com.ezlippi.MemoryLeak<span class="variable">$1</span>.run(MemoryLeak.java:20)</span><br><span class="line">	at java.lang.Thread.run(Unknown Source)</span><br></pre></td></tr></table></figure></p>
<p>可以看到JVM已经没有内存来创建新的Inner对象,因为堆区存放了很多个1MB的字节数组,这里我把类的直方图打印出来了(下图是堆大小为1024M的场景)，省略了一些无关紧要的类，可以看出字节数组占了855M的空间,创建了814个<code>com.ezlippi.MemoryLeak$CustomClassLoader</code>的实例,和字节数组的大小基本吻合：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> num     <span class="comment">#instances         #bytes  class name</span></span><br><span class="line">----------------------------------------------</span><br><span class="line">   1:          6203      855158648  [B</span><br><span class="line">   2:         13527        1487984  [C</span><br><span class="line">   3:           298         700560  [I</span><br><span class="line">   4:          2247         228792  java.lang.Class</span><br><span class="line">   5:          8232         197568  java.lang.String</span><br><span class="line">   6:          3095         150024  [Ljava.lang.Object;</span><br><span class="line">   7:          1649         134480  [Ljava.util.HashMap<span class="variable">$Node</span>;</span><br><span class="line">  11:           813          65040  com.ezlippi.MemoryLeak<span class="variable">$CustomClassLoader</span></span><br><span class="line">  12:           820          53088  [Ljava.util.Hashtable<span class="variable">$Entry</span>;</span><br><span class="line">  15:           817          39216  java.util.Hashtable</span><br><span class="line">  16:           915          36600  java.lang.ref.SoftReference</span><br><span class="line">  17:           543          34752  java.net.URL</span><br><span class="line">  18:           697          33456  java.nio.HeapCharBuffer</span><br><span class="line">  19:           817          32680  java.security.ProtectionDomain</span><br><span class="line">  20:           785          31400  java.util.TreeMap<span class="variable">$Entry</span></span><br><span class="line">  21:           928          29696  java.util.Hashtable<span class="variable">$Entry</span></span><br><span class="line">  22:          1802          28832  java.util.HashSet</span><br><span class="line">  23:           817          26144  java.security.CodeSource</span><br><span class="line">  24:           814          26048  java.lang.ThreadLocal<span class="variable">$ThreadLocalMap</span><span class="variable">$Entry</span></span><br></pre></td></tr></table></figure>
<h2 id="Metaspace溢出"><a href="#Metaspace溢出" class="headerlink" title="Metaspace溢出"></a>Metaspace溢出</h2><p>为了让Metaspace溢出，那就必须把MetaSpace的空间调小一点，要在堆溢出之前加载足够多的类,因此我调整了下JVM参数,并且把字节数组的大小调成了1KB，如下所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private  byte[] KB = new byte[1024];</span><br><span class="line"></span><br><span class="line">-Xms100m -Xmx100m -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:+PrintGCDetails -XX:+PrintHeapAtGC -XX:+PrintClassHistogram -XX:MetaspaceSize=2m -XX:MaxMetaspaceSize=2m</span><br></pre></td></tr></table></figure>
<p>从GC日志可以看出在Meraspace达到GC阈值(也就是MaxMetaspaceSize配置的大小时)会触发一次FullGC：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">	&lt;&lt;no stack trace available&gt;&gt;</span><br><span class="line"></span><br><span class="line">&#123;Heap before GC invocations=20 (full 20):</span><br><span class="line"> par new generation   total 30720K, used 0K [0x00000000f9c00000, 0x00000000fbd50000, 0x00000000fbd50000)</span><br><span class="line">  eden space 27328K,   0% used [0x00000000f9c00000, 0x00000000f9c00000, 0x00000000fb6b0000)</span><br><span class="line">  from space 3392K,   0% used [0x00000000fb6b0000, 0x00000000fb6b0000, 0x00000000fba00000)</span><br><span class="line">  to   space 3392K,   0% used [0x00000000fba00000, 0x00000000fba00000, 0x00000000fbd50000)</span><br><span class="line"> concurrent mark-sweep generation total 68288K, used 432K [0x00000000fbd50000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 1806K, capacity 1988K, committed 2048K, reserved 1056768K</span><br><span class="line">  class space    used 202K, capacity 384K, committed 384K, reserved 1048576K</span><br><span class="line">[Full GC (Metadata GC Threshold) [CMS</span><br><span class="line">Process finished with <span class="built_in">exit</span> code 1</span><br></pre></td></tr></table></figure>
<p>通过上面例子可以看出如果类加载器和ThreadLocal使用的不当确实会导致内存泄露的问题,完整的源码在<a href="https://github.com/EZLippi/blogSourceCode/blob/master/MemoryLeak.java" target="_blank" rel="external">github</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java ThreadLocal原理分析]]></title>
      <url>http://www.ezlippi.com/blog/2017/12/threadlocal.html</url>
      <content type="html"><![CDATA[<p>大家或多或少听说过ThreadLocal这个词,我们创建的对象默认是所有线程可以访问的,多线程并发修改对象时就会可能出现数据不一致的问题,使用ThreadLocal创建的对象只能被当前线程访问，每个线程保存一个对象的副本,在多线程操作时是线程安全的。</p>
<a id="more"></a>
<h2 id="ThreadLocal用法简介"><a href="#ThreadLocal用法简介" class="headerlink" title="ThreadLocal用法简介"></a>ThreadLocal用法简介</h2><p>比如有这样一个类:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"> 	<span class="function"><span class="keyword">public</span> <span class="title">Counter</span><span class="params">(<span class="keyword">int</span> cnt)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.count = cnt;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//省略setter()和getter()方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们希望多线程访问Counter对象时，各个线程各自保留一份count计数,那可以这么写:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Counter&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">threadLocal.set(<span class="keyword">new</span> Counter(<span class="number">0</span>));</span><br><span class="line">Counter counter = threadLocal.get();</span><br></pre></td></tr></table></figure></p>
<p>如果你不想每次调用的时候都去初始化,那可以重写ThreadLocal的initValue()方法给ThreadLocal设置一个对象的初始值,如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Counter&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Counter&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Counter <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Counter(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这样每次调用threadLocal.get()的时候，会去判断当前线程是否存在Counter对象,如果不存在则调用initValue()方法初始化。</p>
<h2 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h2><p>我们先来看一下ThreadLocal的get()方法，如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用get()方法时先获取到当前线程,然后通过线程获取每个线程绑定的ThreadLocalMap对象,map中的key就是ThreadLocal对象,Value就是实际我们要访问的对象，上面的例子中是Counter对象,如果Entry为空,那就调用setInitialValue()方法设置初始值。</p>
<h3 id="ThreadLocalMap实现原理"><a href="#ThreadLocalMap实现原理" class="headerlink" title="ThreadLocalMap实现原理"></a>ThreadLocalMap实现原理</h3><p>从前面可以看出每个线程内部有个ThreadLocalMap,从java.lang.Thread类的源码也可以看到Thread类有个<code>ThreadLocal.ThreadLocalMap threadLocals</code>属性,接下来我们来分析下它的实现原理:<br>ThreadLocalMap和WeakHashMap实现有点类似，也是利用了WeakReference来和GC建立关联,因为ThreadLocal对象被线程对象引用，如果一个线程的生命周期比较长,那可能会出现内存泄露的问题，ThreadLocalMap借助弱引用巧妙的解决了这个问题，源码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">        Object value;</span><br><span class="line">		<span class="comment">//这里的Entry并不是一个链表,如果出现hash碰撞,会放到数组的下一个位置</span></span><br><span class="line">        Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">            <span class="keyword">super</span>(k);</span><br><span class="line">            value = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码可以看到ThreadLocalMap的Entry继承自WeakReference,Entry中的key是一个弱引用，也就是说线程类持有了ThreadLocal对象的一个弱引用,当ThreadLocal对象没有其他强引用关联时,在GC时会把ThreadLocal对象回收掉，但是这里仅仅回收ThreadLocal对象,Entry对象和Value并没有回收,ThreadLocalMap里就可能存在很多Key为null的Entry,所以需要在调用map.getEntry()时对key为null的对象进行处理,源码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">		<span class="comment">//当前位置没有找到,可能Hash碰撞了</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">			<span class="comment">//找到了直接返回</span></span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">			<span class="comment">//检测到有个ThreadLocal对象被回收了,这个时候去清理后面所有Key为null的Entry</span></span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从源码中可以看到ThreadLocalMap清理掉key为Null的Entry的时机是根据ThreadLocal对象的hashCode去获取entry时发生了hash碰撞,并且下一个entry的key为null时才去清理,因为ThreadLocalMap的Entry和普通Map的不太一样，一般的Map是一个链表数组，而它的数组每个元素就是一个Entry，如果出现Hash碰撞了就放到数组的下一个位置,因此如果get的时候发现没有碰撞可以认为当前Map中的元素还不多，一旦检测到碰撞了并且下一个entry的key被回收了,就调用expungeStaleEntry（）来释放ThreadLocal为null的那些entry,避免了内存泄露。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">//清理key为null的entry</span></span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">			<span class="comment">//hashCode发生了变化,重新放置entry</span></span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ThreadLocal可以保证每个线程拥有一个变量的副本，实现了线程隔离,主要利用了每个Thread有个ThreadLocalMap,ThreadLocalMap保存了该线程拥有的所有ThreadLocal对象，并利用弱引用机制避免了Map无线增大导致内存泄露的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[WeakHashMap原理分析]]></title>
      <url>http://www.ezlippi.com/blog/2017/11/java-weak-reference.html</url>
      <content type="html"><![CDATA[<p>在比较简单的应用场景下我们常用HashMap来缓存一些数据,比如建立Socket连接时需要保存Socket关联的用户,这个信息无法直接添加到Socket对象的属性中,那就可以通过Map来保存这些元数据信息。但这样子会产生一个问题，对象元数据的生命周期需要与套接字(Socket)的生命周期挂钩，除非你准确地知道应用程序什么时候不再需要这个套接字，并记住从Map中删除相应的映射，否则，Socket和User对象将会永远留在Map中，远远超过了套接字的生命周期，而且HashMap会对key和value持有一个强引用，这会阻止Socket和User对象被垃圾收集，到最后时间长了可能导致JVM OutOfMemory。</p>
<a id="more"></a>
<h2 id="强引用与弱引用"><a href="#强引用与弱引用" class="headerlink" title="强引用与弱引用"></a>强引用与弱引用</h2><p>JDK里面提供了4种引用类型:强引用、弱引用、软引用和虚引用(四种引用类型的具体介绍可以参考<a href="http://www.importnew.com/20468.html" target="_blank" rel="external">这里</a>)，毫无疑问强引用是使用最多的，我们创建一个对象默认就建立了一个它的强引用,只要对象是强引用可达的，JVM就不会回收这个对象的内存，而弱引用的实现是，当一个对象(这里我们称之为<strong>referent</strong>)只有弱引用可达时，JVM在下次垃圾回收时会回收这个referent对象的内存，听起来可以解决我们前面说的那个问题。那是不是在创建HashMap时，把key和value都设置成WeakReference就可以了呢，这样子实现起来就复杂了，每次往Map中存放数据都要创建WeakReference,虽然GC会回收对应的Key和Value，但是Map里面还是会残留WeakReference对象,Map的大小也会一直越来越大。好在是JDK提供了一个WeakHashMap类，里面比较好的利用了弱引用和引用队列来及时将不再引用的对象从Map中删除。</p>
<h2 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h2><p>WeakHashMap的Entry继承自WeakReference,在创建Entry的时候要关联一个ReferenceQueue,如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">Object</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    Entry&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Entry(Object key, V value,</span><br><span class="line">          ReferenceQueue&lt;Object&gt; queue,</span><br><span class="line">          <span class="keyword">int</span> hash, Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">		<span class="comment">//从这里可以看出Entry里的key是弱引用,并且和Key关联了引用队列</span></span><br><span class="line">        <span class="keyword">super</span>(key, queue);</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.hash  = hash;</span><br><span class="line">        <span class="keyword">this</span>.next  = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那引用队列有什么用呢，引用队列是垃圾收集器(GC)向应用程序返回关于对象生命周期的信息的主要方法。弱引用有两个构造函数：一个只取被引用的对象referent作为参数，另一个还取引用队列(ReferenceQueue)作为参数。如果用关联的引用队列referenceQueue创建弱引用，在GC要回收该弱引用引用的对象（由Entry的构造方法可知,WeakHashMap是根据key来决定这个Entry的生命周期的）时，这个引用对象（<strong>在这里是指Entry对象</strong>）就在引用清除后加入到引用队列中。之后，应用程序从引用队列中获取引用并进行相应的清理活动，如去掉已不在弱集合中的对象的项，在调用WeakHashMap的方法时会调用expungeStaleEntries()来清除在引用队列中的Entry,如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;	</span><br><span class="line">	<span class="comment">//遍历引用队列</span></span><br><span class="line">    <span class="keyword">for</span> (Object x; (x = queue.poll()) != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">             <span class="comment">//注意引用队列中的是Entry不是Key</span></span><br><span class="line">            Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x;</span><br><span class="line">            <span class="keyword">int</span> i = indexFor(e.hash, table.length);</span><br><span class="line"></span><br><span class="line">            Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">            Entry&lt;K,V&gt; p = prev;</span><br><span class="line">			<span class="comment">//从HashMap中清除该Entry</span></span><br><span class="line">            <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = p.next;</span><br><span class="line">                <span class="keyword">if</span> (p == e) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (prev == e)</span><br><span class="line">                        table[i] = next;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        prev.next = next;</span><br><span class="line"></span><br><span class="line">                    e.value = <span class="keyword">null</span>; <span class="comment">// Help GC</span></span><br><span class="line">                    size--;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = p;</span><br><span class="line">                p = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回到我们最初的问题,当我们创建一个Socket和User的映射表时,如果Socket对象不再使用时,JVM在引用处理时会检查到该Socket对象是只有弱引用可达的，在清除该对象时会把对象的WeakReference对象(注意WeakRefence也是一个对象，该对象内部持有Socket对象的引用)放到引用队列中，当应用程序调用WeakHashMap的方法时会遍历referenceQueue，然后清除对应的不再使用的Entry,这样子就避免了HashMap一直膨胀而导致内存泄露的问题。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java ClassLoader loader constraints分析]]></title>
      <url>http://www.ezlippi.com/blog/2017/11/java-classloader-constraint.html</url>
      <content type="html"><![CDATA[<p>在和Web容器打交道的时候大家有时候会遇到<code>java.lang.LinkageError: loader constraint violation: loader (instance of &lt;bootloader&gt;) previously initiated loading for a different type with name ...</code>这个错误，网上的教程都是说类加载冲突了,把从pom文件里把servlet和el这些依赖的scope改为provided，或者将Tomcat webapp类加载器的delegate属性改为true，让Tomcat的CommonClassLoader来加载,但是始终找不到一篇文章来具体分析这个错误。这篇文章从原理和实践的角度来介绍为什么要这么做。</p>
<a id="more"></a>
<h2 id="问题来源"><a href="#问题来源" class="headerlink" title="问题来源"></a>问题来源</h2><p>下面有三个很简单的类，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"LoginService loaded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        System.out.println(<span class="string">"Logging in with User loaded in "</span> + </span><br><span class="line">			user.getClass().getClassLoader());</span><br><span class="line">        LoginService.login(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建自定义的类加载器"><a href="#创建自定义的类加载器" class="headerlink" title="创建自定义的类加载器"></a>创建自定义的类加载器</h2><p>在Java里你可以继承ClassLoader类来实现你自己的类加载器，这样子就允许在内存中加载同个类的多个版本(常用在OSGI里)。当一个类加载器被要求加载一个类时，它可以首先要求它的父类来加载，如果父类加载失败它再尝试自己加载，这种称为父类优先类加载器。除此之外，类加载器可以尝试自己先加载，只有自己找不到时才委托给父类，比如我们要从网络流中加载或者本地字节码经过加密了要先解密再加载。关于类加载器的双亲委派模型我就不介绍了，网上有很多教程。</p>
<p>我这里写了一个自定义的类加载器，重写了findClass()和loadClass()方法，这个类加载器只加载指定列表里的类,其他类委托给父类加载器进行加载,代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span><br><span class="line"> * 自己优先加载的类加载器,只加载指定类,其他委托给父加载器 </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; urls;</span><br><span class="line">    <span class="keyword">private</span> String label;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CustomClassLoader</span><span class="params">(String name, ClassLoader parent, String... url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.label = name;</span><br><span class="line">        <span class="keyword">this</span>.urls = <span class="keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">if</span> (urls.contains(name)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                String location = name.replace(<span class="string">'.'</span>, <span class="string">'/'</span>) + <span class="string">".class"</span>;</span><br><span class="line">                InputStream inputStream = Demo.class.getClassLoader().getResourceAsStream(location);</span><br><span class="line">                <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2000</span>];</span><br><span class="line">                ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">                <span class="keyword">int</span> length; </span><br><span class="line">                <span class="keyword">while</span> ((length = inputStream.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    outputStream.write(buf, <span class="number">0</span> , length);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//流的关闭应该放到finally块,这里为了演示简化了</span></span><br><span class="line">                inputStream.close();</span><br><span class="line">                System.out.println(label + <span class="string">": Loading "</span> + name + <span class="string">" in "</span> +</span><br><span class="line">                        label + <span class="string">" classloader"</span>);</span><br><span class="line">                <span class="keyword">byte</span>[] data = outputStream.toByteArray();</span><br><span class="line">                <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name, e);</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">		<span class="comment">//需要调用findLoaderClass()来检查该类是否已经加载过</span></span><br><span class="line">        <span class="keyword">if</span> (findLoadedClass(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(label + <span class="string">": already loaded("</span> + name + <span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">return</span> findLoadedClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (urls.contains(name)) &#123;</span><br><span class="line">            <span class="keyword">return</span> findClass(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(label + <span class="string">": super.loadclass("</span> + name + <span class="string">")"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name, resolve);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="创建多个类加载器"><a href="#创建多个类加载器" class="headerlink" title="创建多个类加载器"></a>创建多个类加载器</h2><p>接下来我创建了三个不同的类加载器，分别加载不同的类，如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//beanLoader只加载User和LoginService类</span></span><br><span class="line">CustomClassLoader beanLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">"BeanLoader  "</span>,</span><br><span class="line">        Demo.class.getClassLoader(),</span><br><span class="line">        <span class="string">"com.ezlippi.Demo$User"</span>, <span class="string">"com.ezlippi.Demo$LoginService"</span>);</span><br><span class="line"><span class="comment">//webLoader只加载Servlet类,父加载器为beanLoader</span></span><br><span class="line">CustomClassLoader webLoder = <span class="keyword">new</span> CustomClassLoader(<span class="string">"WebLoader"</span>,</span><br><span class="line">        beanLoader, <span class="string">"com.ezlippi.Demo$Servlet"</span>);</span><br><span class="line"><span class="comment">//webBeanLoader加载User和Servlet类,父加载器也为beanLoader</span></span><br><span class="line">CustomClassLoader webBeanLoader = <span class="keyword">new</span> CustomClassLoader(<span class="string">"webBeanLoader"</span>, beanLoader,</span><br><span class="line">        <span class="string">"com.ezlippi.Demo$User"</span>, <span class="string">"com.ezlippi.Demo$Servlet"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>当LoginService类被加载，这中间发生了什么事情，我们来看一下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">beanLoader.loadClass(<span class="string">"com.ezlippi.Demo<span class="variable">$LoginService</span>"</span>, <span class="literal">true</span>).newInstance();</span><br><span class="line">输出如下所示:</span><br><span class="line">BeanLoader  : Loading com.ezlippi.Demo<span class="variable">$LoginService</span> <span class="keyword">in</span> BeanLoader   classloader</span><br><span class="line">BeanLoader  : super.loadclass(java.lang.Object)</span><br><span class="line">BeanLoader  : super.loadclass(java.lang.System)</span><br><span class="line">BeanLoader  : super.loadclass(java.io.PrintStream)</span><br></pre></td></tr></table></figure></p>
<p>当JVM加载LoginService类时，它会检查这个类引用的所有类然后也会加载这些类，java.lang.Object是它的父类，java.lang.System和java.io.PrintStream是在静态块中被引用的，这些类在启动时已经被启动类加载器加载了。当BeanLoader收到加载这些jvm自带的类时，把加载的请求代理给父类加载器(这里是appClassLoader),实际上对于java.<em>和Javax.</em>开头的类我们需要委托给父类加载器加载。</p>
<p>同时我们应该注意到login方法里的User类并没有加载，因为这个User类是在方法内部使用的，这时候还不足以引起这个类的加载。<br>接下来我们用webBeanLoader来加载Servlet类:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">webBeanLoader.loadClass(<span class="string">"com.ezlippi.Demo<span class="variable">$Servlet</span>"</span>, <span class="literal">false</span>).</span><br><span class="line">                getMethod(<span class="string">"doGet"</span>).invoke(null);</span><br><span class="line"></span><br><span class="line">webBeanLoader: Loading com.ezlippi.Demo<span class="variable">$Servlet</span> <span class="keyword">in</span> webBeanLoader classloader</span><br><span class="line">webBeanLoader: Loading com.ezlippi.Demo<span class="variable">$User</span> <span class="keyword">in</span> webBeanLoader classloader</span><br><span class="line">Logging <span class="keyword">in</span> with User loaded <span class="keyword">in</span> webBeanLoader</span><br><span class="line">webBeanLoader: super.loadclass(com.ezlippi.Demo<span class="variable">$LoginService</span>)</span><br><span class="line">BeanLoader  : already loaded(com.ezlippi.Demo<span class="variable">$LoginService</span>)</span><br></pre></td></tr></table></figure></p>
<p>这里我省略了JVM自带的类，由于我们调用了servlet的doGet()方法，所以这里可以看到User类和LoginService类也被加载了，这里是委托给了父类beanLoader进行加载。<br>接下来问题来了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//调用getMethods()时LoginService和User类建立了引用关系,所以会去加载User类</span><br><span class="line">beanLoader.loadClass(<span class="string">"com.ezlippi.Demo<span class="variable">$LoginService</span>"</span>, 	<span class="literal">false</span>).getMethods();</span><br><span class="line">BeanLoader  : already loaded(com.ezlippi.Demo<span class="variable">$LoginService</span>)</span><br><span class="line">BeanLoader  : Loading com.ezlippi.Demo<span class="variable">$User</span> <span class="keyword">in</span> BeanLoader  classloader</span><br><span class="line">java.lang.LinkageError: loader constraint violation: </span><br><span class="line">loader (instance of com/ezlippi/Demo<span class="variable">$CustomClassLoader</span>)previously initiated</span><br><span class="line"> loading <span class="keyword">for</span> a different <span class="built_in">type</span> with name <span class="string">"com/ezlippi/Demo<span class="variable">$User</span>"</span></span><br><span class="line">	... 12 more</span><br></pre></td></tr></table></figure></p>
<p>这里你会发现抛出了java.lang.LinkageError,我们可以加个虚拟机参数-XX:+TraceLoaderConstraints把约束打印出来，结果如下:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BeanLoader  : already loaded(com.ezlippi.Demo<span class="variable">$LoginService</span>)</span><br><span class="line">[Adding new constraint <span class="keyword">for</span> name: com/ezlippi/Demo<span class="variable">$User</span>, loader[0]:com/ezlippi/Demo<span class="variable">$CustomClassLoader</span>, loader[1]: com/ezlippi/Demo<span class="variable">$CustomClassLoader</span> ]</span><br><span class="line">BeanLoader  : Loading com.ezlippi.Demo<span class="variable">$User</span> <span class="keyword">in</span> BeanLoader classloader</span><br><span class="line">[Constraint check failed <span class="keyword">for</span> name com/ezlippi/Demo<span class="variable">$User</span>, loader com/ezlippi/Demo<span class="variable">$CustomClassLoader</span>: the presented classobject differs from that stored ]</span><br><span class="line">java.lang.LinkageError: loader constraint violation: loader(instance of com/ezlippi/Demo<span class="variable">$CustomClassLoader</span>) previously initiated </span><br><span class="line">loading <span class="keyword">for</span> a different <span class="built_in">type</span> with name <span class="string">"com/ezlippi/Demo<span class="variable">$User</span>"</span></span><br><span class="line">	... 12 more</span><br></pre></td></tr></table></figure></p>
<p>类加载器beanLoader在加载完LoginService尝试加载User类时，会添加一个约束,loader[0]就是beanLoader,loader[1]是webBeanLoader,当两个类加载器加载的类引用同一个类(这里是User类),<strong>并且这两个类之间建立了引用关系时</strong>,这个User类必须是同一个,如果不是就会抛出java.lang.LinkageError。</p>
<p>JAVA虚拟机规范里是这么写的:当解析一个包含在<c,l1>中的符号引用（它指向的是类<d,l2>中声明的类型T的字段）时，虚拟机必须产生下列装载约束，TL1=TL2。接下来看另一种场景：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">webLoder.loadClass(<span class="string">"com.ezlippi.Demo<span class="variable">$Servlet</span>"</span>, <span class="literal">false</span>).</span><br><span class="line">                getMethod(<span class="string">"doGet"</span>).invoke(null);</span><br><span class="line">WebLoader: Loading com.ezlippi.Demo<span class="variable">$Servlet</span> <span class="keyword">in</span> WebLoader classloader</span><br><span class="line">WebLoader: super.loadclass(java.lang.Object)</span><br><span class="line">BeanLoader  : already loaded(java.lang.Object)</span><br><span class="line">WebLoader: super.loadclass(com.ezlippi.Demo<span class="variable">$User</span>)</span><br><span class="line">BeanLoader  : Loading com.ezlippi.Demo<span class="variable">$User</span> <span class="keyword">in</span> BeanLoader   classloader</span><br><span class="line">[Constraint check failed <span class="keyword">for</span> name com/ezlippi/Demo<span class="variable">$User</span>, loader</span><br><span class="line"> com/ezlippi/Demo<span class="variable">$CustomClassLoader</span>: the presented class object differs from that stored ]</span><br><span class="line">java.lang.reflect.InvocationTargetException</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">	at sun.reflect.NativeMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(Unknown Source)</span><br><span class="line">	at java.lang.reflect.Method.invoke(Unknown Source)</span><br><span class="line">	at com.ezlippi.Demo.test1(Demo.java:116)</span><br><span class="line">	at com.ezlippi.Demo.main(Demo.java:121)</span><br><span class="line">Caused by: java.lang.LinkageError: loader constraint violation:loader(instance of </span><br><span class="line"> com/ezlippi/Demo<span class="variable">$CustomClassLoader</span>) previously initiated loading <span class="keyword">for</span> a </span><br><span class="line"> different <span class="built_in">type</span> with name <span class="string">"com/ezlippi/Demo<span class="variable">$User</span>"</span></span><br><span class="line">	... 12 more</span><br></pre></td></tr></table></figure></d,l2></c,l1></p>
<p>这里通过webLoader去加载Servlet类，然后调用doGet()方法触发了User类的加载,这里委托给了父类加载器beanLoader去加载,在调用LoginService.login(user)方法时触发了前面这个约束条件,因为加载LoginService的beanLoader也加载了User类，两个类加载器加载同一个类是没问题的，但是当他们<strong>建立了引用关系时就会添加一个约束</strong>,LoginService期望的是beanLoader加载的User类，而Servlet类传递给他的是webLoader加载的User类，两个不是同一个。</p>
<p>总结一下:无论何时当两个类加载器加载两个不同的类(比如这里的Servlet和LoginService)，当这两个不同的类通过某种方式建立了引用关系(比如这里通过User类)，虚拟机就会在约束列表上加一个约束，虚拟机在解析符号引用的时候必须检查当前已经能够装载的所有约束。<br>源码在<a href="https://github.com/EZLippi/Profiles/blob/master/Demo.java" target="_blank" rel="external">这里</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Spring事务源码分析]]></title>
      <url>http://www.ezlippi.com/blog/2017/10/spring-transation-sourcecode.html</url>
      <content type="html"><![CDATA[<p>事务管理能保证一系列操作以原子的方式执行,Spring框架提供了非常完善的事务支持,Spring事务管理主要围绕着TransactionDefinition,<br>AbstractPlatformTransactionManager,TransactionSynchronizationManager,DataSourceTransactionManager这几个类.</p>
<a id="more"></a>
<h3 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h3><h4 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h4><p>事务的传播行为是指如果在开启当前事务之前,当前线程已经存在一个事务上下文,那么用户可以指定当前事务的执行行为,Spring里的<br>传播行为有以下几种:</p>
<ul>
<li>PROPAGATION_REQUIRED    如果当前没有事务,就新建一个事务,如果已经存在一个事务中,加入到这个事务中.</li>
<li>PROPAGATION_SUPPORTS    如果当前存在一个事务,则加入这个事务,如果当前没有事务,就以非事务方式执行</li>
<li>PROPAGATION_MANDATOR    使用当前的事务,如果当前没有事务,就抛出异常</li>
<li>PROPAGATION_REQUIRES_NEW    新建事务,如果当前存在事务,把当前事务挂起</li>
<li>PROPAGATION_NOT_SUPPORTED    以非事务方式执行操作,如果当前存在事务,就把当前事务挂起</li>
<li>PROPAGATION_NEVER    以非事务方式执行,如果当前存在事务,则抛出异常</li>
<li>PROPAGATION_NESTED    如果当前存在事务,则在嵌套事务内执行.如果当前没有事务,则执行与PROPAGATION_REQUIRED类似的操作</li>
</ul>
<p>Spring框架里在事务初始化时对隔离级别的处理如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (isExistingTransaction(transaction)) &#123;</span><br><span class="line">    <span class="comment">// 如果当前上下文存在事务 -&gt; 检查用户设置的隔离级别来确定当前事务的行为</span></span><br><span class="line">    <span class="keyword">return</span> handleExistingTransaction(definition, transaction, debugEnabled);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// PROPAGATION_MANDATORY级别不存在当前事务,抛异常.</span></span><br><span class="line"><span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) &#123;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> IllegalTransactionStateException(</span><br><span class="line">			<span class="string">"No existing transaction found for transaction marked with propagation 'mandatory'"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//需要支持事务</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||</span><br><span class="line">		definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||</span><br><span class="line">		definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) &#123;</span><br><span class="line">	<span class="comment">//把当前事务挂起并保存当前事务的事务属性</span></span><br><span class="line">	SuspendedResourcesHolder suspendedResources = suspend(<span class="keyword">null</span>);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);</span><br><span class="line">		DefaultTransactionStatus status = newTransactionStatus(</span><br><span class="line">				definition, transaction, <span class="keyword">true</span>, newSynchronization, debugEnabled, suspendedResources);</span><br><span class="line">		<span class="comment">//开启事务</span></span><br><span class="line">		doBegin(transaction, definition);</span><br><span class="line">		prepareSynchronization(status, definition);</span><br><span class="line">		<span class="keyword">return</span> status;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">		resume(<span class="keyword">null</span>, suspendedResources);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 其他事务级别以非事务方式执行</span></span><br><span class="line">	<span class="keyword">if</span> (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) &#123;</span><br><span class="line">		logger.warn(<span class="string">"Custom isolation level specified but no actual transaction initiated; "</span> +</span><br><span class="line">				<span class="string">"isolation level will effectively be ignored: "</span> + definition);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">boolean</span> newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);</span><br><span class="line">	<span class="keyword">return</span> prepareTransactionStatus(definition, <span class="keyword">null</span>, <span class="keyword">true</span>, newSynchronization, debugEnabled, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>suspend挂起一个事务时需要判断是否开启事务同步,用户可以给事务注册事务同步器,如果检查到开启事务同步则需要保存事务的名称、事务同步列表、只读属性、超时时间、事务隔离级别、是否开启同步这些属性,<br>如果当前事务不为空,则由TransactionManager将对应事务挂起,通常的挂起行为是将事务对象和资源进行解绑,suspend的代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> SuspendedResourcesHolder <span class="title">suspend</span><span class="params">(Object transaction)</span> <span class="keyword">throws</span> TransactionException </span>&#123;</span><br><span class="line"><span class="comment">//当前事务开启了事务同步</span></span><br><span class="line"><span class="keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;</span><br><span class="line">    <span class="comment">//把当前事务的所有事务同步器挂起</span></span><br><span class="line">	List&lt;TransactionSynchronization&gt; suspendedSynchronizations = doSuspendSynchronization();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Object suspendedResources = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">			suspendedResources = doSuspend(transaction);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//保存事务属性</span></span><br><span class="line">		String name = TransactionSynchronizationManager.getCurrentTransactionName();</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionName(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">boolean</span> readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionReadOnly(<span class="keyword">false</span>);</span><br><span class="line">		Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();</span><br><span class="line">		TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<span class="keyword">null</span>);</span><br><span class="line">		<span class="keyword">boolean</span> wasActive = TransactionSynchronizationManager.isActualTransactionActive();</span><br><span class="line">		TransactionSynchronizationManager.setActualTransactionActive(<span class="keyword">false</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(</span><br><span class="line">				suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (RuntimeException | Error ex) &#123;</span><br><span class="line">		<span class="comment">// doSuspend failed - original transaction is still active...</span></span><br><span class="line">		doResumeSynchronization(suspendedSynchronizations);</span><br><span class="line">		<span class="keyword">throw</span> ex;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//没有开启同步但存在事务,则调用对应TransactionManager的doSuspend()方法挂起事务</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (transaction != <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// Transaction active but no synchronization active.</span></span><br><span class="line">	Object suspendedResources = doSuspend(transaction);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> SuspendedResourcesHolder(suspendedResources);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 不存在事务也没有开启事务同步</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>上面提到了事务同步的概念,Spring里有一个事务同步管理器(TransactionSynchronizationManager)管理着事务的生命周期,用户可以给事务注册事务同步器,监听指定的事务事件,<br>事务同步管理器在指定事务事件(比如事务提交成功、事务执行完成时)回调你事务同步器里的方法;用户只需要实现TransactionSynchronization接口并实现里面的方法.<br>TransactionSynchronizationManager的属性都设置为ThreadLocal类型的,因为事务是和线程进行绑定的,几个属性如下所示:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line"><span class="comment">//线程绑定的资源,比如DataSourceTransactionManager绑定是的某个数据源的一个Connection,在整个事务执行过程中</span></span><br><span class="line"><span class="comment">//都使用同一个Jdbc Connection</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Map&lt;Object, Object&gt;&gt; resources =</span><br><span class="line">		<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transactional resources"</span>);</span><br><span class="line"><span class="comment">//事务注册的事务同步器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;TransactionSynchronization&gt;&gt; synchronizations =</span><br><span class="line">		<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Transaction synchronizations"</span>);</span><br><span class="line"><span class="comment">//事务名称</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; currentTransactionName =</span><br><span class="line">		<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction name"</span>);</span><br><span class="line"><span class="comment">//事务只读属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; currentTransactionReadOnly =</span><br><span class="line">		<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction read-only status"</span>);</span><br><span class="line"><span class="comment">//事务隔离级别</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; currentTransactionIsolationLevel =</span><br><span class="line">		<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Current transaction isolation level"</span>);</span><br><span class="line"><span class="comment">//事务同步开启</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Boolean&gt; actualTransactionActive =</span><br><span class="line">		<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"Actual transaction active"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>JDBC事务的隔离级别通常是由数据库的锁来实现的,MySql数据库通过行锁、Gap锁和next-key锁来解决事务的脏读取、幻读取和<br>不可重复读的问题.事务的隔离级别通常是指同一个事务内相同的一条查询语句前后执行多次的行为差别,下面介绍常见的几种事务<br>隔离级别并简单介绍怎么用锁去实现:</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT：这是默认值,表示使用底层数据库的默认隔离级别.对大部分数据库而言,通常这值就是TransactionDefinition.ISOLATION_READ_COMMITTED.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据.该级别没有用到锁,多个事务可以并发修改同一行数据,因此不能防止脏读和不可重复读.</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据.该级别用到了行锁,查询的时候读取的是快照的数据,每次查询读取的是最新的快照,<br>,可以防止脏读,但是存在幻读取,因为行锁只能锁住修改,不能锁住插入和删除.</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ：该隔离级别表示一个事务在整个过程中可以多次重复执行某个查询,并且每次返回的记录都相同,同个事务内多次查询读取到的是同一个快照(第一次查询时的快照),因此可以防止脏读和不可重复读,<br>MySql数据库InnoDb存储引擎使用使用的是Gap锁和next-key锁,执行查询时锁住的是一个范围,因此可以防止插入和删除.</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE：所有的事务依次顺序执行,该级别可以防止脏读、不可重复读以及幻读,通常情况下不会用到该级别.</li>
</ul>
<h4 id="事务超时"><a href="#事务超时" class="headerlink" title="事务超时"></a>事务超时</h4><p>所谓事务超时,就是指一个事务的最长执行时间,如果超过该时间限制但事务还没有完成,则自动回滚事务.在TransactionDefinition中以int的值来表示超时时间,其单位是秒.</p>
<h4 id="事务的只读属性"><a href="#事务的只读属性" class="headerlink" title="事务的只读属性"></a>事务的只读属性</h4><p>事务的只读属性是指,对事务性资源进行只读操作或者是读写操作.所谓事务性资源就是指那些被事务管理的资源,比如数据源、JMS 资源,以及自定义的事务性资源等等.如果确定只对事务性资源进行只读操作,那么我们可以将事务标志为只读的,以提高事务处理的性能.在 TransactionDefinition 中以 boolean 类型来表示该事务是否只读.</p>
<h4 id="事务的回滚规则"><a href="#事务的回滚规则" class="headerlink" title="事务的回滚规则"></a>事务的回滚规则</h4><p>Spring的默认回滚规则是,如果在事务中抛出了非检查异常(继承自RuntimeException 的异常),则默认将回滚事务.如果没有抛出任何异常,或者抛出了已检查异常,则仍然提交事务.这通常也是大多数开发者希望的处理方式,也是 EJB 中的默认处理方式.但是,我们可以根据需要人为控制事务在抛出某些未检查异常时任然提交事务,或者在抛出某些已检查异常时回滚事务.</p>
<p>下面就以DataSourceTransactionManager为例介绍下开启一个事务时的准备工作,设置事务的隔离级别、关闭Jdbc Connection的自动提交、根据事务的只读属性来设置事务是否只读、<br>设置事务的超时时间、获取数据库连接并绑定资源到事务同步管理器,代码如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBegin</span><span class="params">(Object transaction, TransactionDefinition definition)</span> </span>&#123;</span><br><span class="line">DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;</span><br><span class="line">Connection con = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (!txObject.hasConnectionHolder() ||</span><br><span class="line">			txObject.getConnectionHolder().isSynchronizedWithTransaction()) &#123;</span><br><span class="line">		<span class="comment">//从数据源中获取一个连接</span></span><br><span class="line">		Connection newCon = obtainDataSource().getConnection();</span><br><span class="line">		txObject.setConnectionHolder(<span class="keyword">new</span> ConnectionHolder(newCon), <span class="keyword">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	txObject.getConnectionHolder().setSynchronizedWithTransaction(<span class="keyword">true</span>);</span><br><span class="line">	con = txObject.getConnectionHolder().getConnection();</span><br><span class="line"></span><br><span class="line">	Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);</span><br><span class="line">	txObject.setPreviousIsolationLevel(previousIsolationLevel);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 关闭Connection的自动提交,由Spring框架来控制事务的提交和回滚,</span></span><br><span class="line">	 <span class="comment">//修改自动提交操作代价非常大,先做判断是否开启了自动提交然后再修改</span></span><br><span class="line">	<span class="keyword">if</span> (con.getAutoCommit()) &#123;</span><br><span class="line">		txObject.setMustRestoreAutoCommit(<span class="keyword">true</span>);</span><br><span class="line">		con.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	prepareTransactionalConnection(con, definition);</span><br><span class="line">	txObject.getConnectionHolder().setTransactionActive(<span class="keyword">true</span>);</span><br><span class="line">    <span class="comment">//根据事务定义的超时时间来设置事务的超时时间</span></span><br><span class="line">	<span class="keyword">int</span> timeout = determineTimeout(definition);</span><br><span class="line">	<span class="keyword">if</span> (timeout != TransactionDefinition.TIMEOUT_DEFAULT) &#123;</span><br><span class="line">		txObject.getConnectionHolder().setTimeoutInSeconds(timeout);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//将ConnectionHolder对象绑定到事务同步管理器中</span></span><br><span class="line">	<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">		TransactionSynchronizationManager.bindResource(obtainDataSource(), txObject.getConnectionHolder());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">	<span class="keyword">if</span> (txObject.isNewConnectionHolder()) &#123;</span><br><span class="line">		DataSourceUtils.releaseConnection(con, <span class="keyword">this</span>.dataSource);</span><br><span class="line">		txObject.setConnectionHolder(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> CannotCreateTransactionException(<span class="string">"Could not open JDBC Connection for transaction"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过以上步骤就完成了事务的准备过程,最关键的是通过事务同步管理器绑定了一个Jdbc Connection,如果你要使用Spring事务来管理数据库操作,那就必须保证你用来执行数据库操作的<br>Connection和Spring事务里的Connection是同一个,Spring提供了DataSourceUtils.getConnection(dataSource)来获取事务连接,你也可以用JdbcTemplate来执行SQL,JdbcTemplate<br>内部就是调用的DataSourceUtils来获取Connection.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么不推荐使用-XX:+DisableExplicitGC]]></title>
      <url>http://www.ezlippi.com/blog/2017/10/why-not-expliclitgc.html</url>
      <content type="html"><![CDATA[<h3 id="System-gc-与NIO框架"><a href="#System-gc-与NIO框架" class="headerlink" title="System.gc()与NIO框架"></a>System.gc()与NIO框架</h3><p>System.gc()默认会触发一次Full Gc,如果在代码中不小心调用了System.gc()会导致JVM间歇性的暂停,但有些NIO框架<br>比如Netty框架经常会使用DirectByteBuffer来分配堆外内存,在分配之前会显式的调用System.gc(),如果开启了DisableExplicitGC<br>这个参数,会导致System.gc()调用变成一个空调用,没有任何作用,反而会导致Netty框架无法申请到足够的堆外内存,从而产生<br>java.lang.OutOfMemoryError: Direct buffer memory.</p>
<a id="more"></a>
<p>既然是堆外内存,为什么触发Full GC会有助于回收堆外内存呢,Full GC不是只回收JVM的堆内存吗?这就要了解下DirectByteBuffer的<br>回收机制了,DirectByteBuffer没有finalizer,它的native memory的清理工作是通过sun.misc.Cleaner自动完成的,而sum.misc.Cleaner<br>是一种基于虚引用的回收工具,从JDK源码也可以看到:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当GC检查到Cleaner的引用变成虚引用可达时,reference-handler线程会调用Cleaner的clean方法回收内存,这个机制可以在<br>java.lang.ref.Reference$ReferenceHandler里看到,Reference类加载的时候会创建reference-handler线程:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//省略了一些</span></span><br><span class="line">                <span class="comment">// Fast path for cleaners</span></span><br><span class="line">                <span class="keyword">if</span> (r <span class="keyword">instanceof</span> Cleaner) &#123;</span><br><span class="line">                    ((Cleaner)r).clean();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        ThreadGroup tg = Thread.currentThread().getThreadGroup();</span><br><span class="line">        <span class="keyword">for</span> (ThreadGroup tgn = tg;</span><br><span class="line">             tgn != <span class="keyword">null</span>;</span><br><span class="line">             tg = tgn, tgn = tg.getParent());</span><br><span class="line">        Thread handler = <span class="keyword">new</span> ReferenceHandler(tg, <span class="string">"Reference Handler"</span>);</span><br><span class="line">        <span class="comment">/* If there were a special system-only priority greater than</span><br><span class="line">         * MAX_PRIORITY, it would be used here</span><br><span class="line">         */</span></span><br><span class="line">        handler.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">        handler.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        handler.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>JVM在做Full GC时会对引用作处理(reference processing),当GC检测到Cleaner的引用变成虚可达时,<br>引用Handler线程会触发Cleaner对DirectByteBuffer对象作清理工作.</p>
<h3 id="ExplicitGCInvokesConcurrent"><a href="#ExplicitGCInvokesConcurrent" class="headerlink" title="ExplicitGCInvokesConcurrent"></a>ExplicitGCInvokesConcurrent</h3><p>既然不推荐使用DisableExplicitGC这个参数,那有没有什么办法能尽量减少显式调用System.gc()带来的GC停顿呢,JVM提供了<br>ExplicitGCInvokesConcurrent和ExplicitGCInvokesConcurrentAndUnloadsClasses这两个参数来保证显式调用System.gc()<br>触发的是一个并发GC周期而不是Full GC,这两个参数只能配合CMS使用(-XX:+UseConcMarkSweepGC):</p>
<p>CMS GC周期内也会做reference-processing,因此也能够触发对DirectByteBuffer内存的回收,减少了Full GC带来的长时间<br> 停顿.</p>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>当没有开启DisableExplicitGC这个参数时,你会发现JVM每个小时会执行一次Full GC,这是因为JVM在做分布式GC,为RMI服务的,<br>可以通过sun.rmi.dgc.server.gcInterval这个参数来修改GC间隔,默认是一个小时,具体的参数可以参考<a href="http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html" target="_blank" rel="external">http://docs.oracle.com/javase/6/docs/technotes/guides/rmi/sunrmiproperties.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis多数据源配置实现读写分离]]></title>
      <url>http://www.ezlippi.com/blog/2017/09/mybatis-multidatasource.html</url>
      <content type="html"><![CDATA[<p>常见的数据库连接池有C3P0、DBCP和阿里巴巴的druid,后两个在实际场景中用的比较多,这个案例简单介绍Spring+Druid+MyBatis<br>实现多数据源配置,基本原理是继承自Spring提供的AbstractRoutingDataSource这个抽象类,把所有的DataSource放到Map里面,<br>然后重写determineCurrentLookupKey()这个方法,Spring的AbstractRoutingDataSource在获取数据库连接时会先调用<br>determineCurrentLookupKey()方法来找到数据库的key值,然后从Map中找到对应的DataSource获取数据库连接。</p>
<a id="more"></a>
<h2 id="数据源配置"><a href="#数据源配置" class="headerlink" title="数据源配置"></a>数据源配置</h2><p>数据库连接池我用的阿里的druid,首先配置一个数据源的父类,定义一些公共的连接池参数,然后配置了两个继承自AbstractDataSource的<br>读写datasource,配置如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- applicationContext.xml --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 数据源参数配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:datasource.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"abstractDataSource"</span> <span class="attr">abstract</span>=<span class="string">"true"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span> <span class="attr">init-method</span>=<span class="string">"init"</span></span><br><span class="line">          <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 基本属性 url、user、password --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置初始化大小、最小、最大 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialSize"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minIdle"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxActive"</span> <span class="attr">value</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置获取连接等待超时的时间 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxWait"</span> <span class="attr">value</span>=<span class="string">"6000"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeBetweenEvictionRunsMillis"</span> <span class="attr">value</span>=<span class="string">"60000"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 配置一个连接在池中最小生存的时间，单位是毫秒 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minEvictableIdleTimeMillis"</span> <span class="attr">value</span>=<span class="string">"300000"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"validationQuery"</span> <span class="attr">value</span>=<span class="string">"SELECT 1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testWhileIdle"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnBorrow"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"testOnReturn"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 打开PSCache，并且指定每个连接上PSCache的大小 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"poolPreparedStatements"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolPreparedStatementPerConnectionSize"</span> <span class="attr">value</span>=<span class="string">"20"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filters"</span> <span class="attr">value</span>=<span class="string">"config"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"connectionProperties"</span> <span class="attr">value</span>=<span class="string">"config.decrypt=false"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"DataSourceRead"</span>  <span class="attr">parent</span>=<span class="string">"abstractDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;read_url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;read_userName&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;read_userValue&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"DataSourceWrite"</span>  <span class="attr">parent</span>=<span class="string">"abstractDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;write_url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;write_userName&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;write_userValue&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后实现一个类RWDataSource继承自AbstractRoutingDataSource,readDataSource和writeDataSource通过Spring注入,然后重写<br>afterPropertiesSet()和determineCurrentLookupKey()这两个方法,关键代码如下,setter和getter方法我这里省略了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWDataSource</span> <span class="keyword">extends</span> <span class="title">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object writeDataSource; <span class="comment">//写数据源</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object readDataSource; <span class="comment">//读数据源</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.writeDataSource == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Property 'writeDataSource' is required"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setDefaultTargetDataSource(writeDataSource);</span><br><span class="line">        Map&lt;Object, Object&gt; targetDataSources = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        targetDataSources.put(RWDataSourceType.WRITE.name(), writeDataSource);</span><br><span class="line">        <span class="keyword">if</span>(readDataSource != <span class="keyword">null</span>) &#123;</span><br><span class="line">            targetDataSources.put(RWDataSourceType.READ.name(), readDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用父类的方法把数据源注入</span></span><br><span class="line">        setTargetDataSources(targetDataSources);</span><br><span class="line">        <span class="keyword">super</span>.afterPropertiesSet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">determineCurrentLookupKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        RWDataSourceType dynamicDataSourceGlobal = RWDataSourceHolder.getDataSource();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dynamicDataSourceGlobal == <span class="keyword">null</span></span><br><span class="line">                || dynamicDataSourceGlobal == RWDataSourceType.WRITE) &#123;</span><br><span class="line">            <span class="keyword">return</span> RWDataSourceType.WRITE.name();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> RWDataSourceType.READ.name();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>determineCurrentLookupKey()方法这里主要是从RWDataSourceHolder这个类里取出RWDataSourceType(枚举类,包含Read和Write),<br>RWDataSourceHolder类里只有一个ThreadLocal的RWDataSourceType对象,用于保存每个线程选择的数据源,在使用Mybatis时要<br>根据执行的SQL语句类型动态修改当前线程的RWDataSourceType。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWDataSourceHolder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;RWDataSourceType&gt; holder = <span class="keyword">new</span> ThreadLocal&lt;RWDataSourceType&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putDataSource</span><span class="params">(RWDataSourceType dataSource)</span></span>&#123;</span><br><span class="line">        holder.set(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RWDataSourceType <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> holder.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是重点了,怎么根据MyBatis要执行的语句类型来动态修改数据源类型呢,这里就要用到MyBatis提供的插件的能力,MyBatis<br>里的数据库增删改查操作最后都是执行的Executor的query()或者update()方法,因此我们需要做的就是拦截Executor的query和update<br>方法,根据执行的SQL语句类型来动态修改数据源的key值,插件的代码如下:</p>
<h2 id="MyBatis拦截插件"><a href="#MyBatis拦截插件" class="headerlink" title="MyBatis拦截插件"></a>MyBatis拦截插件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts</span>(&#123;</span><br><span class="line">        <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"update"</span>, args = &#123;</span><br><span class="line">                MappedStatement.class, Object.class &#125;),</span><br><span class="line">        <span class="meta">@Signature</span>(type = Executor.class, method = <span class="string">"query"</span>, args = &#123;</span><br><span class="line">                MappedStatement.class, Object.class, RowBounds.class,</span><br><span class="line">                ResultHandler.class &#125;) &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RWDataSourceMybatisPlugin</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REGEX = <span class="string">".*insert\\u0020.*|.*delete\\u0020.*|.*update\\u0020.*"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RWDataSourceType&gt; cacheMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        Object[] objects = invocation.getArgs();</span><br><span class="line">        MappedStatement ms = (MappedStatement) objects[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        RWDataSourceType dataSourceType = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((dataSourceType = cacheMap.get(ms.getId())) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//读方法</span></span><br><span class="line">            <span class="keyword">if</span>(ms.getSqlCommandType().equals(SqlCommandType.SELECT)) &#123;</span><br><span class="line">                <span class="comment">//!selectKey 为自增id查询主键(SELECT LAST_INSERT_ID() )方法，使用主库</span></span><br><span class="line">                <span class="keyword">if</span>(ms.getId().contains(SelectKeyGenerator.SELECT_KEY_SUFFIX)) &#123;</span><br><span class="line">                    dataSourceType = RWDataSourceType.WRITE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    BoundSql boundSql = ms.getSqlSource().getBoundSql(objects[<span class="number">1</span>]);</span><br><span class="line">                    String sql = boundSql.getSql().toLowerCase().replaceAll(<span class="string">"[\\t\\n\\r]"</span>, <span class="string">" "</span>);</span><br><span class="line">                    <span class="keyword">if</span>(sql.matches(REGEX)) &#123;</span><br><span class="line">                        dataSourceType = RWDataSourceType.WRITE;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dataSourceType = RWDataSourceType.READ;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                dataSourceType = RWDataSourceType.WRITE;</span><br><span class="line">            &#125;</span><br><span class="line">            cacheMap.put(ms.getId(), dataSourceType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//修改当前线程要选择的数据源的key</span></span><br><span class="line">        RWDataSourceHolder.putDataSource(dataSourceType);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> invocation.proceed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">plugin</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target <span class="keyword">instanceof</span> Executor) &#123;</span><br><span class="line">            <span class="keyword">return</span> Plugin.wrap(target, <span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>最后在mybatis的配置文件里配置拦截插件就可以了,通过以上的步骤就实现了数据库读写分离的功能,有些步骤我省略了,有疑问的可以给我留言,<br>晚一点我把附件上传上来。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugin</span> <span class="attr">interceptor</span>=<span class="string">"RWDataSourceMybatisPlugin"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis 缓存介绍]]></title>
      <url>http://www.ezlippi.com/blog/2017/08/mybatis-cache.html</url>
      <content type="html"><![CDATA[<h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>一级缓存是本地缓存，和BaseExecutor关联,BaseExecutor有三个实现类，SimpleExecutor、ReuseExecutor和BatchExecutor,<br>SqlSession初始化时会创建Executor的实例，Mybatis默认使用的是SimpleExecutor,初始化代码如下所示:</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Configuration.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Executor <span class="title">newExecutor</span><span class="params">(Transaction transaction, ExecutorType executorType)</span> </span>&#123;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? defaultExecutorType : executorType;</span><br><span class="line">    executorType = executorType == <span class="keyword">null</span> ? ExecutorType.SIMPLE : executorType;</span><br><span class="line">    Executor executor;</span><br><span class="line">    <span class="keyword">if</span> (ExecutorType.BATCH == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> BatchExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ExecutorType.REUSE == executorType) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> ReuseExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> SimpleExecutor(<span class="keyword">this</span>, transaction);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果启用二级缓存,用CachingExecutor装饰类</span></span><br><span class="line">    <span class="keyword">if</span> (cacheEnabled) &#123;</span><br><span class="line">      executor = <span class="keyword">new</span> CachingExecutor(executor);</span><br><span class="line">    &#125;</span><br><span class="line">    executor = (Executor) interceptorChain.pluginAll(executor);</span><br><span class="line">    <span class="keyword">return</span> executor;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>BaseExecutor初始化时会初始化本地缓存，实现类为PerpetualCache，它的实现比较简单，里面就是一个HashMap来保存对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;Object, Object&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>一级缓存是SqlSession级别的缓存,在sqlSession提交时会清空本地缓存,因为commit操作一般对应插入、更新或者删除操作，清空缓存防止读取脏数据。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BaseExecutor.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">(<span class="keyword">boolean</span> required)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (closed) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> ExecutorException(<span class="string">"Cannot commit, transaction is already closed"</span>);</span><br><span class="line">&#125;</span><br><span class="line">clearLocalCache();</span><br><span class="line">flushStatements();</span><br><span class="line"><span class="keyword">if</span> (required) &#123;</span><br><span class="line">  transaction.commit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>如果用户在全局配置文件SqlMapConfig.xml或者mapper文件里配置了”cacheEnabled=true”，<br>如下所示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//SqlMapConfig.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">//UserMapper.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ezlippi.mybatis.mapper.UserMapper"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启本mapper namespace下的二级缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">cache</span></span><br><span class="line">  <span class="attr">eviction</span>=<span class="string">"FIFO"</span>//缓存过期策略,可以是<span class="attr">LRU</span>、<span class="attr">FIFO</span>、<span class="attr">SOFT</span>、<span class="attr">WEAK</span></span><br><span class="line">  <span class="attr">flushInterval</span>=<span class="string">"60000"</span>//缓存刷新间隔,除了语句刷新外到了这个时间间隔强制刷新</span><br><span class="line">  <span class="attr">size</span>=<span class="string">"512"</span></span><br><span class="line">  <span class="attr">readOnly</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>MyBatis在为SqlSession对象创建Executor对象时，会给Executor对象加上一个装饰者：CachingExecutor，这时SqlSession使用CachingExecutor对象来完成操作请求。CachingExecutor对于查询请求，会先判断该查询请求在二级缓存中是否有缓存，如果有则直接返回缓存结果；如果没有再交给真正的Executor对象来完成查询操作，之后CachingExecutor会将真正Executor返回的查询结果放置到缓存中，然后再返回给用户。</p>
<p>MyBatis的二级缓存是可以热插拔的，你可以用MyBatis自带的LRUCache、FIFOCache等，也可以用第三方的缓存库，比如Memcached或者EhCache,<br>二级缓存的作用域比一级缓存更广，作用域为一个Mapper的namespace,namaspace相同则使用同一个二级缓存区域，比如一个UserMapper类里面有SelectOne()<br>和selectList()两个查询操作，这两个操作共享同一个缓存区域。同一个Mapper的不同SqlSession可以共享一个二级缓存，如果任意一个sqlSession执行了commit()操作<br>则清空该namespace对应的二级缓存。</p>
<p>你还可以为每条Mapper语句设置是否要刷新缓存,可以指定select语句是否使用缓存,如下所示:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"false"</span> <span class="attr">useCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">...</span> <span class="attr">flushCache</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>这里需要注意的是:二级缓存需要查询结果映射的pojo对象实现Java.io.Serializable接口,如果存在父类、成员pojo都需要实现序列化接口。<br>最后贴一下CachingExecutor的查询语句:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">query</span><span class="params">(MappedStatement ms, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, CacheKey key, BoundSql boundSql)</span></span><br><span class="line">  <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"><span class="comment">//获取MapperStatement关联的Cache，和Mapper的Namespace相关联</span></span><br><span class="line">Cache cache = ms.getCache();</span><br><span class="line"><span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">   <span class="comment">//获取Mapper语句的flushCache配置</span></span><br><span class="line">  flushCacheIfRequired(ms);</span><br><span class="line">  <span class="keyword">if</span> (ms.isUseCache() &amp;&amp; resultHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ensureNoOutParams(ms, parameterObject, boundSql);</span><br><span class="line">    <span class="comment">//从TransactionalCacheManager获取缓存的对象</span></span><br><span class="line">    List&lt;E&gt; list = (List&lt;E&gt;) tcm.getObject(cache, key);</span><br><span class="line">    <span class="comment">//如果缓存中没有找到则调用实际的Executor执行查询语句,然后再更新缓存</span></span><br><span class="line">    <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">      list = delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">      tcm.putObject(cache, key, list); <span class="comment">// issue #578 and #116</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> delegate.&lt;E&gt; query(ms, parameterObject, rowBounds, resultHandler, key, boundSql);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[单元测试框架PowerMock教程]]></title>
      <url>http://www.ezlippi.com/blog/2017/08/powermock-introduction.html</url>
      <content type="html"><![CDATA[<p>Mockito 是一个针对 Java 的单元测试模拟框架，它与 EasyMock 和 jMock 很相似，都是为了简化单元测试过程中测试上下文的搭建而开发的工具。</p>
<p>PowerMock 也是一个单元测试模拟框架，它是在其它单元测试模拟框架的基础上做出的扩展。通过提供定制的类加载器以及一些字节码篡改技巧的应用，PowerMock 现了对静态方法、构造方法、私有方法以及 Final 方法的模拟支持，对静态初始化过程的移除等强大的功能。</p>
<a id="more"></a>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>对于使用PowerMock的测试类，需要添加注解:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br></pre></td></tr></table></figure></p>
<h3 id="模拟方法返回"><a href="#模拟方法返回" class="headerlink" title="模拟方法返回"></a>模拟方法返回</h3><p>首先对被测接口(类)进行mock，然后录制相关行为，假设你要测试的类为InterfaceToMock</p>
<p>//通过PowerMock创建一个虚拟对象<br>InterfaceToMock mock = Powermockito.mock(InterfaceToMock.class)<br>//value为你想要让这个method返回的值<br>Powermockito.when(mock.method(Params…)).thenReturn(valueToReturn)<br>//如果这个方法返回值为空，则上面的写法会报错,可采用下面的写法<br>Powermockito.when(mock, “methodName”, Object… params).thenReturn(valueToReturn)<br>// 也可以采用下面的写法，和上面的一样的效果<br>Powermockito.doReturn(valueToReturn).when(mock, “methodName”, Object… params)<br>//这样写也行，适合返回值为void的方法<br>Powermockito.doReturn(valueToReturn).when(mock).methodName(Object… params)<br>//你也可以让方法抛异常<br>Powermockito.when(mock.method(Params..)).thenThrow(new OMSException(“oms”))<br>//你可以让方法每一次返回的结果都不一样,下面的例子第一次正常返回，第二次调用抛异常<br>Powermockito.when(mock.method(Params..)).thenReturn(valueToReturn).thenThrow(new OMSException(“some Exception”))<br>//如果方法返回值为void,不能用thenReturn,要用doThing()<br>Powermockito.doNothing().when(mock.method(Params…))  </p>
<h3 id="模拟构造函数"><a href="#模拟构造函数" class="headerlink" title="模拟构造函数"></a>模拟构造函数</h3><p>模拟构造函数、私有方法、static方法、final方法都需要在测试类上添加注解PrepareForTest({被Mock的类})<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PrepareForTest</span>(&#123; InstanceClass.class &#125;)</span><br><span class="line"><span class="comment">//对于Mock构造函数的场景同时也需要把调用这个构造方法的那个类加到注解里去</span></span><br><span class="line"><span class="meta">@PrepareForTest</span>(&#123; InstanceClass.class,ClassA.class &#125;)</span><br></pre></td></tr></table></figure></p>
<p>对于模拟构造函数，也即当出现new InstanceClass()时可以将此构造函数拦截并替换结果为我们需要的mock对象。</p>
<p>注意：使用时需要加入标记：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(&#123; InstanceClass.class,A.class &#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConstructorMock</span></span>&#123;</span><br><span class="line"> <span class="meta">@Test</span>  </span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">testMock</span><span class="params">()</span></span>&#123;     </span><br><span class="line">    InstanceClass instanceToReturn = PowerMockito.mock(InstanceClass.class);</span><br><span class="line">    <span class="comment">//do something with instanceToReturn  </span></span><br><span class="line">   Powermockito.whenNew(InstanceClass.class).withArguments(Params...).</span><br><span class="line">       thenReturn(instanceToReturn);</span><br><span class="line">   <span class="comment">//或者匹配任何参数</span></span><br><span class="line">   Powermockito.whenNew(InstanceClass.class).withAnyArguments().</span><br><span class="line">        thenReturn(instanceToReturn);  </span><br><span class="line">   <span class="comment">//如果没有参数</span></span><br><span class="line">     Powermockito.whenNew(InstanceClass.class).withNoArguments().</span><br><span class="line">        thenReturn(instanceToReturn);  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>举个实际点的例子,下面的ClassA的myMethod方法会调用MyQueryClass的构造器，并调用getNextId方法，由于这个方法是在myMethod内部调用的，无法直接Mock，这时候需要Mock MyQueryClass的构造器，返回一个Mock的MyQueryClass并修改getNextId的默认行为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Class A &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">myMethod</span><span class="params">(someargs)</span> </span>&#123;</span><br><span class="line">    MyQueryClass query = <span class="keyword">new</span> MyQueryClass();</span><br><span class="line">    Long id = query.getNextId();</span><br><span class="line">    <span class="comment">// some more code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Class MyQueryClass     &#123;</span><br><span class="line">  ....</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Long <span class="title">getNextId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//lot of DB code, execute some DB query</span></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">//测试用例</span></span><br><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(&#123;MyQueryClass.class，A.class&#125;)  </span><br><span class="line">MyQueryClass query = PowerMockito.mock(MyQueryClass.class);</span><br><span class="line">PowerMockito.whenNew(MyQueryClass.class).withNoArguments().thenReturn(query);</span><br><span class="line">when(query.getNextId()).thenReturn(<span class="number">1000000L</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">boolean</span> b = A.getInstance().myMethod(args);</span><br></pre></td></tr></table></figure>
<h3 id="模拟静态方法"><a href="#模拟静态方法" class="headerlink" title="模拟静态方法"></a>模拟静态方法</h3><p>模拟静态方法类似于模拟构造函数，也需要加入注释标记。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"> <span class="meta">@PrepareForTest</span>(&#123; StaticClassToMock.class &#125;)</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConstructorMock</span></span>&#123;</span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="title">testMock</span><span class="params">()</span></span>&#123;  </span><br><span class="line">     <span class="comment">//模拟静态方法前需要调用这一句 </span></span><br><span class="line">     Powermockito.mockStatic(StaticClassToMock.class);</span><br><span class="line">     Powermockito.when(StaticClassToMock.method(Object.. params)).thenReturn(Object value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="模拟final方法"><a href="#模拟final方法" class="headerlink" title="模拟final方法"></a>模拟final方法</h3><p>Final方法的模拟类似于模拟静态方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"> <span class="meta">@PrepareForTest</span>(&#123; FinalClassToMock.class &#125;)</span><br><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestConstructorMock</span></span>&#123;</span><br><span class="line">     <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">testMock</span><span class="params">()</span></span>&#123; </span><br><span class="line">     FinalClassToMock mock = Powermockito.mock(FinalClassToMock.class);</span><br><span class="line">     Powermockito.when(mock.method(Object.. params)).thenReturn(Object value)</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="WhiteBox设置对象的属性、Invoke私有方法"><a href="#WhiteBox设置对象的属性、Invoke私有方法" class="headerlink" title="WhiteBox设置对象的属性、Invoke私有方法"></a>WhiteBox设置对象的属性、Invoke私有方法</h3><p>可以通过WhiteBox这个工具类来注入或者查看对象的私有属性以及Invoke对象的方法(包括私有方法)。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以设置private、static、final域的值,不需要添加到@PrepareForTest注解中</span></span><br><span class="line"><span class="comment">//设置对象的实例域 </span></span><br><span class="line">Whitebox.setInternalState(Object object, String fieldname, Object… value);</span><br><span class="line"><span class="comment">//设置类的静态属性 </span></span><br><span class="line">Whitebox.setInternalState(Class  clazz, String fieldname, Object… value); </span><br><span class="line"><span class="comment">//查看对象的属性</span></span><br><span class="line">Whitebox.getInternalState（Object obj, String fieldName）</span><br><span class="line"><span class="comment">//Invoke对象方法(包括private方法)</span></span><br><span class="line">WhiteBox.invokeMethod(Object obj, Object ... params)</span><br><span class="line"><span class="comment">//invoke静态方法（包括私有静态方法）</span></span><br><span class="line">WhiteBox.invokeMethod(Class clazz, Object ... params)     </span><br><span class="line">其中object为需要设置属性的对象，Class为需要为静态域设置属性的类。</span><br></pre></td></tr></table></figure></p>
<h3 id="使用spy方法避免执行某个类中的成员函数"><a href="#使用spy方法避免执行某个类中的成员函数" class="headerlink" title="使用spy方法避免执行某个类中的成员函数"></a>使用spy方法避免执行某个类中的成员函数</h3><p>如被测试类为：TargetClass，想要屏蔽的方法为targetMethod.</p>
<p>1）  PowerMockito.spy(TargetClass.class);</p>
<p>2）  Powemockito.when(TargetClass.targetMethod()).doReturn()</p>
<p>3）  注意加入<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"></span><br><span class="line"><span class="meta">@PrepareForTest</span>(TargetClass.class)</span><br></pre></td></tr></table></figure></p>
<h2 id="参数匹配器"><a href="#参数匹配器" class="headerlink" title="参数匹配器"></a>参数匹配器</h2><p>有时我们在处理doMethod(Param param)时，不想进行精确匹配，这时可以使用Mockito提供的模糊匹配方式。如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mockito.anyInt()，Mockito.anyString()，Mockito.any()</span><br></pre></td></tr></table></figure></p>
<p>举例说明：DataCenter的getCollectInfo()方法有三个String类型的参数，如果你想匹配所有的参数，可以这样写：</p>
<p>(如果能够精确匹配某个参数那就采用精确匹配)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PowerMockito.when(DataCenter.getCollectInfo(Mockito.anyString(), Mockito.anyString(), Mockito.anyString())).thenReturn(someObjectToReturn);</span><br></pre></td></tr></table></figure></p>
<h2 id="验证方法是否被执行"><a href="#验证方法是否被执行" class="headerlink" title="验证方法是否被执行"></a>验证方法是否被执行</h2><p>对于Mock出来的对象，你可以验证用例执行过程中该对象(类)的实例方法(静态方法)是否被调用，可以采用下面的写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//验证实例方法调用</span></span><br><span class="line"> PowerMockito.verify(object.method());</span><br><span class="line"><span class="comment">//验证静态方法被调用了一次 </span></span><br><span class="line">PowerMockito.verifyStatic( Mockito.times(<span class="number">1</span>)); </span><br><span class="line">InstanceClass.method();</span><br></pre></td></tr></table></figure>
<h2 id="Mockito进阶"><a href="#Mockito进阶" class="headerlink" title="Mockito进阶"></a>Mockito进阶</h2><h3 id="mock-方法的原理"><a href="#mock-方法的原理" class="headerlink" title="mock()方法的原理"></a>mock()方法的原理</h3><p>Mock的原理是通过CGLib动态代理创建了一个新的类，这个类继承自被测试类，包含了所有被测类的方法，但是里面不包含任何代码，只有返回值,对于没有Mock的那些方法返回值都是null；</p>
<p>Mock实例方法的场景利用了Java运行时多态的原理，通过重写父类的方法来修改某个方法的行为。</p>
<p>为什么那些Mock了构造方法、private方法、静态方法和final方法的场景需要添加@PrepareForTest注解呢?这是因为通过继承或者实现接口是无法修改父类的这些行为的，只能通过字节码修改(比如Javasist框架)来修改字节码。</p>
<h3 id="spy"><a href="#spy" class="headerlink" title="spy()"></a>spy()</h3><p>spy的作用是让被测类正常工作，但是可以拦截某些方法的返回值，比如有这样一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doStuff</span><span class="params">()</span></span>&#123;</span><br><span class="line">           System.out.println(<span class="string">"doStuff called"</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="number">42</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我想让doStuff方法的逻辑执行一遍，但是返回一个我期望的值(比如1)，那就可以用spy()，做法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Subject mock = PowerMockito.spy(<span class="keyword">new</span> Subject());</span><br><span class="line">    PowerMockito.when(mock.doStuff()).thenReturn(<span class="number">1</span>);</span><br><span class="line">    Assert.assertEquals(<span class="number">1</span>, mock.doStuff()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doStuff方法执行之后日志打印出来，返回值为1，运行结果如下：</p>
<p>doStuff called<br>Process finished with exit code 0 </p>
<h3 id="禁用非预期行为"><a href="#禁用非预期行为" class="headerlink" title="禁用非预期行为"></a>禁用非预期行为</h3><p>考虑如下的场景，调用子类构造器时会调用父类的构造器，但是父类的数据无法构造导致抛异常，这时候可以禁用父类的构造器来避免抛异常，举例说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseEntity</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseEntity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">performAudit</span><span class="params">(String auditInformation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">BaseEntity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> departmentId;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(<span class="keyword">int</span> departmentId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.departmentId = departmentId;</span><br><span class="line">    &#125;  </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">performAudit</span><span class="params">(String auditInformation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.performAudit(auditInformation);</span><br><span class="line">        <span class="comment">//doSomething()</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getDepartmentId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> departmentId;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常情况下new Department时会报UnsupportOperationException(),这时候可以用Mockito提供的功能来禁用父类构造器的调用，需要在被测类在添加注解SuppressStaticInitializationFor(“BaseEntity”),然后使用PowerMockito的suppress方法来禁止构造器或者方法的调用，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(PowerMockRunner.class)</span><br><span class="line"><span class="meta">@PrepareForTest</span>(&#123;Department.class&#125;)</span><br><span class="line"><span class="meta">@SuppressStaticInitializationFor</span>(<span class="string">"ezlippi.com.test.BaseEntity"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSupress</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PowerMockito.suppress(PowerMockito.constructor(BaseEntity.class));</span><br><span class="line">        Assert.assertEquals(<span class="number">10</span>, <span class="keyword">new</span> Department(<span class="number">10</span>).getDepartmentId());</span><br><span class="line">        PowerMockito.suppress(PowerMockito.method(BaseEntity.class, <span class="string">"performAudit"</span>, String.class));</span><br><span class="line">        Department department = <span class="keyword">new</span> Department(<span class="number">19</span>);</span><br><span class="line">        department.performAudit(<span class="string">"audit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[ElasticSearch Java客户端介绍]]></title>
      <url>http://www.ezlippi.com/blog/2017/03/elasticsearch-java-client.html</url>
      <content type="html"><![CDATA[<p>这篇文章主要介绍ElasticSearch客户端，包括Transport客户端、Jest客户端和Spring Data ElasticSearch,首先来看几个基本概念。</p>
<h2 id="ElasticSearch"><a href="#ElasticSearch" class="headerlink" title="ElasticSearch"></a>ElasticSearch</h2><p>官方的介绍:</p>
<pre><code>ElasticSearch是一个分布式的、基于Json的检索引擎，具有水平扩展、高可靠性和易于管理等优点。
</code></pre><p>为了更好的理解ealsticsearch的作用，我们可以看下Github的搜索页面:</p>
<p><img src="/images/elasticsearch_github.png" alt=""></p>
<p>我们在输入框输入一个单词，会列出许多查询结果，搜索引擎和数据库的区别就是相关性，<br>我们可以看到elasticsearch的项目排在第一位，很有可能别人在搜索这个关键词时想要访问这个项目。对于不同的应用影响排名的因素可能各不一样。</p>
<p>如果你想建立一个像这样的搜索引擎，首先你的安装elasticsearch,elasticsearch很容易安装，你只需要先安装好Java虚拟机就可以了。</p>
<a id="more"></a>
<h2 id="安装和使用ElasticSearch"><a href="#安装和使用ElasticSearch" class="headerlink" title="安装和使用ElasticSearch"></a>安装和使用ElasticSearch</h2><p>ElasticSearch默认绑定9200端口，你可以通过<a href="http://localhost:9200来访问，你也可以用命令行客户端来执行HTTP请求，这里我用curl来执行" target="_blank" rel="external">http://localhost:9200来访问，你也可以用命令行客户端来执行HTTP请求，这里我用curl来执行</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.0.0.zip</span><br><span class="line">unzip elasticsearch-5.0.0.zip</span><br><span class="line"></span><br><span class="line">elasticsearch-5.0.0/bin/elasticsearch</span><br><span class="line"></span><br><span class="line">curl -XGET <span class="string">"http://localhost:9200"</span></span><br></pre></td></tr></table></figure>
<p>你会收到一个Json Document响应，这个响应包含ElasticSearch的安装信息,如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  "name" : "LI8ZN-t",</span><br><span class="line">  "cluster_name" : "elasticsearch",</span><br><span class="line">  "cluster_uuid" : "UvbMAoJ8TieUqugCGw7Xrw",</span><br><span class="line">  "version" : &#123;</span><br><span class="line">    "number" : "5.0.0",</span><br><span class="line">    "build_hash" : "253032b",</span><br><span class="line">    "build_date" : "2016-10-26T04:37:51.531Z",</span><br><span class="line">    "build_snapshot" : false,</span><br><span class="line">    "lucene_version" : "6.2.0"</span><br><span class="line">  &#125;,</span><br><span class="line">  "tagline" : "You Know, for Search"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的信息就是服务器已经启动成功，还包括ElasticSearch和Lucene的版本信息,Lucene是整个搜索功能的核心库。</p>
<p>现在我们开始给ElasticSearch发送一个Json文档来存储数据，这时候我们要用POST请求，这里我就以一个食物搜索系统为例来讲解怎么添加数据到索引。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST "http://localhost:9200/food/dish" -d'</span><br><span class="line">&#123;</span><br><span class="line">  "food": "Hainanese Chicken Rice",</span><br><span class="line">  "tags": ["chicken", "rice"],</span><br><span class="line">  "favorite": &#123;</span><br><span class="line">    "location": "Tian Tian",</span><br><span class="line">    "price": 5.00</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>我们还是用之前的端口，这时候我们加了两个字段在URL后面，food和dish，第一个是索引(index)的名称,这是所有文档的集合，第二个是类型(type)，相当于关系型数据库里的表。</p>
<p>Dish用文档来建模，Elasticsearch支持多种数据类型,比如string,boolean,数值类型numerics以及嵌套的数据类型，比如上面的favorite。</p>
<p>接下来我们再通过一个POST请求添加一个文档:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST "http://localhost:9200/food/dish" -d'</span><br><span class="line">&#123;</span><br><span class="line">  "food": "Ayam Penyet",</span><br><span class="line">  "tags": ["chicken", "indonesian"],</span><br><span class="line">  "spicy": true</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>这一次文档的结构有啥不同，它没有包含faorite元素，但添加了另一个spicy属性。同个类型的文档可能差异很大。</p>
<p>建立索引之后，我们就可以来搜索关键字了。我们可以在链接的后面加一个_search，然后添加一个查询参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -XGET <span class="string">"http://localhost:9200/food/dish/_search?q=chicken"</span></span><br></pre></td></tr></table></figure>
<p>这个请求在dish类型里搜索包含chicken字段的文档，结果如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;"took":57,"timed_out":false,"_shards":&#123;"total":5,"successful":5,"failed":0&#125;,"hits":&#123;"total":2,"max_score":0.3666863,"hits":[&#123;"_index":"food","_type":"dish","_id":"AVq9cnkMZAUVR2HS07Sa","_score":0.3666863,"_source":</span><br><span class="line">&#123;</span><br><span class="line">  "food": "Hainanese Chicken Rice",</span><br><span class="line">  "tags": ["chicken", "rice"],</span><br><span class="line">  "favorite": &#123;</span><br><span class="line">    "location": "Tian Tian",</span><br><span class="line">    "price": 5.00</span><br><span class="line">  &#125;</span><br><span class="line">&#125;&#125;,&#123;"_index":"food","_type":"dish","_id":"AVq9cqoiZAUVR2HS07Sb","_score":0.2876821,"_source":</span><br><span class="line">&#123;</span><br><span class="line">  "food": "Ayam Penyet",</span><br><span class="line">  "tags": ["chicken", "indonesian"],</span><br><span class="line">  "spicy": true</span><br><span class="line">&#125;&#125;]&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>搜索结果包含了找到文档的数量，最重要的属性是hits数组，这里面包含索引到的source原始数据。Elasticsearch提供基于JSON结构的查询DSL，如下所示:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST "http://localhost:9200/food/dish/_search" -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": &#123;</span><br><span class="line">      "match": &#123;</span><br><span class="line">        "_all": "rice"</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "filter": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "tags.keyword": "chicken"</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>上面这个JSON是在搜索包含rice字段以及tags字段里有chicken的文档，elasticsearch 5.0提供了.keyword字段来精确查询。</p>
<p>到目前为止我们只访问了单个ElasticSearch实例,ElasticSearch具有水平伸缩的特性，我们可以添加更多的node，我们仍然可以连接第一个node,它可以将请求转发到集群中的其他节点。</p>
<h2 id="ElasticSearch客户端介绍"><a href="#ElasticSearch客户端介绍" class="headerlink" title="ElasticSearch客户端介绍"></a>ElasticSearch客户端介绍</h2><h3 id="Transport客户端"><a href="#Transport客户端" class="headerlink" title="Transport客户端"></a>Transport客户端</h3><p>Transport客户端从ElasticSearch第一个版本就有了，也是使用最广泛的客户端，使用它需要在你的构建工具中添加依赖，我这里用的Gradle：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'org.elasticsearch.client'</span>,</span><br><span class="line">        name: <span class="string">'transport'</span>,</span><br><span class="line">        version: <span class="string">'5.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过客户端你可以使用ElasticSearch的所有功能，你可以通过Settings对象来初始化一个TransportClient实例，你可以绑定多个节点的地址:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TransportAddress address =</span><br><span class="line">    <span class="keyword">new</span> InetSocketTransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9300</span>);</span><br><span class="line"></span><br><span class="line">Client client = <span class="keyword">new</span> PreBuiltTransportClient(Settings.EMPTY)</span><br><span class="line">    addTransportAddress(address);</span><br></pre></td></tr></table></figure>
<h3 id="查询接口"><a href="#查询接口" class="headerlink" title="查询接口"></a>查询接口</h3><p>对于之前的那条查询:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">curl -XPOST "http://localhost:9200/food/dish/_search" -d'</span><br><span class="line">&#123;</span><br><span class="line">  "query": &#123;</span><br><span class="line">    "bool": &#123;</span><br><span class="line">      "must": &#123;</span><br><span class="line">      "match": &#123;</span><br><span class="line">        "_all": "rice"</span><br><span class="line">      &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      "filter": &#123;</span><br><span class="line">    "term": &#123;</span><br><span class="line">      "tags.keyword": "chicken"</span><br><span class="line">    &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;'</span><br></pre></td></tr></table></figure>
<p>我们将它转换成Java代码:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SearchResponse searchResponse = client</span><br><span class="line">   .prepareSearch(<span class="string">"food"</span>)</span><br><span class="line">   .setQuery(</span><br><span class="line">    boolQuery().</span><br><span class="line">      must(matchQuery(<span class="string">"_all"</span>, <span class="string">"rice"</span>)).</span><br><span class="line">      filter(termQuery(<span class="string">"tags.keyword"</span>, <span class="string">"chicken"</span>)))</span><br><span class="line">   .execute().actionGet();</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="number">1</span>, searchResponse.getHits().getTotalHits());</span><br><span class="line"></span><br><span class="line">SearchHit hit = searchResponse.getHits().getAt(<span class="number">0</span>);</span><br><span class="line">String food = hit.getSource().get(<span class="string">"food"</span>).toString();</span><br></pre></td></tr></table></figure>
<p>我这里调用prepareSearch来请求SearchSourceBuilder，然后我们可以通过静态帮助方法来设置一个查询，上面这个例子用的是bool查询，这个查询的must节点有个match查询，filter节点有个term查询。</p>
<p>调用execute方法会返回一个future对象，actionGet是个阻塞调用，SearchResponse的结果和我们用HTTP访问的结果是等价的。</p>
<h3 id="添加索引接口"><a href="#添加索引接口" class="headerlink" title="添加索引接口"></a>添加索引接口</h3><p>我们可以用不同的方法来添加索引，其中之一就是使用jsonBuilder来创建一个Json表达式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">XContentBuilder builder = jsonBuilder()</span><br><span class="line">    .startObject()</span><br><span class="line">        .field(<span class="string">"food"</span>, <span class="string">"Roti Prata"</span>)</span><br><span class="line">        .array(<span class="string">"tags"</span>, <span class="keyword">new</span> String [] &#123;<span class="string">"curry"</span>&#125;)</span><br><span class="line">        .startObject(<span class="string">"favorite"</span>)</span><br><span class="line">        .field(<span class="string">"location"</span>, <span class="string">"Tiong Bahru"</span>)</span><br><span class="line">        .field(<span class="string">"price"</span>, <span class="number">2.00</span>)</span><br><span class="line">        .endObject()</span><br><span class="line">    .endObject();</span><br></pre></td></tr></table></figure>
<p>上面的表达式使用不同的method来创建JSON文档，这个文档可以作为IndexRequest的source：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IndexResponse resp = client.prepareIndex(<span class="string">"food"</span>,<span class="string">"dish"</span>)</span><br><span class="line">        .setSource(builder)</span><br><span class="line">        .execute()</span><br><span class="line">        .actionGet();</span><br></pre></td></tr></table></figure>
<p>除了使用jsonBuilder我们还可以用其他的选项，如下所示:</p>
<p><img src="/images/indexing source.png" alt=""></p>
<p>对于比较简单的数据结构你可以使用Map来构造数据，可以结合序列化插件入jackson来完成对象的序列化。</p>
<p>从前面的例子我们可以看到Transport客户端接收一个或多个节点的地址，你可能注意到这里用的是9300而不是9200端口，因为Transport客户端不使用HTTP来通信，它内部通过传输层协议来通信。</p>
<p>前面只连接了一个节点，一旦这个节点挂了我们就不能访问数据了，如果你需要高可用性你可以启用sniffing选项来允许你的客户端连接集群中的其他节点,只需要把client.transport.sniff选项为true即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TransportAddress address =</span><br><span class="line">    <span class="keyword">new</span> InetSocketTransportAddress(</span><br><span class="line">        InetAddress.getByName(<span class="string">"localhost"</span>), <span class="number">9300</span>);</span><br><span class="line"></span><br><span class="line">Settings settings = Settings.builder()</span><br><span class="line">            .put(<span class="string">"client.transport.sniff"</span>, <span class="keyword">true</span>)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">Client client = <span class="keyword">new</span> PreBuiltTransportClient(settings)</span><br><span class="line">    addTransportAddress(address);</span><br></pre></td></tr></table></figure>
<p>更多关于sniffing特性可以参考elasticsearch的官方文档:<a href="https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html" target="_blank" rel="external">https://www.elastic.co/guide/en/elasticsearch/client/java-api/current/transport-client.html</a></p>
<h2 id="Jest客户端"><a href="#Jest客户端" class="headerlink" title="Jest客户端"></a>Jest客户端</h2><p>jest客户端能够发送请求给ElasticSearch，首先添加依赖:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'io.searchbox'</span>,</span><br><span class="line">        name: <span class="string">'jest'</span>,</span><br><span class="line">        version: <span class="string">'2.0.0'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以用过工厂方法来创建一个JestClient:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JestClientFactory factory = <span class="keyword">new</span> JestClientFactory();</span><br><span class="line">factory.setHttpClientConfig(<span class="keyword">new</span> HttpClientConfig</span><br><span class="line">            .Builder(<span class="string">"http://localhost:9200"</span>)</span><br><span class="line">            .multiThreaded(<span class="keyword">true</span>)</span><br><span class="line">            .build());</span><br><span class="line"></span><br><span class="line">JestClient client = factory.getObject();</span><br></pre></td></tr></table></figure>
<p>和普通的Rest客户端一样，Jest不支持生成查询，你可以使用string模板或者复用ElasticSearch builders，builder可以用来创建搜索请求:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String query = jsonStringThatMagicallyAppears;</span><br><span class="line"></span><br><span class="line">Search search = <span class="keyword">new</span> Search.Builder(query)</span><br><span class="line">    .addIndex(<span class="string">"library"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">SearchResult result = client.execute(search);</span><br><span class="line">assertEquals(Integer.valueOf(<span class="number">1</span>), result.getTotal());</span><br></pre></td></tr></table></figure>
<p>获取查询结果:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JsonObject jsonObject = result.getJsonObject();</span><br><span class="line">JsonObject hitsObj = jsonObject.getAsJsonObject(<span class="string">"hits"</span>);</span><br><span class="line">JsonArray hits = hitsObj.getAsJsonArray(<span class="string">"hits"</span>);</span><br><span class="line">JsonObject hit = hits.get(<span class="number">0</span>).getAsJsonObject();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... more boring code</span></span><br></pre></td></tr></table></figure>
<p>上面这个不是正常使用Jest的方法，Jest支持搜索和索引Java Bean，比如说我用下面这个Java Bean来表示Dish类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String food;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; tags;</span><br><span class="line">    <span class="keyword">private</span> Favorite favorite;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@JestId</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// ... getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以自动将查询结果转换成Dish对象:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Dish dish = result.getFirstHit(Dish.class).source;</span><br><span class="line"></span><br><span class="line">assertEquals(<span class="string">"Roti Prata"</span>, dish.getFood());</span><br></pre></td></tr></table></figure>
<p>当通过HTTP来访问ElasticSearch时Jest是个不错的选择。</p>
<h2 id="Spring-Data-ElasticSearch"><a href="#Spring-Data-ElasticSearch" class="headerlink" title="Spring Data ElasticSearch"></a>Spring Data ElasticSearch</h2><p>Spring Data项目提供了通用的编程模型来访问不同的数据源，吸引人的特性是Spring Data允许你使用接口来定义查询，比如比较流行的用来访问关系型数据库的Spring Data JPA以及Spring Data MongoDB。</p>
<p>首先添加依赖:</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">group</span>: <span class="string">'org.springframework.data'</span>,</span><br><span class="line">    name: <span class="string">'spring-data-elasticsearch'</span>,</span><br><span class="line">    version: <span class="string">'2.0.4.RELEASE'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用自定义注解来表示要索引的文档:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Document</span>(indexName = <span class="string">"spring_dish"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String food;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; tags;</span><br><span class="line">    <span class="keyword">private</span> Favorite favorite;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// more code</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以定义一个接口来访问文档，这里使用ElasticsearchCrudRepository，它提供通用的索引和查询操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DishRepository</span> </span><br><span class="line">  <span class="keyword">extends</span> <span class="title">ElasticsearchCrudRepository</span>&lt;<span class="title">Dish</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring Data ElasticSearch支持XML配置:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">elasticsearch:transport-client</span> <span class="attr">id</span>=<span class="string">"client"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"elasticsearchTemplate"</span> </span><br><span class="line">  <span class="attr">class</span>=<span class="string">"o.s.d.elasticsearch.core.ElasticsearchTemplate"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"client"</span> <span class="attr">ref</span>=<span class="string">"client"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">elasticsearch:repositories</span> </span><br><span class="line">  <span class="attr">base-package</span>=<span class="string">"ezlippi.elasticsearch.springdata"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>transport-client用于实例化transport客户端，elasticsearchTemplate提供访问ElasticSearch的通用操作，最后repositories元素告诉Spring Data扫描继承自Spring Data接口的接口，Spring会自动为这些接口创建实例。</p>
<p>接下来就可以在Java代码中使用repository来执行索引操作:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Dish mie = <span class="keyword">new</span> Dish();</span><br><span class="line">mie.setId(<span class="string">"hokkien-prawn-mie"</span>);</span><br><span class="line">mie.setFood(<span class="string">"Hokkien Prawn Mie"</span>);</span><br><span class="line">mie.setTags(Arrays.asList(<span class="string">"noodles"</span>, <span class="string">"prawn"</span>));</span><br><span class="line"></span><br><span class="line">repository.save(Arrays.asList(hokkienPrawnMie));</span><br><span class="line"></span><br><span class="line"><span class="comment">// one line ommited</span></span><br><span class="line"></span><br><span class="line">Iterable&lt;Dish&gt; dishes = repository.findAll();</span><br><span class="line"></span><br><span class="line">Dish dish = repository.findOne(<span class="string">"hokkien-prawn-mie"</span>);</span><br></pre></td></tr></table></figure>
<p>根据ID来查询文档没什么意思，你可以添加更多方法到你的接口里:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DishRepository</span> </span><br><span class="line">  <span class="keyword">extends</span> <span class="title">ElasticsearchCrudRepository</span>&lt;<span class="title">Dish</span>, <span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Dish&gt; <span class="title">findByFood</span><span class="params">(String food)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Dish&gt; <span class="title">findByTagsAndFavoriteLocation</span><span class="params">(String tag, String location)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Dish&gt; <span class="title">findByFavoritePriceLessThan</span><span class="params">(Double price)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query</span>(<span class="string">"&#123;\"query\": &#123;\"match_all\": &#123;&#125;&#125;&#125;"</span>)</span><br><span class="line">    <span class="function">List&lt;Dish&gt; <span class="title">customFindAll</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大部分方法都是以findBy+属性名开头，比如findByFood会查询food属性，结构化查询也是支持的，比如上面的lessThan，上面这个接口会查询比给定价格少的dishes,最后这个查询使用不同的方式，可以使用Query注解来添加查询。</p>
<p>更多关于Spring Data ElasticSearch的知识可以参考Spring的文档:<a href="http://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#project" target="_blank" rel="external">http://docs.spring.io/spring-data/elasticsearch/docs/current/reference/html/#project</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>上面介绍了几种常用的ElasticSearch Java客户端，可以针对实际使用场景来选择。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[MyBatis教程]]></title>
      <url>http://www.ezlippi.com/blog/2017/02/mybatis-intorduction.html</url>
      <content type="html"><![CDATA[<p>MyBatis是一个优秀的ORM(对象关系映射)框架，和Hibernate不太一样，Hibernate不用你编写一行SQL语句，而MyBatis需要手写SQL语句，优点就是能够灵活调试SQL语句。这篇文章主要对MyBatis的几个核心概念进行介绍，以及如何在项目中使用MyBatis。<br><a id="more"></a></p>
<h2 id="MyBatis底层原理"><a href="#MyBatis底层原理" class="headerlink" title="MyBatis底层原理"></a>MyBatis底层原理</h2><p>MyBatis底层还是依赖JDBC来操作数据库，不过对JDBC的语法进行了封装，使用JDBC来操作数据库的流程一般是加载JDBC驱动-&gt;创建JDBC连接-&gt;创建Statement-&gt;执行查询-&gt;解析ResultSet-&gt;异常处理-&gt;关闭Statement和Connection，如果每次都这样做就比较繁琐。</p>
<p>MyBatis所有的数据库操作都是在SqlSession中操作，这样的话就可以缓存查询结果、不用重复创建JDBC连接。</p>
<h2 id="MyBatis核心概念"><a href="#MyBatis核心概念" class="headerlink" title="MyBatis核心概念"></a>MyBatis核心概念</h2><h3 id="SqlSessionFactoryBuilder"><a href="#SqlSessionFactoryBuilder" class="headerlink" title="SqlSessionFactoryBuilder"></a>SqlSessionFactoryBuilder</h3><p>顾名思义就是采用了Builder模式，用于创建SqlSessionFactory对象。</p>
<h3 id="SqlSessionFactory"><a href="#SqlSessionFactory" class="headerlink" title="SqlSessionFactory"></a>SqlSessionFactory</h3><p>SqlSessionFactory工厂方法，用于创建SqlSession。</p>
<h3 id="SqlSession"><a href="#SqlSession" class="headerlink" title="SqlSession"></a>SqlSession</h3><p>SqlSession 的实例不是线程安全的,每个线程都应该有它自己的SqlSession 实例，应该随着HttpServletRequest的创建而创建，请求结束则销毁。</p>
<h3 id="Mapper"><a href="#Mapper" class="headerlink" title="Mapper"></a>Mapper</h3><p>承载了实际的业务逻辑，其生命周期比较短，由SqlSession创建,用于将Java对象和实际的SQL语句对应起来。</p>
<h2 id="Spring环境下Mybatis初始化过程"><a href="#Spring环境下Mybatis初始化过程" class="headerlink" title="Spring环境下Mybatis初始化过程"></a>Spring环境下Mybatis初始化过程</h2><p>在开发过程中通常结合Spring框架一起使用提高开发效率，由于Spring进行了控制反转，所以其中MyBatis的初始化过程和正常过程稍稍有些不同：</p>
<p>Spring框架会在classpath下找到MyBatis的核心配置文件，使用它来初始化一个SqlSessionFactory实例。mapper类也会作为bean注入到代码中去的，Spring会使用上一步创建的SqlSessionFactory实例来创建SqlSession的实例，然后再使用SqlSession尝试创建各个mapper对象。</p>
<p>于此同时，MyBatis会扫描classpath下的mapper映射XML文件（此路径可以自定义），对于每一个mapper接口，它的「类全名」会作为命名空间，来和映射文件中的mapper标签进行匹配。<br>对于每一个映射文件中的一个执行语句标签（如select、delete），MyBatis会把他们映射到SqlSession的方法上，创建mapper接口的一个实现类。<br>如果mapper接口和其映射文件一一匹配，则bean创建成功。</p>
<h2 id="Mapper文件举例"><a href="#Mapper文件举例" class="headerlink" title="Mapper文件举例"></a>Mapper文件举例</h2><p>下面的例子中首先创建了一个id为BaseResultMap的ResultMap，和Java模型数据的User相对应，并声明了数据库中列和模型的属性之间的对应关系，后面的Select语句可以引用这个ResultMap作为方法的返回值。然后创建了一个Base_Column_List的SQL语句，后面可以通过refid来引用这个SQL。具体的用法可以参考<a href="http://www.mybatis.org/mybatis-3/zh/java-api.html" target="_blank" rel="external">MyBatis文档</a></p>
<p>需要注意的是下面中的各个select、insert、update、delete的id需要和实际的com.ezlippi.mapper.UserMapper类中的方法一一对应。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.ezlippi.mapper.UserMapper"</span> &gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">&lt;!--定义了Select语句返回结果和实际POJO对象的属性映射关系--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"BaseResultMap"</span> <span class="attr">type</span>=<span class="string">"com.ezlippi.model.User"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span> <span class="attr">jdbcType</span>=<span class="string">"BIGINT"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"userName"</span> <span class="attr">property</span>=<span class="string">"userName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"passWord"</span> <span class="attr">property</span>=<span class="string">"passWord"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"user_sex"</span> <span class="attr">property</span>=<span class="string">"userSex"</span> <span class="attr">javaType</span>=<span class="string">"com.ezlippi.enums.UserSexEnum"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"nick_name"</span> <span class="attr">property</span>=<span class="string">"nickName"</span> <span class="attr">jdbcType</span>=<span class="string">"VARCHAR"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 定义了一条SQL语句模板，后面可以通过&lt;include refid="Base_Column_List"/&gt;引用这条SQL --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"Base_Column_List"</span> &gt;</span></span><br><span class="line">        id, userName, passWord, user_sex, nick_name</span><br><span class="line">    <span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getAll"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span>  &gt;</span></span><br><span class="line">       SELECT </span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">       FROM users</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getOne"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span> <span class="attr">resultMap</span>=<span class="string">"BaseResultMap"</span> &gt;</span></span><br><span class="line">        SELECT </span><br><span class="line">       <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"Base_Column_List"</span> /&gt;</span></span><br><span class="line">       FROM users</span><br><span class="line">       WHERE id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"insert"</span> <span class="attr">parameterType</span>=<span class="string">"com.ezlippi.model.User"</span> &gt;</span></span><br><span class="line">       INSERT INTO </span><br><span class="line">               users</span><br><span class="line">               (userName,passWord,user_sex) </span><br><span class="line">           VALUES</span><br><span class="line">               (#&#123;userName&#125;, #&#123;passWord&#125;, #&#123;userSex&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"update"</span> <span class="attr">parameterType</span>=<span class="string">"com.ezlippi.model.User"</span> &gt;</span></span><br><span class="line">       UPDATE </span><br><span class="line">               users </span><br><span class="line">       SET </span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"userName != null"</span>&gt;</span>userName = #&#123;userName&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"passWord != null"</span>&gt;</span>passWord = #&#123;passWord&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">           nick_name = #&#123;nickName&#125;</span><br><span class="line">       WHERE </span><br><span class="line">               id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"delete"</span> <span class="attr">parameterType</span>=<span class="string">"java.lang.Long"</span> &gt;</span></span><br><span class="line">       DELETE FROM</span><br><span class="line">                users </span><br><span class="line">       WHERE </span><br><span class="line">                id =#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="和-的区别"><a href="#和-的区别" class="headerlink" title="#{}和${}的区别"></a>#{}和${}的区别</h3><p>在拼接SQL语句中可以用”#{}”和”${}”来引用方法中的参数,两者的区别如下:</p>
<p>“#{}”在底层实现上使用?做占位符来生成PreparedStatement，然后将参数传入，大多数情况都应使用这个，它更快、更安全。</p>
<p>“${}”将传入的数据直接显示生成在sql中。如：order by ${user_id}，如果传入的值是111,那么解析</p>
<h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="php"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.2.xsd"</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 加载配置文件 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">"classpath:jdbc.properties"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置dbcp数据源 引用jdbc.peoperties属性文件中的属性--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;connection_pools.initial_pool_size&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;connection_pools.min_pool_size&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span> <span class="attr">value</span>=<span class="string">"$&#123;connection_pools.max_pool_size&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span> <span class="attr">value</span>=<span class="string">"$&#123;connection_pools.max_idle_time&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span> <span class="attr">value</span>=<span class="string">"$&#123;connection_pools.acquire_increment&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span> <span class="attr">value</span>=<span class="string">"$&#123;connection_pools.checkout_timeout&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置mybatisSqlSessionFactoryBean --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis/mybatis.xml"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mapperLocations"</span> <span class="attr">value</span>=<span class="string">"classpath*:com/ezlippi/**/*Mapper.xml"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 配置SqlSessionTemplate --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionTemplate"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionTemplate"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">ref</span>=<span class="string">"sqlSessionFactory"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- mapper批量扫描，从mapper包中扫描出mapper接口，自动创建代理对象并且在spring容器中注册 </span><br><span class="line">	遵循规范：将mapper.java和mapper.xml映射文件名称保持一致，且在一个目录 中</span><br><span class="line">	自动扫描出来的mapper的bean的id为mapper类名（首字母小写）</span><br><span class="line">	--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.ezlippi.**.dao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionTemplateBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionTemplate"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 事务配置 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 使用annotation注解方式配置事务 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>/&gt;</span>  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.ezlippi"</span> /&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">context:annotation-config</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中如下代码为spring自扫描所有dao包并把其下的所有mybatis接口文件装配入容器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"com.ezlippi.**.dao"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"sqlSessionTemplateBeanName"</span> <span class="attr">value</span>=<span class="string">"sqlSessionTemplate"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mybatis配置文件mybatis.xml如下，主要配置一些alias：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Integer"</span> <span class="attr">type</span>=<span class="string">"java.lang.Integer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Long"</span> <span class="attr">type</span>=<span class="string">"java.lang.Long"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"HashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.HashMap"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedHashMap"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedHashMap"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"ArrayList"</span> <span class="attr">type</span>=<span class="string">"java.util.ArrayList"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"LinkedList"</span> <span class="attr">type</span>=<span class="string">"java.util.LinkedList"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>mybatis接口mapper需要加@Repository注解，方可直接在Service层直接自动装配注入。 mybatis接口mapper举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function">List&lt;User&gt; <span class="title">getAll</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">User <span class="title">getOne</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">delete</span><span class="params">(Long id)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Service层注入mybatis接口mapper的时候需要在构造方法中注入，这样注入mapper实例才不会空。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span>(value = <span class="string">"userService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> UserMapper mapper;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">UserServiceImpl</span><span class="params">(UserMapper userMapper)</span> </span>&#123;</span><br><span class="line">    	<span class="keyword">this</span>.mapper = userMapper;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">selectAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> userMapper.selectAll();</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这里，可能会有一个疑问，上面我只声明了UserMapper接口，没有定义实现类怎么调用具体的方法呢，别担心，mybatis通过JDK的动态代理方式，在启动加载配置文件时，根据配置mapper的xml去生成Dao的实现。<br>session.getMapper()使用了代理，当调用一次此方法，都会产生一个代理class的instance。</p>
<p>最后就是UserControl类了，调用UserService来完成具体的业务逻辑，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControl</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@RequestMapping</span>(<span class="string">"/users/all"</span>)</span><br><span class="line">	<span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  		<span class="keyword">return</span> userService.selectAll();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[SED教程]]></title>
      <url>http://www.ezlippi.com/blog/2017/02/sed-introduction.html</url>
      <content type="html"><![CDATA[<p>SED是一个简单强大的文本处理工具，作为标准命令被收集到UNIX系的OS中，它将指定的文本逐行读入，根据给定的条件进行处理。把sed当做单行脚本使用，紧跟着-e选项，就能把处理的内容作为脚本记述下来，如果用-f选项，就可以读取事先准备的脚本文件。<br><a id="more"></a></p>
<p> 一个简单的例子,下面的这条命令用于把input.txt中的每一行中的aaa替换成bbb,”g”表示全局替换，如果没有”g”则只替换第一次匹配到的结果。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'s/aaa/bbb/g'</span> input.txt &gt; output.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="sed的用法"><a href="#sed的用法" class="headerlink" title="sed的用法"></a>sed的用法</h3><h4 id="s命令-字符串替换"><a href="#s命令-字符串替换" class="headerlink" title="s命令(字符串替换)"></a>s命令(字符串替换)</h4><p>s命令用于把某个字符串替换成别的字符串，基本格式如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'s/原字符串/替换后的字符串/标志'</span> 输入.txt</span><br></pre></td></tr></table></figure>
<p>替换后的字符串省略时表示删除匹配的字符串，原字符串中含有”/“时，需要用”\”进行转义处理，也可以在”s”后面指定其他的分隔符，如下这条命令用于把/usr/local替换成很/usr:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'s!/usr/local!/usr!g'</span> 输入.txt</span><br></pre></td></tr></table></figure>
<p>替换后的字符串中可以用”&amp;”符号来引用匹配到的字符串，比如下面这个例子中与”.*”匹配的字符串可以用”&amp;”来引用，下面这个例子是在每行的前面加上”output”:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'s/.*/output&amp;/g'</span> input.txt</span><br></pre></td></tr></table></figure>
<p>比如input.txt的内容为aaa bbb ccc,上一条命令的输出为</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">output aaa bbb ccc</span><br></pre></td></tr></table></figure>
<p>sed默认会把替换后的结果输出来标准输出，可以加上-n命令来取消这个输出，如下所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -n <span class="_">-e</span> <span class="string">'s/aaa/AAA/g'</span> a.txt</span><br></pre></td></tr></table></figure>
<p>如果想把替换后的结果写入到文件中，可以使用w命令，你可以用多一个-e来执行多个命令，或者在多个命令之间用分号分隔:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'s/aaa/AAA/g'</span> <span class="_">-e</span> <span class="string">'w b.txt'</span> a.txt</span><br><span class="line">$ sed <span class="_">-e</span> <span class="string">'s/aaa/AAA/g;w b.txt'</span> a.txt</span><br></pre></td></tr></table></figure>
<h4 id="y命令-替换1个字符"><a href="#y命令-替换1个字符" class="headerlink" title="y命令(替换1个字符)"></a>y命令(替换1个字符)</h4><p>当希望把某个字符替换成另一个字符时可以用y命令，可以指定多个字符，比如’y/abc/xyz’命令用于把a-&gt;x,b-&gt;y,c-&gt;z,如下所示:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'y/abc/xyz/g'</span> <span class="_">-e</span> <span class="string">'w b.txt'</span> a.txt</span><br></pre></td></tr></table></figure>
<h4 id="d命令-删除"><a href="#d命令-删除" class="headerlink" title="d命令(删除)"></a>d命令(删除)</h4><p>d命令用于删除指定行，比如’1,2d’用于删除1~2行，’2,$d’用于删除第二行开始所有的行</p>
<h3 id="文件输出"><a href="#文件输出" class="headerlink" title="文件输出"></a>文件输出</h3><p>除了可以用”&gt;”重定向到文件，或者用’w’命令写文件，还可以用-i选项将处理结果覆盖到源文件中，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed -i <span class="_">-e</span> <span class="string">'s/aaa/AAA/g'</span> a.txt</span><br></pre></td></tr></table></figure>
<h3 id="双引号和单引号"><a href="#双引号和单引号" class="headerlink" title="双引号和单引号"></a>双引号和单引号</h3><p>sed在指定命令时一般需要用单引号括起来，如果用双引号可以指定shell变量，如下所示:</p>
<figure class="highlight plain"><figcaption><span>bash</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ FROM=&quot;aaa&quot;</span><br><span class="line">$ TO=&quot;eee&quot;</span><br><span class="line">$ sed -e &quot;s/$FROM/$TO/g&quot; input.txt</span><br></pre></td></tr></table></figure>
<h3 id="脚本文件的使用"><a href="#脚本文件的使用" class="headerlink" title="脚本文件的使用"></a>脚本文件的使用</h3><p>读取脚本文件执行，需要使用”-f”选项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-f</span> 脚本文件 输入文件</span><br></pre></td></tr></table></figure>
<h3 id="高级命令"><a href="#高级命令" class="headerlink" title="高级命令"></a>高级命令</h3><p>还可以在s命令之前指定要处理的行，比如下面这个命令只处理1到20行的内容:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'1,20s/aaa/AAA/g'</span> 输入文件</span><br></pre></td></tr></table></figure>
<p>下面这个命令只处理包含”bbb”的行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sed <span class="_">-e</span> <span class="string">'/bbb/s/aaa/AAA/g'</span> 输入文件</span><br></pre></td></tr></table></figure>
<p>可以用”(“和”)“把一部分搜索内容括起来，然后用”\1”引用搜索到的这部分内容，比如下面这一行包含一个IP地址，我要把这个IP地址找出来:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat a.txt</span><br><span class="line">sshd[12002]: Failed password from 192.168.19.22 port 334 ssh2</span><br><span class="line">$ sed -n <span class="_">-e</span> <span class="string">'/Failed password/s/.*Failed password from \([0-9.]*\) port .*/\1/p'</span> a.txt</span><br><span class="line">$ 192.168.19.22</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo博客添加站内搜索]]></title>
      <url>http://www.ezlippi.com/blog/2017/02/hexo-search.html</url>
      <content type="html"><![CDATA[<p>NexT主题支持集成 Swiftype、 微搜索、Local Search 和 Algolia,Swiftype和Algolia都只有一段时间的试用期，可以采用Hexo提供的Local Search,原理是通过hexo-generator-search插件在本地生成一个search.xml文件，搜索的时候从这个文件中根据关键字检索出相应的链接。<br><a id="more"></a></p>
<h2 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h2><h3 id="安装-hexo-generator-search"><a href="#安装-hexo-generator-search" class="headerlink" title="安装 hexo-generator-search"></a>安装 hexo-generator-search</h3><p>在站点的根目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure>
<h3 id="安装-hexo-generator-searchdb"><a href="#安装-hexo-generator-searchdb" class="headerlink" title="安装 hexo-generator-searchdb"></a>安装 hexo-generator-searchdb</h3><p>在站点的根目录下执行以下命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<h3 id="启用搜索"><a href="#启用搜索" class="headerlink" title="启用搜索"></a>启用搜索</h3><p>编辑 站点配置文件，新增以下内容到任意位置：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line"><span class="attr">  path:</span> search.xml</span><br><span class="line"><span class="attr">  field:</span> post</span><br><span class="line"><span class="attr">  format:</span> html</span><br><span class="line"><span class="attr">  limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>
<h2 id="介绍其他两个插件"><a href="#介绍其他两个插件" class="headerlink" title="介绍其他两个插件"></a>介绍其他两个插件</h2><h3 id="给博客添加feed"><a href="#给博客添加feed" class="headerlink" title="给博客添加feed"></a>给博客添加feed</h3><p>安装hexo-generator-feed</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-feed --save</span><br></pre></td></tr></table></figure>
<p>配置到站点配置文件_config.yml</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">#RSS订阅</span></span><br><span class="line"><span class="attr">plugin:</span></span><br><span class="line"><span class="bullet">-</span> hexo-generator-feed</span><br><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line"><span class="attr">type:</span> atom</span><br><span class="line"><span class="attr">path:</span> atom.xml</span><br><span class="line"><span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure>
<p>最后，在你next主题下的_config.yml下，添加RSS订阅链接即可：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rss:</span> /atom.xml</span><br></pre></td></tr></table></figure>
<h3 id="给博客生成一个站点地图"><a href="#给博客生成一个站点地图" class="headerlink" title="给博客生成一个站点地图"></a>给博客生成一个站点地图</h3><p>安装hexo-generator-seo-friendly-sitemap</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-seo-friendly-sitemap --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件_config.yml 中添加</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line"><span class="attr">    path:</span> sitemap.xml</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[优秀的程序员都在用谷歌]]></title>
      <url>http://www.ezlippi.com/blog/2017/02/ss-proxy-guide.html</url>
      <content type="html"><![CDATA[<p>众所周知，百度在搜索技术资料方面简直是个白痴，而且GitHub的博客屏蔽了百度蜘蛛的抓取，在公司内每次看到有人用百度来搜索资料我都会建议他改用谷歌搜索，在搜索资料时一个好的搜索引擎是不需要你查看第三页的内容的，大部分情况前几个搜索结果就能解决你的问题。<br><a id="more"></a></p>
<p>但是在中国大陆访问谷歌不太容易，但是对于程序员来讲这是个必备的技能，方法有很多种，最简单的无非是修改hosts文件，但是Google的Ip经常会被屏蔽，所以需要经常更新hosts文件，而且访问速度也比较慢，最近试用了一枝红杏提供的SS翻墙工具，虽然是收费的，标准版一年才99，对于程序员来讲是一笔值得花费的开销。</p>
<p>支持Windows、Linux、Android、IOS多设备登录，使用优惠码还能优惠20%，大家可以试试，如果有更好的工具推荐大家可以留言。</p>
<p>SS翻墙（ShadowSocks 中文名稱：影梭）工具<a href="http://my.yizhihongxing.com/aff.php?aff=4035" target="_blank" rel="external">官网</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Maven生命周期和插件]]></title>
      <url>http://www.ezlippi.com/blog/2016/08/maven-lifecycle-introduction.html</url>
      <content type="html"><![CDATA[<p>Maven有几个核心的概念，包括坐标、依赖、仓库，这几个概念比较容易理解，Maven另外两个重要的概念是生命周期和插件，你在工作中可能会经常使用maven clean install这样的命令来打包项目，但是你有没有仔细想过这两个命令会执行哪些操作。<br><a id="more"></a></p>
<p>项目构建的生命周期不外乎清理、编译、测试、打包和部署，这个工作可以通过自动化脚本来完成，为了能够对各个过程容易扩展，Maven引入了一套生命周期的概念，Maven的生命周期就是对所有的构建过程进行抽象和统一，这个生命周期包括项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成。既然生命周期是抽象的，意味着生命周期本身不做任何实际的工作，实际的任务都是有相应的插件来完成，这种思想和设计模式的模板方法有点相似，在父类中定义算法的整体结构，子类中通过实现或者重写父类的方法来控制实际的行为。</p>
<h2 id="三套生命周期"><a href="#三套生命周期" class="headerlink" title="三套生命周期"></a>三套生命周期</h2><p>Maven有三套相互独立的生命周期，分别是clean,default和site生命周期，clean生命周期用来清理项目，default生命周期用来构建项目，site生命周期用来建立项目站点。每个生命周期都会有相应的阶段(phase),用户一般调用这些生命周期的阶段来完成相应的工作，比如clean生命周期有pre-clean,clean和post-clean三个阶段，生命周期的阶段前后有依赖关系，调用clean阶段时会先执行pre-clean阶段。</p>
<h3 id="default生命周期"><a href="#default生命周期" class="headerlink" title="default生命周期"></a>default生命周期</h3><p>default生命周期用来构建项目，是用户接触最多的，它有很多个阶段，这里我只介绍比较重要的几个阶段：</p>
<ul>
<li><strong>compile:编译项目源代码，一般是src\main\java目录下</strong></li>
<li>test-compile:编译项目的测试代码</li>
<li>test使用单元测试框架运行单元测试，测试代码不会被打包或部署</li>
<li>package:打包成可发布的格式，如Jar，War，Bundle</li>
<li>Integration-test：集成测试</li>
<li>install:将包安装到Maven本地仓库，供本地其他项目使用</li>
<li>deploy：将最终的包袱值到远程仓库，供其他开发人员和项目组使用</li>
</ul>
<h3 id="通过命令行执行生命周期阶段"><a href="#通过命令行执行生命周期阶段" class="headerlink" title="通过命令行执行生命周期阶段"></a>通过命令行执行生命周期阶段</h3><p>比如我们常用<code>mvn clean</code>来清理项目，会执行clean生命周期的clean阶段，实际上会执行pre-clean和clean阶段，调用<code>mvn test</code>来执行单元测试时会自动test阶段之前的所有阶段，包括default生命周期的validate,initialize,compile和test-compile，也就是说调用mvn test会自动编译项目的源代码和测试代码。调用<code>mvn install</code>时会执行default生命周期从validate到install的所有阶段，我们常常会结合两个生命周期来调用，比如<code>mvn clean install</code>既执行了clean生命周期的pre-clean.clean阶段，也执行了default生命周期的compile,test-compile,test,package,install阶段。</p>
<p>site生命周期用来建立和发布项目站点，一般用的比较少，主要有四个阶段，pre-site,site,post-site和site-deploy，这里就不一一介绍了。</p>
<h2 id="插件的目标-Goal"><a href="#插件的目标-Goal" class="headerlink" title="插件的目标(Goal)"></a>插件的目标(Goal)</h2><p>前面讲过，Maven的生命周期只是抽象的，具体的任务执行都依赖于相应的插件，比如编译源代码依赖于maven-compiler插件，执行单元测试依赖于maven-surefire插件,每个插件有很多个目标(goal),不同目标有不同的功能，比如maven-dependecy-plugin有analyze，tree和list目标，一般我们通过·<strong>插件前缀：插件目标</strong>·来执行相应的功能,比如<code>mvn dependency:tree</code>来列出项目的依赖树，用<code>mvn surefire:test</code>来执行maven-surefire-plugin的test目标。</p>
<h3 id="生命周期阶段和插件目标的绑定"><a href="#生命周期阶段和插件目标的绑定" class="headerlink" title="生命周期阶段和插件目标的绑定"></a>生命周期阶段和插件目标的绑定</h3><p>为了减少用户的配置，Maven给一些主要的生命周期阶段绑定了很多插件的目标，比如maven clean生命周期的clean阶段绑定了maven-clean-plugin的clean目标，执行<code>mvn clean</code>会调用maven-clean-plugin的clean目标，compile阶段绑定了maven-compiler-plugin的compiler目标，test阶段绑定了maven-surefire-plugin的test目标，install阶段绑定了maven-install-plugin的install目标，package阶段绑定了maven-jar-plugin的jar目标，除了默认的jar打包类型外，常见的还有pom,war.</p>
<h3 id="自定义绑定"><a href="#自定义绑定" class="headerlink" title="自定义绑定"></a>自定义绑定</h3><p>除了内置绑定意外，用户还能够自己将某个插件目标绑定到生命周期的某个阶段上，这种自定义绑定方式能让Maven项目的构建过程中执行更附特色的任务一个常见的例子是创建项目的源码jar包，内置插件没有绑定这个任务，需要自行设置，maven-source-plugin可以帮我们完成，他的jar-no-fork目标就是将项目的主代码打包成jar文件，可以将其绑定到default生命周期的verify阶段上，在执行完集成测试后很安装构建之前创建源码jar包:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;bulid&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.1.1&lt;/version&gt;</span><br><span class="line">    &lt;executons&gt;</span><br><span class="line">      &lt;execution&gt;</span><br><span class="line">        &lt;id&gt;attach-sources&lt;/id&gt;</span><br><span class="line">        &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line">        &lt;goals&gt;</span><br><span class="line">          &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">        &lt;/goals&gt;</span><br><span class="line">      &lt;/execution&gt;</span><br><span class="line">    &lt;/executons&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/bulid&gt;</span><br></pre></td></tr></table></figure>
<h2 id="插件任务配置"><a href="#插件任务配置" class="headerlink" title="插件任务配置"></a>插件任务配置</h2><p>用户可以为某个插件任务配置特定的参数，以maven-antrun-plugin为例，他有一个目标run，可以用来在Maven中调用Ant任务，用户将这个插件的run绑定到多个生命周期阶段上，再加以不同的配置，就可以让Maven在不同的生命阶段执行不同的任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">&lt;plugins&gt;</span><br><span class="line">  &lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-antrun-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3&lt;/version&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">      &lt;execution&gt;</span><br><span class="line">        &lt;id&gt;ant-validate&lt;/id&gt;</span><br><span class="line">        &lt;phase&gt;validate&lt;/phase&gt;</span><br><span class="line">        &lt;goals&gt;</span><br><span class="line">          &lt;goal&gt;run&lt;/goal&gt;</span><br><span class="line">        &lt;/goals&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;tasks&gt;</span><br><span class="line">            &lt;echo&gt;I&apos;M bound to validate phase&lt;/echo&gt;</span><br><span class="line">          &lt;/tasks&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/execution&gt;</span><br><span class="line">      &lt;execution&gt;</span><br><span class="line">        &lt;id&gt;ant-verify&lt;/id&gt;</span><br><span class="line">        &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line">        &lt;goals&gt;</span><br><span class="line">          &lt;goal&gt;run&lt;/goal&gt;</span><br><span class="line">        &lt;/goals&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">          &lt;tasks&gt;</span><br><span class="line">            &lt;echo&gt;I&apos;M bound to validate phase&lt;/echo&gt;</span><br><span class="line">          &lt;/tasks&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">      &lt;/execution&gt;</span><br><span class="line">    &lt;/executions&gt;</span><br><span class="line">  &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>
<h2 id="maven-help-plugin获取插件描述"><a href="#maven-help-plugin获取插件描述" class="headerlink" title="maven-help-plugin获取插件描述"></a>maven-help-plugin获取插件描述</h2><p>maven-help-plugin用来获取插件的详细信息，可以运行如下命令：<code>$mvn help:describe -Dplugin = org.apache.maven.plugins:maven-compiler-plugin:2.1</code>,也就是执行maven-help-plugin的describe目标，结果中列出了插件的坐标，目标前缀和目标等，目标前缀为了在命令行直接运行插件，maven-compiler-plugin的前缀为compiler，在描述插件时可以省去版本信息，进一步简化为 <code>$mvn help:describe -Dplugin = compiler</code>,只想要了解某个目标信息可以加上goal参数：如<code>$mvn help:describe -Dplugin = compiler -Dgoal = compile</code> 想要更详细信息则加上detail参数：<code>$mvn help:describe -Dplugin = compiler -Ddetail</code>,在命令行执行之后输出如下所示，可以看到插件前缀为compiler:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Name: Apache Maven Compiler Plugin</span><br><span class="line">Description: The Compiler Plugin is used to compile the sources of your</span><br><span class="line">  project.</span><br><span class="line">Group Id: org.apache.maven.plugins</span><br><span class="line">Artifact Id: maven-compiler-plugin</span><br><span class="line">Version: 3.5.1</span><br><span class="line">Goal Prefix: compiler</span><br><span class="line"></span><br><span class="line">This plugin has 3 goals:</span><br><span class="line"></span><br><span class="line">compiler:compile</span><br><span class="line">  Description: Compiles application sources</span><br><span class="line"></span><br><span class="line">compiler:help</span><br><span class="line">  Description: Display help information on maven-compiler-plugin.</span><br><span class="line">    Call mvn compiler:help -Ddetail=true -Dgoal=&lt;goal-name&gt; to display</span><br><span class="line">    parameter details.</span><br><span class="line"></span><br><span class="line">compiler:testCompile</span><br><span class="line">  Description: Compiles application test sources.</span><br><span class="line"></span><br><span class="line">For more information, run &apos;mvn help:describe [...] -Ddetail&apos;</span><br></pre></td></tr></table></figure>
<h2 id="命令行使用插件"><a href="#命令行使用插件" class="headerlink" title="命令行使用插件"></a>命令行使用插件</h2><p>一般通过<code>mvn 插件前缀：目标</code>来调用插件执行某个任务，比如<code>mvn help describe</code>这里调用的是maven-help-plugin的describe目标，插件前缀的信息可以用这个任务来获取，maven-compiler-plugin的插件前缀是compiler,执行编译任务可以用<code>mvn compiler:compile</code>来执行，一般我们直接调用生命周期阶段<code>mvn compile</code>也可以实现相同的效果，因为compile生命周期阶段绑定了maven-compiler-plugin的compile目标。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用Jacoco计算单元测试覆盖率]]></title>
      <url>http://www.ezlippi.com/blog/2016/06/Jacoco-coverage.html</url>
      <content type="html"><![CDATA[<p>随着敏捷开发的流行，编写单元测试已经成为业界共识。TDD(测试驱动开发)的思想也强调了测试的重要性，怎么去衡量我们的测试代码的质量呢，常见的办法就是计算测试的覆盖率，常见的Java的覆盖率计算工具有JCov、Cobertura和Jacoco，三者都支持对class文件离线插桩，JCov和Jacoco还支持动态插桩，单元测试和集成测试都无法在模拟真实的运行环境，存在一定的局限性。<br><a id="more"></a><br>最近开发组这边提出了一个新的任务，要能够在真实的环境中验证一些核心逐组件的功能，并得出测试代码的覆盖率，很快环境就搭建起来，把要测试的一些接口和服务注册在服务总线上，客户端通过Rest请求相应的服务，在被测机上安装好插桩工具，实现覆盖率的收集。这篇文章主要记录Jacoco的Maven配置，方便日后查阅。</p>
<h2 id="配置JaCoCo-Maven插件"><a href="#配置JaCoCo-Maven插件" class="headerlink" title="配置JaCoCo Maven插件"></a>配置JaCoCo Maven插件</h2><p>使用Jacoco Maven插件主要基于两个考虑：</p>
<ol>
<li>通过Maven插件能够访问Jacoco运行时agent</li>
<li>Jacoco runtime agent创建的数据可以生成覆盖率报告</li>
</ol>
<p>主要有以下两步：</p>
<ol>
<li>配置Maven Jacoco插件依赖</li>
<li>为单元测试配置覆盖率报告</li>
</ol>
<h2 id="配置Jacoco插件"><a href="#配置Jacoco插件" class="headerlink" title="配置Jacoco插件"></a>配置Jacoco插件</h2><p>代码如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.5.201505241946<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="为单元测试配置覆盖率报告"><a href="#为单元测试配置覆盖率报告" class="headerlink" title="为单元测试配置覆盖率报告"></a>为单元测试配置覆盖率报告</h2><p>主要配置两个execution，第一个创建一个执行Jacoco运行时Agent的属性，确保覆盖率数据写入到target/coverage-reports/jacoco-ut.exec文件中，属性名称为surefireArgLine,当我们运行单元测试时这个属性传递给JVM参数。</p>
<p>第二个execution配置单元测试运行之后生成覆盖率报告，报告写在target/site/jacoco-ut文件。具体配置代码如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jacoco<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jacoco-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.7.5.201505241946<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span><br><span class="line">           准备指向Jacoco运行时Agent的属性，在测试执行之前传递给虚拟机参数</span><br><span class="line">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>pre-unit-test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>prepare-agent<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 设置覆盖率数据文件路径 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">destFile</span>&gt;</span>$&#123;project.build.directory&#125;/coverage-reports/jacoco-ut.exec<span class="tag">&lt;/<span class="name">destFile</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 设置属性名称，Maven surefire插件需要引用这个作为命令行参数</span><br><span class="line">                --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">propertyName</span>&gt;</span>surefireArgLine<span class="tag">&lt;/<span class="name">propertyName</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span><br><span class="line">            确保在单元测试执行之后生成覆盖率报告</span><br><span class="line">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>post-unit-test<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">phase</span>&gt;</span>test<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">goal</span>&gt;</span>report<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 引用覆盖率文件的路径--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">dataFile</span>&gt;</span>$&#123;project.build.directory&#125;/coverage-reports/jacoco-ut.exec<span class="tag">&lt;/<span class="name">dataFile</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 设置覆盖率报告存放路径. --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">outputDirectory</span>&gt;</span>$&#123;project.reporting.outputDirectory&#125;/jacoco-ut<span class="tag">&lt;/<span class="name">outputDirectory</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置Maven-surefire插件"><a href="#配置Maven-surefire插件" class="headerlink" title="配置Maven surefire插件"></a>配置Maven surefire插件</h2><p>之所以使用Surefire插件来执行单元测试是想确保我们运行测试代码的时候Jacoco Agent能够运行，做法就是把上面的surefireArgLine属性传递给surefire命令行参数，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.15<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 设置虚拟机参数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">argLine</span>&gt;</span>$&#123;surefireArgLine&#125;<span class="tag">&lt;/<span class="name">argLine</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 排除集成测试的代码. --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">exclude</span>&gt;</span>**/IT*.java<span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="生成覆盖率报告"><a href="#生成覆盖率报告" class="headerlink" title="生成覆盖率报告"></a>生成覆盖率报告</h2><p>运行maven clean test命令后就在target/site/jacoco-ut生成了覆盖率报告。</p>
<p>参考文献: <a href="http://www.eclemma.org/jacoco/trunk/doc/maven.html" target="_blank" rel="external">Jacoco Maven文档</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java NIO 基本概念]]></title>
      <url>http://www.ezlippi.com/blog/2016/06/java-nio-concept.html</url>
      <content type="html"><![CDATA[<p>学Java的都会接触到IO，传统的IO是基于字节流和字符流的，数据只能单向传输，JDK1.5引入了NIO，主要包含三个核心概念，Selector,Buffer和Channel。NIO中数据都是通过缓冲区来操作，缓冲区中数据可以移动，可以通过buffer.flip()来改变读写模式，比如调用channel.read(buffer)从文件中写入数据到buffer,之后调用buffer.flip(),再调用Buffer.get()就可以读取buffer里的数据。<br><a id="more"></a></p>
<h2 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h2><p>NIO另一个非常重要的特点就是支持非阻塞操作，传统的IO的read和write只能阻塞执行，线程在读写IO期间不能干其他事情，比如调用socket.read()时，如果服务器一直没有数据传输过来，线程就一直阻塞，NIO中可以配置socket为非阻塞模式:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p>NIO中可以在Selector中注册感兴趣的IO事件，比如:</p>
<ol>
<li>Connect</li>
<li>Accept</li>
<li>Read</li>
<li>Write</li>
</ol>
<p>这4个事件可以用SelectionKey的4个常量来表示:</p>
<ol>
<li>SelectionKey.OP_CONNECT</li>
<li>SelectionKey.OP_ACCEPT</li>
<li>SelectionKey.OP_READ</li>
<li>SelectionKey.OP_WRITE</li>
</ol>
<p>注册相应的感兴趣的事件之后，调用Selector.select()方法会返回就绪的事件数，然后通过selector.selectedKeys()返回就绪的SelectKey集合，再调用相应的方法读写数据就可以了。这样做的好处是可以在一个线程中注册多个IO事件，对于读写事件不是很频繁的情况可以提高CPU的利用率。</p>
<h2 id="关于Selector"><a href="#关于Selector" class="headerlink" title="关于Selector"></a>关于Selector</h2><p>看到Selector源码的应该知道，Selector的实现是基于IO多路复用机制，以Linux系统为例，传统的IO多路复用有select,poll和epoll,epoll由于其采用了事件驱动机制大大提高了IO多路复用的效率得到了广泛的应用，Linux平台下Java的Selector底层就是采用的Epoll，Mac OS采用的是Kqueue。</p>
<p>喜欢网络编程的朋友应该了解过MINA和Netty，是Java语言比较优秀的NIO开源框架，其采用了事件驱动机制(Reactor线程模型)、异步非阻塞，通过Future-Listener机制，用户可以方便的主动获取或者通过通知机制获得IO操作结果。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty的NIO框架构建。</p>
<h2 id="关于Buffer"><a href="#关于Buffer" class="headerlink" title="关于Buffer"></a>关于Buffer</h2><p>Buffer可以理解为一个连续的基本数据类型的数组，Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。每种基本数据类型都有对应的Buffer，比如ByteBuffer，CharBuffer。</p>
<p>ByteBuffer有两种模式:直接/间接模式，间接模式是操作堆内存 (byte[])，但是内存毕竟有限,如果我要发送一个1G的文件怎么办?不可能真的去分配1G的内存，这时就必须使用”直接”模式,即MappedByteBuffer内存文件映射，MappedByteBuffer将文件映射到内存中(虚拟内存),文件较大时可以分段映射。</p>
<h2 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h2><p>内存映射文件和普通IO相比的优点：</p>
<ol>
<li>用户进程把文件看作是内存，不需要再使用read()和write()系统调用</li>
<li>数据自动从磁盘加载到内存，数据更新时自动写入到文件</li>
<li>操作系统的虚拟内存会智能缓存分页，根据内存使用情况自动管理内存</li>
<li>数据永远是分页对齐的</li>
</ol>
<p>使用举例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(bigExcelFile);</span><br><span class="line">     </span><br><span class="line"><span class="comment">//获取FileChannel</span></span><br><span class="line">FileChannel fileChannel = <span class="keyword">new</span> RandomAccessFile(file, <span class="string">"r"</span>).getChannel();</span><br><span class="line">         </span><br><span class="line"><span class="comment">//使用channel.map()获取MappedByteBuffer</span></span><br><span class="line">MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_ONLY, <span class="number">0</span>, fileChannel.size());</span><br></pre></td></tr></table></figure>
<p>更多关于MappedByteBuffer的信息可以参考<a href="http://howtodoinjava.com/java-7/nio/java-nio-2-0-memory-mapped-files-mappedbytebuffer-tutorial/" target="_blank" rel="external">mappedbytebuffer-tutorial</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android APK签名详解]]></title>
      <url>http://www.ezlippi.com/blog/2016/03/android-apk-signing.html</url>
      <content type="html"><![CDATA[<h2 id="App为什么需要签名？"><a href="#App为什么需要签名？" class="headerlink" title="App为什么需要签名？"></a>App为什么需要签名？</h2><ol>
<li>对Apk的完整性和发布机构唯一性的校验</li>
<li>签名之后无法阻止APK被人修改，但修改后再签名就和原先的签名不一致，可以避免有些人用相同包名的APK来替换已有的应用</li>
<li>相同签名的升级软件可以覆盖安装旧版本的软件</li>
<li>签名的私钥在开发者那里，公钥打包在APK内，不同公钥对应不同私钥，通过比较公钥可以判断私钥是否一致</li>
<li>允许代码和数据共享。android中提供了一个基于签名的Permission标签。通过允许的设置，我们可以实现对不同App之间的访问和共享，如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AndroidManifest.xml：<span class="tag">&lt;<span class="name">permission</span> <span class="attr">android:protectionLevel</span>=<span class="string">"normal"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中protectionLevel标签有4种值：normal(缺省值),dangerous, signature,signatureOrSystem。normal是低风险的，所有的App不能访问和共享此App。dangerous是高风险的，所有的App都能访问和共享此App。signature是指具有相同签名的App可以访问和共享此App。<br><a id="more"></a></p>
<h2 id="使用SDK工具生成的DEBUG-Key签名"><a href="#使用SDK工具生成的DEBUG-Key签名" class="headerlink" title="使用SDK工具生成的DEBUG Key签名"></a>使用SDK工具生成的DEBUG Key签名</h2><p>Android签名有两种方式：DEBUG和RELEASE,在开发测试期间使用DEBUG方式，BUILD时，会自动使用工具KeyTools创建KEY包括别名和密码。每次编译时，都会使用DEBUG的KEY进行签名。<br>在第一次安装Android开发环境的时候，SDK工具已经创建了缺省的keystore/key和账号、密码：</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Keystore name – <span class="string">"debug.keystore"</span></span><br><span class="line">Keystore password – <span class="string">"android"</span></span><br><span class="line"><span class="keyword">Key</span> <span class="keyword">alias</span> – <span class="string">"androiddebugkey"</span></span><br><span class="line"><span class="keyword">Key</span> password – <span class="string">"android"</span></span><br><span class="line">CN – <span class="string">"CN=Android Debug,O=Android,C=US"</span></span><br></pre></td></tr></table></figure>
<p>keystore其实就是一个文件，存放以上信息的文件，由于使用了加密难以看懂。DEBUG模式的签名只有365天有效期,过了有效期，编译会出错。但不用担心，只要将debug.keystore文件删除后，下次BUILD会自动生成的keystore和key的。debug.keystore文件一般在/home/username/.android目录下。</p>
<h2 id="使用java命令行工具"><a href="#使用java命令行工具" class="headerlink" title="使用java命令行工具"></a>使用java命令行工具</h2><h3 id="使用Keytool生成key文件"><a href="#使用Keytool生成key文件" class="headerlink" title="使用Keytool生成key文件"></a>使用Keytool生成key文件</h3><p>创建key，需要用到keytool(位于JAVA_HOME\jre\bin目录下),在Shell中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -alias android.keystore -keyalg RSA -validity 36500 -keystore android.keystore</span><br></pre></td></tr></table></figure>
<p>命令行参数解释：</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"><span class="symbol">genkey:</span>产生秘钥</span><br><span class="line"></span>-<span class="ruby"><span class="keyword">alias</span> android.keystore 别名 android.keystore</span><br><span class="line"></span>-<span class="ruby">keyalg RSA 使用RSA算法对签名加密</span><br><span class="line"></span>-<span class="ruby">validity <span class="number">36500</span> 有效期限</span><br><span class="line"></span>-<span class="ruby">keystore android.keystore  存储的文件名</span></span><br></pre></td></tr></table></figure>
<h3 id="使用-jarsigner签名"><a href="#使用-jarsigner签名" class="headerlink" title="使用 jarsigner签名"></a>使用 jarsigner签名</h3><p>jarsigner在目录JAVA_HOME\bin下，在Shell中输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jarsigner -verbose -keystore android.keystore -signedjar android_signed.apk android.apk android.keystore</span><br></pre></td></tr></table></figure>
<p>命令行参数解释：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-verbose 输出签名的详细信息</span><br><span class="line">-keystore  android<span class="selector-class">.keystore</span> 密钥库位置</span><br><span class="line">-signedjar android_signed<span class="selector-class">.apk</span> android<span class="selector-class">.apk</span> android<span class="selector-class">.keystore</span> 正式签名，三个参数中依次为签名后产生的文件android_signed，要签名的文件android.apk和密钥库android.keystore</span><br></pre></td></tr></table></figure>
<h3 id="zipalign压缩对齐优化APK文件"><a href="#zipalign压缩对齐优化APK文件" class="headerlink" title="zipalign压缩对齐优化APK文件"></a>zipalign压缩对齐优化APK文件</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">zipalign</span> <span class="selector-tag">-v</span> 4 <span class="selector-tag">android_signed</span><span class="selector-class">.apk</span> <span class="selector-tag">release</span><span class="selector-class">.apk</span></span><br></pre></td></tr></table></figure>
<p>zipalign能够使apk文件中未压缩的数据在4个字节边界上对齐，这样android系统可以使用mmap()函数读取文件，在读取资源上获得较高的性能。</p>
<p>android系统中的Davlik虚拟机使用自己专有的格式DEX，DEX的结构是紧凑的，为了让运行时的性能更好，可以进一步用”对齐”进一步优化，但是大小一般会有所增加。</p>
<h2 id="使用Gradle完成签名"><a href="#使用Gradle完成签名" class="headerlink" title="使用Gradle完成签名"></a>使用Gradle完成签名</h2><p>前面已经介绍了DEBUG模式的签名，这里主要讲Release模式：<br>在Module的build.gradle文件的android配置代码块添加如下内容：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">android&#123;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"/home/lippi/.android/debug.keystore"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        relealse &#123;</span><br><span class="line">            <span class="comment">//这样写就得把demo.jk文件放在项目目录</span></span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"android.keystore"</span>)</span><br><span class="line">            storePassword <span class="string">"android"</span></span><br><span class="line">            keyAlias <span class="string">"lippi"</span></span><br><span class="line">            keyPassword <span class="string">"password"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// 显示Log</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span></span><br><span class="line"></span><br><span class="line">            versionNameSuffix <span class="string">"-debug"</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">false</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 不显示Log</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span></span><br><span class="line">            <span class="comment">//混淆</span></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//Zipalign优化</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除无用的resource文件</span></span><br><span class="line">            shrinkResources <span class="keyword">true</span></span><br><span class="line">            <span class="comment">//前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard.cfg'</span></span><br><span class="line">            <span class="comment">//签名</span></span><br><span class="line">            signingConfig signingConfigs.relealse</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行gradle 命令，</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>gradle assembleRelease</span><br></pre></td></tr></table></figure>
<p>编译并发布。 在build/outputs/apk/ 下能看到未签名的apk 和 已经签名的apk。如果未用签名文件，使用debug mode的debug签名，那就会生成一个debug签名的apk。</p>
<h3 id="签名密码放在Gradle文件中不安全"><a href="#签名密码放在Gradle文件中不安全" class="headerlink" title="签名密码放在Gradle文件中不安全"></a>签名密码放在Gradle文件中不安全</h3><p>可以改成下面这样的格式这样在执行命令时，就会被要求输入密码</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123; </span><br><span class="line">    myConfig &#123; </span><br><span class="line">        storeFile <span class="keyword">file</span>(<span class="string">"android.keystore"</span>)  </span><br><span class="line">        storePassword System.console().readLine(<span class="string">"\ninput Keystore password: "</span>)  </span><br><span class="line">        keyAlias <span class="string">"lippi"</span>  </span><br><span class="line">        keyPassword System.console().readLine(<span class="string">"\n input Key password: "</span>)  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="使用Android-Studio自带的签名工具"><a href="#使用Android-Studio自带的签名工具" class="headerlink" title="使用Android Studio自带的签名工具"></a>使用Android Studio自带的签名工具</h2><p>菜单Build &gt; Generate Signed APK,具体的就不介绍了，看了前面的部分应该很简单完成。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android反编译(逆向)教程]]></title>
      <url>http://www.ezlippi.com/blog/2016/03/android-apk-classy.html</url>
      <content type="html"><![CDATA[<p>在网上搜索Android反编译教程，搜出来的文章要么是抄袭的，要么是太过与简单，经过自己的实践和摸索，我在这里记录下如下反编译一个Apk并修改一些资源文件，比如App名字、启动界面等，然后重新打包成apk,你可以参照这个教程修改游戏里的金币(估计没这么简单)。</p>
<a id="more"></a>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><p>还是常用的三个工具：Apktool、dex2jar、jd-gui</p>
<h2 id="Apktool"><a href="#Apktool" class="headerlink" title="Apktool"></a>Apktool</h2><p>下载地址：<a href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">Apktool</a></p>
<h3 id="Linux下安装教程："><a href="#Linux下安装教程：" class="headerlink" title="Linux下安装教程："></a>Linux下安装教程：</h3><ol>
<li>下载<a href="https://raw.githubusercontent.com/iBotPeaches/Apktool/master/scripts/windows/apktool.bat" target="_blank" rel="external">Linux wrapper script</a> (鼠标右键另存为apktool)</li>
<li>从<a href="http://ibotpeaches.github.io/Apktool/" target="_blank" rel="external">这里</a>下载最新版的apktool</li>
<li>把下载的Jar文件重命名为apktool.jar</li>
<li>把两个文件(apktool.jar &amp; apktool)移动到/usr/local/bin (需要root权限)，使用chmod +x添加执行权限</li>
<li>现在可以通过命令行来运行apktool了</li>
</ol>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用方式：<br>1.反编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d test.apk</span><br></pre></td></tr></table></figure></p>
<p>反编译后在home目录下生成了一个文件夹，内容如下：<br><img src="/images/apktool.png" alt=""></p>
<p>各个文件简单介绍如下：<br>apktool.yml: apk属性.<br>AndroidManifest.xml: 清单文件, 非二进制.<br>original: 原始数据, 应用的二进制清单和签名.<br>res: 资源文件.<br>smali: dex解析的代码.smali是dex虚拟机的解析格式,在 dex2jar中,也包含smali格式的转换.</p>
<p>打开AndroidManifest文件，内容如下：<br><img src="/images/apktool2.png" alt=""><br>可以看到app_name和app的图标：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:icon="@drawable/icon_meetyou" android:label="@string/app_name"</span><br></pre></td></tr></table></figure></p>
<p>接下来我们修改res/values/strings.xml下app_name的内容，并替换app图标<br>2.重新打包成apk<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool b <span class="built_in">test</span></span><br></pre></td></tr></table></figure></p>
<p>打包后在dist文件夹下生成新的apk文件。</p>
<h2 id="dex2jar"><a href="#dex2jar" class="headerlink" title="dex2jar"></a>dex2jar</h2><p>dex2jar是dex转换为jar的工具，很多人不会看smali文件，还是看java类文件比较舒服，这个时候可以借助这个工具来转成java代码。<br>下载地址:<a href="https://github.com/pxb1988/dex2jar" target="_blank" rel="external">dex2jar</a></p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>从Apk中解压出class.dex，使用dex2jar进行源码解析，在当前目录生成classes.dex.dex2jar.jar。<br>转换过程中, 如果发生内存不够, 修改 d2j_invoke.sh 的虚拟机配置.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xms512m -Xmx1024m -classpath <span class="string">"<span class="variable">$&#123;_classpath&#125;</span>"</span> <span class="string">"<span class="variable">$@</span>"</span></span><br></pre></td></tr></table></figure>
<p>接下来使用JD-GUI打开jar包，下载地址:<a href="http://jd.benow.ca/" target="_blank" rel="external">jd-gui</a><br>界面如下所示:<br><img src="/images/jdgui.png" alt=""></p>
<h2 id="其他工具"><a href="#其他工具" class="headerlink" title="其他工具"></a>其他工具</h2><h3 id="android-killer"><a href="#android-killer" class="headerlink" title="android killer"></a>android killer</h3><p>集成了上面几个工具，并添加了一些功能<br>下载地址：<a href="http://pan.baidu.com/s/1dEy0VVN" target="_blank" rel="external">androidkiller</a></p>
<h3 id="ClassyShark"><a href="#ClassyShark" class="headerlink" title="ClassyShark"></a>ClassyShark</h3><p>下载地址：<a href="https://github.com/google/android-classyshark" target="_blank" rel="external">github</a></p>
<p>ClassyShark是一款可以查看Android可执行文件的浏览工具，支持.dex, .aar, .so, .apk, .jar, .class, .xml 等文件格式，分析里面的内容包括classes.dex文件，包、方法数量、类、字符串、使用的NativeLibrary等。</p>
<h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>1.打开apk文件java -jar ClassyShark.jar -open <your_apk.apk><br>2.将生成的所有数据导出到文本文件里java -jar ClassyShark.jar -dump <binary_file><br>3.将指定类生成的文件导出到文本文件里java -jar ClassyShark.jar -dump <binary_file> <fully_qualified_class_name><br>4.打开ClassyShark，在GUI界面展示某特定的类<br>5.java -jar ClassyShark.jar -open <binary_file> <fully_qualified_class_name><br>6.检测APKjava -jar ClassyShark.jar -inspect <your_apk.apk><br>7.导出所有的字符串 java -jar ClassyShark.jar -stringdump <your_apk.apk></your_apk.apk></your_apk.apk></fully_qualified_class_name></binary_file></fully_qualified_class_name></binary_file></binary_file></your_apk.apk></p>
<p>和其他的工具不同，ClassyShark通过分析App的项目结构和引用库的信息，我们大致掌握了该项目的架构，一些开发中的经验和不足，拓宽下开发视野，发现一些好用的开源库，增强我们的武器，这些都是我们在开发中可以借鉴的东西。比如我们查看美团App的结构，看它使用了哪些开源库，界面如下所示：<br><img src="/images/classshark.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Jekyll迁移到Hexo搭建个人博客]]></title>
      <url>http://www.ezlippi.com/blog/2016/02/jekyll-to-hexo.html</url>
      <content type="html"><![CDATA[<p>个人博客以前由jekyll搭建，主要问题是目录、Rss、sitemap无法自动生成，根据DRY的原则在网上找了下答案，最终发现了用Hexo来搭建博客的方法，配置完之后一劳永逸，目录、Rss和sitemap都是自动生成，解决了我之前的困惑。</p>
<h2 id="从Jekyll迁移到Hexo"><a href="#从Jekyll迁移到Hexo" class="headerlink" title="从Jekyll迁移到Hexo"></a>从Jekyll迁移到Hexo</h2><h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><ul>
<li>安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir hexo  <span class="comment">#创建一个文件夹</span></span><br><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">npm install -g hexo-cli</span><br><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<ul>
<li>部署Hexo：在Git shell 中输入</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure>
<ul>
<li>安装Hexo 插件：自动生成sitemap,Rss，部署到git等，建议安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-archive --save</span><br><span class="line">npm install hexo-generator-category --save</span><br><span class="line">npm install hexo-generator-tag --save</span><br><span class="line">npm install hexo-server --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-deployer-heroku --save</span><br><span class="line">npm install hexo-deployer-rsync --save</span><br><span class="line">npm install hexo-deployer-openshift --save</span><br><span class="line">npm install hexo-renderer-marked@0.2 --save</span><br><span class="line">npm install hexo-renderer-stylus@0.2 --save</span><br><span class="line">npm install hexo-generator-feed@1 --save</span><br><span class="line">npm install hexo-generator-sitemap@1 --save</span><br></pre></td></tr></table></figure>
<h2 id="Hexo常用的几个命令"><a href="#Hexo常用的几个命令" class="headerlink" title="Hexo常用的几个命令"></a>Hexo常用的几个命令</h2><h3 id="创建新博文"><a href="#创建新博文" class="headerlink" title="创建新博文"></a>创建新博文</h3><p>执行new命令，生成指定名称的文章至hexo\source_posts\postName.md。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new [layout] <span class="string">"postName"</span> <span class="comment">#新建文章</span></span><br></pre></td></tr></table></figure></p>
<p>其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\scaffolds\post.md</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<blockquote>
<p>请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。</p>
</blockquote>
<p>我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: &#123; &#123; title &#125; &#125;</span><br><span class="line">date: &#123; &#123; date &#125; &#125;</span><br><span class="line">categories: </span><br><span class="line">tags: </span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>更多信息参考: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="运行服务器"><a href="#运行服务器" class="headerlink" title="运行服务器"></a>运行服务器</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>参考: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="生成静态站点文件"><a href="#生成静态站点文件" class="headerlink" title="生成静态站点文件"></a>生成静态站点文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>参考: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="部署到Git"><a href="#部署到Git" class="headerlink" title="部署到Git"></a>部署到Git</h3><p>部署到Github前需要配置_config.yml文件</p>
<p>添加如下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">	<span class="built_in">type</span>: git</span><br><span class="line">	repository: git@github.com:EZLippi/EZLippi.github.io.git</span><br><span class="line">	branch: master</span><br></pre></td></tr></table></figure>
<p>然后输入：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>参考: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<h2 id="fancybox"><a href="#fancybox" class="headerlink" title="fancybox"></a>fancybox</h2><p>可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。<br>很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: Jekyll迁移到Hexo建立个人博客</span><br><span class="line">photos:</span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg</span><br><span class="line">- http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>本博客采用了iissnan的Next主题，他的博客有详细的安装教程，这里贴下链接<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">next</a>，有需要的朋友直接参考他写的教程，一气呵成~</p>
<h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo目录</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<h3 id="应用Hexo主题"><a href="#应用Hexo主题" class="headerlink" title="应用Hexo主题"></a>应用Hexo主题</h3><p>在hexo目录下找到_config.yml配置文件，找到 theme 字段，并将其值更改为 next，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure></p>
<h3 id="设置RSS"><a href="#设置RSS" class="headerlink" title="设置RSS"></a>设置RSS</h3><p>在上面的步骤中已经安装了Rss插件，只要要在themes\next_config.yml配置文件中添加如下一行即可：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rss：</span><br></pre></td></tr></table></figure></p>
<h3 id="添加标签tags页面"><a href="#添加标签tags页面" class="headerlink" title="添加标签tags页面"></a>添加标签tags页面</h3><p>定位到 Hexo 站点目录下，使用 hexo new page 新建一个页面，命名为 tags，布局格式为page：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> hexo目录</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure></p>
<p>内容如下所示，如果要关闭tags页面的评论可以设置comments为false：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"tags"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>这样以后tags页面在每次执行hexo generate后自动更新。</p>
<h3 id="添加分类页面"><a href="#添加分类页面" class="headerlink" title="添加分类页面"></a>添加分类页面</h3><p>和上面的一样，在hexo目录下执行下面命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></p>
<p>内容为：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line"><span class="built_in">type</span>: <span class="string">"categories"</span></span><br><span class="line">comments: <span class="literal">false</span></span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<h3 id="添加404页面"><a href="#添加404页面" class="headerlink" title="添加404页面"></a>添加404页面</h3><p>新建一个404.html文件，放到themes\next\source目录下，内容你自己定。</p>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>以前jekyll代码高亮需要用到pygments插件，Hexo下更加简单，只需要按照下面的格式：<br><img src="/images/highlight.png" alt=""><br>效果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"hello hexo!"</span>);</span><br></pre></td></tr></table></figure></p>
<p>你也可以更改代码高亮的主题，一共有五种，可选的值有 normal，night， night blue， night bright， night eighties，修改themes\next_config.yml文件，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">highlight_theme: normal</span><br></pre></td></tr></table></figure></p>
<h2 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h2><h3 id="多说评论"><a href="#多说评论" class="headerlink" title="多说评论"></a>多说评论</h3><p>登录多说官网，登录后点我要安装，然后填写站点相关信息，最主要的是duoshuo_shortname这个字段，设置后之后修改themes\next_config.yml文件，把duoshuo_shortname改成你的，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">duoshuo_shortname: ezlippi</span><br></pre></td></tr></table></figure></p>
<h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>登录百度统计，转到获取代码截面，找到百度统计脚本id，然后把themes\next_config.yml文件下的baidu_analytics字段改成你的id，如下所示：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_analytics: 340874ba9357cbe81570aa4ac1185941</span><br></pre></td></tr></table></figure></p>
<h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>next主题集成了swiftype搜索，你需要到swiftype配置一个搜索引擎， 而后编辑 站点配置文件， 新增 swiftype_key 字段，值为你的 swiftype 搜索引擎的 key。 详细的配置请参考：<a href="http://theme-next.iissnan.com/third-party-services.html#swfitype" target="_blank" rel="external">swfitype教程</a></p>
<h3 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h3><p>其他设置比如侧边栏、友情链接、菜单栏等请参考<a href="http://theme-next.iissnan.com/theme-settings.html" target="_blank" rel="external">next主题配置教程</a></p>
<p>最后附上我的站点配置文件，如果有不懂的可以给我留言或者发邮件。<br>_config.yml配置文件内容如下：</p>
<p>站点配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hexo Configuration</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="comment">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> Lippi-浮生志</span><br><span class="line"><span class="attr">subtitle:</span></span><br><span class="line"><span class="attr">description:</span> Easy Lippi</span><br><span class="line"><span class="attr">author:</span> EZLippi </span><br><span class="line"><span class="attr">language:</span> zh-Hans</span><br><span class="line"><span class="attr">timezone:</span> Asia/Shanghai</span><br><span class="line"></span><br><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> http://www.ezlippi.com</span><br><span class="line"><span class="attr">root:</span> /</span><br><span class="line"><span class="attr">permalink:</span> /blog/:year/:month/:title.html</span><br><span class="line"><span class="attr">permalink_defaults:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory</span></span><br><span class="line"><span class="attr">source_dir:</span> source</span><br><span class="line"><span class="attr">public_dir:</span> public</span><br><span class="line"><span class="attr">tag_dir:</span> tags</span><br><span class="line"><span class="attr">archive_dir:</span> archives</span><br><span class="line"><span class="attr">category_dir:</span> categories</span><br><span class="line"><span class="attr">code_dir:</span> downloads/code</span><br><span class="line"><span class="attr">i18n_dir:</span> :lang</span><br><span class="line"><span class="attr">skip_render:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Writing</span></span><br><span class="line"><span class="attr">new_post_name:</span> :year-:month-:day-:title.md <span class="comment"># File name of new posts</span></span><br><span class="line"><span class="attr">default_layout:</span> post</span><br><span class="line"><span class="attr">titlecase:</span> <span class="literal">false</span> <span class="comment"># Transform title into titlecase</span></span><br><span class="line"><span class="attr">external_link:</span> <span class="literal">true</span> <span class="comment"># Open external links in new tab</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">0</span></span><br><span class="line"><span class="attr">render_drafts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">relative_link:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">future:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">highlight:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  line_number:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  auto_detect:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  tab_replace:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Category &amp; Tag</span></span><br><span class="line"><span class="attr">default_category:</span> uncategorized</span><br><span class="line"><span class="attr">category_map:</span></span><br><span class="line"><span class="attr">tag_map:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Date / Time format</span></span><br><span class="line"><span class="comment">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="comment">## You can customize the date format as defined in</span></span><br><span class="line"><span class="comment">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line"><span class="attr">date_format:</span> YYYY-MM-DD</span><br><span class="line"><span class="attr">time_format:</span> HH:mm:ss</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pagination</span></span><br><span class="line"><span class="comment">## Set per_page to 0 to disable pagination</span></span><br><span class="line"><span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">pagination_dir:</span> page</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: http://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: http://hexo.io/themes/</span></span><br><span class="line"><span class="attr">theme:</span> next </span><br><span class="line"><span class="comment">#since: 2014</span></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> git</span><br><span class="line"><span class="attr">  repository:</span> git@github.com:EZLippi/EZLippi.github.io.git </span><br><span class="line">  coding.net: git@git.coding.net:ezlippi/ezlippi.git,coding-pages</span><br></pre></td></tr></table></figure></p>
<p>主题配置文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Site Information Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Place your favicon.ico to /source directory.</span></span><br><span class="line"><span class="attr">favicon:</span> /favicon.ico</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set default keywords (Use a comma to separate)</span></span><br><span class="line"><span class="attr">keywords:</span> <span class="string">"Hexo, NexT"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set rss to false to disable feed link.</span></span><br><span class="line"><span class="comment"># Leave rss as empty to use site's feed link.</span></span><br><span class="line"><span class="comment"># Set rss to specific value if you have burned your feed already.</span></span><br><span class="line"><span class="attr">rss:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Specify the date when the site was setup</span></span><br><span class="line"><span class="attr">since:</span> <span class="number">2014</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Menu Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When running hexo in a subdirectory (e.g. domain.tld/blog)</span></span><br><span class="line"><span class="comment"># Remove leading slashes ( "/archives" -&gt; "archives" )</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line"><span class="attr">  home:</span> /</span><br><span class="line"><span class="attr">  categories:</span> /categories</span><br><span class="line"><span class="attr">  archives:</span> /archives</span><br><span class="line"><span class="attr">  tags:</span> /tags</span><br><span class="line"><span class="attr">  about:</span> /about</span><br><span class="line"><span class="comment">#  commonweal: /404.html</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Enable/Disable menu icons.</span></span><br><span class="line"><span class="comment"># Icon Mapping:</span></span><br><span class="line"><span class="comment">#   Map a menu item to a specific FontAwesome icon name.</span></span><br><span class="line"><span class="comment">#   Key is the name of menu item and value is the name of FontAwsome icon.</span></span><br><span class="line"><span class="comment">#   When an question mask icon presenting up means that the item has no mapping icon.</span></span><br><span class="line"><span class="attr">menu_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mapping.</span></span><br><span class="line"><span class="attr">  home:</span> home</span><br><span class="line"><span class="attr">  about:</span> user</span><br><span class="line"><span class="attr">  categories:</span> th</span><br><span class="line"><span class="attr">  tags:</span> tags</span><br><span class="line"><span class="attr">  archives:</span> archive</span><br><span class="line"><span class="attr">  commonweal:</span> heartbeat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Scheme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment">#scheme: Muse</span></span><br><span class="line"><span class="attr">scheme:</span> Mist</span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Sidebar Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Social links</span></span><br><span class="line"><span class="attr">social:</span></span><br><span class="line"><span class="attr">  GitHub:</span> https://github.com/EZLippi</span><br><span class="line"><span class="attr">  weibo:</span> http://weibo.com/ouyanglip</span><br><span class="line"><span class="attr">  zhihu:</span> http://www.zhihu.com/people/lippi-ouyang</span><br><span class="line">  <span class="comment">#Others:</span></span><br><span class="line"></span><br><span class="line">      </span><br><span class="line"><span class="comment"># Social Icons</span></span><br><span class="line"><span class="attr">social_icons:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Icon Mappings</span></span><br><span class="line"><span class="attr">  GitHub:</span> github</span><br><span class="line"><span class="attr">  Twitter:</span> twitter</span><br><span class="line"><span class="attr">  weibo:</span> weibo</span><br><span class="line"><span class="attr">  zhihu:</span> weibo </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="comment"># in theme directory(source/images): /images/avatar.jpg</span></span><br><span class="line"><span class="comment"># in site  directory(source/uploads): /uploads/avatar.jpg</span></span><br><span class="line"><span class="comment"># default : /images/default_avatar.jpg</span></span><br><span class="line"><span class="attr">avatar:</span> /images/avatar.jpg</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># TOC in the Sidebar</span></span><br><span class="line"><span class="attr">toc:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Automatically add list number to toc.</span></span><br><span class="line"><span class="attr">  number:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># http://creativecommons.org/</span></span><br><span class="line"><span class="comment"># Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero</span></span><br><span class="line"><span class="comment">#creative_commons: by-nc-sa</span></span><br><span class="line"><span class="comment">#creative_commons:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">sidebar:</span></span><br><span class="line">  <span class="comment"># Sidebar Position, available value: left | right</span></span><br><span class="line"><span class="attr">  position:</span> left</span><br><span class="line">  <span class="comment">#position: right</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Sidebar Display, available value:</span></span><br><span class="line">  <span class="comment">#  - post    expand on posts automatically. Default.</span></span><br><span class="line">  <span class="comment">#  - always  expand for all pages automatically</span></span><br><span class="line">  <span class="comment">#  - hide    expand only when click on the sidebar toggle icon.</span></span><br><span class="line">  <span class="comment">#  - remove  Totally remove sidebar including sidebar toggle icon.</span></span><br><span class="line"><span class="attr">  display:</span> post</span><br><span class="line">  <span class="comment">#display: always</span></span><br><span class="line">  <span class="comment">#display: hide</span></span><br><span class="line">  <span class="comment">#display: remove</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Misc Theme Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Custom Logo.</span></span><br><span class="line"><span class="comment"># !!Only available for Default Scheme currently.</span></span><br><span class="line"><span class="comment"># Options:</span></span><br><span class="line"><span class="comment">#   enabled: [true/false] - Replace with specific image</span></span><br><span class="line"><span class="comment">#   image: url-of-image   - Images's url</span></span><br><span class="line"><span class="attr">custom_logo:</span></span><br><span class="line"><span class="attr">  enabled:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  image:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Code Highlight theme</span></span><br><span class="line"><span class="comment"># Available value:</span></span><br><span class="line"><span class="comment">#    normal | night | night eighties | night blue | night bright</span></span><br><span class="line"><span class="comment"># https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line"><span class="attr">highlight_theme:</span> night </span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically scroll page to section which is under &lt;!-- more --&gt; mark.</span></span><br><span class="line"><span class="attr">scroll_to_more:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatically Excerpt</span></span><br><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  length:</span> <span class="number">150</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Use Lato font</span></span><br><span class="line"><span class="attr">use_font_lato:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Third Party Services Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># MathJax Support</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Swiftype Search API Key</span></span><br><span class="line"><span class="attr">swiftype_key:</span> fLM9qfxyerC6njvM7usy</span><br><span class="line"></span><br><span class="line"><span class="comment"># Baidu Analytics ID</span></span><br><span class="line"><span class="attr">baidu_analytics:</span> <span class="number">340874</span>ba9357cbe81570aa4ac1185941</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Duoshuo ShortName</span></span><br><span class="line"><span class="attr">duoshuo_shortname:</span> ezlippi </span><br><span class="line"></span><br><span class="line"><span class="comment"># Disqus</span></span><br><span class="line"><span class="comment">#disqus_shortname:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="comment">#jiathis:</span></span><br><span class="line"><span class="comment">#add_this_id:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Share</span></span><br><span class="line"><span class="attr">duoshuo_share:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment"># 多说热评文章 true 或者 false</span></span><br><span class="line"><span class="attr">duoshuo_hotartical:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Webmaster tools verification setting</span></span><br><span class="line"><span class="comment"># See: https://www.google.com/webmasters/</span></span><br><span class="line"><span class="comment">#google_site_verification:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Google Analytics</span></span><br><span class="line"><span class="comment">#google_analytics:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Make duoshuo show UA</span></span><br><span class="line"><span class="comment"># user_id must NOT be null when admin_enable is true!</span></span><br><span class="line"><span class="comment"># you can visit http://dev.duoshuo.com get duoshuo user id.</span></span><br><span class="line"><span class="attr">duoshuo_info:</span></span><br><span class="line"><span class="attr">  ua_enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">  admin_enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  user_id:</span> <span class="number">0</span></span><br><span class="line">  <span class="comment">#admin_nickname: ROOT</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Facebook SDK Support.</span></span><br><span class="line"><span class="comment"># https://github.com/iissnan/hexo-theme-next/pull/410</span></span><br><span class="line"><span class="attr">facebook_sdk:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  app_id:</span>       <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line"><span class="attr">  fb_admin:</span>     <span class="comment">#&lt;user_id&gt;</span></span><br><span class="line"><span class="attr">  like_button:</span>  <span class="comment">#true</span></span><br><span class="line"><span class="attr">  webmaster:</span>    <span class="comment">#true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Show number of visitors to each article.</span></span><br><span class="line"><span class="comment"># You can visit https://leancloud.cn get AppID and AppKey.</span></span><br><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line"><span class="attr">  enable:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  app_id:</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line"><span class="attr">  app_key:</span> <span class="comment">#&lt;app_key&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Tencent analytics ID</span></span><br><span class="line"><span class="comment"># tencent_analytics:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment">#! DO NOT EDIT THE FOLLOWING SETTINGS</span></span><br><span class="line"><span class="comment">#! UNLESS YOU KNOW WHAT YOU ARE DOING</span></span><br><span class="line"><span class="comment">#! ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Motion</span></span><br><span class="line"><span class="attr">use_motion:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Fancybox</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Static files</span></span><br><span class="line"><span class="attr">vendors:</span> vendors</span><br><span class="line"><span class="attr">css:</span> css</span><br><span class="line"><span class="attr">js:</span> js</span><br><span class="line"><span class="attr">images:</span> images</span><br><span class="line"></span><br><span class="line"><span class="comment"># Theme version</span></span><br><span class="line"><span class="attr">version:</span> <span class="number">0.5</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># title, chinese available</span></span><br><span class="line"><span class="attr">links_title:</span> 友情链接 </span><br><span class="line"><span class="comment"># # links</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line"><span class="attr">   MacTalk:</span> http://macshuo.com/</span><br></pre></td></tr></table></figure></p>
<p>我的hexo主题托管在<a href="https://github.com/EZLippi/hexo-theme" target="_blank" rel="external">Github</a>上面,有需要的可以下载下来使用，修改里面的一些配置即可。</p>
<p>参考文献：</p>
<p><a href="https://hexo.io/" target="_blank" rel="external">Hexo</a><br><a href="http://sunwhut.com/2015/10/30/buildBlog/?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">如何利用GitHub Pages和Hexo快速搭建个人博客</a><br><a href="http://theme-next.iissnan.com/" target="_blank" rel="external">Next主题</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Git操作手册|命令速查表]]></title>
      <url>http://www.ezlippi.com/blog/2016/02/git-guide.html</url>
      <content type="html"><![CDATA[<p>这篇文章主要介绍Git分布式版本管理与集中式管理的一些差异，总结下Git常用命令作为日后的速查表，最后介绍Git进阶的一些案例。<br>本文分为以下几个部分：</p>
<ol>
<li>Git与SVN差异</li>
<li>Git常用命令</li>
<li>Git进阶指南</li>
</ol>
<a id="more"></a>
<h2 id="Git与SVN差异"><a href="#Git与SVN差异" class="headerlink" title="Git与SVN差异"></a>Git与SVN差异</h2><p>Git的第一个版本是Linux之父Linus Torvalds亲手操刀设计和实现的,Git 基于 DAG 结构 (Directed Acyclic Graph)，其运行起来相当的快,它已经是现在的主流。</p>
<p>Git 和 SVN 思想最大的差别有四个：</p>
<ul>
<li>去中心化</li>
<li>直接记录快照，而非差异</li>
<li>不一样的分支概念</li>
<li>三个文件状态</li>
</ul>
<p><strong>去中心化</strong></p>
<p>Git是一个DVCS（分布式版本管理系统），在技术层面上并不存在一个像中心仓库这样的东西 ， 所有的数据都在本地，不存在谁是中心</p>
<p><img src="/images/images/git.gif" alt=""></p>
<p>图中每个开发者拉取(pull)并推送(push)到origin。但除了这种集中式的推送拉取关系，每个开发者也可能会从其他的开发者处拉取代码的变更，从技术上讲，这意味着Alice定义了一个名为bob的Git的remote，它指向了Bob的软件仓库。反之亦然。</p>
<p><strong>直接记录快照，而非差异</strong></p>
<p>Git每一个版本都是直接记录快照，而非文件的差异。 下面两个对比图在网上是广为流传大家应该熟悉：</p>
<p>SVN：</p>
<p><img src="/images/images/svn.png" alt=""></p>
<p>Git:</p>
<p><img src="/images/images/gitgit.png" alt=""></p>
<p>Git使用SHA-1算法计算数据的校验和，通过文件的内容或目录计算出SHA-1哈希值，作为指纹字符串，每个Version 都是一个快照。</p>
<p><strong>不一样的分支概念</strong></p>
<p>Git的分支本质是一个指向提交快照的指针，是从某个提交快照往回看的历史。当创建/切换分支的时候，只是变换了指针指向而已.而SVN创建一个分支， 是的的确确的复制了一份文件。</p>
<p><strong>三个文件状态</strong></p>
<p>在Git中文件有三种状态：</p>
<ul>
<li>已提交（committed）：该文件被安全地保存在了本地数据库</li>
<li>已修改（modified）：修改了某个文件，但还没有保存</li>
<li>已暂存（staged）：把已修改的文件放下下次保存的清单中</li>
</ul>
<h2 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h2><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>复制一个已创建的仓库:</p>
<pre><code>$ git clone ssh://user@domain.com/repo.git
</code></pre><p>创建一个新的本地仓库:</p>
<pre><code>$ git init
</code></pre><h2 id="本地修改"><a href="#本地修改" class="headerlink" title="本地修改"></a>本地修改</h2><p>显示工作路径下已修改的文件：</p>
<pre><code>$ git status
</code></pre><p>显示与上次提交版本文件的不同：</p>
<pre><code>$ git diff
</code></pre><p>把当前所有修改添加到下次提交中：</p>
<pre><code>$ git add
</code></pre><p>把对某个文件的修改添加到下次提交中：</p>
<pre><code>$ git add -p &lt;file&gt;
</code></pre><p>提交本地的所有修改：</p>
<pre><code>$ git commit -a
</code></pre><p>提交之前已标记的变化：</p>
<pre><code>$ git commit
</code></pre><p>附加消息提交：</p>
<pre><code>$ git commit -m &apos;message here&apos;
</code></pre><p>提交，并将提交时间设置为之前的某个日期:</p>
<pre><code>git commit --date=&quot;`date --date=&apos;n day ago&apos;`&quot; -am &quot;Commit Message&quot;
</code></pre><h2 id="修改上次提交"><a href="#修改上次提交" class="headerlink" title="修改上次提交"></a>修改上次提交</h2><p>请勿修改已发布的提交记录!</p>
<pre><code>$ git commit --amend
</code></pre><p>把当前分支中未提交的修改移动到其他分支</p>
<pre><code>git stash
git checkout branch2
git stash pop
</code></pre><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><p>从当前目录的所有文件中查找文本内容：</p>
<pre><code>$ git grep &quot;Hello&quot;
</code></pre><p>在某一版本中搜索文本：</p>
<pre><code>$ git grep &quot;Hello&quot; v2.5
</code></pre><h2 id="提交历史"><a href="#提交历史" class="headerlink" title="提交历史"></a>提交历史</h2><p>从最新提交开始，显示所有的提交记录（显示hash， 作者信息，提交的标题和时间）：</p>
<pre><code>$ git log
</code></pre><p>显示所有提交（仅显示提交的hash和message）：</p>
<pre><code>$ git log --oneline
</code></pre><p>显示某个用户的所有提交：</p>
<pre><code>$ git log --author=&quot;username&quot;
</code></pre><p>显示某个文件的所有修改：</p>
<pre><code>$ git log -p &lt;file&gt;
</code></pre><p>谁，在什么时间，修改了文件的什么内容：</p>
<pre><code>$ git blame &lt;file&gt;
</code></pre><h2 id="分支与标签"><a href="#分支与标签" class="headerlink" title="分支与标签"></a>分支与标签</h2><p>列出所有的分支：</p>
<pre><code>$ git branch
</code></pre><p>切换分支：</p>
<pre><code>$ git checkout &lt;branch&gt;
</code></pre><p>创建并切换到新分支:</p>
<pre><code>$ git checkout -b &lt;branch&gt;
</code></pre><p>基于当前分支创建新分支：</p>
<pre><code>$ git branch &lt;new-branch&gt;
</code></pre><p>基于远程分支创建新的可追溯的分支：</p>
<pre><code>$ git branch --track &lt;new-branch&gt; &lt;remote-branch&gt;
</code></pre><p>删除本地分支:</p>
<pre><code>$ git branch -d &lt;branch&gt;
</code></pre><p>给当前版本打标签：</p>
<pre><code>$ git tag &lt;tag-name&gt;
</code></pre><h2 id="更新与发布"><a href="#更新与发布" class="headerlink" title="更新与发布"></a>更新与发布</h2><p>列出当前配置的远程端：</p>
<pre><code>$ git remote -v
</code></pre><p>显示远程端的信息：</p>
<pre><code>$ git remote show &lt;remote&gt;
</code></pre><p>添加新的远程端：</p>
<pre><code>$ git remote add &lt;remote&gt; &lt;url&gt;
</code></pre><p>下载远程端版本，但不合并到HEAD中：</p>
<pre><code>$ git fetch &lt;remote&gt;
</code></pre><p>下载远程端版本，并自动与HEAD版本合并：</p>
<pre><code>$ git remote pull &lt;remote&gt; &lt;url&gt;
</code></pre><p>将远程端版本合并到本地版本中：</p>
<pre><code>$ git pull origin master
</code></pre><p>将本地版本发布到远程端：</p>
<pre><code>$ git push remote &lt;remote&gt; &lt;branch&gt;
</code></pre><p>删除远程端分支：</p>
<pre><code>$ git push &lt;remote&gt; :&lt;branch&gt; (since Git v1.5.0)
或
git push &lt;remote&gt; --delete &lt;branch&gt; (since Git v1.7.0)
</code></pre><p>发布标签:</p>
<pre><code>$ git push --tags
</code></pre><h2 id="合并与重置"><a href="#合并与重置" class="headerlink" title="合并与重置"></a>合并与重置</h2><p>将分支合并到当前HEAD中：</p>
<pre><code>$ git merge &lt;branch&gt;
</code></pre><p>将当前HEAD版本重置到分支中:<br>请勿重置已发布的提交!</p>
<pre><code>$ git rebase &lt;branch&gt;
</code></pre><p>退出重置:</p>
<pre><code>$ git rebase --abort
</code></pre><p>解决冲突后继续重置：</p>
<pre><code>$ git rebase --continue
</code></pre><p>使用配置好的merge tool 解决冲突：</p>
<pre><code>$ git mergetool
</code></pre><p>在编辑器中手动解决冲突后，标记文件为已解决冲突</p>
<pre><code>$ git add &lt;resolved-file&gt;
$ git rm &lt;resolved-file&gt;
</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><p>放弃工作目录下的所有修改：</p>
<pre><code>$ git reset --hard HEAD
</code></pre><p>移除缓存区的所有文件（i.e. 撤销上次git add）:</p>
<pre><code>$ git reset HEAD
</code></pre><p>放弃某个文件的所有本地修改：</p>
<pre><code>$ git checkout HEAD &lt;file&gt;
</code></pre><p>重置一个提交（通过创建一个截然不同的新提交）</p>
<pre><code>$ git revert &lt;commit&gt;
</code></pre><p>将HEAD重置到指定的版本，并抛弃该版本之后的所有修改：</p>
<pre><code>$ git reset --hard &lt;commit&gt;
</code></pre><p>将HEAD重置到上一次提交的版本，并将之后的修改标记为未添加到缓存区的修改：</p>
<pre><code>$ git reset &lt;commit&gt;
</code></pre><p>将HEAD重置到上一次提交的版本，并保留未提交的本地修改：</p>
<pre><code>$ git reset --keep &lt;commit&gt;
</code></pre><h2 id="Git进阶指南"><a href="#Git进阶指南" class="headerlink" title="Git进阶指南"></a>Git进阶指南</h2><h2 id="问：如何修改-origin-仓库信息？"><a href="#问：如何修改-origin-仓库信息？" class="headerlink" title="问：如何修改 origin 仓库信息？"></a>问：如何修改 origin 仓库信息？</h2><h3 id="1、添加-origin-仓库信息"><a href="#1、添加-origin-仓库信息" class="headerlink" title="1、添加 origin 仓库信息"></a>1、添加 origin 仓库信息</h3><pre><code>git remote add origin &lt;git仓库地址&gt;
</code></pre><h3 id="2、查看-origin-仓库信息"><a href="#2、查看-origin-仓库信息" class="headerlink" title="2、查看 origin 仓库信息"></a>2、查看 origin 仓库信息</h3><pre><code>#以下三种方式均可
git config get --remote.origin.url
git remote -v
git remote show origin
</code></pre><h3 id="3、删除-origin-仓库信息"><a href="#3、删除-origin-仓库信息" class="headerlink" title="3、删除 origin 仓库信息"></a>3、删除 origin 仓库信息</h3><pre><code>git remote rm origin
</code></pre><h2 id="问：如何配置-git-ssh-keys-？"><a href="#问：如何配置-git-ssh-keys-？" class="headerlink" title="问：如何配置 git ssh keys ？"></a>问：如何配置 git ssh keys ？</h2><p>在本地生成 ssh 私钥 / 公钥 文件<br>将「公钥」添加到 git 服务（github、gitlab、coding.net 等）网站后台<br>测试 git ssh 连接是否成功<br>接下来以添加 github ssh keys 为例，请注意替换 github 文件名。</p>
<p>注：如果对密钥机制不熟悉，建议不要指定 -f 参数，直接使用默认的 id_rsa 文件名。</p>
<pre><code>#运行以下命令，一直回车，文件名可随意指定
ssh-keygen -t rsa -b 4096 -C &quot;kaiye@macbook&quot; -f ~/.ssh/github

#如果不是默认密钥 id_rsa ，则需要以下命令注册密钥文件，-K 参数将密钥存入 Mac Keychain
ssh-add -K ~/.ssh/github

#将 pub 公钥的内容粘贴到线上网站的后台
cat ~/.ssh/github.pub

#测试 git ssh 是否连接成功
ssh -T git@github.com
</code></pre><h2 id="问：如何撤销修改？"><a href="#问：如何撤销修改？" class="headerlink" title="问：如何撤销修改？"></a>问：如何撤销修改？</h2><p>  修改包含四种情况，需单独区分。</p>
<h3 id="1、新建的文件和目录，且从未提交至版本库"><a href="#1、新建的文件和目录，且从未提交至版本库" class="headerlink" title="1、新建的文件和目录，且从未提交至版本库"></a>1、新建的文件和目录，且从未提交至版本库</h3><p>  此类文件的状态为 Untracked files ，撤销方法如下：</p>
<pre><code>git clean -fd .
</code></pre><p>其中，. 表示当前目录及所有子目录中的文件，也可以直接指定对应的文件路径，以下其他情况类似。</p>
<h3 id="2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）"><a href="#2、提交过版本库，但未提交至暂存区的文件（未执行-git-add）" class="headerlink" title="2、提交过版本库，但未提交至暂存区的文件（未执行 git add）"></a>2、提交过版本库，但未提交至暂存区的文件（未执行 git add）</h3><p>  此类文件的状态为<code>Changes not staged for commit</code>，撤销方法：</p>
<pre><code>git checkout .
</code></pre><h3 id="3、已提交至暂存区的文件"><a href="#3、已提交至暂存区的文件" class="headerlink" title="3、已提交至暂存区的文件"></a>3、已提交至暂存区的文件</h3><p>  此类文件的状态为 Changes to be committed，撤销方法：</p>
<pre><code>git reset .
</code></pre><p>执行之后文件将会回到以上的 1 或者 2 状态，可继续按以上步骤执行撤销，若 git reset 同时加上 –hard 参数，将会把修改过的文件也还原成版本库中的版本。</p>
<h3 id="4、已提交至版本库（执行了-git-commit）"><a href="#4、已提交至版本库（执行了-git-commit）" class="headerlink" title="4、已提交至版本库（执行了 git commit）"></a>4、已提交至版本库（执行了 git commit）</h3><p>  每次提交都会生成一个 hash 版本号，通过以下命令可查阅版本号并将其回滚：</p>
<pre><code>git log
git reset &lt;版本号&gt;
</code></pre><p>如果需要「回滚至上一次提交」，可直接使用以下命令：</p>
<pre><code>git reset head~1
</code></pre><p>执行之后，再按照 1 或者 2 状态进行处理即可，如果回滚之后的代码同时需要提交至 origin 仓库（即回滚 origin 线上仓库的代码），需要使用 -f 强制提交参数，且当前用户需要具备「强制提交的权限」。</p>
<h3 id="5、如果回滚了之后又不想回滚了怎么办？"><a href="#5、如果回滚了之后又不想回滚了怎么办？" class="headerlink" title="5、如果回滚了之后又不想回滚了怎么办？"></a>5、如果回滚了之后又不想回滚了怎么办？</h3><p>  如果是以上的情况 1 或者 2，只能歇屁了，因为修改没入过版本库，无法回滚。</p>
<p>  如果是情况 4，回滚之后通过 git log 将看不到回滚之前的版本号，但可通过 git reflog 命令（所有使用过的版本号）找到回滚之前的版本号，然后 git reset &lt;版本号&gt; 。</p>
<h2 id="问：遇到冲突了怎么解决？"><a href="#问：遇到冲突了怎么解决？" class="headerlink" title="问：遇到冲突了怎么解决？"></a>问：遇到冲突了怎么解决？</h2><p>  两个分支进行合并时（通常是 git pull 时），可能会遇到冲突，同时被修改的文件会进入 Unmerged 状态，需要解决冲突。</p>
<h3 id="1、最快的办法"><a href="#1、最快的办法" class="headerlink" title="1、最快的办法"></a>1、最快的办法</h3><p>  大部分时候，「最快解决冲突」的办法是：使用当前 HEAD 的版本（ours），或使用合并进来的分支版本（theirs）。</p>
<pre><code># 使用当前分支 HEAD 版本，通常是冲突源文件的 &lt;&lt;&lt;&lt;&lt;&lt;&lt; 标记部分，======= 的上方
git checkout --ours &lt;文件名&gt;

 # 使用合并分支版本，通常是源冲突文件的 &gt;&gt;&gt;&gt;&gt;&gt;&gt; 标记部分
 git checkout --theirs &lt;文件名&gt;

# 标记为解决状态加入暂存区
git add &lt;文件名&gt;
</code></pre><h3 id="2、最通用的办法"><a href="#2、最通用的办法" class="headerlink" title="2、最通用的办法"></a>2、最通用的办法</h3><p>  用编辑器打开冲突的源文件进行修改，可能会发生遗留，且体验不好，通常需要借助 git mergetool 命令。</p>
<p>  在 Mac 系统下，运行 git mergetool &lt;文件名&gt; 可以开启配置的第三方工具进行 merge，默认的是 FileMerge 应用程序，还可以配置成 Meld 或 kdiff3，体验更佳。</p>
<h3 id="3、最好的习惯"><a href="#3、最好的习惯" class="headerlink" title="3、最好的习惯"></a>3、最好的习惯</h3><p>  有三个好的习惯，可以减少代码的冲突：<br> 在开始修改代码前先 git pull 一下；<br>  将业务代码进行划分，尽量不要多个人在同一时间段修改同一文件；<br>  通过Gitflow 工作流也可以提升 git流程效率，减少发生冲突的可能性。</p>
<h3 id="4、最复杂的情况"><a href="#4、最复杂的情况" class="headerlink" title="4、最复杂的情况"></a>4、最复杂的情况</h3><p>  如果你的项目周期比较长，还应该养成「定期 rebase 的习惯」，git pull –rebase 可以让分支的代码和 origin 仓库的代码保持兼容，同时还不会破坏线上代码的可靠性。</p>
<p>  它的大概原理是，先将 origin 仓库的代码按 origin 的时间流在本地分支中提交，再将本地分支的修改记录追加到 origin 分支上。如果发生冲突，则可以即时的发现问题并解决，否则到项目上线时再解决冲突，可能会发生额外的风险。</p>
<p>  rebase 大概的操作步骤如下：</p>
<pre><code># 将当前分支的版本追加到从远程 pull 回来的节点之后
git pull --rebase

# 若发生冲突，则按以上其他方法进行解决，解决后继续
git rebase --continue

# 直到所有冲突得以解决，待项目最后上线前再执行
git push origin

# 若多次提交修改了同一文件，可能需要直接跳过后续提交，按提示操作即可
git rebase --skip
</code></pre><h2 id="问：如何在不提交修改的前提下，执行-pull-merge-等操作？"><a href="#问：如何在不提交修改的前提下，执行-pull-merge-等操作？" class="headerlink" title="问：如何在不提交修改的前提下，执行 pull / merge 等操作？"></a>问：如何在不提交修改的前提下，执行 pull / merge 等操作？</h2><p>  有些修改没有完全完成之前，可能不需要提交到版本库，圡方法是将修改的文件 copy 到 git 仓库之外的目录临时存放，pull / merge 操作完成之后，再 copy 回来。</p>
<p>  这样的做法一个是效率不高，另外一个可能会遗漏潜在的冲突。此类需求最好是通过 git stash 命令来完成，它可以将当前工作状态（WIP，work in progress）临时存放在 stash 队列中，待操作完成后再从 stash 队列中重新应用这些修改。</p>
<p>  以下是 git stash 常用命令：</p>
<pre><code># 查看 stash 队列中已暂存了多少 WIP
git stash list

# 恢复上一次的 WIP 状态，并从队列中移除
git stash pop

# 添加当前 WIP，注意：未提交到版本库的文件会自动忽略，只要不运行 git clean -fd . 就不会丢失
git stash

# 恢复指定编号的 WIP，同时从队列中移除
git stash pop stash@{num}

# 恢复指定编号的 WIP，但不从队列中移除
git stash apply stash@{num}
</code></pre><h2 id="问：如何在-git-log-中查看修改的文件列表？"><a href="#问：如何在-git-log-中查看修改的文件列表？" class="headerlink" title="问：如何在 git log 中查看修改的文件列表？"></a>问：如何在 git log 中查看修改的文件列表？</h2><p>  默认的 git log 会显示较全的信息，且不包含文件列表。使用 –name-status 可以看到修改的文件列表，使用 –oneline 可以将参数简化成一行。</p>
<pre><code>git log --name-status --oneline
</code></pre><p>  每次手动加上参数很麻烦，可以通过自定义快捷命令的方式来简化操作：</p>
<pre><code>git config --global alias.ls &apos;log --name-status --oneline --graph&apos;
</code></pre><p>  运行以上配置后，可通过 git ls 命令来实现「自定义 git log」效果，通过该方法也可以创建 git st 、 git ci 等一系列命令，以便沿用 svn 命令行习惯。</p>
<pre><code>git config --global alias.st &apos;status --porcelain&apos;
</code></pre><p>  更多 git log 参数，可通过 git help log 查看手册。</p>
<p>  如果是看上一次提交的版本日志，直接运行 git show 即可。</p>
<p>  此外，如果你的 Mac 安装了zsh（参考《全新Mac安装指南（编程篇），那么可以直接使用 gst、glog 等一系列快捷命令，详情见此列表：Plugin:git 。</p>
<h2 id="问：git-submodule-update-时出错怎么解决？"><a href="#问：git-submodule-update-时出错怎么解决？" class="headerlink" title="问：git submodule update 时出错怎么解决？"></a>问：git submodule update 时出错怎么解决？</h2><p>  例如，在执行 git submodule update 时有以下错误信息：</p>
<blockquote>
<p>fatal: reference is not a tree: f869da471c5d8a185cd110bbe4842d6757b002f5<br>Unable to checkout ‘f869da471c5d8a185cd110bbe4842d6757b002f5’ in submodule path ‘source/i18n-php-server’</p>
</blockquote>
<p>  在此例中，发生以上错误是因为 i18n-php-server 子仓库在某电脑 A 的「本地」commit 了新的版本 「f869da471c5d8a185cd110bbe4842d6757b002f5」，且该次 commit 未 push origin。但其父级仓库 i18n-www 中引用了该子仓库的版本号，且将引用记录 push origin，导致其他客户机无法 update 。</p>
<p>  解决方法，在电脑 A 上将 i18n-php-server 版本库 push origin 后，在其他客户机上执行 git submodule update 。或者用以上提到的 git reset 方法，将子仓库的引用版本号还原成 origin 上存在的最新版本号。</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>  设置本地分支与远程分支保持同步，在第一次 git push 的时候带上 -u 参数即可</p>
<pre><code>git push origin master -u 
</code></pre><p>  支持中文目录与文件名的显示（git 默认将非 ASCII 编码的目录与文件名以八进制编码展示）</p>
<pre><code>git config core.quotepath off
</code></pre><p>  常用的打 tag 操作，更多请查看《Git 基础 - 打标签》</p>
<pre><code># 列出所有本地 tag
git tag   

# 本地新增一个 tag，推送至 origin 服务器
git tag -a v1.0.0 -m &apos;tag description&apos;
git push origin v1.0.0

# 删除本地与 origin tag
git tag -d v1.0.0
git push origin --delete v1.0.0
</code></pre><p>  使用 git GUI 客户端（如，SoureTree、Github Desktop）能极大的提升分支管理效率。分支合并操作通常只有两种情况：从 origin merge 到本地，使用 git pull 即可；从另外一个本地分支 merge 到当前分支，使用 git merge &lt;分支名&gt;，以下是常用命令：</p>
<pre><code># 新建分支 branch1，并切换过去
git checkout -b branch1

# 查看所有本地与远程分支
git branch -a

# 修改完成后，切换回 master 分支，将 branch1 分支合并进来
git checkout master
git merge branch1

# 删除已完成合并的分支 branch1
git branch -d branch1
</code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li>Pro Git 简体中文版</li>
<li>Git权威指南</li>
<li>命令行man手册</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[解决百度爬虫无法抓取github pages]]></title>
      <url>http://www.ezlippi.com/blog/2016/02/baidu-spider-forbidden.html</url>
      <content type="html"><![CDATA[<p>由于Github Pages禁止了百度爬虫，导致自己的博客无法被百度索引到，使用七牛云和又拍云做镜像存储能解决问题，但是要求域名要备案，由于我的域名从Godaddy上购买的，国内备案手续太复杂，故放弃了CDN的办法，琢磨了一段时间找到了Gitcafe的解决办法。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>既然不想放弃Github，唯一的办法就是不让百度爬虫直接抓取GIthub的内容，而是抓取自己网站的一个镜像，将网站的内容镜像到<a href="www.gitcafe.com">gitcafe</a>,步骤如下：</p>
<a id="more"></a>
<ul>
<li>注册 gitcafe 帐号</li>
<li>创建一个跟用户名一样的项目,比如我的<a href="https://gitcafe.com/ezlippi/ezlippi" target="_blank" rel="external">https://gitcafe.com/ezlippi/ezlipp</a></li>
<li>把 github 的项目推到 gitcafe 上面去，步骤如下：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitcafe https://gitcafe.com/ezlippi/ezlippi.git</span><br><span class="line">git checkout -b gitcafe-pages</span><br><span class="line">切换到一个新分支 <span class="string">'gitcafe-pages'</span></span><br><span class="line">git push gitcafe master:gitcafe-pages</span><br><span class="line">Username <span class="keyword">for</span> <span class="string">'https://gitcafe.com'</span>:ezlippi </span><br><span class="line">Password <span class="keyword">for</span> <span class="string">'https://ezlippi@gitcafe.com'</span></span><br><span class="line">Counting objects: 17, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (10/10), done.</span><br><span class="line">Writing objects: 100% (10/10), 1.06 KiB | 0 bytes/s, done.</span><br><span class="line">Total 10 (delta 8), reused 0 (delta 0)</span><br><span class="line">To https://gitcafe.com/ezlippi/ezlippi.git</span><br><span class="line">   f0d0296..51611d7  master -&gt; gitcafe-pages</span><br></pre></td></tr></table></figure>
<ul>
<li>gitcafe绑定自己的域名</li>
</ul>
<ol>
<li>点击项目的右上角的 项目配置</li>
<li>在项目的 基础设置 中配置项目主页</li>
<li>在 page服务 中添加自己的域名，比如我这里是<a href="coolshell.info">coolshell.info</a>和<a href="www.coolshell.info">www.coolshell.info</a>.</li>
</ol>
<ul>
<li>DNS的配置中增加一项 CNAME.</li>
</ul>
<p>我使用 dnspod 这个提供商来管理DNS.CNAME一般可以按解析路线或者网络类型来单独配置,网络类型选择国内或者联通，设置之后等待一段时间百度的抓取就 恢复正常了，如下图所示：</p>
<p><img src="/images/dnspod.png" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu下Apache服务器的配置]]></title>
      <url>http://www.ezlippi.com/blog/2016/01/apache-configuration-in-ubuntu.html</url>
      <content type="html"><![CDATA[<h2 id="安装Apache"><a href="#安装Apache" class="headerlink" title="安装Apache"></a>安装Apache</h2><a id="more"></a>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install apache2</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">打开浏览器输入你的IP地址或者localhost,就会进入到Apache服务器的默认Index页面。结果如下所示：</span><br><span class="line"></span><br><span class="line">&gt; It works!</span><br><span class="line">&gt; This is the default web page <span class="keyword">for</span> this server.</span><br><span class="line">&gt; The web server software is running but no content has been added, yet.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 配置文件</span></span><br><span class="line"></span><br><span class="line">在Ubuntu系统下Apache的主要配置文件在/etc/apache2文件夹下：</span><br><span class="line"></span><br><span class="line">``` bash</span><br><span class="line"><span class="built_in">cd</span> /etc/apache2</span><br><span class="line">ls -F</span><br></pre></td></tr></table></figure>
<blockquote>
<p>apache2.conf  envvars     magic            mods-enabled/  sites-available/<br>conf.d/       httpd.conf  mods-available/  ports.conf     sites-enabled/</p>
</blockquote>
<p>这个目录下有许多纯文本文件和子目录，基本作用如下：</p>
<ul>
<li>apache2.conf:这是服务器的主要配置文件，几乎所有的配置都通过这个文件来完成，但是为了简洁推荐使用单独的指定的文件来配置不同的模块。</li>
<li>ports.conf:这个文件用来指定虚拟主机监听的端口号，如果你配置了SSL的时候要检查这个文件是否正确。</li>
<li>conf.d/:这个目录用来控制Apache的一些特殊配置，比如SSL配置。</li>
<li>sites-available/:这个目录包括所有不同web站点的虚拟主机文件，不同的请求对应不同的内容，这些都是已有的，并不是正在使用的。</li>
<li>sites-enabled/:这个目录包含正在使用的虚拟主机的定义，通常只包含到sites-available目录下文件的符号链接。</li>
<li>mods-[enabled,available]/:和上面的类似，只不过这里面包含的是可用的模块。</li>
</ul>
<p>从Apache的配置目录结构可以知道，它并不是通过单一的文件来配置，贰拾通过模块化来把整个系统拆分成不同的功能，从而能够动态地增加和修改功能。</p>
<h2 id="深入Apache2-conf文件内容"><a href="#深入Apache2-conf文件内容" class="headerlink" title="深入Apache2.conf文件内容"></a>深入Apache2.conf文件内容</h2><p>文件主要分成三部分，全局配置、默认服务器配置和虚拟主机配置，在Ubuntu系统下，这个文件主要负责全局配置，默认服务器和虚拟主机可以通过Include语句来处理。</p>
<p>Include语句允许Apache读取其他配置文件的内容到当前位置，结果就是Apache启动的时候动态生成一个配置文件，如果拉到文件底部会看到很多Include语句，比如ports.conf等。</p>
<h3 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h3><h4 id="Timeout"><a href="#Timeout" class="headerlink" title="Timeout"></a>Timeout</h4><p>这个参数默认设置为300，意思是服务器有300s来处理每个请求。</p>
<h4 id="KeepAlive"><a href="#KeepAlive" class="headerlink" title="KeepAlive"></a>KeepAlive</h4><p>如果设置为On，将允许同个客户端每个连接一直保持来处理多个请求(HTTP长连接)</p>
<h4 id="MaxKeepAliveRequests"><a href="#MaxKeepAliveRequests" class="headerlink" title="MaxKeepAliveRequests"></a>MaxKeepAliveRequests</h4><p>这个参数用来设置每个连接最多能处理多少个单独的请求</p>
<h4 id="KeepAliveTimeout"><a href="#KeepAliveTimeout" class="headerlink" title="KeepAliveTimeout"></a>KeepAliveTimeout</h4><p>这个参数设置下一个请求来之前来等待多久，超过这个时间自动关闭这个connection。</p>
<h2 id="MPM-配置"><a href="#MPM-配置" class="headerlink" title="MPM 配置"></a>MPM 配置</h2><p>Ubuntu 14.04下MPM(Multi-Processing Module)配置默认采用了event module,如果你系统采用的是prefork module,可以通过如下方法来切换：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo a2dismod mpm_prefork</span><br><span class="line">sudo a2enmod mpm_event</span><br><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure>
<h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>1.首先禁用默认的Apache虚拟主机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2dissite 000-default.conf</span><br></pre></td></tr></table></figure>
<p>2.在/etc/apache2/sites-available目录下创建一个example.com.conf文件，把example.com替换成你的域名：</p>
<p>文件：/etc/apache2/sites-available/example.com.conf</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;VirtualHost *:80&gt; </span><br><span class="line">  ServerAdmin webmaster@example.com</span><br><span class="line">  ServerName example.com</span><br><span class="line">  ServerAlias www.example.com</span><br><span class="line">  DocumentRoot /var/www/example.com/public_html/</span><br><span class="line">  ErrorLog /var/www/example.com/logs/error.log </span><br><span class="line">  CustomLog /var/www/example.com/logs/access.log combined</span><br><span class="line"> &lt;/VirtualHost&gt;</span><br></pre></td></tr></table></figure>
<p> 3.给你的网站内容和日志文件创建目录，把example.com替换成你的域名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /var/www/example.com/public_html</span><br><span class="line">sudo mkdir /var/www/example.com/logs</span><br></pre></td></tr></table></figure>
<p> 4.启用这个站点：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2ensite example.com.conf</span><br></pre></td></tr></table></figure>
<p> 5.重启Apache</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br></pre></td></tr></table></figure>
<p> <em>安装对脚本语言的支持</em></p>
<ul>
<li>Perl support:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-perl2</span><br></pre></td></tr></table></figure>
<ul>
<li>Python support:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-python</span><br></pre></td></tr></table></figure>
<ul>
<li>PHP support:</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install libapache2-mod-php5 php5 php-pear php5-xcache</span><br></pre></td></tr></table></figure>
<h3 id="Apache中启用和禁用网站和模块"><a href="#Apache中启用和禁用网站和模块" class="headerlink" title="Apache中启用和禁用网站和模块"></a>Apache中启用和禁用网站和模块</h3><p>1.启用和禁用网站：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo a2ensite 虚拟主机文件名(example.com.conf)</span><br><span class="line">sudo a2dissite 虚拟主机文件名(example.com.conf)</span><br></pre></td></tr></table></figure>
<p>2.启用和禁用模块</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod 模块配置文件名</span><br><span class="line">sudo a2dismod  模块配置文件名</span><br></pre></td></tr></table></figure>
<h2 id="启用用户文件夹实现文件服务器的功能"><a href="#启用用户文件夹实现文件服务器的功能" class="headerlink" title="启用用户文件夹实现文件服务器的功能"></a>启用用户文件夹实现文件服务器的功能</h2><p>1.使用如下命令启用userdir模块:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo a2enmod userdir</span><br></pre></td></tr></table></figure>
<p>2.编辑userdir.conf配置userdir模块:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/apache2/mods-enabled/userdir.conf</span><br></pre></td></tr></table></figure>
<p>内容如下，把public_html改为你的个人文件夹名称，如果不存在则创建：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_userdir.c&gt;</span><br><span class="line">        UserDir public_html</span><br><span class="line">        UserDir disabled root</span><br><span class="line"> </span><br><span class="line">        &lt;Directory /home/*/public_html&gt;</span><br><span class="line">		AllowOverride All</span><br><span class="line">		Options MultiViews Indexes SymLinksIfOwnerMatch</span><br><span class="line">		&lt;Limit GET POST OPTIONS&gt;</span><br><span class="line">			<span class="comment"># Apache &lt;= 2.2:</span></span><br><span class="line">		        Order allow,deny</span><br><span class="line">		        Allow from all</span><br><span class="line"> </span><br><span class="line">		        <span class="comment"># Apache &gt;= 2.4:</span></span><br><span class="line">		        <span class="comment">#Require all granted</span></span><br><span class="line">		&lt;/Limit&gt;</span><br><span class="line">		&lt;LimitExcept GET POST OPTIONS&gt;</span><br><span class="line">			<span class="comment"># Apache &lt;= 2.2:</span></span><br><span class="line">		        Order deny,allow</span><br><span class="line">		        Deny from all</span><br><span class="line"> </span><br><span class="line">			<span class="comment"># Apache &gt;= 2.4:</span></span><br><span class="line">			<span class="comment">#Require all denied</span></span><br><span class="line">		&lt;/LimitExcept&gt;</span><br><span class="line">        &lt;/Directory&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
<p>3.创建个人文件夹并重启APache</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo service apache2 restart</span><br><span class="line">mkdir /home/<span class="variable">$USER</span>/public_html</span><br></pre></td></tr></table></figure>
<p>接下来在浏览器中输入<a href="http://localhost/~username/就可以访问你的个人文件夹了，把username替换为你的用户名。" target="_blank" rel="external">http://localhost/~username/就可以访问你的个人文件夹了，把username替换为你的用户名。</a></p>
<h3 id="给你的文件添加访问权限"><a href="#给你的文件添加访问权限" class="headerlink" title="给你的文件添加访问权限"></a>给你的文件添加访问权限</h3><p>把上面的AllowOverride All改为AllowOverride AuthConfig,然后给你的服务器添加认证用户，认证用户保存在/var/www/passwd/中，需要使用htpasswd命令来添加用户，如下所示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">htpasswd -c /var/www/passwd/public_html lippi </span><br><span class="line">New password: mypassword</span><br><span class="line">Re-type new password: mypassword</span><br><span class="line">Adding password <span class="keyword">for</span> user lippi</span><br></pre></td></tr></table></figure>
<p>最后的userdir.conf是这样的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;IfModule mod_userdir.c&gt;</span><br><span class="line">	UserDir public_html </span><br><span class="line">	UserDir disabled root</span><br><span class="line"></span><br><span class="line">	&lt;Directory /home/*/public_html&gt;</span><br><span class="line">		AllowOverride FileInfo AuthConfig Limit Indexes</span><br><span class="line">		Options MultiViews Indexes SymLinksIfOwnerMatch IncludesNoExec</span><br><span class="line">		&lt;Limit GET POST OPTIONS&gt;</span><br><span class="line"><span class="comment">#		Require all granted</span></span><br><span class="line">			AuthType Basic</span><br><span class="line">			AuthName <span class="string">"lippi"</span></span><br><span class="line">			AuthUserFile /var/www/passwd/public_html</span><br><span class="line">			Require valid-user</span><br><span class="line">		&lt;/Limit&gt;</span><br><span class="line">		&lt;LimitExcept GET POST OPTIONS&gt;</span><br><span class="line">			Require all denied</span><br><span class="line">		&lt;/LimitExcept&gt;</span><br><span class="line">	&lt;/Directory&gt;</span><br><span class="line">&lt;/IfModule&gt;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[终端复用软件之tmux简介]]></title>
      <url>http://www.ezlippi.com/blog/2016/01/tmux-guide.html</url>
      <content type="html"><![CDATA[<p>  Tmux是一个优秀的终端复用软件，支持多标签，也支持窗口内部面板的分割，更重要的是，Tmux提供了窗体随时保存和恢复的功能。想象一下假如你在公司的服务器上开了许多窗口调试程序，回到家时通过SSH连接公司电脑又要打开一堆繁琐的窗口，而且还忘记了当时调试到哪一步了，那Tmux可以帮你解决这个难题，当SSH连接断开重新连接后能够恢复到原来的工作环境。</p>
<a id="more"></a>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install tmux</span><br></pre></td></tr></table></figure>
<p>安装完成后输入tmux进入软件，界面类似一个下方带有状态栏的终端。</p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>  Tmux基于典型的c/s模型，主要分为会话、窗口和面板三个元素：</p>
<ul>
<li>Session：输入tmux后就创建了一个会话，一个会话是一组窗体的集合。</li>
<li>Window：会话中一个可见的窗口。</li>
<li>Pane:一个窗口可以分成多个面板。</li>
</ul>
<p><img src="/images/images/tmux.jpg" alt=""></p>
<p>图中左下角的3显示为当前会话，随后1 vim,2 bash,3 ssh 分别是3个窗口，蓝色bash表示当前窗口，图中用蓝色数字标记的1,2,3分别是bash窗口的三个面板。你还可以在tmux配置文件中给状态栏添加时间、天气等信息。</p>
<h2 id="Tmux基本操作"><a href="#Tmux基本操作" class="headerlink" title="Tmux基本操作"></a>Tmux基本操作</h2><p>Tmux的所有操作必须使用一个前缀进入命令模式，默认前缀为Ctrl+b，很多人会改为Ctrl+a,你可以修改tmux.conf配置文件来修改默认前缀：</p>
<figure class="highlight vim"><figcaption><span>Script </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 前缀设置为<span class="symbol">&lt;Ctrl-a&gt;</span></span><br><span class="line"><span class="keyword">set</span> -g prefix C-<span class="keyword">a</span></span><br><span class="line"># 解除<span class="symbol">&lt;Ctrl-b&gt;</span></span><br><span class="line">ubind C-<span class="keyword">b</span></span><br></pre></td></tr></table></figure>
<p>修改之后重启Tmux生效，或者先按Ctrl+b，然后输入：，进入命令行模式， 在命令行模式下输入：</p>
<figure class="highlight vim"><figcaption><span>Script </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span>-<span class="keyword">file</span> ~/.tmux.<span class="keyword">conf</span></span><br></pre></td></tr></table></figure>
<p>你也可以在配置文件中加入下面这句话，以后改了配置文件只需要按前缀+r了。</p>
<figure class="highlight"><figcaption><span>Script </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将r 设置为加载配置文件，并显示"reloaded!"信息</span><br><span class="line">bind r source-file ~/.tmux.conf \; display "Reloaded!"</span><br></pre></td></tr></table></figure>
<p>加入如下几条语句， 现在切换面板就和vim一样了：</p>
<figure class="highlight vim"><figcaption><span>Script </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">map</span> Vi movement <span class="built_in">keys</span> <span class="keyword">as</span> pane movement <span class="built_in">keys</span></span><br><span class="line">bind h select-pane -L</span><br><span class="line">bind <span class="keyword">j</span> select-pane -D</span><br><span class="line">bind <span class="keyword">k</span> select-pane -U</span><br><span class="line">bind <span class="keyword">l</span> select-pane -R</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 复制/粘贴</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 按前缀+[ 进入复制模式</span><br><span class="line"><span class="number">2</span>. 按 space 开始复制，移动光标选择复制区域</span><br><span class="line"><span class="number">3</span>. 按 Enter 复制并退出<span class="keyword">copy</span>-<span class="keyword">mode</span>。</span><br><span class="line"><span class="number">4</span>. 将光标移动到指定位置，按前缀+ ] 粘贴</span><br><span class="line"></span><br><span class="line">如果把tmux比作<span class="keyword">vim</span>的话，那么我们大部分时间都是处于编辑模式，只需要在配置文件(~/.tmux.<span class="keyword">conf</span>)中加入如下行即可以像 <span class="keyword">vim</span>一样使用hjkl移动:</span><br><span class="line"></span><br><span class="line">``` Vim Script </span><br><span class="line">#copy-<span class="keyword">mode</span> 将快捷键设置为<span class="keyword">vi</span> 模式</span><br><span class="line">setw -g <span class="keyword">mode</span>-<span class="built_in">keys</span> <span class="keyword">vi</span></span><br></pre></td></tr></table></figure>
<h2 id="会话的创建和保存"><a href="#会话的创建和保存" class="headerlink" title="会话的创建和保存"></a>会话的创建和保存</h2><ul>
<li>终端运行tmux + 会话名，创建或打开会话</li>
<li>前缀 + d 退出并保存会话</li>
</ul>
<h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><ul>
<li>前缀 + c 创建一个新的window</li>
<li>前缀 + b 重命名当前window</li>
<li>前缀 + &amp; 关闭当前window</li>
<li>前缀 + n 移动到下一个窗口</li>
<li>前缀 + p 移动到前一个窗口</li>
<li>前缀 + l 切换到上一个窗口</li>
</ul>
<h2 id="面板操作"><a href="#面板操作" class="headerlink" title="面板操作"></a>面板操作</h2><p>在配置文件中添加下面两行就可以使用<code>前缀+ |-</code>来水平和垂直分割窗口：</p>
<figure class="highlight vim"><figcaption><span>Script </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># use PREFIX | <span class="keyword">to</span> <span class="keyword">split</span> window horizontally <span class="built_in">and</span> PREFIX - <span class="keyword">to</span> <span class="keyword">split</span> vertically</span><br><span class="line">bind | <span class="keyword">split</span>-window -h</span><br><span class="line">bind - <span class="keyword">split</span>-window -v</span><br></pre></td></tr></table></figure>
<p>添加如下命令到配置文件后后可以使用HJKL来调整窗口大小:</p>
<figure class="highlight vim"><figcaption><span>Script </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">resize</span> panes using PREFIX H, J, K, L</span><br><span class="line">bind H <span class="keyword">resize</span>-pane -L <span class="number">5</span></span><br><span class="line">bind J <span class="keyword">resize</span>-pane -D <span class="number">5</span></span><br><span class="line">bind K <span class="keyword">resize</span>-pane -U <span class="number">5</span></span><br><span class="line">bind L <span class="keyword">resize</span>-pane -R <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>其他操作：</p>
<ul>
<li><ctrl-b> + 方向键，切换窗口</ctrl-b></li>
<li><ctrl-b> + q 显示所有面板</ctrl-b></li>
<li><ctrl-b> + !/x 关闭当前面板</ctrl-b></li>
</ul>
<p>查看所有的按键，使用<code>&lt;Ctrl-b&gt; + ?</code></p>
<h2 id="Tmux个性化"><a href="#Tmux个性化" class="headerlink" title="Tmux个性化"></a>Tmux个性化</h2><p>你可以使用<a href="https://github.com/erikw/tmux-powerline" target="_blank" rel="external">tmux-powerline</a>来美化你的状态栏。</p>
<p>美化之后的效果是这样的：</p>
<p><img src="/images/images/tmux2.jpg" alt=""></p>
<p>最后附上我的tmux配置文件：<a href="https://github.com/LippiOuYang/Profiles/blob/master/tmux.conf" target="_blank" rel="external">.tmux.conf</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[提高效率的Android Studio插件]]></title>
      <url>http://www.ezlippi.com/blog/2015/09/android-studio-plugins.html</url>
      <content type="html"><![CDATA[<p>这里记录那些可以显著提升Android开发效率的Studio插件，好的插件和快捷键可以提高效率，缩短开发周期。这里介绍的插件大部分都可以通过Studio的插件市场下载安装，安装方法如下：<br><a id="more"></a></p>
<ol>
<li><p>in Android Studio: go to Preferences → Plugins → Browse repositories,搜索你要安装的插件</p>
</li>
<li><p>download it and install via Preferences → Plugins → Install plugin from disk</p>
</li>
</ol>
<p>主要的插件：</p>
<p>1.H.A.X.M和GenyMotion这两个网上介绍的比较多，就不说了</p>
<p>2.<a href="https://github.com/avast/android-butterknife-zelezny" target="_blank" rel="external">ButterKnifeZelezny</a></p>
<p>ButterKnife视图注入插件,如果你的Activity布局里面有很多组件，写一堆的findViewById岂不是很烦人，ButterKnife解决了这个烦人的问题,这个插件的效果图如下：</p>
<p><img src="/images/butterknife.gif" alt=""></p>
<p>3.<a href="https://github.com/winterDroid/android-drawable-importer-intellij-plugin" target="_blank" rel="external">android-drawable-importer</a></p>
<p>它可以减少导入缩放图像到Android项目所需的工作量,Android  Drawable Importer添加了一个在不同分辨率导入画板或缩放指定图像到定义分辨率的选项,该插件包含三个主要功能，可以在New下的Android module的任意地方通过右键访问它们：<br>1、引入AndroidIcons Drawable<br>选择资源，指定颜色，改变目标资源名字以及选中所有你想引入的资源。然后会自动创建所有缺失的文件夹，如果已经存在相同名字的drawable，则会进行警告。</p>
<p>2、Scaled Drawable<br>选择资源并指定分辨率。如果你想缩放引入的图片，你应该选择“其他”选项，然后填充目标分辨率和目标宽度/高度。</p>
<p>3、Multisource-Drawable<br>引入不同资源的Drawable，设计者根据如下结构设计不同资源的Drawable zip文件，引入一个zip文件即可引入不同分辨率的Drawable。<br>    root/<br>          ./drawable_ldpi.png<br>          ./drawable_mdpi.png<br>          ./drawable_hdpi.png<br>          ./drawable_xhdpi.png<br>如图所示:<br><img src="/images/drawableimport.png" alt=""></p>
<p>4.<a href="https://github.com/pbreault/adb-idea" target="_blank" rel="external">adb-idea</a><br>支持直接在AS面板中进行ADB操作,快捷键:</p>
<ul>
<li>Mac OSX: Ctrl+Shift+A</li>
<li>Windows/Linux: Ctrl+Alt+Shift+A</li>
</ul>
<p><img src="/images/adb.png" alt=""></p>
<p>5.<a href="https://github.com/inmite/android-selector-chapek" target="_blank" rel="external">SelectorChapek</a></p>
<p>按照命名规范自动生成Selector,如图所示：</p>
<p>如何使用：</p>
<ul>
<li>在资源文件夹下右击，比如’drawable_xhdpi’下：</li>
</ul>
<p><img src="/images/selector1.png" alt=""></p>
<ul>
<li>选择Generate Android Selectors</li>
</ul>
<p><img src="/images/selector2.png" alt=""></p>
<ul>
<li>所有的selector自动出现在drawable文件夹下 </li>
</ul>
<p><img src="/images/selector3.png" alt=""></p>
<p>6.<a href="https://github.com/zzz40500/GsonFormat" target="_blank" rel="external">GsonFormat</a></p>
<p>根据Gson　api接口生成相应的实体类</p>
<p><img src="/images/gson_format.gif" alt=""></p>
<p>7.<a href="https://github.com/mcharmas/android-parcelable-intellij-plugin" target="_blank" rel="external">ParcelableGenerator</a></p>
<p>Android中的序列化有两种方式，分别是实现Serializable接口和Parcelable接口，但在Android中是推荐使用Parcelable，只不过我们这种方式要比Serializable方式要繁琐,这个插件帮助我们解决繁琐的事情。</p>
<p><img src="/images/parcelable_generator.png" alt=""></p>
<p>8.<a href="https://github.com/konifar/android-material-design-icon-generator-plugin" target="_blank" rel="external">android-material-design-icon-generator</a></p>
<p><img src="/images/capture.gif" alt=""></p>
<p>9.<a href="https://github.com/nicoulaj/idea-markdown" target="_blank" rel="external">idea-markdown</a></p>
<p><img src="/images/preview.png" alt=""></p>
<p>10.<a href="ns.jetbrains.com/plugin/7366?pr=">Android Holo Colors Generator</a></p>
<p><img src="/images/holocolor.png" alt=""></p>
<p>11.<a href="https://www.codota.com/" target="_blank" rel="external">Codota</a></p>
<p>搜索代码的插件，他的搜索源，不仅只有Github，而且还有知名博客和开发者网站，让你搜索一个东西，不用在找上半天；</p>
<p>除了搜索功能，首页的下方还罗列比较流行的类库，还提供保存代码的CodeBox，同时还提供了Chrome 插件和Android Studio 插件，最后通过Google，Github，Facebook 任意一个授权登录即可使用；</p>
<p>而且当你点击搜索的结果（Java class）的时候，右侧会显示UML 视图，而且左边的代码如果点击会有高亮现实，而且还会显示Doc，并提供了API Doc 的链接</p>
<p><img src="/images/codota.png" alt=""></p>
<p>12.<a href="https://github.com/JetBrains/ideavim" target="_blank" rel="external">ideaVim</a><br>   有了它之后就可以在Idea里指尖如飞了</p>
<p>13.<a href="https://github.com/square/leakcanary" target="_blank" rel="external">LeakCanary</a></p>
<p>Square最近刚开源的一个非常有用的工具，强烈推荐，帮助你在开发阶段方便的检测出内存泄露的问题，使用起来更简单方便</p>
<p><img src="/images/leak.png" alt=""></p>
<p>14.checkStyle 和　findBugs都还不错</p>
<p>15.如果你像推荐其他插件，可以在本文最上方点击纠错后添加，然后pull request。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Volley源码分析]]></title>
      <url>http://www.ezlippi.com/blog/2015/08/volley-source-code.html</url>
      <content type="html"><![CDATA[<p>说到Android的网络库，比较常用的就是Volley和okHttp了，最近重温了下Volley的源码，感觉应该写点什么．Volley 是 Google 推出的 Android 异步网络请求框架和图片加载框架，适合数据量小通信比较频繁的情形．<br><a id="more"></a><br>先看一下Volley的设计图：</p>
<p><img src="/images/volley.png" alt=""></p>
<h2 id="请求Request"><a href="#请求Request" class="headerlink" title="请求Request"></a>请求Request</h2><p>Volley里面每一个请求都是继承自Request抽象类，比如图中的StringRequest,JsonRequest,ImageRequest,请求最主要的几个属性有：http请求的方法method,请求资源url,是否应该缓存响应shouldCache,如果缓存的话就会有对应的缓存对象Cache.Entry,以及用来标识请求的序列号mSequence,当然这里的每一个请求是异步的，你还需要注册对应的响应监听器，<code>private final Listener&lt;String&gt; mListener;</code>,这个后面再讲．</p>
<h2 id="请求队列"><a href="#请求队列" class="headerlink" title="请求队列"></a>请求队列</h2><p>请求队列是用来管理所有请求的，里面有四个集合类，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个waitingRequest是因为用户可能重复提交了相同的请求，第一次提交一个请求后</span></span><br><span class="line"><span class="comment">//会在这个Map里添加一个key,表示这个请求已经在处理了，如果再提交相同的请求就会</span></span><br><span class="line"><span class="comment">//把这个请求添加到这个key对应的请求队列里，并把第一次的请求加入到缓存队列里，</span></span><br><span class="line"><span class="comment">//后面再发出这个请求就可以从缓存中获取响应了</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line">		<span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br><span class="line"><span class="comment">//用来存储当前所有的请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">//这是个优先队列，存储那些需要缓存的请求，处理这类请求时，先从缓存中查询，</span></span><br><span class="line"><span class="comment">//如果缓存miss再把它丢进networkRequest中从网络中获取数据  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</span><br><span class="line">		<span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"><span class="comment">//这个队列用于存储需要直接从网络中获取数据的请求</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line">		<span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>
<p>上面讲到请求是保存在优先队列中，那么请求按照什么排序呢？自然是优先级了，<br>如果优先级一样就按照序列号排序，先进先出．请求一共有四个优先级，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</span><br><span class="line">        LOW,</span><br><span class="line">	NORMAL,</span><br><span class="line">	HIGH,</span><br><span class="line">	IMMEDIATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>既然是这样那么请求一定实现了java的<code>Comparable</code>接口了，没错，而且正如前面所说请求按照优先级和序列号来排序，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Request&lt;T&gt; other)</span> </span>&#123;</span><br><span class="line">Priority left = <span class="keyword">this</span>.getPriority();</span><br><span class="line">Priority right = other.getPriority();</span><br><span class="line"></span><br><span class="line"><span class="comment">// High-priority requests are "lesser" so they are sorted to the front.</span></span><br><span class="line"><span class="comment">// Equal priorities are sorted by sequence number to provide FIFO ordering.</span></span><br><span class="line"><span class="keyword">return</span> left == right ?</span><br><span class="line">        <span class="keyword">this</span>.mSequence - other.mSequence :</span><br><span class="line">        right.ordinal() - left.ordinal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="请求分派RequestDispatcher"><a href="#请求分派RequestDispatcher" class="headerlink" title="请求分派RequestDispatcher"></a>请求分派RequestDispatcher</h2><p>Volley里面有两个<code>Dispacher</code>,一个是<code>CacheDispatcher</code>,另一个是<code>NetworkDispatcher</code>,两个都是继承自线程，<code>CacheDispatcher</code>启动后从mCacheQueue里取出请求，根据请求的CacheKey(实际上是url)从缓存中检索数据，如果没有检索到数据就把它重新丢进<code>mNetworkQueue</code>中从网络中获取数据，如果缓存命中同时检查下缓存是否过期，如果缓存过期了照样要重新获取数据，否则调用<code>ResponseDelivery</code>把响应传递给相应的对象(实际上是调用请求注册的相应监听器)．<br>Volley默认启动了４个<code>NetworkDispatcher</code>线程来处理网络请求，为了避免过多的网络请求造成UI卡死，Volley默认把这些线程的优先级设置为后台线程<code>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</code></p>
<h2 id="HttpStack"><a href="#HttpStack" class="headerlink" title="HttpStack"></a>HttpStack</h2><p>Volley的<code>NetworkDispatcher</code>线程默认调用的是Network类的<code>HttpStack</code>的方法来执行Http请求，HttpStack的实现有两种，如果系统在 Gingerbread 及之后(即 API Level &gt;= 9)，采用基于 <code>HttpURLConnection</code> 的 HurlStack，如果小于 9，采用基于 HttpClient 的 <code>HttpClientStack</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">	stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到了 HttpStack,然后通过它构造一个代表网络（Network）的具体实现BasicNetwork。</p>
<h3 id="HttpURLConnection-和-AndroidHttpClient-HttpClient的封装-如何选择"><a href="#HttpURLConnection-和-AndroidHttpClient-HttpClient的封装-如何选择" class="headerlink" title="HttpURLConnection 和 AndroidHttpClient(HttpClient的封装)如何选择"></a>HttpURLConnection 和 AndroidHttpClient(HttpClient的封装)如何选择</h3><p>在 Froyo(2.2) 之前，HttpURLConnection 有个重大 Bug，调用 close() 函数会影响连接池，导致连接复用失效，所以在 Froyo 之前使用 HttpURLConnection 需要关闭 keepAlive。<br>另外在 Gingerbread(2.3) HttpURLConnection 默认开启了 gzip 压缩，提高了 HTTPS 的性能，Ice Cream Sandwich(4.0) HttpURLConnection 支持了请求结果缓存。<br>再加上 HttpURLConnection 本身 API 相对简单，所以对 Android 来说，在 2.3 之后建议使用 HttpURLConnection，之前建议使用 AndroidHttpClient。</p>
<h3 id="关于-User-Agent"><a href="#关于-User-Agent" class="headerlink" title="关于 User Agent"></a>关于 User Agent</h3><p>通过代码我们发现如果是使用 AndroidHttpClient，Volley 还会将请求头中的 User-Agent 字段设置为 App 的 ${packageName}/${versionCode}，如果异常则使用 “volley/0”，不过这个获取 User-Agent 的操作应该放到 if else 内部更合适。而对于 HttpURLConnection 却没有任何操作，为什么呢？<br>如果用 Fiddler 或 Charles 对数据抓包我们会发现，我们会发现 HttpURLConnection 默认是有 User-Agent 的，类似：</p>
<pre><code>Dalvik/1.6.0 (Linux; U; Android 4.1.1; Google Nexus 4 - 4.1.1 - API 16 - 768x1280_1 Build/JRO03S)
</code></pre><p>经常用 WebView 的同学会也许会发现似曾相识，是的，WebView 默认的 User-Agent 也是这个。实际在请求发出之前，会检测 User-Agent 是否为空，如果不为空，则加上系统默认 User-Agent。在 Android 2.1 之后，我们可以通过</p>
<pre><code>String userAgent = System.getProperty(&quot;http.agent&quot;);
</code></pre><p>得到系统默认的 User-Agent，Volley 如果希望自定义 User-Agent，可在自定义 Request 中重写 getHeaders() 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">getHeaders</span><span class="params">()</span> <span class="keyword">throws</span> AuthFailureError </span>&#123;</span><br><span class="line">    <span class="comment">// self-defined user agent</span></span><br><span class="line">    Map&lt;String, String&gt; headerMap = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    headerMap.put(<span class="string">"User-Agent"</span>, <span class="string">"android-open-project-analysis/1.0"</span>);</span><br><span class="line">    <span class="keyword">return</span> headerMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="DiskBasedCache"><a href="#DiskBasedCache" class="headerlink" title="DiskBasedCache"></a>DiskBasedCache</h2><p>Volley默认是把缓存保存在文件中，并在内存中保存了缓存的头部，缓存头部占的最大内存可以设置，便于快速查询缓存是否存在．CacheHeader的主要属性有<br>文件大小size,缓存的etag,获取缓存的key,ttl,softTtl以及responseHeader.根据key来查询缓存，先从内存中查询是否存在CacheHeader,如果存在再从文件中把响应的data再读出来．每次向缓存中插入数据时先看看是否达到了缓存的最大大小，如果超过了容量就按照LRU算法从缓存中删除一部分数据直到满足需求，LRU算法实现很简单，直接调用LinkedHashMap来实现，<code>private final Map&lt;String, CacheHeader&gt; mEntries = new LinkedHashMap&lt;String, CacheHeader&gt;(16,0.75f,true)</code>.</p>
<h2 id="ByteArrayPool"><a href="#ByteArrayPool" class="headerlink" title="ByteArrayPool"></a>ByteArrayPool</h2><p>ByteArrayPool很有意思，这是一个字节数组池，Volley进行网络操作的时候会把HTTP响应的内容写入到字节数组中，如果频繁的申请大的字节数组可能会对系统性能有所影响，所以Volley采取了对象池的方法来解决频繁申请内存的问题，它的实现也比较简单，用的两个字节数组链表，一个按照使用的先后排序，另一个按照字节数组的大小排序，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersByLastUse = <span class="keyword">new</span> LinkedList&lt;<span class="keyword">byte</span>[]&gt;();</span><br><span class="line"><span class="keyword">private</span> List&lt;<span class="keyword">byte</span>[]&gt; mBuffersBySize = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">byte</span>[]&gt;(<span class="number">64</span>);</span><br></pre></td></tr></table></figure>
<p>池当然也有它的大小限制．申请字节数组的时候从mBuffersBySize中申请一个比请求大小更大的数组给他，如果没找到就调用new从堆中申请一个字节数组返回给它，数组用完之后调用returnBuff返回给数组池中，当数组池的大小超过了规定的大小时，就按照LRU算法删除一些数组．那么这个对象池具体在哪里用上了呢？答案是在BasicNetwork中，调用HttpStack返回了Http响应，然后需要把响应的Entity转换为字节数组，一般我们会用ByteArrayOutputStream来做，但是ByteArrayOutputStream是需要从堆中申请一个字节数组的，所以Volley创建了一个继承自ByteArrayOutputStream的类PoolingByteArrayOutputStream并覆写了相应的方法．不得不佩服谷歌的工程师啊，每个细节都考虑的很周到．</p>
<h2 id="关于Http缓存"><a href="#关于Http缓存" class="headerlink" title="关于Http缓存"></a>关于Http缓存</h2><p>Volley中对Http缓存作了相应的处理，在使用BasicNetwork执行Request之前，会给请求添加相应的缓存首部，利用<code>If-None-Match</code>和<code>If-Modified-Since</code>对过期缓存或者不新鲜缓存，进行请求再验证,代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">	<span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">	    headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (entry.serverDate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">	    Date refTime = <span class="keyword">new</span> Date(entry.serverDate);</span><br><span class="line">	    headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同样，在收到Http响应之后，Volley也会检查响应首部中的缓存字段，根据<code>Cache-Control</code>和<code>Expires</code>首部来计算缓存的过期时间。如果两个首部都存在情况下，以<code>Cache-Control</code>为准。代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Cache.<span class="function">Entry <span class="title">parseCacheHeaders</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line"><span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String&gt; headers = response.headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> serverDate = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> serverExpires = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> softExpire = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> maxAge = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">boolean</span> hasCacheControl = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">String serverEtag = <span class="keyword">null</span>;</span><br><span class="line">String headerValue;</span><br><span class="line"></span><br><span class="line">headerValue = headers.get(<span class="string">"Date"</span>);</span><br><span class="line"><span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">    serverDate = parseDateAsEpoch(headerValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headerValue = headers.get(<span class="string">"Cache-Control"</span>);</span><br><span class="line"><span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hasCacheControl = <span class="keyword">true</span>;</span><br><span class="line">    String[] tokens = headerValue.split(<span class="string">","</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tokens.length; i++) &#123;</span><br><span class="line">        String token = tokens[i].trim();</span><br><span class="line">        <span class="keyword">if</span> (token.equals(<span class="string">"no-cache"</span>) || token.equals(<span class="string">"no-store"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.startsWith(<span class="string">"max-age="</span>)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                maxAge = Long.parseLong(token.substring(<span class="number">8</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.equals(<span class="string">"must-revalidate"</span>) || token.equals(<span class="string">"proxy-revalidate"</span>)) &#123;</span><br><span class="line">            maxAge = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">headerValue = headers.get(<span class="string">"Expires"</span>);</span><br><span class="line"><span class="keyword">if</span> (headerValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">    serverExpires = parseDateAsEpoch(headerValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverEtag = headers.get(<span class="string">"ETag"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Cache-Control takes precedence over an Expires header, even if both exist and Expires</span></span><br><span class="line"><span class="comment">// is more restrictive.</span></span><br><span class="line"><span class="keyword">if</span> (hasCacheControl) &#123;</span><br><span class="line">    softExpire = now + maxAge * <span class="number">1000</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (serverDate &gt; <span class="number">0</span> &amp;&amp; serverExpires &gt;= serverDate) &#123;</span><br><span class="line">    <span class="comment">// Default semantic for Expire header in HTTP specification is softExpire.</span></span><br><span class="line">    softExpire = now + (serverExpires - serverDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Cache.Entry entry = <span class="keyword">new</span> Cache.Entry();</span><br><span class="line">entry.data = response.data;</span><br><span class="line">entry.etag = serverEtag;</span><br><span class="line">entry.softTtl = softExpire;</span><br><span class="line">entry.ttl = entry.softTtl;</span><br><span class="line">entry.serverDate = serverDate;</span><br><span class="line">entry.responseHeaders = headers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> entry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读完Volley的源码之后只有一个感觉，就是<code>谷歌出品，必属精品</code>.</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Zsh-Linux下最好的Shell简介]]></title>
      <url>http://www.ezlippi.com/blog/2015/08/linux-zsh.html</url>
      <content type="html"><![CDATA[<p>没听过Shell?Shell是Unix/Linux系统下的外壳，负责外界和Linux内核的交互，将用户输入的命令转换成内核能懂的语言，执行相应的指令，然后将输出返回给用户．<br><a id="more"></a></p>
<h3 id="查看当前系统所有的Shell"><a href="#查看当前系统所有的Shell" class="headerlink" title="查看当前系统所有的Shell"></a>查看当前系统所有的Shell</h3><pre><code>ls /etc/shells
</code></pre><p>结果如下：<br><img src="/images/zsh1.png" alt=""></p>
<h3 id="安装Zsh"><a href="#安装Zsh" class="headerlink" title="安装Zsh"></a>安装Zsh</h3><pre><code>sudo apt-get install zsh
</code></pre><p>简单吧？把它设置为默认Shell,<code>chsh -s /bin/zsh</code><br>它的默认配置为.zshrc,你可以在里面配置各种按键别名，你也可以使用Github上比较流行的oh-my-zsh配置，安装方法：</p>
<p>自动安装：</p>
<pre><code>wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | sh
</code></pre><p>手动安装：</p>
<pre><code>git clone git://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh
cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc
</code></pre><p>安装之后进入一个Git分支，显示是这样的，很炫对吧？</p>
<p><img src="/images/zsh2.png" alt=""></p>
<p>以前切换工作目录一直按cd加tab是不是很麻烦，现在有了Zsh只需要输入d,他会显示最近使用的工作目录，然后输入数字进入对应的目录，是不是很省事？</p>
<p><img src="/images/zsh3.png" alt=""></p>
<p>它的功能不局限如此，时间长了忘记了tar的参数？输入<code>tar -</code>按一下tab键会显示所有的命令行参数，再按一下tab进入选择模式，如图：</p>
<p><img src="/images/zsh4.png" alt=""></p>
<p>以前杀死进程是不是用<code>ps aux | grep python</code><br><img src="/images/zsh5.png" alt=""><br>现在只需要输入<code>kill python</code>再按一下tab键，结果变成这样了,神奇把？</p>
<p><img src="/images/zsh6.png" alt=""></p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>在.zshrc文件里可以配置你要使用的插件，Zsh提供上千种插件，你可以配置自己Shell的主题，我用的是<code>ZSH_THEME=”robbyrussell”</code>,你还可以配置需要的插件，我的插件是<code>plugins=(git autojump mvn gradle)</code>,简单介绍下git和autojump:</p>
<p>git. 当你进入一个git目录时，Zsh会显示git和所在的分支，对git的命令进行了简化，例如 gco=’git checkout’、gd=’git diff’、gst=’git status’、g=’git’等等，熟练使用可以大大减少 git 的命令长度，命令内容可以参考~/.oh-my-zsh/plugins/git/git.plugin.zsh</p>
<p>autojump. 安装方法：</p>
<pre><code>wget https://github.com/downloads/joelthelion/autojump/autojump_v21.1.2.tar.gz
</code></pre><p>解压缩后进入目录，执行<code>./install.sh</code>,最后加上这一行代码到.zshrc中：</p>
<pre><code>[[ -s ~/.autojump/etc/profile.d/autojump.sh ]] &amp;&amp; . ~/.autojump/etc/profile.d/autojump.sh
</code></pre><p>安装了autojump之后，zsh 会自动记录你访问过的目录，通过 j + 目录名 可以直接进行目录跳转，而且目录名支持模糊匹配和自动补全，例如你访问过workspace目录，输入j work 即可正确跳转。j –stat 可以看你的历史路径库。</p>
<p>你还可以参考<a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="external">Zsh</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Latex中英文环境设置]]></title>
      <url>http://www.ezlippi.com/blog/2015/08/latex-fonts-settings.html</url>
      <content type="html"><![CDATA[<p>Latex默认是不支持中文的,后来有人开发了XeLatex来支持非英文字符,xetex是一种使用Unicode的TeX排版引擎,并默认其输入文件为UTF-8编码，也即,英文字符与非英文字符不再有区别，原生支持系统字体，这意味着我们无需再额外编译字体, 故可以在不进行额外配置的情况下直接使用操作系统中安装的字体。<br><a id="more"></a><br>安装完TexLive后,编写下面的tex文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[<span class="number">12</span>pt,a4paper]&#123;article&#125;</span><br><span class="line">\usepackage&#123;xltxtra,fontspec,xunicode&#125;</span><br><span class="line"></span><br><span class="line">\setmainfont&#123;WenQuanYi Zen Hei&#125; % 设置文档默认字体</span><br><span class="line">\date&#123;&#125; % 不显示文档生成日期</span><br><span class="line">\title&#123;\XeTeX&#123;&#125; 中英文环境测试&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">\XeTeX&#123;&#125; is a \TeX&#123;&#125; typesetting engine using Unicode and supporting modern font technologies.\\</span><br><span class="line">\XeTeX&#123;&#125; 是一个使用Unicode的\TeX&#123;&#125;排版系统，并支持一些现代字体技术.\\</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>使用下面命令编译:<code>XeLatex test.tex</code></p>
<p>输出结果如下：</p>
<p><img src="/images/latex1.png" alt=""></p>
<p>上面的英文也使用了中文字体, 看上去不是很美观. 于是, xetex 和 CJK 商量了一下, 就有了xeCJK 宏包, 可以分别指定中英文字体, 于是可以很好的排版中英混合的文章了．</p>
<p>当然首先是要使用xeCJK包,添加上<code>\usepackage[slantfont,boldfont]{xeCJK}</code><br>分别设置中英文字体, 英文字体可以不用设置, xetex会调用默认的字体:<code>\setCJKmainfont{SimKai}   % 设置缺省中文字体为楷体</code><br>下面是测试文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">	\documentclass[<span class="number">12</span>pt,a4paper]&#123;article&#125;</span><br><span class="line">\usepackage&#123;xltxtra,fontspec,xunicode&#125;</span><br><span class="line">\usepackage[slantfont,boldfont]&#123;xeCJK&#125;</span><br><span class="line">\setCJKmainfont&#123;WenQuanYi Zen Hei&#125;   % 设置缺省中文字体</span><br><span class="line">%\setCJKmonofont&#123;Hei&#125;   % 设置等宽字体</span><br><span class="line"></span><br><span class="line">%\setmainfont&#123;Optima&#125;   %% 不指定，使用Tex的默认英文衬线字体</span><br><span class="line">%\setmonofont&#123;Monaco&#125;   % 英文等宽字体</span><br><span class="line">%\setsansfont&#123;Trebuchet MS&#125; % 英文无衬线字体</span><br><span class="line">\date&#123;&#125; % 不显示文档生成日期</span><br><span class="line">\title&#123;\XeTeX&#123;&#125; 中英文环境测试&#125;</span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">\maketitle</span><br><span class="line">\XeTeX&#123;&#125; is a \TeX&#123;&#125; typesetting engine using Unicode and supporting modern font technologies.\\</span><br><span class="line"></span><br><span class="line">\XeTeX&#123;&#125; 是一个使用Unicode的\TeX&#123;&#125;排版系统，并支持一些现代字体技术.\\</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：<br><img src="/images/latex2.png" alt=""></p>
<p>这样效果就好很多了．</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Dagger依赖注入浅析]]></title>
      <url>http://www.ezlippi.com/blog/2015/08/dagger-dependency-injection.html</url>
      <content type="html"><![CDATA[<p>最早接触依赖注入这个概念是在使用Spring框架的时候，一开始没太在意它，后面开发项目的过程中发现使用依赖注入可以降低代码的耦合性,Spring的依赖注入是通过反射机制实现的，而Dagger依赖注入是在编译期生成辅助的类，这些类继承特定父类或实现特定接口，程序在运行时 Dagger 加载这些辅助类，调用相应接口完成依赖生成和注入.</p>
<a id="more"></a>
<h2 id="什么是控制反转？"><a href="#什么是控制反转？" class="headerlink" title="什么是控制反转？"></a>什么是控制反转？</h2><p>比如你有一个DataProcessor类，DataProcessor里有一个DataFinder对象，用于查找数据，DataFinder是一个接口，它有一个实现类:IndexDataFinder,如果你要使用DataFinder来查找数据，传统的做法是在DataProcessor构造器里新建一个DataFinder对象，然后再调用DataFinder的findData方法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataProcessor</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.dataFinder = <span class="keyword">new</span> IndexDataFinder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的实现中，DataProcessor就和DataFinder紧密的耦合在一起．假设后来DataFinder又有一个新的实现类SQLDataFinder,根据需求来选择相应的实现，这时候你要怎么做呢？传统的做法就是给构造器传递一个int参数，根据参数的值来初始化DataFinder,还要处理异常参数如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataProcessor</span><span class="params">(<span class="keyword">int</span> dataFinderIndex)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(dataFinderIndex == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.dataFinder = <span class="keyword">new</span> IndexDataFinder();	</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span>(dataFinderIndex == <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">this</span>.dataFinder = <span class="keyword">new</span> SQLDataFinder();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子虽然代码变得简单，但是DataProcessor类仍然依赖于具体的实现，实际上DataProcessor不应该有这么多的控制逻辑，它只需要负责调用dataFinder的方法来完成它的逻辑，至于是什么类型的DataFinder它不应该考虑．我们试着将控制DataFinder的任务交给客户：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DataProcessor</span><span class="params">(DataFinder dataFinder)</span></span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.dataFinder = dataFinder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样DataProcessor就不用依赖具体的实现了，不用管到底是哪种类型的DataFinder,也就是说将选择DataFinder的控制权交给了客户端，实现了”控制反转”．控制反转只是一个概念而已，依赖注入是他的一种实现方法，依赖注入就是将实例变量传递到一个对象中去，依赖注入的方法有两种：构造器注入和setter方法注入．</p>
<h2 id="Dagger依赖注入"><a href="#Dagger依赖注入" class="headerlink" title="Dagger依赖注入"></a>Dagger依赖注入</h2><p>Spring IoC和Google Guice的依赖注入都很有名，但它们都是使用Java的反射机制来实现的，这对性能要求比较高的Android平台来说就不太适合了，于是Dagger应运而生.</p>
<h3 id="编译期"><a href="#编译期" class="headerlink" title="编译期"></a>编译期</h3><p>Dagger在编译时使用注解处理工具(APT)对所有的类进行扫描，这里包括两个工具InjectAdapterProcessor和ModuleAdapterProcessor,InjectAdapterProcessor会扫描所有的被@inject注解的元素，包括静态域，实例域和构造器，然后根据这几个元素生成一个内部对象InjectedClass，它的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectedClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> TypeElement type;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Element&gt; staticFields;</span><br><span class="line">	<span class="keyword">final</span> ExecutableElement constructor;</span><br><span class="line">	<span class="keyword">final</span> List&lt;Element&gt; fields;</span><br><span class="line">	..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据域是否是静态域注入方式会有不同，非静态域生成InjectAdapter对象并保存在同个被注入类同个目录下，比如被注入的类为A,生成的类名称为A$$InjectAdapter,InjectAdapter包含了所有需要注入的实例域和构造器参数的信息．如果被注解的是静态域，则生成A$$StaticInjection.这里需要注意的是如果你是在构造函数上用@inject注解而且构造函数有其他参数，你需要给这些参数添加@inject注解或者在Module中提供provide方法（下面会讲到Module）．InjectAdapter类的生成Dagger用到了JavaPoet这个用于生成Java源文件的类库，用法简介：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">.addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">.returns(<span class="keyword">void</span>.class)</span><br><span class="line">.addParameter(String[].class, <span class="string">"args"</span>)</span><br><span class="line">.addStatement(<span class="string">"$T.out.println($S)"</span>, System.class, <span class="string">"Hello, JavaPoet!"</span>)</span><br><span class="line">.build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">.addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">.addMethod(main)</span><br><span class="line">.build();</span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld)</span><br><span class="line"> .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure>
<p>上面这种过注入依赖的方法适合我们自己编写的类，如果是第三方类库的话你没有修改它的源代码给它的构造器或者域添加@inject注解，这时候就需要使用第二种注入依赖的方法.通过新建一个用@Module注解的类，这个类告诉Dagger编译期哪些类要注入依赖，这个Module包含哪些子Module，通过编写provide方法来生成一些依赖实例．具体用法举例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Module</span>(</span><br><span class="line">	injects = CoffeeApp.class<span class="comment">//表示CoffeeApp这个类需要注入依赖</span></span><br><span class="line">	includes = PumpModule.class<span class="comment">//包括PumpModule这个Module</span></span><br><span class="line">	)	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DripCoffeeModule</span> </span>&#123;</span><br><span class="line">	<span class="comment">//所有需要被注入的实例都用@Provides方法提供</span></span><br><span class="line">	<span class="meta">@Provides</span> <span class="meta">@Singleton</span> <span class="function">Heater <span class="title">provideHeater</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		  <span class="keyword">return</span> <span class="keyword">new</span> ElectricHeater();</span><br><span class="line">	 &#125;</span><br><span class="line">	<span class="comment">//方法可以有参数，前提是这个参数能够被注入</span></span><br><span class="line">	<span class="meta">@Provides</span> <span class="function">Pump <span class="title">providePump</span><span class="params">(Heater heater)</span> </span>&#123;</span><br><span class="line">		 <span class="keyword">return</span> <span class="keyword">new</span> Thermosiphon(heater);	</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译时Dagger编译期扫描所有被@Provides注解的方法，然后扫描它所在的类是否被＠Module注解，根据Module注解的参数injects,includes,complete,library生成ModuleAdapter类，保存为［Module名称］$$ModuleAdapter的形式,内部使用的是generateModuleAdapter方法，定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> JavaFile <span class="title">generateModuleAdapter</span><span class="params">(TypeElement type,</span><br><span class="line">  Map&lt;String, Object&gt; <span class="keyword">module</span>, List&lt;ExecutableElement&gt; providerMethods)</span> </span>&#123;</span><br><span class="line">Object[] injects = (Object[]) <span class="keyword">module</span>.get(<span class="string">"injects"</span>);</span><br><span class="line">Object[] includes = (Object[]) <span class="keyword">module</span>.get(<span class="string">"includes"</span>);</span><br><span class="line"><span class="keyword">boolean</span> complete = (Boolean) <span class="keyword">module</span>.get(<span class="string">"complete"</span>);</span><br><span class="line"><span class="keyword">boolean</span> library = (Boolean) <span class="keyword">module</span>.get(<span class="string">"library"</span>);</span><br><span class="line"><span class="comment">//省略了其他部分</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行时，在 Application 或某个具体模块的初始化处，使用ObjectGraph类来加载部分依赖(实质上是利用编译时生成的ModuleAdapters加载了所有的ProvidesBinding)，形成一个不完整的依赖关系图。 这个不完整的依赖关系图生成之后，就可以调用ObjectGraph的相应函数来获取实例和注入依赖了。实现依赖注入的函数有两个：<code>ObjectGraph.get(Class&lt;T&gt; type)</code>函数，用于直接获取对象；<code>ObjectGraph.inject(T instance)</code>函数，用于对指定对象进行属性的注入。在这些获取实例和注入依赖的过程中，如果用到了还未加载的依赖，程序会自动对它们进行加载(实质上是加载的编译时生成的InjectAdapter)。在此过程中，内存中的 DAG 也被补充地越来越完整。</p>
<p>简单介绍一些Dagger的Binding 类，它相当于依赖关系 DAG 图中的节点，依赖关系 DAG 图中得每一个节点都有一个由 APT 生成的继承自 Binding 的类与之对应，而依赖关系 DAG 图中的每一个节点与Host和Dependency一一对应，所以每个Host或Dependency必然有一个由 APT 生成的继承自 Binding 的子类与之对应，Binding.java 实现了两个接口，第一个是 javax 的Provider接口，此接口提供了 get() 函数用于返回一个Dependency实例，当然也可以是Host实例。第二个接口是 Dagger 中的MembersInjector接口，此接口提供了 injectMembers() 用来向Host对象中注入Dependency。<br>单纯的DependencyBinding只要实现Provider接口，在 get() 函数中返回自己的实例即可。单纯的HostBinding只要实现MembersInjector，在 injectMembers() 函数中调用DependencyBinding的 get() 函数得到依赖，然后对自己的依赖进行注入即可。如果一个类既是Host又是Dependency，则与它对应的Binding这两个接口都需要实现。</p>
<p>还是之前那个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoffeeApp</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> CoffeeMaker coffeeMaker;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		coffeeMaker.brew();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//建立依赖关系图</span></span><br><span class="line">	ObjectGraph objectGraph = ObjectGraph.create(<span class="keyword">new</span> DripCoffeeModule());</span><br><span class="line">	<span class="comment">//调用objectGraph．get(CoffeeApp.class)来获取一个CoffeeApp实例</span></span><br><span class="line">	CoffeeApp coffeeApp = objectGraph.get(CoffeeApp.class);</span><br><span class="line">	coffeeApp.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CoffeeMaker的定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CoffeeMaker</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Inject</span> Lazy&lt;Heater&gt; heater; </span><br><span class="line">  <span class="meta">@Inject</span> Pump pump;</span><br><span class="line"></span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">brew</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	 heater.get().on();</span><br><span class="line">	 pump.pump();</span><br><span class="line">	 System.out.println(<span class="string">" [_]P coffee! [_]P "</span>);</span><br><span class="line">	 heater.get().off();</span><br><span class="line">	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>这样在运行中Dagger会自动注入CoffeeMaker实例以及它依赖的对象heater和pump.
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[彻底理解Gradle的任务]]></title>
      <url>http://www.ezlippi.com/blog/2015/07/gradle-tasks-guide.html</url>
      <content type="html"><![CDATA[<p>在Gradle的build文件中，任务是构建活动最基本的单元，它是许多构建指令的集合，下面我将仔细介绍Gradle任务的细节。<br><a id="more"></a></p>
<h2 id="声明一个任务"><a href="#声明一个任务" class="headerlink" title="声明一个任务"></a>声明一个任务</h2><p>声明任务很简单，你只需要一个任务名：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">task hello</span><br></pre></td></tr></table></figure>
<p>你可以在命令行中使用<code>gradle tasks</code>来查看所有的任务：</p>
<pre><code>------------------------------------------------------------
Root Project
------------------------------------------------------------
Help tasks
----------
dependencies - Displays the dependencies of root project &apos;task-lab&apos;.
help - Displays a help message
projects - Displays the subprojects of root project &apos;task-lab&apos;.
properties - Displays the properties of root project &apos;task-lab&apos;.
13
tasks - Displays the tasks in root project &apos;task-lab&apos;.
Other tasks
-----------
hello
</code></pre><h2 id="任务的动作"><a href="#任务的动作" class="headerlink" title="任务的动作"></a>任务的动作</h2><p>很显然执行<code>gradle hello</code>不会有任何结果，因为你没有给这个任务添加动作，我们可以通过左移操作符给任务添加一个动作(在Groovy语言中左移操作符可以重载成在任务的最后添加一个动作)：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task hello &lt;&lt;&#123;</span><br><span class="line">    println <span class="string">'hello,world'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以在任务的后面引用前面声明的任务:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task hello</span><br><span class="line"></span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    print <span class="string">'hello,'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">hello &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'world'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来在命令行中运行<code>gradle hello</code>,输出如下：</p>
<pre><code>$ gradle hello
hello, world
$
</code></pre><p>##任务的配置</p>
<p>Gradle新手可能会很容易混淆任务的动作和配置，看下面这个例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task initializeDatabase</span><br><span class="line">initializeDatabase &lt;&lt; &#123; println <span class="string">'connect to database'</span> &#125;</span><br><span class="line">initializeDatabase &lt;&lt; &#123; println <span class="string">'update database schema'</span> &#125;</span><br><span class="line">initializeDatabase &#123; println <span class="string">'configuring database connection'</span> &#125;<span class="comment">//这里没有左移操作符</span></span><br></pre></td></tr></table></figure>
<p>运行这个构建脚本，猜猜输出是什么：</p>
<pre><code>//－b 选项用于指定gradle构建脚本文件名
$ gradle -b scratch.gradle initializeDatabase
configuring database connection
:initializeDatabase
connect to database
update database schema
$
</code></pre><p>如果第三个代码块我们用的是&lt;&lt;操作浮，这个消息就是在最后而不是最先打印出来了，我把用{}扩起来的部分统称为一个闭包，上面第三个闭包并不是任务的动作，他直接使用了任务名+闭包，在这里它是一个配置块。在Gradle的构建生命周期里配置阶段是在执行阶段前运行的，所以这个块里的代码最先执行了。</p>
<p>Gradle的构建生命周期分为三部分，初始化、配置和执行阶段。在执行阶段，任务按照他们的依赖顺序按序执行，在配置阶段所有的任务都转换成Gradle的内部对象模型，通常叫做有向无环图(DAG)。图的节点就是构建脚本里的任务，任务与任务之间可以定义依赖关系。初始化阶段是Gradle用来找出哪些项目会参与到项目构建中，这在多项目构建中很重要。</p>
<p>和动作闭包一样，配置闭包也具有可加性，你可以像下面这样编写构建脚本：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task initializeDatabase</span><br><span class="line">initializeDatabase &lt;&lt; &#123; println <span class="string">'connect to database'</span> &#125;</span><br><span class="line">initializeDatabase &lt;&lt; &#123; println <span class="string">'update database schema'</span> &#125;</span><br><span class="line">initializeDatabase &#123; print <span class="string">'configuring '</span> &#125;</span><br><span class="line">initializeDatabase &#123; println <span class="string">'database connection'</span> &#125;</span><br></pre></td></tr></table></figure>
<p>配置块是用来放置变量和数据结构的地方，这些可能会在任务的执行过程中用到。</p>
<h2 id="一切任务都是对象"><a href="#一切任务都是对象" class="headerlink" title="一切任务都是对象"></a>一切任务都是对象</h2><p>前面讲过Gradle会在任务执行之前把他们创建成内部的对象模型，每一个你声明的任务都是一个任务对象，这个对象有自己的属性和方法，就和Java语言里的对象一样，我们可以控制每个任务对象的类型。默认情况每一个新创建的任务都是DefaultTask类型，就像Java语言里的java.lang.Object一样，每一个Gradle任务都继承自DefaultTask类型，你也可以定义自己的类型。DefaultTask事实上没有做任务事情，不过它具有基本的属性和方法用来和Gradle项目模型交互。接下来我会一一介绍每个任务都有的方法和属性。</p>
<h2 id="DefaultTask的方法"><a href="#DefaultTask的方法" class="headerlink" title="DefaultTask的方法"></a>DefaultTask的方法</h2><h3 id="dependsOn-task"><a href="#dependsOn-task" class="headerlink" title="dependsOn(task)"></a>dependsOn(task)</h3><p>用于给任务添加一个依赖的任务，被依赖的任务总是在依赖它的任务之前运行，你可以有多种方式声明这种依赖关系，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//最简单的方法</span></span><br><span class="line">task loadTestData &#123;</span><br><span class="line">   	dependsOn createSchema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用&lt;&lt;声明依赖</span></span><br><span class="line">task loadTestData &#123;</span><br><span class="line">    dependsOn &lt;&lt; createSchema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用单引号声明依赖</span></span><br><span class="line">task loadTestData &#123;</span><br><span class="line">    dependsOn <span class="string">'createSchema'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//显式调用dependsOn方法</span></span><br><span class="line">task loadTestData</span><br><span class="line">loadTestData.dependsOn createSchema</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快捷方法</span></span><br><span class="line">task loadTestData(<span class="string">dependsOn:</span> createSchema)</span><br></pre></td></tr></table></figure>
<p>任务可以依赖多个任务，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//每次声明一个任务</span></span><br><span class="line">task loadTestData &#123;</span><br><span class="line">    dependsOn &lt;&lt; compileTestClasses</span><br><span class="line">    dependsOn &lt;&lt; createSchema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依次传递任务名</span></span><br><span class="line">task world &#123;</span><br><span class="line">    dependsOn compileTestClasses, createSchema</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显式调用方法</span></span><br><span class="line">task world</span><br><span class="line">world.dependsOn compileTestClasses, createSchema</span><br><span class="line"></span><br><span class="line"><span class="comment">//快捷方式</span></span><br><span class="line">task world(<span class="string">dependsOn:</span> [ compileTestClasses, createSchema ])</span><br></pre></td></tr></table></figure>
<h3 id="doFirst-closure"><a href="#doFirst-closure" class="headerlink" title="doFirst(closure)"></a>doFirst(closure)</h3><p>在任务的最开始添加一个可执行的代码块，doFirst方法允许你添加动作到现有的任务中，这个任务是在其他插件中定义的，你没有办法修改，但是你可以多次调用doFirst方法在任务执行之前添加一些代码块。<br>你可以使用任务对象调用doFirst方法，传递一个闭包给这个方法，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task setupDatabaseTests &lt;&lt; &#123;</span><br><span class="line"><span class="comment">// 任务现有的代码</span></span><br><span class="line">println <span class="string">'load test data'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupDatabaseTests.doFirst &#123;</span><br><span class="line">println <span class="string">'create schema'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后运行gradle setupDatabaseTests,结果如下：</p>
<pre><code>$ gradle setupDatabaseTests
:setupDatabaseTests
create schema
load test data
$
</code></pre><p>你也可以在任务的配置块里面调用doFirst方法，不过要记住配置块里的代码在任务的动作之前执行：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task setupDatabaseTests &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'load test data'</span></span><br><span class="line">&#125;</span><br><span class="line">setupDatabaseTests &#123;</span><br><span class="line">doFirst &#123;</span><br><span class="line">    println <span class="string">'create schema'</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>doFirst方法也是可加的，你可以多次调用这个方法在任务的最前面添加代码块，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task setupDatabaseTests &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'load test data'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupDatabaseTests.doFirst &#123;</span><br><span class="line">    println <span class="string">'create database schema'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setupDatabaseTests.doFirst &#123;</span><br><span class="line">    println <span class="string">'drop database schema'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<pre><code>$ gradle world
:setupDatabaseTests
drop database schema
create database schema
load test data
$
</code></pre><h3 id="doLast-closure"><a href="#doLast-closure" class="headerlink" title="doLast(closure)"></a>doLast(closure)</h3><p>doLast方法和doFirst方法很类似，它用于在任务的最后面添加一段代码，这里就不重复了。</p>
<h3 id="onlyIf-closure"><a href="#onlyIf-closure" class="headerlink" title="onlyIf(closure)"></a>onlyIf(closure)</h3><p>onlyIf方法用于决定是否执行一个任务，这里使用闭包返回的值来作为onlyIf的判断依据，在Groovy语言中，一个闭包的最后一个表达式用来作为这个闭包的返回值，即使你没有声明return语句，看一个例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task createSchema &lt;&lt; &#123;</span><br><span class="line">    println 'create database schema'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task loadTestData(dependsOn: createSchema) &lt;&lt; &#123;</span><br><span class="line">    println 'load test data'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">loadTestData.onlyIf &#123;</span><br><span class="line">    System.properties['load.data'] == 'true'//当系统属性load.data为true时这个闭包返回true</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line">    </span><br><span class="line">看下下面的运行结果：</span><br><span class="line"></span><br><span class="line">	//这里没有系统属性load.data</span><br><span class="line">    $ build loadTestData</span><br><span class="line">    create database schema</span><br><span class="line">    :loadTestData SKIPPED</span><br><span class="line">    </span><br><span class="line">    //在命令行中传递系统属性</span><br><span class="line">    $ gradle -Dload.data=true loadTestData</span><br><span class="line">    :createSchema</span><br><span class="line">    create database schema</span><br><span class="line">    :loadTestData</span><br><span class="line">    load test data</span><br><span class="line">    $</span><br><span class="line"></span><br><span class="line">##DefaultTask的属性</span><br><span class="line"></span><br><span class="line">###didWork</span><br><span class="line"></span><br><span class="line">一个用来标识任务是否成功完成的boolean属性，不是所有的任务都是在完成之后设置didWork变量，一些自带的任务比如Compile,Copy和Delete会根据动作是否执行成功来设置这个变量，JavaCompiler任务的实现是只要有一个文件成功编译就返回true,你可以在你自己的任务中设置didWork属性来反映构建代码的执行结果，举例如下：</span><br><span class="line"></span><br><span class="line">``` Groovy</span><br><span class="line"></span><br><span class="line">apply plugin: 'java'</span><br><span class="line"></span><br><span class="line">task emailMe(dependsOn: compileJava) &lt;&lt; &#123;</span><br><span class="line">    if(tasks.compileJava.didWork) &#123;</span><br><span class="line">    	println 'SEND EMAIL ANNOUNCING SUCCESS'</span><br><span class="line">   	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<pre><code>$ gradle -b didWork.gradle emailMe
SEND EMAIL ANNOUNCING SUCCESS
$
</code></pre><h3 id="enabled"><a href="#enabled" class="headerlink" title="enabled"></a>enabled</h3><p>一个用来设置任务是否会执行的一个属性，你可以设置enabled为false不让它运行，但是它依赖的任务依然会运行。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task templates &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'process email templates'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task sendEmails(<span class="string">dependsOn:</span> templates) &lt;&lt; &#123;</span><br><span class="line">    println <span class="string">'send emails'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sendEmails.enabled = <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>运行结果如下：</p>
<pre><code>$ gradle -b enabled.gradle sendEmails
:templates
process email templates
:sendEmails SKIPPED
$
</code></pre><h3 id="path"><a href="#path" class="headerlink" title="path"></a>path</h3><p>一个字符串属性包含任务的全限定路径名，默认是一个冒号加上任务名，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task echoMyPath &lt;&lt; &#123;</span><br><span class="line">println <span class="string">"THIS TASK'S PATH IS $&#123;path&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，输出如下：</p>
<pre><code>$ gradle -b path.gradle echoMyPath
THIS TASK&apos;S PATH IS :echoMyPath
$
</code></pre><p>最开始的冒号表示这个任务在最顶级的构建文件里面，由于Gradle支持多项目构建，一个项目里面可能有多个子项目，假如echoMyPath在子项目subProject构建文件中,那它的全限定路径名就是:subProject:echoMyPath。</p>
<h3 id="description"><a href="#description" class="headerlink" title="description"></a>description</h3><p>正如它的名字一样，这个用来给一个任务添加一段容易阅读的描述，你可以使用如下几种方法给任务添加描述。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task helloWorld(<span class="string">description:</span> <span class="string">'Says hello to the world'</span>) &lt;&lt; &#123;</span><br><span class="line">println <span class="string">'hello, world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task helloWorld &lt;&lt; &#123;</span><br><span class="line">println <span class="string">'hello, world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">helloWorld &#123;</span><br><span class="line">description = <span class="string">'Says hello to the world'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Another way to do it</span></span><br><span class="line">helloWorld.description = <span class="string">'Says hello to the world'</span></span><br></pre></td></tr></table></figure>
<h2 id="任务的类型"><a href="#任务的类型" class="headerlink" title="任务的类型"></a>任务的类型</h2><p>我前面说过每个任务都有一个类型。除了DefaultTask之外，还有许多其他类型，你可以继承DefaultTask来声明新的类型，下面介绍几种比较重要的类型，以后可能经常会用到。</p>
<h3 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h3><p>Copy任务用于把文件从一个地方复制到另一个地方，你可以设置源目录、目标目录和要复制的文件类型，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task copyFiles(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">    from <span class="string">'resources'</span></span><br><span class="line">    into <span class="string">'target'</span></span><br><span class="line">    include <span class="string">'**/*.xml'</span>, <span class="string">'**/*.txt'</span>, <span class="string">'**/*.properties'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果目标目录不存在,Copy任务会自动创建，上面这个任务会把resources目录下所有的xml、txt和propertied文件都复制到target目录。</p>
<h3 id="Jar"><a href="#Jar" class="headerlink" title="Jar"></a>Jar</h3><p>Jar任务用于打包源代码生成Jar文件，Java插件就自带这种类型，任务类型就叫做jar,这个任务把源代码文件和资源文件打包成Jar文件，并保存在build/libs目录下，文件名默认是用项目的名称。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line">task customJar(<span class="string">type:</span> Jar) &#123;</span><br><span class="line">manifest &#123;</span><br><span class="line"><span class="comment">//设置一些属性值(以键值对的形式)</span></span><br><span class="line">    attributes <span class="string">firstKey:</span> <span class="string">'firstValue'</span>, <span class="string">secondKey:</span> <span class="string">'secondValue'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//文件名</span></span><br><span class="line">archiveName = <span class="string">'hello.jar'</span></span><br><span class="line"><span class="comment">//目标路径</span></span><br><span class="line">destinationDir = file(<span class="string">"$&#123;buildDir&#125;/jars"</span>)<span class="comment">//file方法用于把一个字符串变成文件对象</span></span><br><span class="line"><span class="comment">//要打包的文件</span></span><br><span class="line">from sourceSets.main.classes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaExec"><a href="#JavaExec" class="headerlink" title="JavaExec"></a>JavaExec</h3><p>用于执行一个Java类的main()方法。举例说明：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">apply <span class="string">plugin:</span> <span class="string">'java'</span></span><br><span class="line"><span class="comment">//maven中央仓库</span></span><br><span class="line">repositories &#123;</span><br><span class="line">    mavenCentral()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//项目依赖</span></span><br><span class="line">dependencies &#123;</span><br><span class="line">    runtime <span class="string">'commons-codec:commons-codec:1.5'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task encode(<span class="string">type:</span> JavaExec, <span class="string">dependsOn:</span> classes) &#123;</span><br><span class="line">    </span><br><span class="line">main = <span class="string">'org.gradle.example.commandline.MetaphoneEncoder'</span></span><br><span class="line">    args = <span class="string">"The rain in Spain falls mainly in the plain"</span>.split().toList()</span><br><span class="line">    classpath sourceSets.main.classesDir</span><br><span class="line">    classpath configurations.runtime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个构建文件声明了一个外部依赖，Apache Commons Codec库。一般情况下，在命令行运行一个class文件的步骤是编译Java源文件，然后在命令行中设置class文件的路径和依赖的库文件。我们上面encode任务声明了main函数所在的类，给他传递了命令行参数，设置classpath参数。</p>
<h2 id="编写自定义的任务类型"><a href="#编写自定义的任务类型" class="headerlink" title="编写自定义的任务类型"></a>编写自定义的任务类型</h2><p>如果Gradle自带的任务类型不满足你的工作需求时，最简单的办法就是编写自定义的任务类型，Gradle提供了多种方法来实现，这里我介绍两种最常用的方法。</p>
<h3 id="在Build文件中编写自定义任务类型"><a href="#在Build文件中编写自定义任务类型" class="headerlink" title="在Build文件中编写自定义任务类型"></a>在Build文件中编写自定义任务类型</h3><p>假设你的构建脚本需要对MySQL数据库执行一些随机的查询，下面我们来编写一个任务执行数据库查询：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">task createDatabase(type: MySqlTask) &#123;</span><br><span class="line">    sql = 'CREATE DATABASE IF NOT EXISTS example'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task createUser(type: MySqlTask, dependsOn: createDatabase) &#123;</span><br><span class="line">    sql = "GRANT ALL PRIVILEGES ON example.*</span><br><span class="line">    TO exampleuser@localhost IDENTIFIED BY 'passw0rd'"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task createTable(type: MySqlTask, dependsOn: createUser) &#123;</span><br><span class="line">    username = 'exampleuser'</span><br><span class="line">    password = 'passw0rd'</span><br><span class="line">    database = 'example'</span><br><span class="line">    sql = 'CREATE TABLE IF NOT EXISTS users</span><br><span class="line">    (id BIGINT PRIMARY KEY, username VARCHAR(100))'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MySqlTask extends DefaultTask &#123;</span><br><span class="line">    //声明任务的属性</span><br><span class="line">    def hostname = 'localhost'</span><br><span class="line">    def port = 3306</span><br><span class="line">    def sql</span><br><span class="line">    def database</span><br><span class="line">    def username = 'root'</span><br><span class="line">    def password = 'password'</span><br><span class="line"></span><br><span class="line">//表示这是任务的动作</span><br><span class="line">@TaskAction</span><br><span class="line">def runQuery() &#123;</span><br><span class="line">	def cmd</span><br><span class="line">if(database) &#123;</span><br><span class="line">	cmd = "mysql -u $&#123;username&#125; -p$&#123;password&#125; -h 	$&#123;hostname&#125;-P $&#123;port&#125; $&#123;database&#125; -e "</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">	cmd = "mysql -u $&#123;username&#125; -p$&#123;password&#125; -h $&#123;hostname&#125; -P $&#123;port&#125; -e "</span><br><span class="line">&#125;</span><br><span class="line">project.exec &#123;</span><br><span class="line">	commandLine = cmd.split().toList() + sql</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的MySqlTask继承自DefaultTask,所有的任务都必须继承自这个类或者它的子类。任务声明了几个属性，然后声明了一个方法runQuery(),这个方法用@TaskAction注解了，表示这个方法会在任务执行的时候执行。最上面定义的三个任务都声明为MySqlTask类型，因此他们都自动继承了它的属性和方法，有些属性有默认值，你可以覆写这些默认值，来添加你的逻辑。</p>
<h3 id="在源码树中定义自定义任务类型"><a href="#在源码树中定义自定义任务类型" class="headerlink" title="在源码树中定义自定义任务类型"></a>在源码树中定义自定义任务类型</h3><p>前面你在build文件中定义了一个自定义的MySqlTask类型，这样的缺点就是你无法在其他构建文件中使用它，只能把它的源码复制过去。我们可以在源码树的buildSrc目录下定义自定义任务类型，这个目录下的文件会被自动编译然后添加到项目的classpath中，如下所示：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//任务MySqlTask并没有定义在构建脚本中</span><br><span class="line">task createDatabase(type: MySqlTask) &#123;</span><br><span class="line">    sql = 'CREATE DATABASE IF NOT EXISTS example'</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task createUser(type: MySqlTask, dependsOn: createDatabase) &#123;</span><br><span class="line">    sql = "GRANT ALL PRIVILEGES ON example.*</span><br><span class="line">    TO exampleuser@localhost IDENTIFIED BY 'passw0rd'"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task createTable(type: MySqlTask, dependsOn: createUser) &#123;</span><br><span class="line">    username = 'exampleuser'</span><br><span class="line">    password = 'passw0rd'</span><br><span class="line">    database = 'example'</span><br><span class="line">    sql = 'CREATE TABLE IF NOT EXISTS users</span><br><span class="line">    (id BIGINT PRIMARY KEY, username VARCHAR(100))'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在buildSrc目录下新建一个文件MysqlTask.groovy,然后添加下面的代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.gradle.api.DefaultTask</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.tasks.TaskAction</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MySqlTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line">    <span class="comment">//声明任务的属性</span></span><br><span class="line">    <span class="keyword">def</span> hostname = <span class="string">'localhost'</span></span><br><span class="line">    <span class="keyword">def</span> port = <span class="number">3306</span></span><br><span class="line">    <span class="keyword">def</span> sql</span><br><span class="line">    <span class="keyword">def</span> database</span><br><span class="line">    <span class="keyword">def</span> username = <span class="string">'root'</span></span><br><span class="line">    <span class="keyword">def</span> password = <span class="string">'password'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//表示这是任务的动作</span></span><br><span class="line"><span class="meta">@TaskAction</span></span><br><span class="line"><span class="keyword">def</span> runQuery() &#123;</span><br><span class="line">	<span class="keyword">def</span> cmd</span><br><span class="line"><span class="keyword">if</span>(database) &#123;</span><br><span class="line">	cmd = <span class="string">"mysql -u $&#123;username&#125; -p$&#123;password&#125; -h 	$&#123;hostname&#125;-P $&#123;port&#125; $&#123;database&#125; -e "</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	cmd = <span class="string">"mysql -u $&#123;username&#125; -p$&#123;password&#125; -h $&#123;hostname&#125; -P $&#123;port&#125; -e "</span></span><br><span class="line">&#125;</span><br><span class="line">project.exec &#123;</span><br><span class="line">	commandLine = cmd.split().toList() + sql</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译之后buildSrc目录树如下所示：</p>
<p><img src="/images/gradle-tasks.png" alt="/images/gradle-tasks.png"></p>
<p>对Gradle的任务介绍就到此为止，大家如果还有不懂的地方可以去查看Gradle的官方文档<a href="https://docs.gradle.org/current/release-notes" target="_blank" rel="external">https://docs.gradle.org/current/release-notes</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hibernate缓存配置笔记]]></title>
      <url>http://www.ezlippi.com/blog/2015/07/hibernate-cache-guide.html</url>
      <content type="html"><![CDATA[<p>Hibernate中提供了两级Cache，第一级别的缓存是Session级别的缓存，这一级别的缓存由hibernate管理的，一般情况下无需进行干预；第二级别的缓存是SessionFactory级别的缓存，它是属于进程范围或群集范围的缓存,这一级别的缓存可以进行配置和更改，并且可以动态加载和卸载。 Hibernate还为查询结果提供了一个查询缓存，它依赖于第二级缓存。<br><a id="more"></a><br><strong>一级缓存和二级缓存的要点</strong></p>
<p><img src="/images/hibernate1.png" alt=""><br><img src="/images/hibernate2.png" alt=""><br><img src="/images/hibernate3.png" alt=""></p>
<p><strong>使用二级缓存</strong></p>
<p>这里以EhCache作为二级缓存的插件为例介绍Hibernate二级缓存的配置。</p>
<p>（1）打开二级缓存：</p>
<p>为Hibernate配置二级缓存：</p>
<p>在主配置文件中hibernate.cfg.xml ：</p>
<p>Hibernate3.3以上：</p>
<pre><code>&lt;property     name=&quot;hibernate.cache.region.factory_class&quot;&gt;net.sf.ehcache.hibernate.EhCacheRegionFactory&lt;/property&gt;
</code></pre><p>Hibernate4.0以上,使用<code>org.hibernate.cache.ehcache.EhCacheRegionFactory</code>代替<code>net.sf.ehcache.hibernate.EhCacheRegionFactory</code></p>
<pre><code>&lt;!--二级缓存--&gt;
&lt;property name=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/property&gt;
&lt;!--查询缓存--&gt;
&lt;property name=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/property&gt;
在查询定义的地方加入setCacheable(true)，这次查询就被缓存起来了 
</code></pre><p>（2）配置ehcache.xml</p>
<pre><code>&lt;ehcache&gt;
&lt;!--缓存到硬盘的路径--&gt;
&lt;diskStore path=&quot;/home/lippi/ehcache&quot;/&gt;
&lt;defaultCache
maxElementsInMemory=&quot;200&quot;&lt;!-- 最多缓存多少个对象 --&gt;
eternal=&quot;false&quot;&lt;!-- 内存中的对象是否永远不变 --&gt;
timeToIdleSeconds=&quot;50&quot;&lt;!--空闲了多长时间，超过这个时间清除 --&gt;
timeToLiveSeconds=&quot;60&quot;&lt;!--总共存活时间 --&gt;
overflowToDisk=&quot;true&quot;&lt;!--内存中溢出就放到硬盘上 --&gt;
/&gt;

&lt;cache name=&quot;org.hibernate.cache.spi.UpdateTimestampsCache&quot;  
       maxElementsInMemory=&quot;5000&quot;   
       eternal=&quot;true&quot;   
       overflowToDisk=&quot;true&quot; /&gt;  
&lt;cache name=&quot;org.hibernate.cache.internal.StandardQueryCache&quot;  
       maxElementsInMemory=&quot;10000&quot;   
       eternal=&quot;false&quot;   
       timeToLiveSeconds=&quot;120&quot;  
       overflowToDisk=&quot;true&quot; /&gt; 
&lt;!--
java文件注解查找cache方法名的策略：如果不指定java文件注解中的    region=&quot;ehcache.xml中的name的属性值&quot;, 则使用name名为全限定包名, 如果不存在与类名匹配的cache名称, 则用 defaultCache，如果类中包含set集合, 则需要另行指定其cache指定缓存的对象，缓存哪一个实体类，下面出现的的属性覆盖上面出现的，没出现的继承上面的。
--&gt;
&lt;cache name=&quot;com.lippi.hibernate.pojos.Order&quot;
maxElementsInMemory=&quot;200&quot;
eternal=&quot;true&quot;
timeToIdleSeconds=&quot;0&quot;
timeToLiveSeconds=&quot;0&quot;
overflowToDisk=&quot;false&quot;
/&gt;
&lt;/ehcache&gt;
</code></pre><p>（3）使用二级缓存需要在实体类中加入注解：</p>
<pre><code>@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
</code></pre><p>Load默认使用二级缓存，就是当查一个对象的时候，它先会去二级缓存里面去找，如果找到了就不去数据库中查了。</p>
<p>Iterator默认的也会使用二级缓存，有的话就不去数据库里面查了，不发送select语句了。</p>
<p>List默认的往二级缓存中加数据，假如有一个query，把数据拿出来之后会放到二级缓存，但是执行查询的时候不会到二级缓存中查，会在数据库中查。原因每个query中查询条件不一样。</p>
<p>（4）也可以在需要被缓存的对象中hbm文件中的<class>标签下添加一个<cache>子标签:</cache></class></p>
<pre><code>&lt;hibernate-mapping&gt;
&lt;class name=&quot;com.lippi.hibernate.pojos.Order&quot; table=&quot;Orders&quot;&gt;
&lt;cache usage=&quot;read-only&quot;/&gt;
&lt;id name=&quot;id&quot; type=&quot;string&quot;&gt;
&lt;column name=&quot;id&quot;&gt;&lt;/column&gt;
&lt;generator class=&quot;uuid&quot;&gt;&lt;/generator&gt;
&lt;/id&gt;
&lt;property name=&quot;orderNumber&quot; column=&quot;orderNumber&quot; type=&quot;string&quot;&gt;&lt;/property&gt;
&lt;property name=&quot;cost&quot; column=&quot;cost&quot; type=&quot;integer&quot;&gt;&lt;/property&gt;
&lt;many-to-one name=&quot;customer&quot; class=&quot;com.lippi.hibernate.pojos.Customer&quot;
column=&quot;customer_id&quot; cascade=&quot;save-update&quot;&gt;
&lt;/many-to-one&gt;
&lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre><p>存在一对多的关系，想要在在获取一方的时候将关联的多方缓存起来，需要在集合属性下添加<cache>子标签，这里需要将关联的对象的hbm文件中必须在存在<class>标签下也添加<cache>标签，不然Hibernate只会缓存OID。</cache></class></cache></p>
<pre><code>&lt;hibernate-mapping&gt;
&lt;class name=&quot;com.lippi.hibernate.pojos.Customer&quot; table=&quot;customer&quot;&gt;
&lt;!-- 主键设置--&gt;
&lt;id name=&quot;id&quot; type=&quot;string&quot;&gt;
&lt;column name=&quot;id&quot;&gt;&lt;/column&gt;
&lt;generator class=&quot;uuid&quot;&gt;&lt;/generator&gt;
&lt;/id&gt;
&lt;!-- 属性设置--&gt;
&lt;property name=&quot;username&quot; column=&quot;username&quot; type=&quot;string&quot;&gt;&lt;/property&gt;
&lt;property name=&quot;balance&quot; column=&quot;balance&quot; type=&quot;integer&quot;&gt;&lt;/property&gt;
&lt;set name=&quot;orders&quot; inverse=&quot;true&quot; cascade=&quot;all&quot; lazy=&quot;false&quot; fetch=&quot;join&quot;&gt;
&lt;cache usage=&quot;read-only&quot;/&gt;
&lt;key column=&quot;customer_id&quot; &gt;&lt;/key&gt;
&lt;one-to-many class=&quot;com.lippi.hibernate.pojos.Order&quot;/&gt;
&lt;/set&gt;
&lt;/class&gt;
&lt;/hibernate-mapping&gt;
</code></pre><p>(5)在hibernate.cfg.xml中配置ehcache.xml文件的位置</p>
<pre><code>&lt;property name=&quot;cache.provider_configuration_file_resource_path&quot;&gt;config/hibernate/ehcache/ehcache.xml&lt;/property&gt;
</code></pre><p>(6)和Spring集成</p>
<p>在Spring集成Hibernate配置中，添加如下属性:</p>
<pre><code>&lt;prop key=&quot;hibernate.cache.use_second_level_cache&quot;&gt;true&lt;/prop&gt;
&lt;prop key=&quot;hibernate.cache.use_query_cache&quot;&gt;true&lt;/prop&gt;
&lt;prop key=&quot;hibernate.cache.region.factory_class&quot;&gt;net.sf.ehcache.hibernate.EhCacheRegionFactory&lt;/prop&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java Lambda简明教程]]></title>
      <url>http://www.ezlippi.com/blog/2015/06/java-lambda-expression.html</url>
      <content type="html"><![CDATA[<p>许多热门的编程语言如今都有一个叫做lambda或者闭包的语言特性，包括比较经典的函数式编程语言Lisp,Scheme,也有稍微年轻的语言比如JavaScript,Python,Ruby,Groovy,Scale,C#,甚至C++也有Lambda表达式。一些语言是运行在java虚拟机上，作为虚拟机最具代表的语言java当然也不想落后。<br><a id="more"></a></p>
<h1 id="究竟什么是Lambda表达式"><a href="#究竟什么是Lambda表达式" class="headerlink" title="究竟什么是Lambda表达式?"></a>究竟什么是Lambda表达式?</h1><p>Lambda表达式的概念来自于Lambda演算，下面是一个java lambda的简单例子，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">int</span> x) -&gt; &#123; <span class="keyword">return</span> x+<span class="number">1</span>; &#125;</span><br></pre></td></tr></table></figure>
<p>简单来看lambda像一个没有名字的方法，它具有一个方法应该有的部分：参数列表<code>int x</code>，方法body　<code>return x+1</code>,和方法相比lambda好像缺少了一个返回值类型、异常抛出和名字。返回值类型和异常是通过编译器在方法体中推导出来，在上面这个例子中返回值类型是int,没有抛出异常。真正缺少的就是一个名字，从这个角度来看，lambda表达式是一种匿名方法。</p>
<h1 id="Lambda表达式和匿名内部类"><a href="#Lambda表达式和匿名内部类" class="headerlink" title="Lambda表达式和匿名内部类"></a>Lambda表达式和匿名内部类</h1><p>从上面的分析可以看出lambda和java内部类的特性有点相似，匿名内部类不只是一个方法，而是一个包含一个或多个方法的类，他们的作用都是一样的，都是作为方法的参数传递，我从JDK源码中提取出来<code>listFiles(FileFilter)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles(FileFilter filter) &#123;</span><br><span class="line">	String ss[] = list();</span><br><span class="line">	<span class="keyword">if</span> (ss == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	</span><br><span class="line">	ArrayList&lt;File&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (String s : ss) &#123;</span><br><span class="line">		File f = <span class="keyword">new</span> File(s, <span class="keyword">this</span>);</span><br><span class="line">		<span class="keyword">if</span> ((filter == <span class="keyword">null</span>) || filter.accept(f))</span><br><span class="line">		files.add(f);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> files.toArray(<span class="keyword">new</span> File[files.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>listFilter</code>方法接收一个功能接口作为参数，在这里是FileFilter接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileFilter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>fileFilter</code>接收一个<code>File</code>对象返回一个<code>boolean</code>值，<code>listFiles</code>方法把<code>Filter</code>应用到所有的<code>File</code>对象接收 那些<code>accept</code>返回<code>true</code>的文件。对于<code>listFiles</code>方法来讲我们必须传递一个函数式接口给他，这是<code>FileFileter</code>的一个实现，一般我们通过匿名类来完成：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">File myDir = <span class="keyword">new</span> File(<span class="string">"／home/user/files"</span>);</span><br><span class="line"><span class="keyword">if</span> (myDir.isDirectory()) &#123;</span><br><span class="line">	File[] files = myDir.listFiles(</span><br><span class="line">	<span class="keyword">new</span> FileFilter() &#123;</span><br><span class="line">	 <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File f)</span> </span>&#123; <span class="keyword">return</span> f.isFile(); &#125;</span><br><span class="line">	 &#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　我们现在可以用lambda来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File myDir = <span class="keyword">new</span> File(<span class="string">"／home/user/files"</span>);</span><br><span class="line"><span class="keyword">if</span> (myDir.isDirectory()) &#123;</span><br><span class="line">	File[] files = myDir.listFiles(</span><br><span class="line">	(File f) -&gt; &#123; <span class="keyword">return</span> f.isFile(); &#125;</span><br><span class="line">	);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两种情况我们都是传递了一个函数式接口给方法就像传递对象一样，我们使用代码就像使用数据一样，使用匿名类我们实际上传递了一个对象给方法，使用lambda不再需要创建对象，我们只需要把lambda代码传递给方法。</p>
<p>除了传递lambda之外我们还可以传递一个方法引用，比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">File[] files = myDir.listFiles( File::isFile );</span><br></pre></td></tr></table></figure>
<h1 id="Lambda表达式的表示"><a href="#Lambda表达式的表示" class="headerlink" title="Lambda表达式的表示"></a>Lambda表达式的表示</h1><p>在之前的例子，我们使用lambda表达式定义了一个函数，我们可以把它作为参数传递给一个方法，方法把它当成一个对象来使用，lambda表达式有函数和对象的一些属性，看你从什么角度来看：</p>
<ul>
<li>从概念来讲，lambda表达式是一个匿名函数，它有签名和方法体但是没有名字</li>
<li>当lambda表达式作为参数传递给方法时，接收方法把它当对象使用，在<code>listFiles</code>方法内部，lambda表达式是一个对象的引用，在这里lambda表达式是一种常规的对象，比如有地址和类型。</li>
</ul>
<p>从实际的角度来分析，lambda对象是由编译期和运行时系统来创建的，这就允许编译期进行优化而使用者不需要关心具体细节，编译器从lambda表达式的上下文环境来获取lambda对象的语义类型，但是编译期并不创建那个对象而是直到运行时由虚拟机动态创建，这里说的动态创建是指调用<code>invokedynamic</code>字节码指令来创建。使用动态创建可以推迟对象的创建到对象第一次被使用时，如果你只是定义了lambda表达式而从未使用，它的类型和对象都不会创建。</p>
<h1 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h1><p>整个魔幻之处就在于类型的推导，这个类型称为目标类型，运行时系统动态创建的类型是目标类型的子类型。之前的那个例子我们看到目标类型是<code>FileFilter</code>,在例子中我们定义了一个lambda表达式把它传递给listFiles方法，然后listFiles方法把它作为<code>FileFilter</code>子类的一个对象来使用。这里看起来好像有点神奇，我们并没有声明lambda表达式实现了<code>FileFilter</code>接口，<code>listFiles</code>方法也没有表明它很愉快的接收了lambda表达式，它只是需要一个<code>FileFilter</code>的子类的对象，这是如何工作的？</p>
<p>这里面的魔术在于编译期执行了类型推导，编译器根据lambda表达式的上下文来决定需要什么类型的对象，然后编译器观察lambda表达式是否兼容需要的类型。如果Java是一种函数式编程语言的话lambda表达式最自然的类型就是某种函数式类型，用来描述函数的一种特殊类型。函数式类型仅仅描述了函数的签名比如<code>(int,int)-&gt;boolean</code>.但是Java不是函数式编程语言因此没有函数式类型，语言的设计者可以选择添加一种新的类型，由于他们不想给Java的类型系统引入太多的改变，因此他们尝试寻找一种办法来集成lambda表达式到语言中而不需要添加函数式类型。</p>
<p>结果他们使用函数式接口来代替，函数式接口是只有一个方法的接口，这样的接口在JDK里有很多，比如经典的Runnable接口，它只有一个方法<code>void run()</code>,还有很多其他的，比如<code>Readable,Callable,Iterable,closeable,Flushnable,Formattable,Comparable,Comparator</code>,或者我们前面提到的<code>FileFilter</code>接口。函数是接口和lambda表达式奕扬都只有一个方法，语言的设计者决定让编译器把lambda表达式转换成匹配的函数式接口。这种转换通常是自动的。比如我们前面提到的<code>(File f) -&gt; { return f.isFile(); }</code>,编译器知道listFiles方法的签名，因此我们需要的类型就是<code>FileFilter</code>,<code>FileFilter</code>是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileFilter</span> </span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>FileFilter仅仅需要一个方法因此它是函数式接口类型，我们定义的lambda表达式有一个相匹配的签名，接收一个<code>File</code>对象，返回一个<code>boolean</code>值，不抛出检查的异常，因此编译器把lambda表达式转换成函数式接口<code>FileFilter</code>类型。</p>
<p>假如我们有下面两个函数式接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileFilter</span> </span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span></span>; &#125;</span><br><span class="line">　</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Predicate</span>&lt;<span class="title">T</span>&gt; </span>&#123; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span></span>; &#125;</span><br></pre></td></tr></table></figure>
<p>我们的lambda表达式兼容两种函数式接口类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileFilter filter = (File f) -&gt; &#123; <span class="keyword">return</span> f.isFile(); &#125;;</span><br><span class="line"></span><br><span class="line">Predicate&lt;File&gt; predicate = (File f) -&gt; &#123; <span class="keyword">return</span> f.isFile(); &#125;;</span><br><span class="line"></span><br><span class="line">filter = predicate;<span class="comment">//错误，不兼容的类型</span></span><br></pre></td></tr></table></figure>
<p>当我们试图给两个变量相互赋值时编译器会报错，虽然两个变量都是同一个lambda表达式，原因很简单两个变量是不同的类型。也有可能出现编译器无法判断匹配的函数式接口类型，比如这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object ref　= (File f) -&gt; &#123; <span class="keyword">return</span> f.isFile(); &#125;;</span><br></pre></td></tr></table></figure>
<p>这个赋值语句的上下文没有提供足够的信息来转换，因此编译器会报错，解决这个问题最简单的方法就是添加一个类型转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　	Object ref　= (FileFilter) (File f) -&gt; &#123; <span class="keyword">return</span> f.isFile(); &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="Lambda表达式和匿名内部类的区别"><a href="#Lambda表达式和匿名内部类的区别" class="headerlink" title="Lambda表达式和匿名内部类的区别"></a>Lambda表达式和匿名内部类的区别</h1><p>Lambda表达式出现在我们通常需要匿名内部类的地方，在很多场合他们是可以互换的。但是他们还是有几个区别：</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>匿名类一般这样编写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File[] fs = myDir.<span class="function">lis <span class="title">tFiles</span><span class="params">(</span><br><span class="line">	new FileFilter()</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File f)</span> </span>&#123; <span class="keyword">return</span> f.isFile(); &#125;</span><br><span class="line">	&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>而Lambda表达式有多种形式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File[] files = myDir.listFiles( (File f) -&gt; &#123;<span class="keyword">return</span> f.isFile();&#125; );</span><br><span class="line">File[] files = myDir.listFiles( f -&gt; f.isFile() );</span><br><span class="line">F ile[] fil e s = myDir.listFiles( File::isFile );</span><br></pre></td></tr></table></figure>
<h3 id="运行时成本"><a href="#运行时成本" class="headerlink" title="运行时成本"></a>运行时成本</h3><p>匿名类相对Lambda表达式来讲多了一些成本，使用匿名类或造成新类型的创建、新类型对象的创建。运行时匿名内需要：</p>
<ul>
<li>类加载</li>
<li>内存分配、对象初始化</li>
<li>调用非静态方法</li>
</ul>
<p>Lambda表达式需要函数式接口的转换和最终的调用，类型推导发生在编译期，不需要运行时消耗，之前提到过，lambda对象的创建是通过字节码指令<code>invokedynamic</code>来完成的，减少了类型和实例的创建消耗。</p>
<h3 id="变量绑定"><a href="#变量绑定" class="headerlink" title="变量绑定"></a>变量绑定</h3><p>匿名类可以访问外部域的<code>final</code>变量，如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">final</span> <span class="keyword">int</span> cnt = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"count: "</span> + cnt);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">	t.start();</span><br><span class="line"></span><br><span class="line">	cnt++;<span class="comment">// error: cnt is final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于lambda表达式，cnt变量不需要显式声明为final的，一旦变量在lambda中使用编译期会自动把它当成是<code>final</code>的变量，换句话说在lambda中使用的外部域变量是隐式final的，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	Runnable r = () -&gt; &#123; System.out.println(<span class="string">"count: "</span> + cnt);</span><br><span class="line">	&#125;;</span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">	t.start();</span><br><span class="line"></span><br><span class="line">	cnt++;<span class="comment">// error: cnt is implicitly final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从java8开始匿名内部类也不需要再显式声明final类，编译器会自动把它当成是final。</p>
<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>匿名内部类是一个类，也就是说它自己引入了一个作用域，你可以在里面定义变量，而lambda表达式没有自己的作用域。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">16</span>;</span><br><span class="line">	Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// fine</span></span><br><span class="line">		System.out.println(<span class="string">"cnt is: "</span> + cnt); &#125;</span><br><span class="line">		&#125;;</span><br><span class="line">　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>lambda表达式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> cnt = <span class="number">16</span>;</span><br><span class="line">	Runnable r = () -&gt; &#123; <span class="keyword">int</span> cnt = <span class="number">0</span>; <span class="comment">// error: cnt has already been defined</span></span><br><span class="line">		System.out.println(<span class="string">"cnt is: "</span> + cnt);</span><br><span class="line">	&#125;;</span><br><span class="line">　</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的作用域规则对于<code>this</code>和<code>super</code>关键字有不同的效果，在匿名类中<code>this</code>表示匿名类对象本身的引用，<code>super</code>表示匿名类的父类。在lambda表达式<code>this</code>和<code>super</code>关键字意思和外部域中<code>this</code>和<code>super</code>的意思一样，<code>this</code>一般是包含它的那个对象，<code>super</code>表示包含它的类的父类。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[安卓开发者必备的42个链接]]></title>
      <url>http://www.ezlippi.com/blog/2015/05/android-links.html</url>
      <content type="html"><![CDATA[<p>官方网站</p><br><p>1、<a href="http://developer.android.com/develop/index.html" class="external" rel="nofollow" target="_blank">谷歌安卓开发者页面 </a></p><br><p>这里是主站点，在这您可以找到一切资源帮助您开始安卓开发。此站包含了很多关于学习基础知识的资源，完整的API引用，以及你开始开发所需的各种工具。此站共分为五个部分：</p><br><a id="more"></a><br><ul><br><li>作为初学者，你应该从<a href="http://developer.android.com/tools/index.html" class="external" rel="nofollow" target="_blank">工具</a>开始，这部分讲解了如何安装安卓SDK。</li><br><li><a href="http://developer.android.com/training/index.html" class="external" rel="nofollow" target="_blank">教程</a>为你提供了关于安卓的基本介绍，教给你如何写出你的第一个程序。它包括很多的资源，即便成为高级程序员你仍需阅读这里面的文章。</li><br><li><a href="(http://developer.android.com/guide/components/index.html ">API指南</a>是对于不同API更技术性的手册，在更加深入理解安卓内部工作方面十分有用。</li><br><li><a href="http://developer.android.com/reference/packages.html " target="_blank" rel="external">参考手册</a>包含关于安卓库的完整的类引用。</li><br><li>在<a href="http://developer.android.com/google/index.html" class="external" rel="nofollow" target="_blank">Google Services</a>部分你会找到更多库的信息，这些库可以让你连接到Google的服务，例如地图和Google+。</li><br></ul><br><p>教程</p><br><p>2、<a href="http://www.vogella.com/android.html" class="external" rel="nofollow" target="_blank">Vogella的安卓教程</a></p><br><p>这里面包括许多给初学者以及高级安卓开发者的教程。这些文章由Lars Vogel编写，文章十分专业，为你提供对安卓架构的深入理解。</p><br><p>3、<a href="http://www.edumobile.org/android/" class="external" rel="nofollow" target="_blank">EduMobile 安卓开发与编程</a></p><br><p>在这里你可以找到许多基于单独话题的教程。这些教程并非按照循序渐进的顺序排列的，但是却包含了多种多样的独立话题。</p><br><p>4、<a href="http://www.coreservlets.com/android-tutorial/" class="external" rel="nofollow" target="_blank">CoreServlets安卓编程教程</a></p><br><p>这是一个更循序渐进的教程系列，可以在你迈出安卓编程的第一步时为你指导。</p><br><p>5、<a href="http://www.linux.com/learn/docs/683628-android-programming-for-beginners-part-1" class="external" rel="nofollow" target="_blank">给初学者的安卓Linux编程</a></p><br><p>该教程由三部分组成的，是由linux.com主办目标受众是具有Java背景的安卓初学者。</p><br><p>6、<a href=" http://androiddevblog.blogspot.co.uk/" target="_blank" rel="external">安卓快乐编程</a></p><br><p>这是一个程序员学习安卓的博客。Kinam Choi在他了解安卓架构过程中通过他的经验帮助你来理解。</p><br><p>7、<a href="http://blog.stylingandroid.com/" class="external" rel="nofollow" target="_blank">Styling Android</a></p><br><p>在这个博客中Mark Allison 专注于设计和安卓应用程序的布局。对于那些想要写出有着杰出UI、漂亮的程序的人来说，这是非常有用的资源。</p><br><p>8、<a href="http://forum.xda-developers.com/showthread.php?t=2092271" class="external" rel="nofollow" target="_blank">“How To Make An Android App”  XDA 论坛</a><br><br>这里包含了一系列的论坛帖子，这些帖子指导你开发简单的安卓应用程序。</p><br><p>视频教程</p><br><p>9、<a href="http://www.youtube.com/playlist?list=PL2F07DBCDCC01493A" class="external" rel="nofollow" target="_blank">TheNewBoston 安卓教程</a></p><br><p>这里有200个视频教程，这些教程专注于安卓开发的各个方面，从下载和安装安卓SDK开始。大多数视频在5分钟左右，这使得你可以在任何小憩的时候看上一段。</p><br><p>10、<a href="http://www.youtube.com/playlist?list=PLGLfVvz_LVvQUjiCc8lUT9aO0GsWA4uNe" class="external" rel="nofollow" target="_blank">Derek Banas 安卓开发教程</a></p><br><p>Derek 定期的上传关于各种主题的视频教程。目前共有五个关于安卓开发的视频。</p><br><p>11、<a href=" http://www.youtube.com/watch?v=I7i7B4SK0Z4&amp;feature=channel" target="_blank" rel="external"> “如何进行Android编程”</a> — tgent07</p><br><p>这里有10个简单的视频为你介绍安卓开发。有些视频是其它教程很少涉及到的内容。全部看完10个视频大概需要两个小时左右。</p><br><p>12、<a href="http://www.youtube.com/user/androiddevelopers" class="external" rel="nofollow" target="_blank">安卓开发者</a></p><br><p>如果你想紧跟安卓开发的步伐，那么你应该订阅官方的安卓开发者（Android Developers）频道。这里你会学习到最新的特性以及独门绝技。</p><br><p>13、<a href="http://www.youtube.com/user/AndroidAuthority" class="external" rel="nofollow" target="_blank">Android Authority</a> （安卓权威）</p><br><p>这是另一个专注于安卓的频道。主要是面向用户，但是作为一个好的开发者，你也应该时刻了解用户的观点。</p><br><p>工具</p><br><p>14、<a href="http://developer.android.com/tools/sdk/eclipse-adt.html" class="external" rel="nofollow" target="_blank">ADT Plugin for Eclipse</a> （ADT 插件）</p><br><p>对于新手而言，这是目前开发程序的标准的方式，也是最佳选项。Android Developer Tools 插件在<span class="wp_keywordlink"><a href="http://res.importnew.com/eclipse" title="Eclipse ImportNew主页" target="_blank">Eclipse</a></span>中集成了安卓SDK并且包括一个图形化的布局编辑器，它能自动生成布局XML文件。如果你不喜欢Eclipse，你也可以尝试用<a href="http://www.jetbrains.com/idea/" class="external" rel="nofollow" target="_blank">IntelliJ IDEA 12</a> 来替代。</p><br><p>15、<a href="http://androidannotations.org/" class="external" rel="nofollow" target="_blank">AndroidAnnotations</a></p><br><p>AndroidAnnotations 通过使用Java注解来创建样板代码，从而简化了安卓应用程序的开发。它负责替你来最常用的任务从而显著地提高代码开发速度，同时增加了代码的可读性。</p><br><p>16、<a href="https://github.com/roboguice/roboguice" class="external" rel="nofollow" target="_blank">RoboGuice</a></p><br><p>RoboGuice的目的在与为安卓开发加入依赖注入。 RoboGuice同时利用了标注以及Java映像来达到它的目标。</p><br><p>资源</p><br><p>17、<a href="https://play.google.com/store/apps/details?id=com.tual&#038;hl=en" class="external" rel="nofollow" target="_blank">The Ultimate Android Library</a> (T.U.A.L) 终极安卓库</p><br><p>这是一个展现了许多定制库、图标和视图的程序。你可以在你的设备上安装这个程序并且在action中看到这些元素。你也可以在他们的网站上贡献新的的库。</p><br><p>18、<a href="http://www.androidviews.net/" class="external" rel="nofollow" target="_blank">AndroidViews</a></p><br><p>这里有许多定制视图、库和其它资源。你不用重新发明已有的东西，所以可以节省很多时间。</p><br><p>19、<a href="http://www.chupamobile.com/" class="external" rel="nofollow" target="_blank">Chupa Mobile</a></p><br><p>如果你愿意为应用程序组件花钱的话，那么这个市场就是为你而存在的。同是你也可以考虑卖出你自己的定制组件，小工具等等。</p><br><p>APP UI 设计</p><br><p>20、<a href=" http://developer.android.com/design/index.html" target="_blank" rel="external">官方设计指南</a></p><br><p>这是安卓网页上的官方站点。它包含所有程序设计的基本信息。</p><br><p>21、<a href="http://www.androidpatterns.com/" class="external" rel="nofollow" target="_blank">Android Patterns</a></p><br><p>这是一个UI模式的目录，它解释了与你的应用程序交互的最常用和直观的方法。如果你想为用户创建无缝体验，那么这个网站是必须要看的。</p><br><p>22、<a href="http://www.android-app-patterns.com/" class="external" rel="nofollow" target="_blank">Android App Patterns</a></p><br><p>这里有很多截图，这些截图来自不同种类的应用程序。例如，你可以比较各种导航界面来发现哪一种最适合你的程序。</p><br><p>23、<a href="http://www.mobile-patterns.com/" class="external" rel="nofollow" target="_blank">Mobile Patterns</a></p><br><p>这是另一个有很多截图的网站，既有安卓的也有iPhone。</p><br><p>24、<a href="http://speckyboy.com/2010/10/27/30-fresh-web-ui-mobile-ui-and-wireframe-kits/" class="external" rel="nofollow" target="_blank">30 Web、Mobile Wireframe Toolkits</a></p><br><p>这是一篇文章，文章包含了30个资源的链接。Wireframe 工具包让你可以更加专业地布局你的程序设计。</p><br><p>25、<a href="http://petrnohejl.github.io/Android-Cheatsheet-For-Graphic-Designers/" class="external" rel="nofollow" target="_blank">Graphic Designers Cheatsheet</a></p><br><p>如果你想创建、实现你想要的布局，并快速发布的话，这是一个非常有用的资源。</p><br><p>灵感</p><br><p>26、<a href="http://androidniceties.tumblr.com/" class="external" rel="nofollow" target="_blank">Android Niceties</a></p><br><p>这是Tumblr上的一些内容展示了最优美的安卓程序，它是启发灵感的好资源。</p><br><p>27、<a href=" http://www.lovelyui.com/" target="_blank" rel="external">Lovely.ui</a></p><br><p>这是一个展示漂亮的手机程序的网站。不仅有安卓程序也有其他的，但是对于手机程序设计者来说都非常有用。</p><br><p>博客</p><br><p>28、<a href="http://android-developers.blogspot.co.uk/" class="external" rel="nofollow" target="_blank">安卓官方开发者博客</a>  </p><br><p>这个官方博客来自于谷歌的安卓开发者。与这些内部人士保持联系以获得最新资讯是非常有必要的。</p><br><p>29、<a href="http://androidweekly.net/" class="external" rel="nofollow" target="_blank">安卓周刊</a></p><br><p>这个其实不太像是一个博客，它更像是一个每周的新闻通讯，它让你知道最新的安卓开发的问题。</p><br><p>30、<a href="http://cyrilmottier.com/" class="external" rel="nofollow" target="_blank">Cyril Mottier</a><br><br>这是一个非常好的博客，它关注与安卓界当前的发展趋势。</p><br><p>31、<a href="http://commonsware.com/blog/" class="external" rel="nofollow" target="_blank">The Commons Blog</a></p><br><p>对于了解安卓开发的更深层次的信息， 这个博客是非常必要的读物。Mark Murphy关注与开发者需要注意的细节以及陷阱。</p><br><p>32、<a href="http://www.androiduipatterns.com/" class="external" rel="nofollow" target="_blank">Android UI Patterns</a></p><br><p>在Juhani的这个博客中，他专注于应用程序的设计和可用性。</p><br><p>人物</p><br><p>要保证时刻获取最新的安卓开发的信息，最好的方式就是与那些开发或为架构出力的人们保持联系。因为安卓是谷歌创建的，你会发现开发者社区主要在Google+上（而不是Facebook上）。但是你同样可以在其他社交网站上找到他们。</p><br><p>33、<a href="https://plus.google.com/114205433913370454414/posts" class="external" rel="nofollow" target="_blank">Mark Murphy</a> （Commonsware）</p><br><p>Mark Murphy撰写了“The Busy Coder’s Guide to Android Development”这本书，此书共有2300页，其中包含了大量有用的信息。他主要使用<a href="https://plus.google.com/114205433913370454414/posts" class="external" rel="nofollow" target="_blank">Google+</a>，但他也有一个<a href="http://commonsware.com/" class="external" rel="nofollow" target="_blank">自己的网站</a>，同时也会在<a href="http://stackoverflow.com/users/115145/commonsware" class="external" rel="nofollow" target="_blank">stack overflow</a>上回答问题。</p><br><p>34、<a href="https://plus.google.com/+TorNorbye/posts" class="external" rel="nofollow" target="_blank">Tor Norbye</a></p><br><p>Tor Norbye 是谷歌公司安卓部门的一员。在安卓开发上，他从事视觉工具方面的工作。你也可在<a href="https://twitter.com/tornorbye" class="external" rel="nofollow" target="_blank">Twitter</a>和<a href="http://www.youtube.com/user/tnorbye" class="external" rel="nofollow" target="_blank">YouTube</a>上找到他，同时他也是<a href="http://javaposse.com/" class="external" rel="nofollow" target="_blank">The Java Posse</a>的一员。他的<a href="http://tornorbye.blogspot.co.uk/" class="external" rel="nofollow" target="_blank">博客</a>已经不在更新，因为他已经把主要活动转移至<a href="https://plus.google.com/+TorNorbye/posts" class="external" rel="nofollow" target="_blank">Google+</a>。</p><br><p>35、<a href="https://plus.google.com/+RomainGuy/posts" class="external" rel="nofollow" target="_blank">Romain Guy</a></p><br><p>Romain Guy 是安卓UI部门内部的专家，他专注于图形性能和动画。他使用<a href="https://plus.google.com/+RomainGuy/posts" class="external" rel="nofollow" target="_blank">Google+</a>和<a href="https://twitter.com/romainguy" class="external" rel="nofollow" target="_blank">Twitter</a>, 也在<a href="http://stackoverflow.com/users/298575/romain-guy" class="external" rel="nofollow" target="_blank">Stackoverflow</a>上回答问题，同时有自己的<a href="http://www.curious-creature.org/" class="external" rel="nofollow" target="_blank">博客</a>。请务必看看他的这个在2013 Google I/O大会上关于安卓<a href="http://www.youtube.com/watch?v=vQZFaec9NpA " target="_blank" rel="external">图形和性能</a>以及<a href="http://www.youtube.com/watch?v=ihzZrS69i_s" class="external" rel="nofollow" target="_blank">动画</a>的视频。</p><br><p>36、<a href="https://plus.google.com/105051985738280261832/posts" class="external" rel="nofollow" target="_blank">Dianne Hackborn</a></p><br><p>Dianne Hackborn 是一名安卓架构工程师。除了使用<a href="https://plus.google.com/105051985738280261832/about" class="external" rel="nofollow" target="_blank">Google+</a>，他还在<a href="http://stackoverflow.com/users/236398/hackbod" class="external" rel="nofollow" target="_blank">Stackoverflow</a>上回答问题。</p><br><p>37、<a href="https://plus.google.com/+ChrisBanes/posts" class="external" rel="nofollow" target="_blank">Chris Banes</a></p><br><p>Chris Banes 是ActionBar-<a href="https://github.com/chrisbanes/ActionBar-PullToRefresh" class="external" rel="nofollow" target="_blank">PullToRefresh</a>、<a href="https://github.com/chrisbanes/PhotoView" class="external" rel="nofollow" target="_blank">PhotoView</a>和Android-<a href="https://github.com/chrisbanes/Android-BitmapCache" class="external" rel="nofollow" target="_blank">BitmapCache</a>的作者，这三个均为对于安卓开发者非常有用的库。你可以在<a href="https://plus.google.com/+ChrisBanes/posts" class="external" rel="nofollow" target="_blank">Google+</a>、<a href="https://twitter.com/chrisbanes" class="external" rel="nofollow" target="_blank">Twitter</a>、<a href="http://stackoverflow.com/users/474997/chris-banes" class="external" rel="nofollow" target="_blank">Stackoverflow</a>、<a href="http://chris.banes.me/" class="external" rel="nofollow" target="_blank">博客</a>甚至<a href="https://www.facebook.com/chris.banes" class="external" rel="nofollow" target="_blank">Facebook</a>上找到他。</p><br><p>38、<a href="https://plus.google.com/+JakeWharton/posts" class="external" rel="nofollow" target="_blank">Jake Wharton</a></p><br><p>Jake Wharton是Android-<a href="https://github.com/JakeWharton/Android-ViewPagerIndicator" class="external" rel="nofollow" target="_blank">ViewPagerIndicator</a>和<a href="http://actionbarsherlock.com/" class="external" rel="nofollow" target="_blank">ActionBarSherlock</a>的开发者，这两者简化了所有版本安卓中action bar<span class="wp_keywordlink_affiliate"><a href="http://www.amazon.cn/gp/product/B001130JN8/ref=as_li_qf_sp_asin_il_tl?ie=UTF8&#038;tag=importnew-23&#038;linkCode=as2&#038;camp=536&#038;creative=3200&#038;creativeASIN=B001130JN8" title="设计模式:可复用面向对象软件的基础" rel="nofollow" target="_blank" class="external">设计模式</a></span>的使用。他使用<a href="https://plus.google.com/+JakeWharton/posts" class="external" rel="nofollow" target="_blank">Google+</a>、<a href="https://twitter.com/JakeWharton" class="external" rel="nofollow" target="_blank">Twitter</a>, 同时也在<a href="http://stackoverflow.com/users/132047/jake-wharton" class="external" rel="nofollow" target="_blank">Stackoverflow</a>上回答问题。</p><br><p>39、<a href="https://plus.google.com/+RomanNurik/posts" class="external" rel="nofollow" target="_blank">Roman Nurik</a></p><br><p>Roman Nurik 对于安卓的贡献主要是改善了用户体验和视觉设计。你可以在<a href="https://plus.google.com/+RomanNurik/posts" class="external" rel="nofollow" target="_blank">Google+</a>、<a href="https://twitter.com/romannurik" class="external" rel="nofollow" target="_blank">Twitter</a>、<a href="http://stackoverflow.com/users/102703/roman-nurik" class="external" rel="nofollow" target="_blank">Stackoverflow</a>和<a href="http://dribbble.com/romannurik" class="external" rel="nofollow" target="_blank">Dribbble</a>上关注他。</p><br><p>40、<a href="https://plus.google.com/+AdamWPowell/posts" class="external" rel="nofollow" target="_blank">Adam Powell</a></p><br><p>Adam Powell 是一名安卓架构开发者，他主要从事UI工具箱的工作。你可以在<a href="https://plus.google.com/+AdamWPowell/about" class="external" rel="nofollow" target="_blank">Google+</a>、<a href="https://twitter.com/adamwp" class="external" rel="nofollow" target="_blank">Twitter</a>和<a href="http://stackoverflow.com/users/342605/adamp" class="external" rel="nofollow" target="_blank">Stackoverflow</a>上找到他。</p><br><p>41、<a href="https://plus.google.com/+RichHyndman/posts" class="external" rel="nofollow" target="_blank">Richard Hyndman</a></p><br><p>Richard Hyndman是安卓开发组的一员。他主要在<a href="https://plus.google.com/+RichHyndman/posts" class="external" rel="nofollow" target="_blank">Google+</a>和<a href="https://twitter.com/geekyouup" class="external" rel="nofollow" target="_blank">Twitter</a>上发帖。</p><br><p>42、<a href="https://plus.google.com/+CyrilMottier/posts" class="external" rel="nofollow" target="_blank">Cyril Mottier</a></p><br><p>Cyril Mottier 是<a href="https://github.com/cyrilmottier/GreenDroid" class="external" rel="nofollow" target="_blank">GreenDroid</a>和常规<a href="http://cyrilmottier.com/" class="external" rel="nofollow" target="_blank">blogger</a>的开发者。你可以在<a href="https://plus.google.com/+CyrilMottier/posts" class="external" rel="nofollow" target="_blank">Google+</a>和<a href="https://twitter.com/cyrilmottier" class="external" rel="nofollow" target="_blank">Twitter</a>上找到他。</p><br><p>片尾备注</p><br><p>我希望这些链接都是有用的，我也相信它们会让你忙活一阵子的。我尝试在适合初学者的内容和高级内容之间找到一个平衡点，并将二者均匀地结合起来。如果你有任何更多的评论或者建议，如果你发现了任何错误，或者你想让我知道哪些链接对你来说是最重要的，请给通过留言告诉我。</p>


<p>原文链接： <a target="_blank" href="http://cogitolearning.co.uk/?p=858" class="external" rel="nofollow">cogitolearning</a>    翻译： <a href="http://www.importnew.com" target="_blank" rel="external"> ImportNew.com </a> - <a href="http://www.importnew.com/author/lijuanlong" target="_blank" rel="external">汤米猫</a><br>译文链接： <a href="http://www.importnew.com/8229.html" target="_blank" rel="external">http://www.importnew.com/8229.html</a><br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android自定义视图教程]]></title>
      <url>http://www.ezlippi.com/blog/2015/05/define-custom-view.html</url>
      <content type="html"><![CDATA[<p>Android的UI元素都是基于View(屏幕中单个元素)和ViewGroup(元素的集合),Android有许多自带的组件和布局，比如Button、TextView、RelativeLayout。在app开发过程中我们需要自定义视图组件来满足我们的需求。通过继承自View或者View的子类，覆写onDraw或者onTouchEvent等方法来覆盖视图的行为。<br><a id="more"></a></p>
<h2 id="创建完全自定义的组件"><a href="#创建完全自定义的组件" class="headerlink" title="创建完全自定义的组件"></a>创建完全自定义的组件</h2><p>创建自定义的组件主要围绕着以下五个方面：</p>
<ul>
<li>绘图(Drawing)： 控制视图的渲染，通常通过覆写onDraw方法来实现</li>
<li>交互(Interaction)： 控制用户和视图的交互方式，比如OnTouchEvent,gestures</li>
<li>尺寸(Measurement)： 控制视图内容的维度，通过覆写onMeasure方法</li>
<li>属性(Attributes)： 在XML中定义视图的属性，使用TypedArray来获取属性值</li>
<li>持久化(Persistence)： 配置发生改变时保存和恢复状态，通过onSaveInstanceState和onRestoreInstanceState</li>
</ul>
<p>举个栗子，假设我们想创建一个图形允许用户点击的时候改变形状（方形、圆形、三角形）。如下所示：</p>
<p><img src="/images/dag48.png" alt=""></p>
<h3 id="定义视图类"><a href="#定义视图类" class="headerlink" title="定义视图类"></a>定义视图类</h3><p>我们创建一个ShapeSelectorView继承自View，实现必要的构造器，如下所示：</p>
<pre><code>public class ShapeSelectorView extends View {
  // We must provide a constructor that takes a Context and an AttributeSet.
  // This constructor allows the UI to create and edit an instance of your view.
  public ShapeSelectorView(Context context, AttributeSet attrs) {
    super(context, attrs);
    }
}
</code></pre><h3 id="添加视图到布局中"><a href="#添加视图到布局中" class="headerlink" title="添加视图到布局中"></a>添加视图到布局中</h3><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;
    &lt;com.codepath.example.customviewdemo.ShapeSelectorView
    android:id=&quot;@+id/shapeSelector&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:layout_alignParentRight=&quot;true&quot;
    android:layout_alignParentTop=&quot;true&quot;
    android:layout_alignParentLeft=&quot;true&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>接下来我们定义一个命名空间app,这个命名空间允许Android自动解析而不需要指定具体的包名。</p>
<h3 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h3><p>视图可以通过XML来配置属性和样式，你需要想清楚要添加那些自定义的属性，比如我们想让用户可以选择形状的颜色、是否显示形状的名称，比如我们想让视图可以像下面一样配置：</p>
<pre><code>&lt;com.codepath.example.customviewdemo.ShapeSelectorView
    app:shapeColor=&quot;#7f0000&quot;
    app:displayShapeName=&quot;true&quot;
    android:id=&quot;@+id/shapeSelector&quot;
    ... /&gt;
</code></pre><p>为了能够定义shapeColor和displayShapeName,我们需要在res/values/attrs.xml中配置：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
   &lt;declare-styleable name=&quot;ShapeSelectorView&quot;&gt;
       &lt;attr name=&quot;shapeColor&quot; format=&quot;color&quot; /&gt;
       &lt;attr name=&quot;displayShapeName&quot; format=&quot;boolean&quot; /&gt;
   &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>对于每个你想自定义的属性你需要定义attr节点，每个节点有name和format属性，format属性是我们期望的值的类型，比如color,dimension,boolean,integer,float等。一旦定义好了属性，你可以像使用自带属性一样使用他们，唯一的区别在于你的自定义属性属于一个不同的命名空间，你可以在根视图的layout里面定义命名空间，一般情况下你只需要这样子指定：<code>http://schemas.android.com/apk/res/&lt;package_name&gt;</code>,但是你可以使用<code>http://schemas.android.com/apk/res-auto</code>自动解析命名空间。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; &gt;
    &lt;com.codepath.example.customviewdemo.ShapeSelectorView
       app:shapeColor=&quot;#7f0000&quot;
       app:displayShapeName=&quot;true&quot;
       android:id=&quot;@+id/shapeSelector&quot;
       android:layout_width=&quot;wrap_content&quot;
       android:layout_height=&quot;wrap_content&quot;
       android:layout_above=&quot;@+id/btnSelect&quot;
       android:layout_alignParentLeft=&quot;true&quot;
       android:layout_below=&quot;@+id/tvPrompt&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><h3 id="应用自定义属性"><a href="#应用自定义属性" class="headerlink" title="应用自定义属性"></a>应用自定义属性</h3><p>在前面我们定义了shapeColor和displayShapeName两个属性值，我们需要提取这两个属性值来用在自定义的视图中，可以使用TypedArray和obtainStyledAttributes方法来完成，如下所示：</p>
<pre><code>public class ShapeSelectorView extends View {
  private int shapeColor;
  private boolean displayShapeName;

  public ShapeSelectorView(Context context, AttributeSet attrs) {
    super(context, attrs);
    setupAttributes(attrs);
  }

  private void setupAttributes(AttributeSet attrs) {
    // Obtain a typed array of attributes
    TypedArray a = getContext().getTheme().obtainStyledAttributes(attrs, R.styleable.ShapeSelectorView, 0, 0);
    // Extract custom attributes into member variables
    try {
      shapeColor = a.getColor(R.styleable.ShapeSelectorView_shapeColor, Color.BLACK);
      displayShapeName = a.getBoolean(R.styleable.ShapeSelectorView_displayShapeName, false);
    } finally {
      // TypedArray objects are shared and must be recycled.
      a.recycle();
    }
  }
}
</code></pre><p>接下来添加一些getter和setter方法：</p>
<pre><code>public class ShapeSelectorView extends View {
  // ...
  public boolean isDisplayingShapeName() {
    return displayShapeName;
  }

  public void setDisplayingShapeName(boolean state) {
    this.displayShapeName = state;
    invalidate();
    requestLayout();
  }

  public int getShapeColor() {
    return shapeColor;
  }

  public void setShapeColor(int color) {
    this.shapeColor = color;
    invalidate();
    requestLayout();
  }
}
</code></pre><p>当视图属性发生改变的时候可能需要重新绘图，你需要调用invalidate()和requestLayout()来刷新显示。</p>
<h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><p>假设我们要使用前面的属性画一个长方形，所有的绘图都是在onDraw方法里执行，使用Canvas对象来绘图，如下所示：</p>
<pre><code>public class ShapeSelectorView extends View {
  // ...
  private int shapeWidth = 100;
  private int shapeHeight = 100;
  private int textXOffset = 0;
  private int textYOffset = 30;
  private Paint paintShape;

  // ...
  public ShapeSelectorView(Context context, AttributeSet attrs) {
    super(context, attrs);
    setupAttributes(attrs);
    setupPaint();
  }

  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.drawRect(0, 0, shapeWidth, shapeHeight, paintShape);
    if (displayShapeName) {
      canvas.drawText(&quot;Square&quot;, shapeWidth + textXOffset, shapeHeight + textXOffset, paintShape);
    }
  }

  private void setupPaint() { 
      paintShape = new Paint();
      paintShape.setStyle(Style.FILL);
      paintShape.setColor(shapeColor);
      paintShape.setTextSize(30);
   }
}
</code></pre><p>这段代码就会根据XML里设置的shapeColor来画图，根据displayShapeName属性来决定是否显示图形的名称，结果如下图：</p>
<p><img src="/images/dag49.png" alt=""></p>
<p>更多画图的教程可以参考这里<a href="http://developer.android.com/guide/topics/graphics/2d-graphics.html" target="_blank" rel="external"> Custom 2D Drawing Tutorial</a></p>
<h3 id="计算尺寸"><a href="#计算尺寸" class="headerlink" title="计算尺寸"></a>计算尺寸</h3><p>为了更好的理解自定义视图的宽度和高度，我们需要定义onMeasure方法，这个方法根据视图的内容来决定它的宽度和高度，在这里宽度和高度是由形状和下面的文本决定的，如下所示：</p>
<pre><code>public class ShapeSelectorView extends View {
  @Override
  protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    // Defines the extra padding for the shape name text
    int textPadding = 10;
    int contentWidth = shapeWidth;

    // Resolve the width based on our minimum and the measure spec
    int minw = contentWidth + getPaddingLeft() + getPaddingRight();
    int w = resolveSizeAndState(minw, widthMeasureSpec, 0);

    // Ask for a height that would let the view get as big as it can
    int minh = shapeHeight + getPaddingBottom() + getPaddingTop();
    if (displayShapeName) { 
    minh += textYOffset + textPadding;
    }
    int h = resolveSizeAndState(minh, heightMeasureSpec, 0);

    // Calling this method determines the measured width and height
    // Retrieve with getMeasuredWidth or getMeasuredHeight methods later
    setMeasuredDimension(w, h);
  }
}
</code></pre><p>宽度和高度都是基于MeasureSpec来讨论的，一个MeasureSpec封装了父布局传递给子布局的布局要求，每个MeasureSpec代表了一组宽度和高度的要求。一个MeasureSpec由大小和模式组成。它有三种模式：UNSPECIFIED(未指定),父元素未给子元素施加任何束缚，子元素可以得到任意想要的大小；EXACTLY(完全)，父元素决定子元素的确切大小，子元素将被限定在给定的边界里而忽略它本身大小；AT_MOST(至多)，子元素至多达到指定大小的值。resolveSizeAndState()方法根据视图想要的大小和MeasureSpec返回一个合适的值，最后你需要调用setMeasureDimension()方法生效。</p>
<h3 id="不同形状之间切换"><a href="#不同形状之间切换" class="headerlink" title="不同形状之间切换"></a>不同形状之间切换</h3><p>如果想实现用户点击之后改变形状，需要在onTouchEvent方法里添加自定义逻辑：</p>
<pre><code>public class ShapeSelectorView extends View {
  // ...
  private String[] shapeValues = { &quot;square&quot;, &quot;circle&quot;, &quot;triangle&quot; };
  private int currentShapeIndex = 0;

  // Change the currentShapeIndex whenever the shape is clicked
  @Override
  public boolean onTouchEvent(MotionEvent event) {
    boolean result = super.onTouchEvent(event);
    if (event.getAction() == MotionEvent.ACTION_DOWN) {
      currentShapeIndex ++;
      if (currentShapeIndex &gt; (shapeValues.length - 1)) {
    currentShapeIndex = 0;
      }
      postInvalidate();
      return true;
    }
    return result;
  }
}
</code></pre><p>现在不管什么时候视图被单击，选择的形状的下标会改变，调用postInvalisate()方法后会显示一个不同的形状，接下来更新onDraw()方法来实现更改形状的逻辑：</p>
<pre><code>public class ShapeSelectorView extends View {
  // ...

  @Override
  protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    String shapeSelected = shapeValues[currentShapeIndex];
    if (shapeSelected.equals(&quot;square&quot;)) {
      canvas.drawRect(0, 0, shapeWidth, shapeHeight, paintShape);
      textXOffset = 0;
    } else if (shapeSelected.equals(&quot;circle&quot;)) {
      canvas.drawCircle(shapeWidth / 2, shapeHeight / 2, shapeWidth / 2, paintShape);
      textXOffset = 12;
    } else if (shapeSelected.equals(&quot;triangle&quot;)) {
      canvas.drawPath(getTrianglePath(), paintShape);
      textXOffset = 0;
    }
    if (displayShapeName) {
      canvas.drawText(shapeSelected, 0 + textXOffset, shapeHeight + textYOffset, paintShape);
    }
  }

  protected Path getTrianglePath() {
    Point p1 = new Point(0, shapeHeight), p2 = null, p3 = null;
    p2 = new Point(p1.x + shapeWidth, p1.y);
    p3 = new Point(p1.x + (shapeWidth / 2), p1.y - shapeHeight);
    Path path = new Path();
    path.moveTo(p1.x, p1.y);
    path.lineTo(p2.x, p2.y);
    path.lineTo(p3.x, p3.y);
    return path;
  }

  // ...
}
</code></pre><p>现在每次点击都会显示一个不同的形状，结果如下：</p>
<p><img src="/images/dag50.png" alt=""></p>
<p>接下来添加一个获取形状的方法：</p>
<pre><code>public class ShapeSelectorView extends View {
  // ...
  // Returns selected shape name
  public String getSelectedShape() {
    return shapeValues[currentShapeIndex];
  }
}
</code></pre><h3 id="保存视图的状态"><a href="#保存视图的状态" class="headerlink" title="保存视图的状态"></a>保存视图的状态</h3><p>当配置发生改变的时候(比如屏幕旋转)视图需要保存它们的状态，你可以实现onSaveInstanceState()和onRestoreInstanceState()方法来保存和恢复视图状态，如下所示：</p>
<pre><code>public class ShapeSelectorView extends View {
  // This is the view state for this shape selector
  private int currentShapeIndex = 0;

  @Override
  public Parcelable onSaveInstanceState() {
    // Construct bundle
    Bundle bundle = new Bundle();
    // Store base view state
    bundle.putParcelable(&quot;instanceState&quot;, super.onSaveInstanceState());
    // Save our custom view state to bundle
    bundle.putInt(&quot;currentShapeIndex&quot;, this.currentShapeIndex);
    // ... store any other custom state here ...
    // Return the bundle
    return bundle;
  }

  @Override
  public void onRestoreInstanceState(Parcelable state) {
    // Checks if the state is the bundle we saved
    if (state instanceof Bundle) {
      Bundle bundle = (Bundle) state;
      // Load back our custom view state
      this.currentShapeIndex = bundle.getInt(&quot;currentShapeIndex&quot;);
      // ... load any other custom state here ...
      // Load base view state back
      state = bundle.getParcelable(&quot;instanceState&quot;);
    }
    // Pass base view state on to super
    super.onRestoreInstanceState(state);
  }
}
</code></pre><p>一旦你实现了这些保存和恢复的逻辑，当手机配置改变的时候你的视图能够自动保存状态。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列教程之依赖管理]]></title>
      <url>http://www.ezlippi.com/blog/2015/05/gradle-dependency-management.html</url>
      <content type="html"><![CDATA[<p>这一章我将介绍Gradle对依赖管理的强大支持，学习依赖分组和定位不同类型仓库。依赖管理看起来很容易，但是当出现依赖解析冲突时就会很棘手，复杂的依赖关系可能导致构建中依赖一个库的多个版本。Gradle通过分析依赖树得到依赖报告，你将很容易找到一个指定的依赖的来源。</p>
<p>Gradle有自己的依赖管理实现，除了支持ant和Maven的特性外，Gradle关心的是性能、可靠性和复用性。<br><a id="more"></a></p>
<h2 id="简要概述依赖管理"><a href="#简要概述依赖管理" class="headerlink" title="简要概述依赖管理"></a>简要概述依赖管理</h2><p>几乎所有基于JVM的项目都会或多或少依赖其他库，假设你在开发一个基于web的项目，你很可能会依赖很受欢迎的开源框架比如Spring MVC来提高效率。Java的第三方库一般以JAR文件的形式存在，一般用库名加版本号来标识。随着开发的进行依赖的第三方库增多小的项目变的越来越大，组织和管理你的JAR文件就很关键。</p>
<h2 id="不算完美的依赖管理技术"><a href="#不算完美的依赖管理技术" class="headerlink" title="不算完美的依赖管理技术"></a>不算完美的依赖管理技术</h2><p>由于Java语言并没提供依赖管理的工具，所以你的团队需要自己开发一套存储和检索依赖的想法。你可能会采取以下几种常见的方法：</p>
<ul>
<li>手动复制JAR文件到目标机器，这是最原始的很容易出错的方法。</li>
<li>使用一个共享的存储介质来存储JAR文件(比如共享的网盘)，你可以加载网络硬盘或者通过FTP检索二进制文件。这种方法需要开发者事先建立好与仓库的连接，手动添加新的依赖到仓库中。</li>
<li>把依赖的JAR文件同源代码都添加到版本控制系统中。这种方法不需要任何额外的步骤，你的同伴在拷贝仓库的时候就能检索依赖的改变。另一方面，这些JAR文件占用了不必要的空间，当你的项目存在相互之间依赖的时候你需要频繁的check-in的检查源代码是否发生了改变。</li>
</ul>
<h2 id="自动管理依赖的重要性"><a href="#自动管理依赖的重要性" class="headerlink" title="自动管理依赖的重要性"></a>自动管理依赖的重要性</h2><p>尽管上面的方法都能用，但是这距离理想的解决方案差远了，因为他们没有提供一个标准化的方法来命名和管理JAR文件。至少你得需要开发库的准确版本和它依赖的库(传递依赖)，这个为什么这么重要？</p>
<h3 id="准确知道依赖的版本"><a href="#准确知道依赖的版本" class="headerlink" title="准确知道依赖的版本"></a>准确知道依赖的版本</h3><p>如果在项目中你没有准确声明依赖的版本这将会是一个噩梦，如果没有文档你根本无法知道这个库支持哪些特性，是否升级一个库到新的版本就变成了一个猜谜游戏因为你不知道你的当前版本。</p>
<h3 id="管理传递依赖"><a href="#管理传递依赖" class="headerlink" title="管理传递依赖"></a>管理传递依赖</h3><p>在项目的早期开发阶段传递依赖就会是一个隐患，这些库是第一层的依赖需要的，比如一个比较常见的开发方案是将Spring和Hibernate结合起来这会引入超过20个其他的开发库，一个库需要很多其他库来正常工作。下图展示了Hibernate核心库的依赖图：</p>
<p><img src="/images/5-1.png" alt=""></p>
<p>如果没有正确的管理依赖，你可以会遇到没想到过的编译期错误和运行期类加载问题。我们可以总结到我们需要一个更好的方式来管理依赖，一般来讲你想在项目元数据中声明你的依赖和它的版本号。作为一个项目自动化的过程，这个版本的库会自动从中央仓库下载、安装到你的项目中，我们来看几个现有的开源解决方案。</p>
<h3 id="使用自动化的依赖管理"><a href="#使用自动化的依赖管理" class="headerlink" title="使用自动化的依赖管理"></a>使用自动化的依赖管理</h3><p>在Java领域里支持声明的自动依赖管理的有两个项目：Apache Ivy(Ant项目用的比较多的依赖管理器)和Maven(在构建框架中包含一个依赖管理器)，我不再详细介绍这两个的细节而是解释自动依赖管理的概念和机制。</p>
<p>Ivy和Maven是通过XML描述文件来表达依赖配置，配置包含两部分：依赖的标识加版本号和中央仓库的位置(可以是一个HTTP链接)，依赖管理器根据这个信息自动定位到需要下载的仓库然后下载到你的机器中。库可以定义传递依赖，依赖管理器足够聪明分析这个信息然后解析下载传递依赖。如果出现了依赖冲突比如上面的Hibernate core的例子，依赖管理器会试着解决。库一旦被下载就会存储在本地的缓存中，构建系统先检查本地缓存中是否存在需要的库然后再从远程仓库中下载。下图显示了依赖管理的关键元素：</p>
<p><img src="/images/5-2.png" alt=""></p>
<p>Gradle通过DSL来描述依赖配置，实现了上面描述的架构。</p>
<h3 id="自动依赖管理面临的挑战"><a href="#自动依赖管理面临的挑战" class="headerlink" title="自动依赖管理面临的挑战"></a>自动依赖管理面临的挑战</h3><p>虽然依赖管理器简化了手工的操作，但有时也会遇到问题。你会发现你的依赖图中会依赖同个库的不同版本，使用日志框架经常会遇到这个问题，依赖管理器基于一个特定的解决方案只选择其中一个版本来避免版本冲突。如果你想知道某个库引入了什么版本的传递依赖，Gradle提供了一个非常有用的依赖报告来回答这个问题。下一节我会通过一个例子来讲解。</p>
<h2 id="声明依赖"><a href="#声明依赖" class="headerlink" title="声明依赖"></a>声明依赖</h2><p>DSL配置block dependencies用来给配置添加一个或多个依赖，你的项目不仅可以添加外部依赖，下面这张表显示了Gradle支持的各种不同类型的依赖。</p>
<p><img src="/images/5-3.png" alt=""></p>
<p>这一章直接扫外部模块依赖和文件依赖，我们来看看Gradle APi是怎么表示依赖的。</p>
<h3 id="理解依赖的API表示"><a href="#理解依赖的API表示" class="headerlink" title="理解依赖的API表示"></a>理解依赖的API表示</h3><p>每个Gradle项目都有一个DependencyHandler的实例，你可以通过getDependencies()方法来获取依赖处理器的引用，上表中每一种依赖类型在依赖处理器中都有一个相对应的方法。每一个依赖都是Dependency的一个实例，group, name, version, 和classifier这几个属性用来标识一个依赖，下图清晰的表示了项目(Project)、依赖处理器(DependencyHandler)和依赖三者之间的关系：</p>
<p><img src="/images/5-4.png" alt=""></p>
<h3 id="外部模块依赖"><a href="#外部模块依赖" class="headerlink" title="外部模块依赖"></a>外部模块依赖</h3><p>在Gradle的术语里，外部库通常是以JAR文件的形式存在，称之为外部模块依赖，代表项目层次外的一个模块，这种类型的依赖是通过属性来唯一的标识，接下来我们来介绍每个属性的作用。</p>
<h3 id="依赖属性"><a href="#依赖属性" class="headerlink" title="依赖属性"></a>依赖属性</h3><p>当依赖管理器从仓库中查找依赖时，需要通过属性的结合来定位，最少需要提供一个name。</p>
<ul>
<li>group： 这个属性用来标识一个组织、公司或者项目，可以用点号分隔，Hibernate的group是org.hibernate。</li>
<li>name： name属性唯一的描述了这个依赖，hibernate的核心库名称是hibernate-core。</li>
<li>version： 一个库可以有很多个版本，通常会包含一个主版本号和次版本号，比如Hibernate核心库3.6.3-Final。</li>
<li>classifier： 有时候需要另外一个属性来进一步的说明，比如说明运行时的环境，Hibernate核心库没有提供classifier。</li>
</ul>
<h3 id="依赖的写法"><a href="#依赖的写法" class="headerlink" title="依赖的写法"></a>依赖的写法</h3><p>你可以使用下面的语法在项目中声明依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	configurationName dependencyNotation1, 	dependencyNotation2, ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你先声明你要给哪个配置添加依赖，<br>Java插件指定了若干依赖配置项，其描述如下：当项目的源代码被编译时，compile配置项中的依赖是必须的。</p>
<ul>
<li>runtime配置项中包含的依赖在运行时是必须的。</li>
<li>testCompile配置项中包含的依赖在编译项目的测试代码时是必须的。</li>
<li>testRuntime配置项中包含的依赖在运行测试代码时是必须的。</li>
<li>archives配置项中包含项目生成的文件（如Jar文件）。</li>
<li>default配置项中包含运行时必须的依赖。</li>
</ul>
<p>然后添加依赖列表，你可以用map的形式来注明，你也可以直接用冒号来分隔属性，比如这样的：</p>
<p><img src="/images/5-5.png" alt=""></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明外部属性</span></span><br><span class="line">ext.cargoGroup = <span class="string">'org.codehaus.cargo'</span></span><br><span class="line">ext.cargoVersion = <span class="string">'1.3.1'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line">	<span class="comment">//使用映射声明依赖</span></span><br><span class="line">	compile <span class="string">group:</span> cargoGroup, <span class="string">name:</span> <span class="string">'cargo-core-uberjar'</span>,<span class="string">version:</span> cargoVersion</span><br><span class="line">	<span class="comment">//用快捷方式来声明，引用了前面定义的外部属性</span></span><br><span class="line">	cargo <span class="string">"$cargoGroup:cargo-ant:$cargoVersion"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你项目中依赖比较多，你把一些共同的依赖属性定义成外部属性可以简化build脚本。</p>
<p>Gradle没有给项目选择默认的仓库，当你没有配置仓库的时候运行deployTOLocalTomcat任务的时候回出现如下的错误：</p>
<pre><code>$ gradle deployToLocalTomcat
:deployToLocalTomcat FAILED
FAILURE: Build failed with an exception.

Where: Build file &apos;/Users/benjamin/gradle-in-action/code/chapter5/cargo-configuration/build.gradle&apos; line: 10

What went wrong:
Execution failed for task &apos;:deployToLocalTomcat&apos;.
&gt; Could not resolve all dependencies for configuration &apos;:cargo&apos;.
    &gt; Could not find group:org.codehaus.cargo, module:cargo-core-uberjar, version:1.3.1.
    Required by:
        :cargo-configuration:unspecified
&gt; Could not find group:org.codehaus.cargo, module:cargo-ant,version:1.3.1.
    Required by:
    :cargo-configuration:unspecified
</code></pre><p>到目前为止还没讲到怎么配置不同类型的仓库，比如你想使用MavenCentral仓库，添加下面的配置代码到你的build脚本中：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="检查依赖报告"><a href="#检查依赖报告" class="headerlink" title="检查依赖报告"></a>检查依赖报告</h3><p>当你运行dependencies任务时，这个依赖树会打印出来，依赖树显示了你build脚本声明的顶级依赖和它们的传递依赖：</p>
<p><img src="/images/5-6.png" alt=""><br><img src="/images/5-7.png" alt=""></p>
<p>仔细观察你会发现有些传递依赖标注了*号，表示这个依赖被忽略了，这是因为其他顶级依赖中也依赖了这个传递的依赖，Gradle会自动分析下载最合适的依赖。</p>
<h3 id="排除传递依赖"><a href="#排除传递依赖" class="headerlink" title="排除传递依赖"></a>排除传递依赖</h3><p>Gradle允许你完全控制传递依赖，你可以选择排除全部的传递依赖也可以排除指定的依赖，假设你不想使用UberJar传递的xml-api的版本而想声明一个不同版本，你可以使用exclude方法来排除它：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	cargo(<span class="string">'org.codehaus.cargo:cargo-ant:1.3.1'</span>) &#123;</span><br><span class="line">		exclude <span class="string">group:</span> <span class="string">'xml-apis'</span>, <span class="string">module:</span> <span class="string">'xml-apis'</span></span><br><span class="line">	&#125;</span><br><span class="line">	cargo <span class="string">'xml-apis:xml-apis:2.0.2'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exclude属性值和正常的依赖声明不太一样，你只需要声明group和(或)module，Gradle不允许你只排除指定版本的依赖。</p>
<p>有时候仓库中找不到项目依赖的传递依赖，这会导致构建失败，Gradle允许你使用transitive属性来排除所有的传递依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	cargo(<span class="string">'org.codehaus.cargo:cargo-ant:1.3.1'</span>) &#123;</span><br><span class="line">	transitive = <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 选择性的声明一些需要的库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态版本声明"><a href="#动态版本声明" class="headerlink" title="动态版本声明"></a>动态版本声明</h3><p>如果你想使用一个依赖的最新版本，你可以使用latest.integration，比如声明 Cargo Ant tasks的最新版本，你可以这样写 <code>org.codehaus
.cargo:cargo-ant:latest-integration</code>，你也可以用一个+号来动态的声明：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	<span class="comment">//依赖最新的1.x版本</span></span><br><span class="line">	cargo <span class="string">'org.codehaus.cargo:cargo-ant:1.+'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Gradle的dependencies任务可以清晰的看到选择了哪个版本，这里选择了1.3.1版本：</p>
<pre><code>$ gradle –q dependencies
------------------------------------------------------------
Root project
------------------------------------------------------------
Listing 5.4 Excluding a single dependency
Listing 5.5 Excluding all transitive dependencies
Listing 5.6 Declaring a dependency on the latest Cargo 1.x version
Exclusions can be
declared in a shortcut
or map notation.
120 CHAPTER 5 Dependency management
cargo - Classpath for Cargo Ant tasks.
\--- org.codehaus.cargo:cargo-ant:1.+ -&gt; 1.3.1
\--- ...
</code></pre><h3 id="文件依赖"><a href="#文件依赖" class="headerlink" title="文件依赖"></a>文件依赖</h3><p>如果你没有使用自动的依赖管理工具，你可能会把外部库作为源代码的一部分或者保存在本地文件系统中，当你想把项目迁移到Gradle的时候，你不想去重构，Gradle很简单就能配置文件依赖。下面这段代码复制从Maven中央仓库解析的依赖到libs/cargo目录。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task copyDependenciesToLocalDir(<span class="string">type:</span> Copy) &#123;</span><br><span class="line">	<span class="comment">//Gradle提供的语法糖</span></span><br><span class="line">	from configurations.cargo.asFileTree</span><br><span class="line">	into <span class="string">"$&#123;System.properties['user.home']&#125;/libs/cargo"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行这个任务之后你就可以在依赖中声明Cargo库了，下面这段代码展示了怎么给cargo配置添加JAR文件依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">	cargo fileTree(<span class="string">dir:</span> <span class="string">"$&#123;System.properties['user.home']&#125;/libs/cargo"</span>,<span class="string">include:</span> <span class="string">'*.jar'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h2><p>Gradle支持下面三种不同类型的仓库：</p>
<p><img src="/images/5-8.png" alt=""></p>
<p>下图是配置不同仓库对应的Gradle API：</p>
<p><img src="/images/5-9.png" alt=""></p>
<p>下面以Maven仓库来介绍，Maven仓库是Java项目中使用最为广泛的一个仓库，库文件一般是以JAR文件的形式存在，用XML(POM文件)来来描述库的元数据和它的传递依赖。所有的库文件都存储在仓库的指定位置，当你在构建脚本中声明了依赖时，这些属性用来找到库文件在仓库中的准确位置。group属性标识了Maven仓库中的一个子目录，下图展示了Cargo依赖属性是怎么对应到仓库中的文件的：</p>
<p><img src="/images/5-10.png" alt=""></p>
<p>RepositoryHandler接口提供了两个方法来定义Maven仓库，mavenCentral方法添加一个指向仓库列表的引用，mavenLocal方法引用你文件系统中的本地Maven仓库。</p>
<h3 id="添加Maven仓库"><a href="#添加Maven仓库" class="headerlink" title="添加Maven仓库"></a>添加Maven仓库</h3><p>要使用Maven仓库你只需要调用mavenCentral方法，如下所示：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加本地仓库"><a href="#添加本地仓库" class="headerlink" title="添加本地仓库"></a>添加本地仓库</h3><p>本地仓库默认在 <user_home>/.m2/repository目录下，只需要添加如下脚本来引用它：</user_home></p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	mavenLocal()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="添加自定义Maven仓库"><a href="#添加自定义Maven仓库" class="headerlink" title="添加自定义Maven仓库"></a>添加自定义Maven仓库</h3><p>如果指定的依赖不存在与Maven仓库或者你想通过建立自己的企业仓库来确保可靠性，你可以使用自定义的仓库。仓库管理器允许你使用Maven布局来配置一个仓库，这意味着你要遵守artifact的存储模式。你也可以添加验证凭证来提供访问权限，Gradle的API提供两种方法配置自定义的仓库：maven()和mavenRepo()。下面这段代码添加了一个自定义的仓库，如果Maven仓库中不存在相应的库会从自定义仓库中查找：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123;</span><br><span class="line">	mavenCentral()</span><br><span class="line">	maven &#123;</span><br><span class="line">	name <span class="string">'Custom Maven Repository'</span>,</span><br><span class="line">	url <span class="string">'http://repository.forge.cloudbees.com/release/'</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Gradle系列教程之任务管理]]></title>
      <url>http://www.ezlippi.com/blog/2015/04/gradle-task-management.html</url>
      <content type="html"><![CDATA[<p>Gradle有两个最基本的概念：project和task,Gradle里面的所有东西都基于这两个概念。project通常指一个项目，而task指构建过程中的任务。一次构建可以有1到n个project，每个project有1到n个task，这篇文章主要介绍Gradle任务的创建和管理。<br><a id="more"></a></p>
<h2 id="管理任务"><a href="#管理任务" class="headerlink" title="管理任务"></a>管理任务</h2><p>每个新创建的任务都是org.gradle.api.DefaultTask类型，org.gradle.api.Task的标准实现，DefaultTask所有的域都是私有的，意味着他们只能通过setter和getter方法来访问，庆幸的是Groovy提供了一些语法糖来允许你通过名字来使用域。</p>
<h3 id="管理项目的版本"><a href="#管理项目的版本" class="headerlink" title="管理项目的版本"></a>管理项目的版本</h3><p>许多公司或者开源组织有他们自己的发布版本的措施，一般用主版本号和次版本号来表示，也会用SNAPSHOT来表示项目正在开发中，版本号是通过String类型来表示，如果你想准确获得项目的主版本号，那应该怎么办？使用正则表达式匹配点号然后过滤得到主版本号和次版本号？如果我们用一个类来表示是不是更简单？</p>
<p>你可以很简单的通过类的域来设置、查询和修改你的版本号的某个部分，甚至你可以把版本信息直接保存在一个文件里，比如一个文件或者数据库里，避免通过修改构建脚本来更改版本号，如下图所示：</p>
<p><img src="/images/dag26.png" alt=""></p>
<p>通过编程来控制版本表单对于自动化项目生命周期很有必要，比如：你的代码通过了单元测试准备交付了，当前的版本是1.3-SNAPSHOT,在打包成war文件之前你想把它变成发布版本1.3然后自动部署到服务器中，这些步骤可以划分为多个任务：一个用来修改项目的版本号另一个用于打包WAR文件。</p>
<h3 id="声明任务的动作-actions"><a href="#声明任务的动作-actions" class="headerlink" title="声明任务的动作(actions)"></a>声明任务的动作(actions)</h3><p>动作就是在你的任务中放置构建逻辑的地方，Task接口提供了两个接口来声明任务的动作：<br>doFirst和doLast，当任务执行的时候，定义在闭包里的动作逻辑就按顺序执行。</p>
<p>接下来我们会写一个简单的任务printVersion,任务的作用就是打印项目的版本号，在任务<br>的最后一个动作定义这个逻辑。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">version = <span class="string">'0.1-SNAPSHOT'</span></span><br><span class="line"></span><br><span class="line">task printVersion &#123;</span><br><span class="line">	doLast &#123;</span><br><span class="line">	println <span class="string">"Version: $version"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面我们讲过左移操作符是方法doLast的快捷键，他们的作用是一样的，当你执行gradle printVersion,你应该得到下面的输出：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gradle printVersion</span><br><span class="line">:printVersion</span><br><span class="line"><span class="string">Version:</span> <span class="number">0.1</span>-SNAPSHOT</span><br></pre></td></tr></table></figure></p>
<p>如果你用doFirst方法的话输出的结果是一样的：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">task printVersion &#123;</span><br><span class="line">	doFirst &#123;</span><br><span class="line">	println <span class="string">"Version: $version"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="给已经存在的任务添加动作"><a href="#给已经存在的任务添加动作" class="headerlink" title="给已经存在的任务添加动作"></a>给已经存在的任务添加动作</h3><p>到目前为止，你只是给printVersion这个任务添加了单个动作，要么是第一个或者最后一个，对于每个任务可以有多个动作，实际上，当任务创建的时候你可以添加任意多个动作，每一个任务都有一个动作清单，他们在运行的时候是执行的，接下来我们来修改之前的例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">task printVersion &#123;</span><br><span class="line"><span class="comment">//任务的初始声明可以添加first和last动作</span></span><br><span class="line">	doFirst &#123;</span><br><span class="line">	println <span class="string">"Before reading the project version"</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	doLast &#123;</span><br><span class="line">	println <span class="string">"Version: $version"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>//你可以在任务的动作列表的最前面添加其他任务，比如：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printVersion.doFirst &#123; println <span class="string">"First action"</span> &#125;</span><br></pre></td></tr></table></figure>
<p>由此可知，我们可以添加额外的动作给已经存在的任务，当你想添加动作的那个任务不是你自己写的时候这会非常有用，你可以添加一些自定义的逻辑，比如你可以添加doFirst动作到compile-Java任务来检查项目是否包含至少一个source文件。</p>
<h3 id="访问任务属性"><a href="#访问任务属性" class="headerlink" title="访问任务属性"></a>访问任务属性</h3><p>接下来我们来改善一下输出版本号的方法，Gradle提供一个基于SLF4J库的日子实现，除了实现了基本的日子级别（DEBUG, ERROR, INFO, TRACE, WARN)）外，还添加了额外的级别，日子实例可以通过任务的方法来直接访问，接下来，你将用QUIET级别打印项目的版本号：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task printVersion &lt;&lt; &#123;</span><br><span class="line">	logger.quiet <span class="string">"Version: $version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>访问任务的属性是不是很容易？接下来我将给你展示两个其他的属性，group和description，两个都是documentation任务的一部分，description属性简短的表示任务的目的，group表示任务的逻辑分组。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">task printVersion(<span class="string">group:</span> <span class="string">'versioning'</span>, <span class="string">description:</span> 	<span class="string">'Prints project version.'</span>) &lt;&lt; &#123;</span><br><span class="line">	logger.quiet <span class="string">"Version: $version"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你也可以通过setter方法来设置属性：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">task printVersion &#123;</span><br><span class="line">	group = <span class="string">'versioning'</span></span><br><span class="line">	description = <span class="string">'Prints project version.'</span></span><br><span class="line">	doLast &#123;</span><br><span class="line">	logger.quiet <span class="string">"Version: $version"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当你运行gradle tasks,你会看到任务显示在正确的分组里和它的描述信息：</p>
<pre><code>gradle tasks
:tasks
...
Versioning tasks
----------------
printVersion - Prints project version.
...
</code></pre><h3 id="定义任务依赖"><a href="#定义任务依赖" class="headerlink" title="定义任务依赖"></a>定义任务依赖</h3><p>dependsOn方法用来声明一个任务依赖于一个或者多个任务，接下来通过一个例子来讲解运用不同的方法来应用依赖：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">task first &lt;&lt; &#123; println <span class="string">"first"</span> &#125;</span><br><span class="line">task second &lt;&lt; &#123; println <span class="string">"second"</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明多个依赖</span></span><br><span class="line">task printVersion(<span class="string">dependsOn:</span> [second, first]) &lt;&lt; &#123;</span><br><span class="line">logger.quiet <span class="string">"Version: $version"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">task third &lt;&lt; &#123; println <span class="string">"third"</span> &#125;</span><br><span class="line"><span class="comment">//通过任务名称来声明依赖</span></span><br><span class="line">third.dependsOn(<span class="string">'printVersion'</span>)</span><br></pre></td></tr></table></figure>
<p>你可以通过命令行调用third任务来执行这个任务依赖链：</p>
<pre><code>$ gradle -q third
first
second
Version: 0.1-SNAPSHOT
third
</code></pre><p>仔细看这个执行顺序，你有没用发现printVersion声明了对second和first任务的依赖，但是first在second任务前执行了，Gradle里面任务的执行顺序并不是确定的。</p>
<h3 id="任务依赖执行顺序"><a href="#任务依赖执行顺序" class="headerlink" title="任务依赖执行顺序"></a>任务依赖执行顺序</h3><p>Gradle并不保证依赖的任务能够按顺序执行，dependsOn方法只是定义这些任务应该在这个任务之前执行，但是这些依赖的任务具体怎么执行它并不关心，如果你习惯用命令式的构建工具来定义依赖（比如ant）这可能会难以理解。在Gradle里面，执行顺序是由任务的输入输出特性决定的，这样做有很多优点，比如你想修改构建逻辑的时候你不需要去了解整个任务依赖链，另一方面，因为任务不是顺序执行的，就可以并发的执行来提高性能。</p>
<h3 id="终结者任务"><a href="#终结者任务" class="headerlink" title="终结者任务"></a>终结者任务</h3><p>在实际情况中，你可能需要在一个任务执行之后进行一些清理工作，一个典型的例子就是Web容器在部署应用之后要进行集成测试，Gradle提供了一个finalizer任务来实现这个功能，你可以用finalizedBy方法来结束一个指定的任务：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">task first &lt;&lt; &#123; println <span class="string">"first"</span> &#125;</span><br><span class="line">task second &lt;&lt; &#123; println <span class="string">"second"</span> &#125;</span><br><span class="line"><span class="comment">//声明first结束后执行second任务</span></span><br><span class="line">first.finalizedBy second</span><br></pre></td></tr></table></figure>
<p>你会发现任务first结束后自动触发任务second：</p>
<pre><code>$ gradle -q first
first
second
</code></pre><h3 id="添加随意的代码"><a href="#添加随意的代码" class="headerlink" title="添加随意的代码"></a>添加随意的代码</h3><p>接下来我们来学习怎么在build脚本中定义一些随机的代码，在实际情况下，如果你熟悉Groovy的语法你可以编写一些类或者方法，接下来你将会创建一个表示版本的类，在Java中一个class遵循bean的约定（POJO），就是添加setter和getter方法来访问类的域，到后面发现手工写这些方法很烦人，Groovy有个对应的概念叫POGO(plain-old Groovy object),他们的setter和getter方法在生成字节码的时候自动添加，因此运行的时候可以直接访问，看下面这个例子：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">version = <span class="keyword">new</span> ProjectVersion(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProjectVersion</span> &#123;</span></span><br><span class="line">	Integer major</span><br><span class="line">	Integer minor</span><br><span class="line">	Boolean release</span><br><span class="line"></span><br><span class="line">	ProjectVersion(Integer major, Integer minor) &#123;</span><br><span class="line">		<span class="keyword">this</span>.major = major</span><br><span class="line">		<span class="keyword">this</span>.minor = minor</span><br><span class="line">		<span class="keyword">this</span>.release = Boolean.FALSE</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ProjectVersion(Integer major, Integer minor, 	Boolean release) &#123;</span><br><span class="line">		<span class="keyword">this</span>(major, minor)</span><br><span class="line">		<span class="keyword">this</span>.release = release</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	String toString() &#123;</span><br><span class="line">		<span class="comment">//只有release为false的时候才添加后缀SNAPSHOT</span></span><br><span class="line">		<span class="string">"$major.$minor$&#123;release ? '' : '-SNAPSHOT'&#125;"</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当运行这个修改的脚本之后，你可以看到printVersion的输出和之前一样，但是你还是得手工修改build脚本来更改版本号，接下来你将学习如何把版本号存储在一个文件里然后配置你的脚本去读取这个配置。</p>
<h3 id="任务的配置"><a href="#任务的配置" class="headerlink" title="任务的配置"></a>任务的配置</h3><p>在你写代码之前，你要新建一个属性文件version.properties,内容如下：</p>
<pre><code>major = 0
minor = 1
release = false
</code></pre><h3 id="添加任务配置块"><a href="#添加任务配置块" class="headerlink" title="添加任务配置块"></a>添加任务配置块</h3><p>接下来我们将声明一个任务loadVersion来从属性文件中读取版本号并赋给ProjectVersion实例，第一眼看起来和其他定义的任务一样，仔细一看你会主要到你没有定义动作或者使用左移操作符，在Gradle里称之为task configuration。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ext.versionFile = file(<span class="string">'version.properties'</span>)</span><br><span class="line"><span class="comment">//配置任务没有左移操作符</span></span><br><span class="line">task loadVersion &#123;</span><br><span class="line">project.version = readVersion()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ProjectVersion readVersion() &#123;</span><br><span class="line">	logger.quiet <span class="string">'Reading the version file.'</span></span><br><span class="line">	<span class="comment">//如果文件不存在抛出异常</span></span><br><span class="line">	<span class="keyword">if</span>(!versionFile.exists()) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> GradleException(<span class="string">"Required version file does not exist:$versionFile.canonicalPath"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">Properties versionProps = <span class="keyword">new</span> Properties()</span><br><span class="line"></span><br><span class="line"><span class="comment">//groovy的file实现了添加方法通过新创建的流来读取</span></span><br><span class="line"></span><br><span class="line">versionFile.withInputStream &#123; stream -&gt;</span><br><span class="line">versionProps.load(stream)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在Groovy中如果这是最后一个语句你可以省略return关键字</span></span><br><span class="line"><span class="keyword">new</span> ProjectVersion(versionProps.major.toInteger(),</span><br><span class="line"> versionProps.minor.toInteger(), versionProps.release.toBoolean())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来运行printVersion，你会看到loadVersion任务先执行了：</p>
<pre><code>$ gradle printVersion
Reading the version file.
:printVersion
Version: 0.1-SNAPSHOT
</code></pre><p>你也许会很奇怪这个任务是怎么调用的，你没有声明依赖，也没有在命令行中调用它。<strong>任务配置块总是在任务动作之前执行的</strong>，理解这个行为的关键就是Gradle的构建生命周期，我们来看下Gradle的构建阶段：</p>
<p><img src="/images/4-1.png" alt=""></p>
<h3 id="Gradle的构建生命周期"><a href="#Gradle的构建生命周期" class="headerlink" title="Gradle的构建生命周期"></a>Gradle的构建生命周期</h3><p>无论你什么时候执行一个gradle build,都会经过三个不同的阶段：初始化、配置和执行。</p>
<p>在初始化阶段，Gradle给你的项目创建一个Project实例，你的构建脚本只定义了单个项目，在多项目构建的上下文环境中，构建的阶段更为重要。根据你正在执行的项目，Gradle找出这个项目的依赖。</p>
<p>下一个阶段就是配置阶段，Gradle构建一些在构建过程中需要的一些模型数据，当你的项目或者指定的任务需要一些配置的时候这个阶段很有帮助。</p>
<h3 id="记住不管你执行哪个build哪怕是gradle-tasks配置代码都会执行"><a href="#记住不管你执行哪个build哪怕是gradle-tasks配置代码都会执行" class="headerlink" title="记住不管你执行哪个build哪怕是gradle tasks配置代码都会执行"></a>记住不管你执行哪个build哪怕是gradle tasks配置代码都会执行</h3><p>在执行阶段任务按顺序执行，执行顺序是通过依赖关系决定的，标记为up-to-date的任务会跳过，比如任务B依赖于任务A，当你运行gradle B的时候执行顺序将是A-&gt;B。</p>
<h3 id="声明任务的输入和输出"><a href="#声明任务的输入和输出" class="headerlink" title="声明任务的输入和输出"></a>声明任务的输入和输出</h3><p>Gradle通过比较两次build之间输入和输出有没有变化来确定这个任务是否是最新的，如果从上一个执行之后这个任务的输入和输出没有发生改变这个任务就标记为up-to-date，跳过这个任务。</p>
<p><img src="/images/4-2.png" alt=""></p>
<p>输入可以是一个目录、一个或者多个文件或者随机的属性，任务的输出可以是路径或者文件，输入和输出在DefaultTask类中用域来表示。假设你想创建一个任务把项目的版本由SNAPSHOT改为release，下面的代码定义一个新任务给release变量赋值为true，然后把改变写入到文件中。</p>
<pre><code>task makeReleaseVersion(group: &apos;versioning&apos;, description: &apos;Makes project a release version.&apos;) &lt;&lt; {
    version.release = true
    //ant的propertyfile任务提供很方便的方法来修改属性文件
    ant.propertyfile(file: versionFile) {
        entry(key: &apos;release&apos;, type:&apos;string&apos;,operation: &apos;=&apos;, value: &apos;true&apos;)
    }
}
</code></pre><p>运行这个任务会修改版本属性并写入到文件中。</p>
<pre><code>$ gradle makeReleaseVersion
:makeReleaseVersion

$ gradle printVersion
:printVersion
Version: 0.1
</code></pre><h3 id="编写自定义的任务"><a href="#编写自定义的任务" class="headerlink" title="编写自定义的任务"></a>编写自定义的任务</h3><p>makeReleaseVersion的逻辑比较简单，你可能不用考虑代码维护的问题，随着构建逻辑越来越复杂，你添加了越来越多的简单的任务，这时候你就有需要用类和方法来结构化你的代码，你可以把你编写源代码的那一套代码实践搬过来。</p>
<h3 id="编写自定义任务类"><a href="#编写自定义任务类" class="headerlink" title="编写自定义任务类"></a>编写自定义任务类</h3><p>之前提到过，Gradle会给每一个任务创建一个DefaultTask类型的实例，当你要创建一个自定义的任务时，你需要创建一个继承自DefaultTask的类，看看下面这个例子：</p>
<pre><code>class ReleaseVersionTask extends DefaultTask {
    //通过注解声明任务的输入和输出    
    @Input Boolean release
    @OutputFile File destFile

    ReleaseVersionTask() {
        //在构造器里设置任务的分组和描述
        group = &apos;versioning&apos;
        description = &apos;Makes project a release version.&apos;
    }
    //通过注解声明要执行的任务
    @TaskAction
    void start() {
        project.version.release = true
        ant.propertyfile(file: destFile) {
        entry(key: &apos;release&apos;, type: &apos;string&apos;, operation: &apos;=&apos;, value: &apos;true&apos;)
    }
    }
}
</code></pre><h3 id="通过注解来表达输入和输出"><a href="#通过注解来表达输入和输出" class="headerlink" title="通过注解来表达输入和输出"></a>通过注解来表达输入和输出</h3><p>任务输入和输出注解给你的实现添加了语法糖，他们和调用TasksInputs和TaskOutputs方法是一样的效果，你一眼就知道任务期望什么样的输入数据以及会产生什么输出。我们使用@Input注解来声明输入属性release，用@OutputFile来定义输出文件。</p>
<h3 id="使用自定义的任务"><a href="#使用自定义的任务" class="headerlink" title="使用自定义的任务"></a>使用自定义的任务</h3><p>上面我们实现了自定义的动作方法，但是我们怎么使用这个方法，你需要在build脚本中创建一个ReleaseVersionTask类型的任务，通过给属性赋值来设定输入和输出：</p>
<pre><code>//定义一个ReleaseVersionTask类型的任务
task makeReleaseVersion(type: ReleaseVersionTask) {
    //设定任务属性
    release = version.release
    destFile = versionFile
}
</code></pre><h3 id="复用自定义的任务"><a href="#复用自定义的任务" class="headerlink" title="复用自定义的任务"></a>复用自定义的任务</h3><p>假设你在另一个项目中想使用前面这个自定义的任务，在另一个项目中需求又不太一样，用来表示版本的POGO有不同的域，比如下面这个：</p>
<pre><code>class ProjectVersion {
    Integer min
    Integer maj
    Boolean prodReady

    @Override
    String toString() {
    &quot;$maj.$min${prodReady? &apos;&apos; : &apos;-SNAPSHOT&apos;}&quot;
    }
}
</code></pre><p>此外，你还想把版本文件名改为project-version.properties,需要怎么做才能复用上面那个自定义的任务呢？</p>
<pre><code>task makeReleaseVersion(type: ReleaseVersionTask) {
    release = version.prodReady
    //不同的版本文件
    destFile = file(&apos;project-version.properties&apos;)
}
</code></pre><h3 id="Gradle自带的任务类型"><a href="#Gradle自带的任务类型" class="headerlink" title="Gradle自带的任务类型"></a>Gradle自带的任务类型</h3><p>Gradle自带的任务类型继承自DefaultTask，Gradle提供了很多自带的任务类型，这里我只介绍两个，Zip和copy用在发布项目中。</p>
<pre><code>//eg.使用任务类型来备份发布版本

task createDistribution(type: Zip, dependsOn:     makeReleaseVersion) {
    //引用war任务的输出
    from war.outputs.files
    //把所有文件放进ZIP文件的src目录
    from(sourceSets*.allSource) {
    into &apos;src&apos;
    }
    //添加版本文件
    from(rootDir) {
    include versionFile.name
    }
}

task backupReleaseDistribution(type: Copy) {
        //引用createDistribution的输出
        from createDistribution.outputs.files
        into &quot;$buildDir/backup&quot;
    }

    task release(dependsOn: backupReleaseDistribution)     &lt;&lt; {
        logger.quiet &apos;Releasing the project...&apos;
}
</code></pre><h3 id="任务依赖推导"><a href="#任务依赖推导" class="headerlink" title="任务依赖推导"></a>任务依赖推导</h3><p>你可能注意到上面通过dependsOn方法来显示声明两个任务之间的依赖，可是，一些任务并不是直接依赖于其他任务(比如上面createDistribution依赖于war)。Gradle怎么知道在任务之前执行哪个任务？通过使用一个任务的输出作为另一个任务的输入，依赖就推导出来了，结果依赖的任务自动执行了，我们来看一下完整的执行图：</p>
<pre><code>$ gradle release
:makeReleaseVersion
:compileJava
:processResources UP-TO-DATE
:classes
:war
:createDistribution
:backupReleaseDistribution
:release
Releasing the project...
</code></pre><p>运行build之后你可以在build/distribution目录找到生成的ZIP文件，这是打包任务的默认输出目录，下面这个图是生成的目录树：</p>
<p><img src="/images/4-3.png" alt=""></p>
<h3 id="在buildSrc目录创建代码"><a href="#在buildSrc目录创建代码" class="headerlink" title="在buildSrc目录创建代码"></a>在buildSrc目录创建代码</h3><p>在前面我们创建了两个类，ProjectVersion和ReleaseVersionTask，这些类可以移动到你项目的buildSrc目录，buildSrc目录是一个放置源代码的可选目录，你可以很容易的管理你的代码。Gradle采用了标准的项目布局，java代码在src/main/java目录，Groovy代码应该在src/main/groovy目录，在这些目录的任何代码都会自动编译然后放置到项目的classpath目录。这里你是在处理class，你可以把他们放到指定的包里面，假如com.manning.gia,下面显示了Groovy类在项目中的目录结构：</p>
<p><img src="/images/4-4.png" alt=""></p>
<p>不过要记住把这些类放在源代码目录需要额外的工作，这和在脚本文件中定义有点不一样，你需要导入Gradle的API，看看下面这个例子：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.manning.gia</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.DefaultTask</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.tasks.Input</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.tasks.OutputFile</span><br><span class="line"><span class="keyword">import</span> org.gradle.api.tasks.TaskAction</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReleaseVersionTask</span> <span class="keyword">extends</span> <span class="title">DefaultTask</span> &#123;</span></span><br><span class="line">	(...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>反过来，你的构建脚本需要从buildSrc中导入编译的classes(比如 <code>com.manning.gia.ReleaseVersionTask</code>)，下面这个是编译任务输出：</p>
<pre><code>$ gradle makeReleaseVersion
:buildSrc:compileJava UP-TO-DATE
:buildSrc:compileGroovy
:buildSrc:processResources UP-TO-DATE
:buildSrc:classes
:buildSrc:jar
:buildSrc:assemble
:buildSrc:compileTestJava UP-TO-DATE
:buildSrc:compileTestGroovy UP-TO-DATE
:buildSrc:processTestResources UP-TO-DATE
:buildSrc:testClasses UP-TO-DATE
:buildSrc:test
:buildSrc:check
:buildSrc:build
:makeReleaseVersion UP-TO-DATE
</code></pre><p>到此为止你学习了简单任务的创建，自定义的task类，指定Gradle API提供的task类型，查看了任务动作和任务配置的区别，以及他们的使用情形，任务配置和任务动作是在不同阶段执行的。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java虚拟机简介]]></title>
      <url>http://www.ezlippi.com/blog/2015/04/java-virtual-mechine.html</url>
      <content type="html"><![CDATA[<p>Java虚拟机是整个Java平台的基础，是Java语言用于实现与硬件、操作系统无关的关键，Java虚拟机类似一个微型的计算机，它有自己的指令集和运行时的内存区域。java虚拟机和java语言并没有必然的联系，它只与特定的二进制文件–class文件相关联，只要符合java虚拟机规范的class文件都能在虚拟机上运行。<br><a id="more"></a><br>下面讲到虚拟机的特性时，都只限于 SE 7，因为前不久出了SE8，虚拟机的有些特性发生了改变，以后再来阐述。<br>这个系列将分为几个部分来阐述：</p>
<ol>
<li>Java虚拟机结构简介</li>
<li>Java虚拟机编译器</li>
<li>Class文件格式</li>
<li>加载、链接和初始化</li>
<li>虚拟机指令集</li>
<li>SE 8 的新特性</li>
</ol>
<h1 id="Java虚拟机结构简介"><a href="#Java虚拟机结构简介" class="headerlink" title="Java虚拟机结构简介"></a>Java虚拟机结构简介</h1><h2 id="Class文件格式"><a href="#Class文件格式" class="headerlink" title="Class文件格式"></a>Class文件格式</h2><p>编译后Java虚拟机采用了一种与平台无关的二进制格式来表示，为了确保class文件能在不同的平台上运行，所以虚拟机也约定了一些惯例，比如字节序。具体的请参考第三部分。</p>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>与Java语言的数据类型相似，Java虚拟机可以操作的数据类型分为2类：原生类型(primitive type)和引用类型，可用于变量复制、参数传递、方法返回和运算操作。</p>
<p>Java虚拟机希望在程序运行之前尽可能多的进行类型检查，使得虚拟机在运行期间无需进行这些操作。</p>
<p><strong>原生类型</strong></p>
<p>整数类型：</p>
<ul>
<li>byte类型：8位有符号整数，默认为0</li>
<li>char类型：16位<strong>无符号</strong>整数，默认为Unicode的null（’\u0000’）</li>
<li>short类型：16位有符号整数，默认为0</li>
<li>int类型：32位有符号整数，默认为0</li>
<li>long类型：64位有符号整数，默认为0</li>
</ul>
<p>浮点数类型：</p>
<ul>
<li>float单精度浮点数：默认值为正数0</li>
<li>double双精度浮点数：默认为正数0</li>
</ul>
<p>特殊的类型：</p>
<ul>
<li>boolean类型： 默认为false，虚拟机对boolean类型没有提供任何专用的字节码指令，在java语言中有关boolean类型的运算在编译之后都转换成int类型来代替，对于boolean类型的数组，虚拟机的newarray指令可以创建这种数组，在Oracle公司的虚拟机里，boolean数组会编译成byte数组，每个boolean元素占8位。</li>
<li>返回地址：作为一条字节码指令的操作数，这是唯一一个在虚拟机支持的类型当中不能直接与java语言的数据类型相对应的。</li>
</ul>
<p><strong>引用类型</strong></p>
<p>Java虚拟机有三种引用类型：类类型、数组类型和接口类型，这些引用类型的值分别由类实例、数组实例和实现某种接口的类实例创建。</p>
<h2 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h2><h3 id="PC程序计数器"><a href="#PC程序计数器" class="headerlink" title="PC程序计数器"></a>PC程序计数器</h3><p>每一个虚拟机线程都有自己的pc，在任何时刻，一个虚拟机线程只会执行一个方法的代码，这个方法称为该线程的当前方法，如果这个方法不是native的，pc寄存器就保存虚拟机正在执行的字节码指令的地址，如果方法是native的，那么pc寄存器的值是undefined,pc寄存器的容量至少应当保存一个returnAddress类型的数据或者一个与平台相关的本地指针的值。</p>
<h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><p>每一个虚拟机线程都有自己的虚拟机栈，这个栈与线程同时创建，用于存储栈帧(frame),虚拟机栈的作用就是用于存储一些局部变量和过程调用的返回结果，在方法调用和返回中起了重要的作用。栈容量只能由-Xss参数指定，由于Java虚拟机栈会出现StackOverflowError和OutOfMemoryError两种异常，所以分别使用两个例子演示这两种情况：</p>
<ul>
<li>java虚拟机栈深度溢出：</li>
</ul>
<p>单线程的环境下，无论是由于栈帧太大，还是虚拟机栈容量太小，当内存无法再分配的时候，虚拟机总抛出StackOverflowError异常。使用-Xss128k将java虚拟机栈大小设置为128kb，例子代码如下：</p>
<pre><code>public class JavaVMStackOF{  
    private int stackLength = 1;  
    public void stackLeak(){  
        statckLength++;  
        stackLeak();  
}  

public static void main(String[] args){  
    JavaVMStackOF oom = new JavaVMStackOF();  
oom.stackLeak();  
}  

} 
</code></pre><p>运行一段时间后，产生StackOverflowError异常。Java虚拟机栈溢出一般会产生在方法递归调用过多而java虚拟机栈内存不够的情况下。</p>
<ul>
<li>java虚拟机栈内存溢出：</li>
</ul>
<p>多线程环境下，能够创建的线程最大内存=物理内存-最大堆内存-最大方法区内存，在java虚拟机栈内存一定的情况下，单个线程占用的内存越大，所能创建的线程数目越小，所以在多线程条件下很容易产生java虚拟机栈内存溢出的异常。</p>
<p>使用-Xss2m参数设置java虚拟机栈内存大小为2MB，例子代码如下：</p>
<pre><code>public class JavaVMStackOOM{  
    private void dontStop(){  
    while(true){  
}  
}  
public void stackLeakByThread(){  
    while(true){  
        Thread t = new Thread(new Runnable(){  
    public void run(){  
    dontStop();  
}  
});  
t.start();  
}  
}   
public static void main(String[] args){  
    JavaVMStackOOM oom = new JavaVMStackOOM();  
    oom. stackLeakByThread();.  
}  
}  
</code></pre><p>运行一段时间之后，java虚拟机栈就会因为内存太小无法创建线程而产生OutOfMemoryError。</p>
<h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>在java虚拟机中，堆是各个线程共享的运行时内存区域，所有的对象都是在堆中创建。Java堆在虚拟机启动的时候被创建，它存储了垃圾收集器来管理对象，这些受管理的对象无需也无法显式的销毁，你想一个对象尽快被销魂，只能通过把所有的对象引用设置为null，等内存不足的时候垃圾收集器会标记这个不再被引用的对象然后回收该对对象占有的内存。当对象数量达到堆最大容量时产生OutOfMemoryError异常。</p>
<p>想要方便快速地产生堆溢出，要使用如下java虚拟机参数：-Xms10m(最小堆内存为10MB)，-Xmx10m(最大堆内存为10MB，最小堆内存和最大堆内存相同是为了避免堆动态扩展)，-XX:+HeapDumpOnOutOfMemoryError可以让java虚拟机在出现内存溢出时产生当前堆内存快照以便进行异常分析。</p>
<p>例子代码如下：</p>
<pre><code>public class HeapOOM{  
    static class OOMObject{  
}  
public static void main(String[] args){  
    List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject&gt;();  
    while(true){  
    list.add(new OOMObject());  
}  
}  
}  
</code></pre><h3 id="方法区-amp-amp-运行时常量池"><a href="#方法区-amp-amp-运行时常量池" class="headerlink" title="方法区&amp;&amp;运行时常量池"></a>方法区&amp;&amp;运行时常量池</h3><p>方法区也是供各个线程共享的内存区域，用于存储加载的类的结构信息，比如：运行时常量池、字段、方法数据等。方法区在虚拟机启动时创建，简单的虚拟机实现可以选择在这个区域不进行垃圾收集。运行时常量池用于保存加载的class文件的数字字面量和符号引用，在加载类和接口到虚拟机之后，就创建对应的运行时常量池。可以使用-XX:PermSize=10m和-XX:MaxPermSize=10m将永久代最大内存和最小内存设置为10MB大小，并且由于永久代最大内存和最小内存大小相同，因此无法扩展。</p>
<p>String的intern()方法用于检查常量池中如果有等于此String对象的字符串存在，则直接返回常量池中的字符串对象，否则，将此String对象所包含的字符串添加到运行时常量池中，并返回此String对象的引用。因此String的intern()方法特别适合演示运行时常量池溢出，例子代码如下：</p>
<pre><code>public class RuntimeConstantPoolOOM{  
    public static void main(String[] args){  
List&lt;String&gt; list = new ArrayList&lt;String&gt;();  
        int i = 0;  
        while(true){  
        list.add(String.valueOf(i++).intern());  
}  
}  
}  
</code></pre><p>运行一段时间，永久代内存不够，运行时常量池因无法再添加常量而产生OutOfMemoryError。</p>
<h2 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h2><p>栈帧是用来存储数据和部分过程调用结果的数据结构，有时也会用来处理动态链接、方法返回值和异常分派。</p>
<p>栈帧随着方法调用而创建，随着方法结束而销毁–无论是正常结束还是异常完成都算方法结束，每一个栈帧都有自己的局部变量表和操作数栈(operand stack)和<strong>指向当前方法所属类的运行时常量池的引用</strong>。</p>
<p>局部变量表和操作数栈的容量在编译器确定，保存在方法的code属性提供给栈帧使用，在给定的一个线程中，只有目前那个正在执行的方法的栈帧是活动的，这个栈帧称为当前栈帧，这个栈帧对应的方法称为当前方法，定义这个方法的类称为当前类。对局部变量表和操作数栈的各种操作，都是指对当前栈帧的局部变量表和操作数栈进行的操作。</p>
<p>如果当前方法调用了其他方法时，一个新的栈帧随之创建，随着程序的控制权转移交到新的方法而成为新的当前栈帧，当方法返回之时，当前栈帧把执行结果返回给前一个栈帧，随之丢弃当前栈帧，前一个栈帧重新成为当前栈帧。</p>
<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>一个局部变量可以保存一个类型为boolean、byte、char、short、int、float、refrence或返回地址的数据，两个局部变量可以保存一个类型为long或者double的数据。</p>
<p>局部变量表使用索引来定位访问，long和double占用两个连续的局部变量，这两种类型的数据使用两个局部变量中较小的索引来访问，Java虚拟机使用局部变量表来完成方法调用时的参数传递，当调用一个方法时，他的参数会传递至从0开始的连续的局部变量表的位置上。当调用的是实例方法时，第0个局部变量一定是用来存储被调用方法所在对象的引用(java语言的this关键字)。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>每个栈帧内部都包含一个称为操作数栈的先进后出的结构，同样操作数栈的长度由编译器决定，并且通过方法的code属性保存及提供给栈帧使用。<br>栈帧在刚刚创建的时候，操作数栈是空的，java虚拟机提供一些字节码指令来从局部变量表或者对象的字段中复制常量或者变量值到操作数栈中，也提供一些指令用于从操作数栈中取走数据、操作数据以及把操作结果重新入栈，每个操作数栈的位置报以保存一个Java虚拟机定义的任何数据类型的值，包括long和double。在操作数栈中的数据必须正确操作，不可以入栈两个int类型的数据然后当成long类型区操作，也不能入栈两个float类型的数据然后使用iadd指令对他们求和。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧内部都包含一个指向当前方法所属的类的运行时常量池的引用，动态链接的作用就是将这些符号引用所表示的方法转换成实际方法的引用，类加载的过程将变量访问转换为这些变量的存储结构所在的运行时内存的位置的正确偏移量。</p>
<h3 id="方法正常调用完成"><a href="#方法正常调用完成" class="headerlink" title="方法正常调用完成"></a>方法正常调用完成</h3><p>方法正常调用完成是指在方法的执行过程中，没有抛出任何异常，如果当前方法正常完成，它很可能会返回一个值给他的调用者，使用哪一个返回指令取决于方法返回值的数据类型。在这样的情况下，当前栈帧(被调用者)承担着回复调用者状态的责任，其状态包括调用者的局部变量表，操作数栈以及PC，使得调用者的代码在被调用者返回后能够继续执行。</p>
<h2 id="对象的表示"><a href="#对象的表示" class="headerlink" title="对象的表示"></a>对象的表示</h2><p>Java虚拟机并不强制规定对象的内部结构应该如何表示。在Oracle的某些虚拟机实现中，指向对象的引用实际上一个指向句柄(Handler)的指针，这个句柄包含两部分，一部分是指向在堆中分配的对象数据，另一部分是指向常量池中该对象所属类的相关信息。</p>
<h2 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h2><p>大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型，编译器会在编译器或者运行期把byte和short类型的数据进行符号扩展成int类型数据，把boolean和char类型的数据进行零位扩展成int类型数据。</p>
<p>Java虚拟机支持数值类型之间进行相互转换，包括宽化类型转换和窄化类型转换，这里的宽和窄是指该类型能表示的数值范围大小，比如float的范围比int大。</p>
<p>从int转换成long或者double不会丢失精度，但是从int或者long转换成float，或者long转换成double可能会丢失精度(可能丢失最低几个有效位的数值)。窄化类型的转换可能导致转换结果产生不同的正负号，这种转换仅仅是把数据的高位丢弃，正数int转换成short就可能变成了负数。</p>
<p>将浮点数转换成整数，很有可能浮点数的范围超过了整数能表示的范围，这时候就转换成整数类型所能表示的最大或者最小值，NaN转换成int或者long类型的0。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[android实用小技巧]]></title>
      <url>http://www.ezlippi.com/blog/2015/04/android-tips.html</url>
      <content type="html"><![CDATA[<p>本文是一篇译文,讲述的是Android开发过程中遇到的一些实用的小技巧,或者一些实用的API,作者介绍的非常全面，推荐大家收藏起来，平常写Android程序也用的上。<br><a id="more"></a></p>
<h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h3><ul>
<li><p><a href="http://developer.android.com/reference/android/app/Activity.html#startActivities(android.content.Intent[]" target="_blank" rel="external">Activity.startActivities() </a>常用于在应用程序中间启动其他的Activity.</p>
</li>
<li><p><a href="http://developer.android.com/reference/android/text/TextUtils.html#isEmpty(java.lang.CharSequence" target="_blank" rel="external">TextUtils.isEmpty()</a> 简单的工具类,用于检测是否为空</p>
</li>
<li><a href="http://developer.android.com/reference/android/text/Html.html#fromHtml(java.lang.String" target="_blank" rel="external">Html.fromHtml()</a> 用于生成一个Html,参数可以是一个字符串.个人认为它不是很快,所以我不怎么经常去用.（我说不经常用它是为了重点突出这句话：请多手动构建 Spannable 来替换 Html.fromHtml），但是它对渲染从 web 上获取的文字还是很不错的。</li>
<li><a href="http://developer.android.com/reference/android/widget/TextView.html#setError%28java.lang.CharSequence%29" target="_blank" rel="external">TextView.setError() </a>在验证用户输入的时候很棒</li>
<li><a href="http://developer.android.com/reference/android/os/Build.VERSION_CODES.html" target="_blank" rel="external"></a>Build.VERSION_CODES 这个标明了当前的版本号,在处理兼容性问题的时候经常会用到.点进去可以看到各个版本的不同特性</li>
<li><a href="http://developer.android.com/reference/android/util/Log.html#getStackTraceString(java.lang.Throwable" target="_blank" rel="external">Log.getStackTraceString()</a> 方便的日志类工具,方法Log.v()、Log.d()、Log.i()、Log.w()和Log.e()都是将信息打印到LogCat中，有时候需要将出错的信息插入到数据库或一个自定义的日志文件中，那么这种情况就需要将出错的信息以字符串的形式返回来，也就是使用static String getStackTraceString(Throwable tr)方法的时候.</li>
<li><a href="http://developer.android.com/reference/android/view/LayoutInflater.html#from%28android.content.Context%29" target="_blank" rel="external">LayoutInflater.from()</a> 顾名思义,用于Inflate一个layout,参数是layout的id.这个经常写Adapter的人会用的比较多.</li>
<li><a href="http://developer.android.com/reference/android/view/ViewConfiguration.html#getScaledTouchSlop%28%29" target="_blank" rel="external">ViewConfiguration.getScaledTouchSlop()</a> 使用 ViewConfiguration 中提供的值以保证所有触摸的交互都是统一的。这个方法获取的值表示:用户的手滑动这个距离后,才判定为正在进行滑动.当然这个值也可以自己来决定.但是为了一致性,还是使用标准的值较好.</li>
<li><a href="http://developer.android.com/reference/android/telephony/PhoneNumberUtils.html#convertKeypadLettersToDigits%28java.lang.String%29" target="_blank" rel="external">PhoneNumberUtils.convertKeypadLettersToDigits</a> 顾名思义.将字母转换为数字,类似于T9输入法,</li>
<li><a href="http://developer.android.com/reference/android/content/Context.html#getCacheDir%28%29" target="_blank" rel="external">Context.getCacheDir()</a> 获取缓存数据文件夹的路径,很简单但是知道的人不多,这个路径通常在SD卡上(这里的SD卡指的是广义上的SD卡,包括外部存储和内部存储)Adnroid/data/您的应用程序包名/cache/  下面.测试的时候,可以去这里面看是否缓存成功.缓存在这里的好处是:不用自己再去手动创建文件夹,不用担心用户把自己创建的文件夹删掉,在应用程序卸载的时候,这里会被清空,使用第三方的清理工具的时候,这里也会被清空.</li>
<li><a href="http://developer.android.com/reference/android/animation/ArgbEvaluator.html" target="_blank" rel="external"></a>ArgbEvaluator 用于处理颜色的渐变。就像 Chris Banes 说的一样，这个类会进行很多自动装箱的操作，所以最好还是去掉它的逻辑自己去实现它。这个没用过,不明其所以然,回头再补充.</li>
<li><a href="http://developer.android.com/reference/android/view/ContextThemeWrapper.html" target="_blank" rel="external">ContextThemeWrapper</a> 方便在运行的时候修改主题.</li>
<li><a href="http://developer.android.com/reference/android/widget/Space.html" target="_blank" rel="external"></a>Space space是Android 4.0中新增的一个控件，它实际上可以用来分隔不同的控件，其中形成一个空白的区域.这是一个轻量级的视图组件，它可以跳过Draw，对于需要占位符的任何场景来说都是很棒的。</li>
<li><a href="http://developer.android.com/reference/android/animation/ValueAnimator.html#reverse%28%29" target="_blank" rel="external">ValueAnimator.reverse()</a> 这个方法可以很顺利地取消正在运行的动画.我超喜欢.</li>
</ul>
<h3 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h3><ul>
<li><p><a href="http://developer.android.com/reference/android/text/format/DateUtils.html#formatDateTime%28android.content.Context,%20long,%20int%29" target="_blank" rel="external">DateUtils.formatDateTime() </a>用来进行区域格式化工作,输出格式化和本地化的时间或者日期.</p>
</li>
<li><p><a href="http://developer.android.com/reference/android/app/AlarmManager.html#setInexactRepeating(int, long, long, android.app.PendingIntent" target="_blank" rel="external">AlarmManager.setInexactRepeating</a> 通过闹铃分组的方式省电,即使你只调用了一个闹钟,这也是一个好的选择,（可以确保在使用完毕时自动调用 AlarmManager.cancel ()。原文说的比较抽象,这里详细说一下:setInexactRepeating指的是设置非准确闹钟,使用方法:alarmManager.setInexactRepeating(AlarmManager.RTC, startTime,intervalL, pendingIntent),非准确闹钟只能保证大致的时间间隔，但是不一定准确，可能出现设置间隔为30分钟，但是实际上一次间隔20分钟，另一次间隔40分钟。它的最大的好处是可以合并闹钟事件，比如间隔设置每30分钟一次，不唤醒休眠，在休眠8小时后已经积累了16个闹钟事件，而在手机被唤醒的时候，非准时闹钟可以把16个事件合并为一个, 所以这么看来,非准时闹钟一般来说比较节约能源.</p>
</li>
<li><a href="http://developer.android.com/reference/android/text/format/Formatter.html#formatFileSize(android.content.Context, long" target="_blank" rel="external">Formatter.formatFileSize()</a> 一个区域化的文件大小格式化工具。通俗来说就是把大小转换为MB,G,KB之类的字符串.</li>
<li><a href="http://developer.android.com/reference/android/app/ActionBar.html#hide" target="_blank" rel="external">ActionBar.hide()</a>顾名思义,隐藏和显示ActionBar,可以优雅地在全屏和带Actionbar之间转换.</li>
<li><a href="http://developer.android.com/reference/android/text/util/Linkify.html#addLinks(android.text.Spannable, int" target="_blank" rel="external">Linkify.addLinks()</a>  在Text上添加链接.很实用.</li>
<li><a href="http://developer.android.com/reference/android/text/StaticLayout.html" target="_blank" rel="external">StaticLayout</a> 在自定义 View 中渲染文字的时候很实用。</li>
<li><a href="http://developer.android.com/reference/android/app/Activity.html#onBackPressed(" target="_blank" rel="external">onBackPressed()</a>很方便的管理back键的方法,有时候需要自己控制返回键的事件的时候,可以重写一下.比如加入 “点两下back键退出” 功能.</li>
<li><a href="http://developer.android.com/reference/android/view/GestureDetector.html" target="_blank" rel="external">GestureDetector</a> 用来监听和相应对应的手势事件,比如点击,长按,慢滑动,快滑动,用起来很简单,比你自己实现要方便许多.</li>
<li><a href="http://developer.android.com/reference/android/graphics/DrawFilter.html" target="_blank" rel="external">DrawFilter</a> 可以让你在不调用onDrew方法的情况下,操作canvas,比了个如,你可以在创建自定义 View 的时候设置一个 DrawFilter，给父 View 里面的所有 View 设置反别名。</li>
<li><a href="http://developer.android.com/reference/android/app/ActivityManager.html#getMemoryClass(" target="_blank" rel="external">ActivityManager.getMemoryClass() </a>告诉你你的机器还有多少内存,在计算缓存大小的时候会比较有用.</li>
<li><a href="http://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="external">ViewStub</a> 它是一个初始化不做任何事情的 View，但是之后可以载入一个布局文件。在慢加载 View 中很适合做占位符。唯一的缺点就是不支持标签，所以如果你不太小心的话，可能会在视图结构中加入不需要的嵌套。</li>
<li><a href="http://developer.android.com/reference/android/os/SystemClock.html#sleep(long" target="_blank" rel="external">SystemClock.sleep()</a> 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</li>
<li><a href="http://developer.android.com/reference/android/util/DisplayMetrics.html#density" target="_blank" rel="external">DisplayMetrics.density</a> 这个方法你可以获取设备像素密度,大部分时候最好让系统来自动进行缩放资源之类的操作,但是有时候控制的效果会更好一些.(尤其是在自定义View的时候).</li>
<li><a href="http://developer.android.com/reference/android/util/Pair.html#create(A, B" target="_blank" rel="external">Pair.create()</a> 方便构建类和构造器的方法。</li>
</ul>
<h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3><ul>
<li><p><a href="http://developer.android.com/reference/android/net/UrlQuerySanitizer.html" target="_blank" rel="external">UrlQuerySanitizer</a>——使用这个工具可以方便对 URL 进行检查。</p>
</li>
<li><p><a href="http://developer.android.com/reference/android/app/Fragment.html#setArguments%28android.os.Bundle%29" target="_blank" rel="external">Fragment.setArguments</a>——因为在构建 Fragment 的时候不能加参数，所以这是个很好的东西，可以在创建 Fragment 之前设置参数（即使在 configuration 改变的时候仍然会导致销毁/重建）。</p>
</li>
<li><a href="http://developer.android.com/reference/android/app/DialogFragment.html#setShowsDialog%28boolean%29" target="_blank" rel="external">DialogFragment.setShowsDialog ()</a>—— 这是一个很巧妙的方式，DialogFragment 可以作为正常的 Fragment 显示！这里可以让 Fragment 承担双重任务。我通常在创建 Fragment 的时候把 onCreateView ()和 onCreateDialog ()都加上，就可以创建一个具有双重目的的 Fragment。</li>
<li><a href="http://developer.android.com/reference/android/app/FragmentManager.html#enableDebugLogging%28boolean%29" target="_blank" rel="external">FragmentManager.enableDebugLogging ()</a>——在需要观察 Fragment 状态的时候会有帮助。</li>
<li><a href="http://developer.android.com/reference/android/support/v4/content/LocalBroadcastManager.html" target="_blank" rel="external">LocalBroadcastManager</a>——这个会比全局的 broadcast 更加安全，简单，快速。——顾名思义，这是对数字进行格式化操作的时候用的。</li>
<li><a href="http://developer.android.com/reference/android/graphics/Region.html#op%28android.graphics.Region,%20android.graphics.Region,%20android.graphics.Region.Op%29" target="_blank" rel="external">Region.op()</a>——我发现在对比两个渲染之前的区域的时候很实用，如果你有两条路径，那么怎么知道它们是不是会重叠呢？使用这个方法就可以做到。</li>
<li><a href="http://developer.android.com/reference/android/app/Application.html#registerActivityLifecycleCallbacks%28android.app.Application.ActivityLifecycleCallbacks%29" target="_blank" rel="external">Application.registerActivityLifecycleCallbacks</a>——虽然缺少官方文档解释，不过我想它就是注册 Activity 的生命周期的一些回调方法（顾名思义），就是一个方便的工具。</li>
<li><a href="http://tools.android.com/tech-docs/new-build-system/user-guide#TOC-Build-Types" target="_blank" rel="external">versionNameSuffix</a>——这个 gradle 设置可以让你在基于不同构建类型的 manifest 中修改版本名这个属性，例如，如果需要在在 debug 版本中以”-SNAPSHOT”结尾，那么就可以轻松的看出当前是 debug 版还是 release 版。</li>
<li><a href="http://developer.android.com/reference/android/database/CursorJoiner.html" target="_blank" rel="external">CursorJoiner</a>——如果你是只使用一个数据库的话，使用 SQL 中的 join 就可以了，但是如果收到的数据是来自两个独立的 ContentProvider，那么 CursorJoiner 就很实用了。</li>
<li><a href="http://www.genymotion.com/" target="_blank" rel="external"></a>Genymotion——一个非常快的 Android 模拟器，本人一直在用。</li>
<li><a href="http://developer.android.com/guide/practices/screens_support.html#qualifiers" target="_blank" rel="external">nodpi</a>——在没有特别定义的情况下，很多修饰符(-mdpi,-hdpi,-xdpi等等)都会默认自动缩放 assets/dimensions，有时候我们需要保持显示一致，这种情况下就可以使用 -nodpi。</li>
<li><a href="http://developer.android.com/reference/android/content/BroadcastReceiver.html#setDebugUnregister%28boolean%29" target="_blank" rel="external">BroadcastRecevier.setDebugUnregister ()</a>——又一个方便的调试工具。</li>
<li><a href="http://developer.android.com/reference/android/app/Activity.html#recreate%28%29" target="_blank" rel="external">Activity.recreate ()</a>——强制让 Activity 重建。</li>
<li><a href="http://developer.android.com/reference/android/content/pm/PackageManager.html#checkSignatures%28java.lang.String,%20java.lang.String%29" target="_blank" rel="external"></a>PackageManager.checkSignatures ()——如果同时安装了两个 app 的话，可以用这个方法检查。如果不进行签名检查的话，其他人可以轻易通过使用一样的包名来模仿你的 app。</li>
</ul>
<h3 id="第四部分"><a href="#第四部分" class="headerlink" title="第四部分"></a>第四部分</h3><ul>
<li><p><a href="http://developer.android.com/reference/android/app/Activity.html#isChangingConfigurations%28%29" target="_blank" rel="external">Activity.isChangingConfigurations ()</a>——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p>
</li>
<li><p><a href="http://developer.android.com/reference/android/content/SearchRecentSuggestionsProvider.html" target="_blank" rel="external">SearchRecentSuggestionsProvider</a>——可以创建最近提示效果的 provider，是一个简单快速的方法。</p>
</li>
<li><a href="http://developer.android.com/reference/android/view/ViewTreeObserver.html" target="_blank" rel="external">ViewTreeObserver</a>——这是一个很棒的工具。可以进入到 VIew 里面，并监控 View 结构的各种状态，通常我都用来做 View 的测量操作（自定义视图中经常用到）。</li>
<li><a href="https://www.timroes.de/2013/09/12/speed-up-gradle/" target="_blank" rel="external"></a>org.gradle.daemon=true——这句话可以帮助减少 Gradle 构建的时间，仅在命令行编译的时候用到，因为 Android Studio 已经这样使用了。</li>
<li><a href="http://developer.android.com/reference/android/database/DatabaseUtils.html" target="_blank" rel="external"></a>——一个包含各种数据库操作的使用工具。</li>
<li><a href="http://developer.android.com/reference/android/widget/LinearLayout.html#attr_android:weightSum" target="_blank" rel="external"></a>android:weightSum (LinearLayout)——如果想使用 layout weights，但是却不想填充整个 LinearLayout 的话，就可以用 weightSum 来定义总的 weight 大小。</li>
<li><a href="http://developer.android.com/reference/android/view/View.html#attr_android:duplicateParentState" target="_blank" rel="external"></a>android:duplicateParentState (View)——此方法可以使得子 View 可以复制父 View 的状态。比如如果一个 ViewGroup 是可点击的，那么可以用这个方法在它被点击的时候让它的子 View 都改变状态。</li>
<li><a href="http://developer.android.com/reference/android/view/ViewGroup.html#attr_android:clipChildren" target="_blank" rel="external">DatabaseUtils</a>android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</li>
<li><a href="http://developer.android.com/reference/android/widget/ScrollView.html#attr_android:fillViewport" target="_blank" rel="external">android:fillViewport (ScrollView)</a>——在这片文章中有详细介绍——可以指定图片使用重复填充的模式。</li>
<li><a href="http://developer.android.com/reference/android/R.attr.html#exitFadeDuration" target="_blank" rel="external">android:enterFadeDuration/android:exitFadeDuration (Drawables)</a>——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</li>
<li><a href="http://developer.android.com/reference/android/widget/ImageView.html#attr_android:scaleType" target="_blank" rel="external">android:scaleType (ImageView)</a>——定义在 ImageView 中怎么缩放/剪裁图片，一般用的比较多的是“centerCrop”和“centerInside”。</li>
<li><a href="http://developer.android.com/training/improving-layouts/reusing-layouts.html#Merge" target="_blank" rel="external">Merge</a>——此标签可以在另一个布局文件中包含别的布局文件，而不用再新建一个 ViewGroup，对于自定义 ViewGroup 的时候也需要用到；可以通过载入一个带有标签的布局文件来自动定义它的子部件。</li>
<li><a href="http://developer.android.com/reference/android/util/AtomicFile.html" target="_blank" rel="external">AtomicFile</a>——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</li>
</ul>
<h3 id="第五部分"><a href="#第五部分" class="headerlink" title="第五部分"></a>第五部分</h3><ul>
<li><p><a href="https://developer.android.com/reference/android/support/v4/widget/ViewDragHelper.html" target="_blank" rel="external">ViewDragHelper</a> ——视图拖动是一个比较复杂的问题。这个类可以帮助解决不少问题。</p>
</li>
<li><p><a href="https://developer.android.com/reference/android/widget/PopupWindow.html" target="_blank" rel="external">PopupWindow</a>—-Android到处都在使用PopupWindow ，甚至你都没有意识到（标题导航条ActionBar，自动补全AutoComplete，编辑框错误提醒Edittext Errors）。这个类是创建浮层内容的主要方法。</p>
</li>
<li><a href="https://developer.android.com/reference/android/app/ActionBar.htmlgetThemedContext%28%29" target="_blank" rel="external">Actionbar.getThemrContext()</a>——导航栏的主题化是很复杂的（不同于Activity其他部分的主题化）。你可以得到一个上下文（Context），用这个上下文创建的自定义组件可以得到正确的主题。</li>
<li><a href="https://developer.android.com/reference/android/media/ThumbnailUtils.html" target="_blank" rel="external">ThumbnailUtils</a>——帮助创建缩略图。通常我都是用现有的图片加载库（比如，Picasso 或者 Volley），不过这个ThumbnaiUtils可以创建视频缩略图。该API从V8才开始支持。</li>
<li><a href="https://developer.android.com/reference/android/content/Context.htmlgetExternalFilesDir%28java.lang.String%29" target="_blank" rel="external">Context.getExternalFilesDir()</a>———— 申请了SD卡写权限后，你可以在SD的任何地方写数据，把你的数据写在设计好的合适位置会更加有礼貌。这样数据可以及时被清理，也会有更好的用户体验。此外，Android 4.0 Kitkat中在这个文件夹下写数据是不需要权限的，每个用户有自己的独立的数据存储路径。</li>
<li><a href="https://developer.android.com/reference/android/util/SparseArray.html" target="_blank" rel="external">SparseArray</a>——Map的高效优化版本。推荐了解姐妹类SparseBooleanArray、SparseIntArray和SparseLongArray。</li>
<li><a href="https://developer.android.com/reference/android/content/pm/PackageManager.htmlsetComponentEnabledSetting%28android.content.ComponentName,%20int,%20int%29" target="_blank" rel="external">PackageManager.setComponentEnabledSetting()</a>——可以用来启动或者禁用程序清单中的组件。对于关闭不需要的功能组件是非常赞的，比如关掉一个当前不用的广播接收器。</li>
<li><a href="https://developer.android.com/reference/android/database/sqlite/SQLiteDatabase.htmlyieldIfContendedSafely%28%29" target="_blank" rel="external">SQLiteDatabase.yieldIfContendedSafely()</a>——让你暂时停止一个数据库事务， 这样你可以就不会占用太多的系统资源。</li>
<li><a href="https://developer.android.com/reference/android/os/Environment.html#getExternalStoragePublicDirectory%28java.lang.String%29" target="_blank" rel="external">Environment.getExternalStoragePublicDirectory()</a>——还是那句话，用户期望在SD卡上得到统一的用户体验。用这个方法可以获得在用户设备上放置指定类型文件（音乐、图片等）的正确目录。</li>
<li><a href="https://developer.android.com/reference/android/view/View.htmlgenerateViewId%28%29" target="_blank" rel="external">View.generateViewId()</a>——每次我都想要推荐动态生成控件的ID。需要注意的是，不要和已经存在的控件ID或者其他已经生成的控件ID重复。</li>
<li><a href="https://developer.android.com/reference/android/app/ActivityManager.htmlclearApplicationUserData%28%29" target="_blank" rel="external">ActivityManager.clearApplicationUserData()</a>—— 一键清理你的app产生的用户数据，可能是做用户退出登录功能，有史以来最简单的方式了。</li>
<li><a href="http://developer.android.com/reference/android/content/Context.htmlcreateConfigurationContext%28android.%E2%80%94%E2%80%94ontent.res.Configuration%29" target="_blank" rel="external">Context.createConfigurationContext()</a> ——自定义你的配置环境信息。我通常会遇到这样的问题：强制让一部分显示在某个特定的环境下（倒不是我一直这样瞎整，说来话长，你很难理解）。用这个实现起来可以稍微简单一点。</li>
<li><a href="http://developer.android.com/reference/android/app/ActivityOptions.html" target="_blank" rel="external">ActivityOptions</a> ——方便的定义两个Activity切换的动画。</li>
<li><a href="http://developer.android.com/reference/android/view/ViewParent.htmlrequestDisallowInterceptTouchEvent%28boolean%29" target="_blank" rel="external">ViewParent.requestDisallowInterceptTouchEvent()</a> ——Android系统触摸事件机制大多时候能够默认处理，不过有时候你需要使用这个方法来剥夺父级控件的控制权（顺便说一下，如果你想对Android触摸机制了解更多，<a href="https://www.youtube.com/watch?v=EZAoJU-nUyI这个演讲会令你惊叹不已。）" target="_blank" rel="external">https://www.youtube.com/watch?v=EZAoJU-nUyI这个演讲会令你惊叹不已。）</a></li>
</ul>
<p>本文地址：<a href="http://ezlippi.com/blog/2015/04/android-tips.html" target="_blank" rel="external">http://ezlippi.com/blog/2015/04/android-tips.html</a>,转载请注明出处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[网络传输基础]]></title>
      <url>http://www.ezlippi.com/blog/2015/04/web-transmission-basis.html</url>
      <content type="html"><![CDATA[<p>示例：Web服务器向Http客户端传送数据的过程:</p>
<p>在详细阐述网络传输过程之前，先来看一个最常见的例子，下图显示了一个网络服务器向客户端传送数据的完整过程：</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90202/image002.jpg" alt=""></p>
<a id="more"></a>
<ol>
<li>需要传送的数据是网络服务器的HTML页面。</li>
<li>应用协议HTTP报文首部添加到HTML数据之前。报文头信息包括：服务器所使用的HTTP版本（1.0/1.1），以及表明它包含发给网络客户端信息的状态编码（比如200表示Ok）。</li>
<li>HTTP应用层协议将HTML格式的网页数据发送给传输层，传输层添加TCP首部信息。TCP传输层用于管理网络服务器和客户端之间的会话，TCP是面向连接的，通过拥赛控制、滑动窗口、超时重传等机制保证数据有效的传输给客户端。</li>
<li>IP首部添加到TCP首部之前。IP层指定适当的源和目的IP地址。这些信息就构成了IP报文（IP Packet）。</li>
<li>以太网协议首部添加到IP报文的两端之后，就形成了数据链路帧(frame)。上述帧发送至通向网络客户端的路径上的最近一个路由器（默认网关）。每经过一个路由器会移除以太网信息，观察IP报文，判定最佳路径，将报文插入一个新的帧（下一个路由器的MAC地址），并发送至目标路径上下一个相邻路由器。每一个路由器在转发之前都移除并添加新的数据链路层信息。</li>
<li>数据通过互联网络传输，互联网络包含媒介和中间设备。</li>
<li>客户端接收到包含数据的数据链路帧，处理各层协议头，之后以与添加时相反的顺序移除协议头。首先处理并移除以太网信息，之后是IP协议信息，接下来TCP信息，最后是HTTP信息。</li>
<li>之后，将网页信息传递给客户端网页浏览器，浏览器把HTML网页渲染呈现给用户。</li>
</ol>
<h3 id="数据封装"><a href="#数据封装" class="headerlink" title="数据封装:"></a>数据封装:</h3><p>消息要在网络中传输，必须对它进行编码，以特定的格式进行封装，同时需要适当地封装以足够的控制和地址信息，以使它能够从发送方移动到接收方。</p>
<p><strong>消息大小</strong></p>
<p>理论上，视频或邮件信息是能够以大块非中断型流从网络源地址传送到目的地址，但这也意味着同一时刻同一网络其他设备就无法收发消息。这种大型数据流会造成显著延时。并且，如果传输过程中连接断开，整个数据流都会丢失需要全部重传。因此更好的方法是将数据流分割（segmentation）为较小的，便于管理的片段，能够带来两点好处：</p>
<p>· 发送较小片段，网络上同时可有多个会话交错进行。这种在网络上将不同会话片段交错进行的过程称为多路传输（multiplexing）。<br>· 分割可提高网络通讯的可靠性。各消息片段从源地址到目的地址无需经过相同路径，如果一条路径被堵塞或断开，其余消息可从替换路径到达目的地址。如果部分消息到不了目的地址，那只需重传丢失部分。</p>
<p>通过对片段打上标签的方式来保证顺序以及在接收时重组。</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90202/image003.jpg" alt=""></p>
<p><strong>协议数据单元（Protocol Data Unit, PDU）</strong></p>
<p>应用层数据在传输过程中沿着协议栈向下传递，每一层协议都会向其中添加首部信息，TCP首部和IP首部都是20字节的长度。这就是封装的过程。<br>数据片段在各层网络结构中采用的形式就称为协议数据单元（PDU）。封装过程中，下一层对从上一层收到的PDU进行封装。在处理的每一个阶段PDU都有不同的名字来反应它的功能。</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90203/image004.jpg" alt=""></p>
<p>PDU按照TCP/IP协议的命名规范：<br>· 数据（Data）：应用层PDU的常用术语<br>· 分段（Segment）：传输层PDU<br>. 数据报(Packet): 网络成PDU<br>· 以太网帧（Frame）：链路层PDU<br>· 比特（Bits）：在介质上物理传输数据所使用的PDU。</p>
<p><strong>封装</strong></p>
<p>封装是指在传输之前为数据添加额外的协议头信息的过程。在绝大多数数据通信过程中，源数据在传输前都会封装以数层协议。在网络上发送消息时，主机上的协议栈从上至下进行操作。</p>
<p>以网络服务器为例，HTTP应用层协议发送HTML格式网页数据到传输层，应用层数据被分成TCP分段。各TCP分段被打上标签（主要是端口号，HTTP默认端口为80），称为首部（header），表明接收方哪一个进程应当接收此消息。同时也包含使得接收方能够按照原有的格式来重组数据的信息。</p>
<p>传输层将网页HTML数据封装成分段并发送至网络层，执行IP层协议。整个TCP分段封装成IP报文，也就是再添上IP首部。IP首部包括源和目的IP地址，以及发送报文到目的地址所必须的信息，包括一些控制字段。</p>
<p>之后，IP报文发送到链路层，封装以帧头和帧尾。每个帧头都包含源和目的物理地址。物理地址唯一指定了本地网络上的设备。帧尾包含差错校正信息。最后，由服务器网卡将比特编码传输给介质。  </p>
<p><strong>解封装</strong></p>
<p>接收主机以相反的方式（从下至上）进行操作称为解封装。解封装是接收设备移除一层或多层协议头的过程。数据在协议栈中向上移动直到终端应用层伴随着解封装。</p>
<h3 id="访问本地资源："><a href="#访问本地资源：" class="headerlink" title="访问本地资源："></a>访问本地资源：</h3><p>访问本地网络资源需要两种类型的地址：网络层地址和数据链路层地址。网络层和数据链路层负责将数据从发送设备传输至接收设备。两层协议都有源和目的地址，但两种地址的目的不同。</p>
<p>示例：客户端PC1与FTP在同一IP网络的通信</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90204/image005.jpg" alt=""></p>
<p><strong>网络地址</strong></p>
<p>网络层地址或IP地址包含两个部分：网络号和主机号。路由器使用网络前缀部分将报文转发给适当的网络。最后一个路由器使用主机部分将报文发送给目标设备。同一本地网络中，网络前缀部分是相同的，只有主机设备地址部分不同。</p>
<p>源IP地址：发送设备，即客户端PC1的IP地址：192.168.1.110<br>目的IP地址：接收设备，即FTP服务器：192.168.1.9</p>
<p><strong>数据链路地址</strong></p>
<p>数据链路地址（MAC）的目的是在<strong>同一网络中</strong>将数据链路帧从一个网络接口发送至另一个网络接口。以太网LAN和无线网LAN是两种不同物理介质的网络示例，分别有自己的数据链路协议。<br>当IP报文的发送方和接收方位于同一网络，数据链路帧直接发送到接收设备（通过ARP来获取目的IP的MAC地址）。以太网上数据链路地址就是以太网MAC地址。MAC地址是物理植入网卡的48比特地址。<br>源MAC地址：发送IP报文的PC1以太网卡MAC地址，AA-AA-AA-AA-AA-AA。<br>目的MAC地址：当发送设备与接收设备位于同一网络，即为接收设备的数据链路地址。本例中，FTP MAC地址：CC-CC-CC-CC-CC-CC。<br>源和目的MAC地址添加到以太网帧中。</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90205/image006.jpg" alt=""></p>
<p><strong>MAC与IP地址</strong></p>
<p>发送方必须知道接收方的物理和逻辑地址。发送方主机能够以多种方式学习到接收方的IP地址：比如浏览器缓存、getHostByName系统调用、域名系统（Domain Name System, DNS），或通过应用手动输入，如用户指定FTP地址。</p>
<p>以太网MAC地址是怎么识别的呢？发送方主机使用地址解析协议（Address Resolution Protocol, ARP）以检测本地网络的所有MAC地址。如下图所示，发送主机在整个LAN发送ARP请求消息，这是一条广播消息。ARP请求包含目标设备的IP地址，LAN上的每一个设备都会检查该ARP请求，看看是否包含它自身的IP地址。只有符合该IP地址的设备才会发送ARP响应。ARP响应包含ARP请求中IP地址相对应的MAC地址。</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90206/670-270/image007.jpg" alt=""></p>
<p><strong>访问远程资源：</strong></p>
<p><strong>默认网关</strong></p>
<p>当主机发送消息到远端网络，必须使用路由器，也称为默认网关。默认网关就是位于发送主机同一网络上的路由器的接口IP地址。有一点很重要：本地网络上的所有主机都能够配置自己的默认网关地址。如果该主机的TCP/IP设置中没有配置默认网关地址，或指定了错误的默认网关地址，则远端网络消息无法被送达。<br>如下图所示，LAN上的主机PC 1使用IP地址为192.168.1.1的R1作为默认网关，如果PDU的目的地址位于另一个网络，则主机将PDU发送至路由器上的默认网关。</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90207/image008.jpg" alt=""></p>
<p><strong>与远端网络设备通讯</strong></p>
<p>下图显示了客户端主机PC 1与远端IP网络服务器进行通讯的网络层地址与数据链路层地址：</p>
<p><img src="https://community.emc.com/servlet/JiveServlet/downloadImage/2-831148-90208/image009.jpg" alt=""></p>
<p><strong>网络地址</strong></p>
<p>当报文的发送方与接收方位于不同网络，源和目的IP地址将会代表不同网络上的主机。<br>源IP地址：发送设备即客户端主机PC 1的IP地址：192.168.1.110。<br>目的IP地址：接收设备即网络服务器的IP地址：172.16.1.99。</p>
<p><strong>数据链路地址</strong></p>
<p>当报文的发送方与接收方位于不同网络，以太网数据链路帧无法直接被发送到目的主机。以太网帧必须先发送给路由器或默认网关。本例中，默认网关是R1，R1的接口IP地址与PC 1属于同一网络，因此PC 1能够直接达到路由器。<br>源MAC地址：发送设备即PC 1的MAC地址，PC1的以太网接口MAC地址为：AA-AA-AA-AA-AA-AA。<br>目的MAC地址：当报文的发送方与接收方位于不同网络，这一值为路由器或默认网关的以太网MAC地址。本例中，即R1的以太网接口MAC地址，即：11-11-11-11-11-11。<br>IP报文封装成的以太网帧先被传输至R1，R1再转发给目的地址即网络服务器。R1可以转发给另一个路由器，如果目的服务器所在网路连接至R1，则直接发送给服务器。</p>
<p>发送设备如何确定路由器的MAC地址？每一个设备通过自己的TCP/IP设置中的默认网关地址得知路由器的IP地址。之后，它通过ARP来得知默认网关的MAC地址，该MAC地址随后添加到帧中。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[优化java代码建议(1)]]></title>
      <url>http://www.ezlippi.com/blog/2015/04/java-code-opt-one.html</url>
      <content type="html"><![CDATA[<p>假设你要统计一个地区的人口平均年龄，你可能写出下面这段代码：</p>
<pre><code>public static void main(String[] args){
   //人口数量50万
   int peopleNum = 50 * 10000;
   List&lt;Integer&gt; heights = new ArrayList&lt;&gt;(peopleNum);

   for(int i =0; i &lt; peopleNum; i++){
       heights.add(new Random().nextInt(300));
   }
   //计算时间
   long start = System.currentTimeMillis();
   System.out.println(&quot;平均高度是： &quot; + average(heights));
   System.out.println(&quot;运行时间： &quot; + (System.currentTimeMillis() - start) + &quot;ms&quot;);
   }

   //计算平均值
   public static int average(List&lt;Integer&gt; list){
   int sum = 0;
   //遍历求和
   for(int i : list){
       sum += i;
   }
   return sum/list.size();
   }
</code></pre><a id="more"></a>
<p>这个程序把50万人的身高存入一个ArrayList中，然后通过foreach遍历求和，再计算平均值，输出结果是：</p>
<pre><code>平均高度是： 154
运行时间： 47ms
</code></pre><p>仅仅是一个算术平均值就花费了47ms，如果是加权平均值等算法，那花的时间肯定更长了，这段代码也没什么好优化的，唯一剩下的就是元素的遍历，List的遍历可以优化吗？</p>
<p>我们之道List的遍历还有另外一种方法，通过下标来索引，代码如下：</p>
<pre><code>public static int average1(List&lt;Integer&gt; list){
    int sum = 0;
    //遍历求和
    for(int i = 0, size = list.size(); i &lt; size; i++){
        sum += list.get(i);
    }
    return sum/list.size();
}
</code></pre><p>运行结果是：</p>
<pre><code>平均身高是： 154
运行时间： 16ms
</code></pre><p>可以看到运行时间大幅下降，效率提高了65%，为什么性能得到这么大幅度的提升？</p>
<p>这是因为Arraylist实现了RandomAccess接口（随机存取接口），这就标志这ArrayList是一个可以随机存取的列表，实现RandomAccess接口表明这个类可以随机存取，标志着这个List的元素之间<strong>没有关联</strong>，两个相邻的元素之间没有相互的依赖关系和索引关系，可以随机访问和存储。</p>
<p>Java中的foreach语法是iterator的变形用法，也就是说foreach和下面的代码等价：</p>
<pre><code>for(Iterator&lt;Integer&gt; i = list.iterator(); i.hasNext();){
    sum += i.next();
}
</code></pre><p>我们再来想想什么是迭代器，迭代器是23中设计模式中的一种，提供一种方法能够遍历容器的各个元素，同时又无需暴露该对象的实现细节，也就是说需要先创建一个迭代器容器，然后屏蔽内部遍历细节，对外提供hasNext、next方法，问题是ArrayList实现了RandomAccess接口，表明元素之间本来没有关系，可视为了使用迭代器就需要强制建立一种相互“知晓”的一种关系，比如上一个元素可以判断是否有下一个元素，以及下一个元素是什么，这就是通过foreach遍历耗时的原因。</p>
<p>但是有些List实现类不是随机存取的，比如LinkedList类，也是一个列表，但它实现了双向链表，每个数据节点node都有三个数据项：前一个节点的引用、本节点元素、下一个节点的引用，也就是说LinkedList的两个元素之间是有关联的，我知道你的存在，你知道我的存在，这时候使用foreach来遍历效率就会更高，我们把代码中的ArrayList修改成LinkedList之后再运行下，结果如下：</p>
<pre><code>平均身高是： 154
运行时间： 16ms
</code></pre><p>确实如此，也是16ms，你可能也想用测试一下下标访问方法遍历LinkedList的元素，其实不用测试，效率非常低下。</p>
<p>明白了随机存取和有序存取列表的区别，在遍历列表时就应该采用不同的遍历方式。    </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一些强大的Vim插件]]></title>
      <url>http://www.ezlippi.com/blog/2015/03/vim-plugins.html</url>
      <content type="html"><![CDATA[<p>除了一些常用的插件比如ctags，taglist，bufexplorer,winmamager之外，这里介绍一些很强大的插件。</p>
<p>1.<em>Vundle</em> <a href="https://github.com/gmarik/Vundle.vim" target="_blank" rel="external">Github主页</a>，一个强大的插件管理器<br><a id="more"></a></p>
<h3 id="Vundle可以："><a href="#Vundle可以：" class="headerlink" title="Vundle可以："></a>Vundle可以：</h3><p>1.在Vimrc文件里跟踪和配置你的插件</p>
<p>2.只需敲一条命令就可以安装、更新、搜索、清除插件</p>
<h3 id="安装Vundle"><a href="#安装Vundle" class="headerlink" title="安装Vundle"></a>安装Vundle</h3><pre><code>$ git clone https://github.com/gmarik/Vundle.vim.git ~/.vim/bundle/Vundle.vim
</code></pre><p>配置Vundle插件：</p>
<pre><code>set nocompatible              &quot; be iMproved, required
filetype off                  &quot; required

&quot; set the runtime path to include Vundle and initialize
set rtp+=~/.vim/bundle/Vundle.vim
call vundle#begin()
&quot; alternatively, pass a path where Vundle should install plugins
&quot;call vundle#begin(&apos;~/some/path/here&apos;)
&quot;在下面添加你需要安装的插件
&quot; let Vundle manage Vundle, required
Plugin &apos;gmarik/Vundle.vim&apos;

&quot; The following are examples of different formats supported.
&quot; Keep Plugin commands between vundle#begin/end.
&quot;在Github仓库的插件
Plugin &apos;tpope/vim-fugitive&apos;
&quot; http://vim-scripts.org/vim/scripts.html网站上的插件直接写插件名称
Plugin &apos;L9&apos;
&quot; Git plugin not hosted on GitHub
Plugin &apos;git://git.wincent.com/command-t.git&apos;
&quot; 本机目录下的插件
Plugin &apos;file:///home/gmarik/path/to/plugin&apos;
&quot; The sparkup vim script is in a subdirectory of this repo called vim.
&quot; Pass the path to set the runtimepath properly.
Plugin &apos;rstacruz/sparkup&apos;, {&apos;rtp&apos;: &apos;vim/&apos;}
&quot; Avoid a name conflict with L9
Plugin &apos;user/L9&apos;, {&apos;name&apos;: &apos;newL9&apos;}

&quot; 所有的插件需要在这一行之前添加
call vundle#end()            &quot; required
filetype plugin indent on    &quot; required
&quot; To ignore plugin indent changes, instead use:
&quot;filetype plugin on
</code></pre><h3 id="如何使用Vundle"><a href="#如何使用Vundle" class="headerlink" title="如何使用Vundle"></a>如何使用Vundle</h3><pre><code>&quot; Brief help
&quot; :PluginList       - lists configured plugins
&quot; :PluginInstall    - installs plugins; append `!` to update or just :PluginUpdate
&quot; :PluginSearch foo - searches for foo; append `!` to refresh local cache
&quot; :PluginClean      - confirms removal of unused plugins; append `!` to auto-approve removal

&quot; 使用:h vundle 显示帮助文档
</code></pre><hr>
<p>2.<em>neocomplete</em> <a href="https://github.com/Shougo/neocomplete.vim" target="_blank" rel="external">github主页</a>，一个比VIm自带补全更强大的自动补全插件，支持更多的特性。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>确保你的系统安装了下列之一：</p>
<ul>
<li>vim-nox</li>
<li>vim-gtk</li>
<li>vim-gnome</li>
<li>vim-athena</li>
</ul>
<p>然后再Vundle中添加一句：Plugin ‘Shougo/neocomplete.vim’，重新打开Vim就自动安装了</p>
<h3 id="ScreenShots"><a href="#ScreenShots" class="headerlink" title="ScreenShots"></a>ScreenShots</h3><p><img src="https://camo.githubusercontent.com/2135f9b37963594325b304a7a57163b5b6ab8b11/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f3231343438382f3632333135312f32383461643836652d636635622d313165322d383238652d3235376433316266303537322e706e67" alt=""></p>
<p><img src="https://camo.githubusercontent.com/4a4d1893ce150863dd815fa6967e5f526ac84727/68747470733a2f2f662e636c6f75642e6769746875622e636f6d2f6173736574732f3231343438382f3632333439362f39346564313961322d636636382d313165322d386433332d3361616438613339643763312e676966" alt=""></p>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><pre><code>&quot;Note: This option must set it in .vimrc(_vimrc).  NOT IN .gvimrc(_gvimrc)!
&quot; Disable AutoComplPop.
let g:acp_enableAtStartup = 0
&quot; Use neocomplete.
let g:neocomplete#enable_at_startup = 1
&quot; Use smartcase.
let g:neocomplete#enable_smart_case = 1
&quot; Set minimum syntax keyword length.
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#lock_buffer_name_pattern = &apos;\*ku\*&apos;

&quot; Define dictionary.
let g:neocomplete#sources#dictionary#dictionaries = {
    \ &apos;default&apos; : &apos;&apos;,
    \ &apos;vimshell&apos; : $HOME.&apos;/.vimshell_hist&apos;,
    \ &apos;scheme&apos; : $HOME.&apos;/.gosh_completions&apos;
        \ }

&quot; Define keyword.
if !exists(&apos;g:neocomplete#keyword_patterns&apos;)
    let g:neocomplete#keyword_patterns = {}
endif
let g:neocomplete#keyword_patterns[&apos;default&apos;] = &apos;\h\w*&apos;

&quot; Plugin key-mappings.
inoremap &lt;expr&gt;&lt;C-g&gt;     neocomplete#undo_completion()
inoremap &lt;expr&gt;&lt;C-l&gt;     neocomplete#complete_common_string()

&quot; Recommended key-mappings.
&quot; &lt;CR&gt;: close popup and save indent.
inoremap &lt;silent&gt; &lt;CR&gt; &lt;C-r&gt;=&lt;SID&gt;my_cr_function()&lt;CR&gt;
function! s:my_cr_function()
  return neocomplete#close_popup() . &quot;\&lt;CR&gt;&quot;
  &quot; For no inserting &lt;CR&gt; key.
  &quot;return pumvisible() ? neocomplete#close_popup() : &quot;\&lt;CR&gt;&quot;
endfunction
&quot; &lt;TAB&gt;: completion.
inoremap &lt;expr&gt;&lt;TAB&gt;  pumvisible() ? &quot;\&lt;C-n&gt;&quot; : &quot;\&lt;TAB&gt;&quot;
&quot; &lt;C-h&gt;, &lt;BS&gt;: close popup and delete backword char.
inoremap &lt;expr&gt;&lt;C-h&gt; neocomplete#smart_close_popup().&quot;\&lt;C-h&gt;&quot;
inoremap &lt;expr&gt;&lt;BS&gt; neocomplete#smart_close_popup().&quot;\&lt;C-h&gt;&quot;
inoremap &lt;expr&gt;&lt;C-y&gt;  neocomplete#close_popup()
inoremap &lt;expr&gt;&lt;C-e&gt;  neocomplete#cancel_popup()
&quot; Close popup by &lt;Space&gt;.
&quot;inoremap &lt;expr&gt;&lt;Space&gt; pumvisible() ? neocomplete#close_popup() : &quot;\&lt;Space&gt;&quot;

&quot; For cursor moving in insert mode(Not recommended)
&quot;inoremap &lt;expr&gt;&lt;Left&gt;  neocomplete#close_popup() . &quot;\&lt;Left&gt;&quot;
&quot;inoremap &lt;expr&gt;&lt;Right&gt; neocomplete#close_popup() . &quot;\&lt;Right&gt;&quot;
&quot;inoremap &lt;expr&gt;&lt;Up&gt;    neocomplete#close_popup() . &quot;\&lt;Up&gt;&quot;
&quot;inoremap &lt;expr&gt;&lt;Down&gt;  neocomplete#close_popup() . &quot;\&lt;Down&gt;&quot;
&quot; Or set this.
&quot;let g:neocomplete#enable_cursor_hold_i = 1
&quot; Or set this.
&quot;let g:neocomplete#enable_insert_char_pre = 1

&quot; AutoComplPop like behavior.
&quot;let g:neocomplete#enable_auto_select = 1

&quot; Shell like behavior(not recommended).
&quot;set completeopt+=longest
&quot;let g:neocomplete#enable_auto_select = 1
&quot;let g:neocomplete#disable_auto_complete = 1
&quot;inoremap &lt;expr&gt;&lt;TAB&gt;  pumvisible() ? &quot;\&lt;Down&gt;&quot; : &quot;\&lt;C-x&gt;\&lt;C-u&gt;&quot;

&quot; Enable omni completion.
autocmd FileType css setlocal omnifunc=csscomplete#CompleteCSS
autocmd FileType html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
autocmd FileType javascript setlocal omnifunc=javascriptcomplete#CompleteJS
autocmd FileType python setlocal omnifunc=pythoncomplete#Complete
autocmd FileType xml setlocal omnifunc=xmlcomplete#CompleteTags

&quot; Enable heavy omni completion.
if !exists(&apos;g:neocomplete#sources#omni#input_patterns&apos;)
  let g:neocomplete#sources#omni#input_patterns = {}
endif
&quot;let g:neocomplete#sources#omni#input_patterns.php = &apos;[^. \t]-&gt;\h\w*\|\h\w*::&apos;
&quot;let g:neocomplete#sources#omni#input_patterns.c = &apos;[^.[:digit:] *\t]\%(\.\|-&gt;\)&apos;
&quot;let g:neocomplete#sources#omni#input_patterns.cpp = &apos;[^.[:digit:] *\t]\%(\.\|-&gt;\)\|\h\w*::&apos;

&quot; For perlomni.vim setting.
&quot; https://github.com/c9s/perlomni.vim
let g:neocomplete#sources#omni#input_patterns.perl = &apos;\h\w*-&gt;\h\w*\|\h\w*::&apos;
</code></pre><p>3.<em>CtrlP插件</em> <a href="https://github.com/kien/ctrlp.vim" target="_blank" rel="external">github主页</a></p>
<p>快速查找文件、缓冲区、tag的Vim插件，可以同时打开多个文件，创建文件和目录</p>
<p>基本操作：</p>
<pre><code>在Vim中按下Ctrl+p打开Ctrlp插件
&lt;c-d&gt;在路径搜索和文件名搜索之间切换
 &lt;c-r&gt;在字符串搜索和正则表达式搜索中切换
&lt;c-f&gt;和&lt;c-b&gt;forward和backward，搜索结果在不同搜索模式中切换
&lt;c-j&gt;&lt;c-k&gt;在结果中切换
&lt;c-n&gt;&lt;c-p&gt;在搜索历史中切换
&lt;c-t&gt;在新Tab中打开选中的文件
&lt;c-v&gt;在垂直分屏中打开选中的文件
&lt;c-s&gt;在水平分屏中打开选中的文件
&lt;c-y&gt;创建新的文件和目录
&lt;c-z&gt;标记将要打开的文件
&lt;c-o&gt;打开被&lt;c-z&gt;标记的文件
</code></pre><p>4<em>surround</em> <a href="https://github.com/tpope/vim-surround" target="_blank" rel="external">github主页</a></p>
<p>大多数编程语言的语法都用到了配对符号surrounding: (), [], {}, &lt;&gt;, ‘’, “”，标记语言xml html 等更是完全依赖与这种语法。正常输入时，所有的编辑器都能胜任，大部分会在你输入一个括号时帮你补全另一半。vim 也有这样的插件auto-pair, 但是这个不是重点，真正的难题是当你需要为已一些存在的代码加上括号，删除一对括号但保留其中的内容，或者把一对()改成[]。</p>
<p>使用surround，你将很容易添加和修改配对符号，比如：</p>
<pre><code>   Old text                  Command         New text ~
&quot;Hello *world!&quot;                 ds&quot;         Hello world!
[123+4*56]/2                    cs])        (123+456)/2
&quot;Look ma, I&apos;m *HTML!&quot;            cs&quot;&lt;q&gt;      &lt;q&gt;Look ma, I&apos;m HTML!&lt;/q&gt;
if *x&gt;3 {                        ysW(        if ( x&gt;3 ) {
my $str = *whee!;                vlllls&apos;     my $str = &apos;whee!&apos;;
&lt;div&gt;Yo!*&lt;/div&gt;                dst         Yo!
&lt;div&gt;Yo!*&lt;/div&gt;                cst&lt;p&gt;      &lt;p&gt;Yo!&lt;/p&gt;
</code></pre><p>上面*代表当前光标位置，添加替换时使用后半括号)]}，添加的括号和内容间就没有空格（如第2个示例），反之会在内容前后添加一个空格（如第4个实例）。第6个示例中的t代表一对HTML或者xml tag。其他表示范围的符号：w代表word, W代表WORD(被空格分开的连续的字符窜），p代表paragraph。</p>
<h3 id="命令列表"><a href="#命令列表" class="headerlink" title="命令列表"></a>命令列表</h3><pre><code>    Normal mode
-----------
ds  - delete a surrounding
cs  - change a surrounding
ys  - add a surrounding
yS  - add a surrounding and place the surrounded text on a new line + indent it
yss - add a surrounding to the whole line
ySs - add a surrounding to the whole line, place it on a new line + indent it
ySS - same as ySs

Visual mode
-----------
s   - in visual mode, add a surrounding
S   - in visual mode, add a surrounding but place text on new line + indent it

Insert mode
-----------
&lt;CTRL-s&gt; - in insert mode, add a surrounding
&lt;CTRL-s&gt;&lt;CTRL-s&gt; - in insert mode, add a new line + surrounding + indent
&lt;CTRL-g&gt;s - same as &lt;CTRL-s&gt;
&lt;CTRL-g&gt;S - same as &lt;CTRL-s&gt;&lt;CTRL-s&gt;
</code></pre><p>5.<em>syntastic</em>  <a href="https://github.com/scrooloose/syntastic#installation" target="_blank" rel="external">githun主页</a></p>
<p>来看一下官方给的图片：<br><img src="http://foocoder.qiniudn.com/blog/syntasticsyntastic.png?token=hYfsyKwhHPe-Ga-1Hypx5F8CwimEywvTI8XdNpEm:z6zQYbdezgOYcKfzok7LEkuRDkg=:eyJTIjoiZm9vY29kZXIucWluaXVkbi5jb20vYmxvZy9zeW50YXN0aWNzeW50YXN0aWMucG5nIiwiRSI6MTQwMDA2ODU2N30=" alt=""></p>
<ul>
<li>图片很清楚的介绍了插件功能：</li>
<li>用location list 列出所有错误。</li>
<li>命令行窗口显示当前错误。</li>
<li>错误标记，有警告和错误。</li>
<li>鼠标悬停可以出现错误提示框</li>
<li>状态栏标记。</li>
</ul>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p>当然也可以做一些简单的配置，比如设置为每次打开buffer就执行语法检查，而不只是在保存时：<br>    let g:syntastic_check_on_open = 1<br>如果想使用多个检查器，可以这样写：<br>    let g:syntastic_php_checkers = [‘php’, ‘phpcs’, ‘phpmd’]</p>
<h3 id="错误跳转"><a href="#错误跳转" class="headerlink" title="错误跳转"></a>错误跳转</h3><p>syntastic使用location list来显示所有的错误，location list和quificfix 类似，包含了位置信息。<br>调起这个location list<br>    :Errors 或者 :lopen<br>使用:lne[xt]和:lp[revious]就可以在错误间跳转。当然，如果用的多，可以做个mapping,更多内容可以参考帮助文档:help syntastic.</p>
<p>6.<em>fugitive</em><a href="https://github.com/tpope/vim-fugitive" target="_blank" rel="external">github主页</a></p>
<blockquote>
<p>If you don’t know GIT, learn it right now!If you use GIT and VIM, use Fugitive right now!</p>
</blockquote>
<p>fugitive.vim插件是由Tim Pope创建的VIM插件。该插件与命令行git工具相辅相成，可以无缝的插入到工作流程中。</p>
<p>在VIM的命令行中，%符号具有特殊的含义：他将扩展为当前文件的全路径。可以使用该命令来运行使用文件名作为参数的任意git命令，从而使得命令作用于当前的文件。但是fugitive也提供了一些便利的方法，其中的一些总结如下：</p>
<pre><code>  git                 fugitive          action
:Git add %            :Gwrite           Stage the current file to the index
:Git checkout %        :Gread             Revert current file to last checked in version
:Git rm %            :Gremove         Delete the current file and the corresponding Vim buffer
:Git mv %            :Gmove             Rename the current file and the corresponding Vim buffer
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android Studio多渠道打包和代码混淆教程]]></title>
      <url>http://www.ezlippi.com/blog/2015/03/android-studio-prefrence.html</url>
      <content type="html"><![CDATA[<h2 id="什么是Gradle"><a href="#什么是Gradle" class="headerlink" title="什么是Gradle"></a>什么是Gradle</h2><p>Gradle是一种依赖管理工具，基于Groovy语言，面向Java应用为主，它抛弃了基于XML的各种繁琐配置，取而代之的是一种基于Groovy的领域特定（DSL）语言。Android Studio中新建项目成功后自动下载Gradle。<br>Gradle有几个基本组件：<br><a id="more"></a><br>1.整个项目的gradle配置文件build.gradle</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Top-level build file where you can add configuration options common to all sub-projects/modules.</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line"> repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:1.1.0'</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">    <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">allprojects &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内容主要包含了两个方面：一个是声明仓库的源，我这里用的是mavenCentral(), jcenter可以理解成是一个新的中央远程仓库，兼容maven中心仓库，而且性能更优。另一个是声明了android gradle plugin的版本，android studio 1.1正式版必须要求支持gradle plugin 1.1的版本。</p>
<hr>
<p>2.app文件夹下这个Module的gradle配置文件，也可以算是整个项目最主要的gradle配置文件</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">buildscript &#123;</span><br><span class="line">    repositories &#123;</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">    dependencies &#123;</span><br><span class="line">        classpath <span class="string">'com.android.tools.build:gradle:1.1.0'</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">17</span></span><br><span class="line">    buildToolsVersion <span class="string">"21.1.2"</span></span><br><span class="line"></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.lippi.recorder"</span></span><br><span class="line">        minSdkVersion <span class="number">15</span></span><br><span class="line">        targetSdkVersion <span class="number">17</span></span><br><span class="line">        versionCode <span class="number">1</span></span><br><span class="line">        versionName <span class="string">'1.4'</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// dex突破65535的限制</span></span><br><span class="line">        multiDexEnabled <span class="literal">true</span></span><br><span class="line">        <span class="comment">// AndroidManifest.xml 里面UMENG_CHANNEL的value为 $&#123;UMENG_CHANNEL_VALUE&#125;</span></span><br><span class="line">        manifestPlaceholders = [<span class="string">UMENG_CHANNEL_VALUE:</span> <span class="string">"channel_name"</span>]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sourceSets &#123;</span><br><span class="line">        main &#123;</span><br><span class="line">            manifest.srcFile <span class="string">'src/main/AndroidManifest.xml'</span></span><br><span class="line">            java.srcDirs = [<span class="string">'src/main/java'</span>]</span><br><span class="line">            resources.srcDirs = [<span class="string">'src/main/resources'</span>]</span><br><span class="line">            aidl.srcDirs = [<span class="string">'src/main/aidl'</span>]</span><br><span class="line">            renderscript.srcDirs = [<span class="string">'src/maom'</span>]</span><br><span class="line">            res.srcDirs = [<span class="string">'src/main/res'</span>]</span><br><span class="line">            assets.srcDirs = [<span class="string">'src/main/assets'</span>]</span><br><span class="line">            jniLibs.srcDir <span class="string">'src/main/jniLibs'</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the tests to tests/java, tests/res, etc...</span></span><br><span class="line">        instrumentTest.setRoot(<span class="string">'tests'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Move the build types to build-types/&lt;type&gt;</span></span><br><span class="line">        <span class="comment">// For instance, build-types/debug/java, build-types/debug/AndroidManifest.xml, ...</span></span><br><span class="line">        <span class="comment">// This moves them out of them default location under src/&lt;type&gt;/... which would</span></span><br><span class="line">        <span class="comment">// conflict with src/ being used by the main source set.</span></span><br><span class="line">        <span class="comment">// Adding new build types or product flavors should be accompanied</span></span><br><span class="line">        <span class="comment">// by a similar customization.</span></span><br><span class="line">        debug.setRoot(<span class="string">'build-types/debug'</span>)</span><br><span class="line">        release.setRoot(<span class="string">'build-types/release'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行lint检查，有任何的错误或者警告提示，都会终止构建，我们可以将其关掉。</span></span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//签名</span></span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            storeFile file(<span class="string">"/home/lippi/.android/debug.keystore"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        relealse &#123;</span><br><span class="line">            <span class="comment">//这样写就得把demo.jk文件放在项目目录</span></span><br><span class="line">            storeFile file(<span class="string">"recorder.jks"</span>)</span><br><span class="line">            storePassword <span class="string">"recorder"</span></span><br><span class="line">            keyAlias <span class="string">"recorder"</span></span><br><span class="line">            keyPassword <span class="string">"recorder"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// 显示Log</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"true"</span></span><br><span class="line"></span><br><span class="line">            versionNameSuffix <span class="string">"-debug"</span></span><br><span class="line">            minifyEnabled <span class="literal">false</span></span><br><span class="line">            zipAlignEnabled <span class="literal">false</span></span><br><span class="line">            shrinkResources <span class="literal">false</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 不显示Log</span></span><br><span class="line">            buildConfigField <span class="string">"boolean"</span>, <span class="string">"LOG_DEBUG"</span>, <span class="string">"false"</span></span><br><span class="line">            <span class="comment">//混淆</span></span><br><span class="line">            minifyEnabled <span class="literal">true</span></span><br><span class="line">            <span class="comment">//Zipalign优化</span></span><br><span class="line">            zipAlignEnabled <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 移除无用的resource文件</span></span><br><span class="line">            shrinkResources <span class="literal">true</span></span><br><span class="line">            <span class="comment">//前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard.cfg'</span></span><br><span class="line">            <span class="comment">//签名</span></span><br><span class="line">            signingConfig signingConfigs.relealse</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//渠道Flavors，配置不同风格的app</span></span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        GooglePlay &#123;&#125;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        umeng &#123;&#125;</span><br><span class="line">        _360 &#123;&#125;</span><br><span class="line">        baidu &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//批量配置</span></span><br><span class="line">    productFlavors.all &#123; flavor -&gt;</span><br><span class="line">        flavor.manifestPlaceholders = [<span class="string">UMENG_CHANNEL_VALUE:</span> name]</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_7</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_7</span><br><span class="line">    &#125;</span><br><span class="line">    applicationVariants.all &#123; variant -&gt;</span><br><span class="line">        variant.outputs.each &#123; output -&gt;</span><br><span class="line">            <span class="keyword">def</span> outputFile = output.outputFile</span><br><span class="line">            <span class="keyword">if</span> (outputFile != <span class="literal">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</span><br><span class="line">                <span class="keyword">def</span> fileName = outputFile.name.replace(<span class="string">".apk"</span>, <span class="string">"-$&#123;defaultConfig.versionName&#125;.apk"</span>)</span><br><span class="line">                output.outputFile = <span class="keyword">new</span> File(outputFile.parent, fileName)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dependencies &#123;</span><br><span class="line">        compile fileTree(<span class="string">include:</span> [<span class="string">'*.jar'</span>], <span class="string">dir:</span> <span class="string">'libs'</span>)</span><br><span class="line">        compile <span class="string">'org.apache.commons:commons-math:2.1'</span></span><br><span class="line">        compile <span class="string">'org.slf4j:slf4j-log4j12:1.7.5'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>文件开头apply plugin是最新gradle版本的写法，以前的写法是apply plugin: ‘android’, 如果还是以前的写法，请改正过来。</p>
</li>
<li><p>buildToolsVersion这个需要你本地安装该版本才行，很多人导入新的第三方库，失败的原因之一是build version的版本不对，这个可以手动更改成你本地已有的版本或者打开 SDK Manager 去下载对应版本。</p>
</li>
<li><p>applicationId代表应用的包名，也是最新的写法，这里就不在多说了。</p>
</li>
<li><p>android 5.0开始默认安装jdk1.7才能编译</p>
</li>
<li><p>minifyEnabled（混淆）也是最新的语法，很早之前是runProguard,这个也需要更新下。</p>
</li>
<li><p>proguardFiles这部分有两段，前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，免去了我们很多事，这个文件的目录在 <strong>/tools/proguard/proguard-android.txt</strong> , 后一部分是我们项目里的自定义的混淆文件，目录就在 <strong>app/proguard-rules.txt</strong> , 如果你用Studio 1.0创建的新项目默认生成的文件名是 <strong>proguard-rules.pro</strong> , 这个名字没关系，在这个文件里你可以声明一些第三方依赖的一些混淆规则,后面会具体讲到。</p>
</li>
</ul>
<p>compile project(‘:extras:ShimmerAndroid’)这一行是因为项目中存在其他Module，你可以理解成Android Library，由于Gradle的普及以及远程仓库的完善，这种依赖渐渐的会变得非常不常见，但是你需要知道有这种依赖的。</p>
<hr>
<p>3.gradle目录下有个 wrapper 文件夹，里面可以看到有两个文件，我们主要看下 gradle-wrapper.properties 这个文件的内容：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#Fri Dec 19 21:59:01 CST 2014</span><br><span class="line">distributionBase=GRADLE_USER_HOME</span><br><span class="line">distributionPath=wrapper/dists</span><br><span class="line">zipStoreBase=GRADLE_USER_HOME</span><br><span class="line">zipStorePath=wrapper/dists</span><br><span class="line">distributionUrl=https\://services.gradle.org/distributions/gradle-2.2.1-all.zip</span><br></pre></td></tr></table></figure>
<p>可以看到里面声明了gradle的目录与下载路径以及当前项目使用的gradle版本，这些默认的路径我们一般不会更改的，这个文件里指明的gradle版本不对也是很多导包不成功的原因之一</p>
<hr>
<p>4.settings.gradle</p>
<p>这个文件是全局的项目配置文件，里面主要声明一些需要加入gradle的module</p>
<pre><code>include &apos;:recorder&apos;
</code></pre><p>文件中recorder是项目的module，如果还有其他module按照相同的格式加上去。</p>
<hr>
<h2 id="Gradle多渠道打包"><a href="#Gradle多渠道打包" class="headerlink" title="Gradle多渠道打包"></a>Gradle多渠道打包</h2><p>由于国内Android市场众多渠道，为了统计每个渠道的下载及其它数据统计，就需要我们针对每个渠道单独打包，如果让你打几十个市场的包岂不烦死了，不过有了Gradle，这再也不是事了。<br>以友盟统计为例，在AndroidManifest.xml里面会有这么一段：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line"><span class="string">android:</span>name=<span class="string">"UMENG_CHANNEL"</span></span><br><span class="line"><span class="string">android:</span>value=<span class="string">"Channel_ID"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>里面的Channel_ID就是渠道标示。我们的目标就是在编译的时候这个值能够自动变化。</p>
<ul>
<li>第一步 在AndroidManifest.xml里配置PlaceHolder</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data</span><br><span class="line"><span class="string">android:</span>name=<span class="string">"UMENG_CHANNEL"</span></span><br><span class="line"><span class="string">android:</span>value=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>第二步 在build.gradle  设置productFlavors</li>
</ul>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">android &#123; </span><br><span class="line">productFlavors &#123;</span><br><span class="line">    xiaomi &#123;&#125;</span><br><span class="line">    _360 &#123;&#125;</span><br><span class="line">    baidu &#123;&#125;</span><br><span class="line">    wandoujia &#123;&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">productFlavors.all &#123; </span><br><span class="line">    flavor -&gt; flavor.manifestPlaceholders = [<span class="string">UMENG_CHANNEL_VALUE:</span> name] </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后直接执行<code>./gradlew assembleRelease</code>然后就等待打包完成吧。</p>
<p> assemble 这个命令，会结合 Build Type 创建自己的task，如:</p>
<ul>
<li><p>./gradlew assembleDebug</p>
</li>
<li><p>./gradlew assembleRelease</p>
</li>
</ul>
<p>除此之外 assemble 还能和 Product Flavor 结合创建新的任务，其实 assemble 是和 Build Variants 一起结合使用的，而 Build Variants = Build Type + Product Flavor ， 举个例子大家就明白了：</p>
<p>如果我们想打包wandoujia渠道的release版本，执行如下命令就好了：</p>
<pre><code>./gradlew assembleWandoujiaRelease
</code></pre><p>如果我们只打wandoujia渠道版本，则：</p>
<pre><code>./gradlew assembleWandoujia
</code></pre><p>此命令会生成wandoujia渠道的Release和Debug版本</p>
<p>同理我想打全部Release版本：</p>
<pre><code>./gradlew assembleRelease
</code></pre><p>这条命令会把Product Flavor下的所有渠道的Release版本都打出来。</p>
<hr>
<h2 id="代码混淆"><a href="#代码混淆" class="headerlink" title="代码混淆"></a>代码混淆</h2><p>下面是常见的的proguard.cfg配置项：</p>
<pre><code># 指定代码的压缩级别
-optimizationpasses 5

# 包明不混合大小写
-dontusemixedcaseclassnames

# 不去忽略非公共的库类
-dontskipnonpubliclibraryclasses

 # 优化不优化输入的类文件
-dontoptimize

 # 预校验
-dontpreverify

 # 混淆时是否记录日志
-verbose

 # 混淆时所采用的算法
-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*

# 保护注解
-keepattributes *Annotation*

# 保持哪些类不被混淆
-keep public class * extends android.app.Fragment
-keep public class * extends android.app.Activity
-keep public class * extends android.app.Application
-keep public class * extends android.app.Service
-keep public class * extends android.content.BroadcastReceiver
-keep public class * extends android.content.ContentProvider
-keep public class * extends android.app.backup.BackupAgentHelper
-keep public class * extends android.preference.Preference
-keep public class com.android.vending.licensing.ILicensingService
# 如果有引用v4包可以添加下面这行
-keep public class * extends android.support.v4.app.Fragment



# 忽略警告
-ignorewarning

#记录生成的日志数据,gradle build时在本项目根目录输出 

# apk 包内所有 class 的内部结构
-dump class_files.txt
# 未混淆的类和成员
-printseeds seeds.txt
# 列出从 apk 中删除的代码
-printusage unused.txt
# 混淆前后的映射
-printmapping mapping.txt

#记录生成的日志数据，gradle build时 在本项目根目录输出-end


#####混淆保护自己项目的部分代码以及引用的第三方jar包library

#-libraryjars libs/umeng-analytics-v5.2.4.jar

#三星应用市场需要添加:sdk-v1.0.0.jar,look-v1.0.1.jar
#-libraryjars libs/sdk-v1.0.0.jar
#-libraryjars libs/look-v1.0.1.jar

#如果不想混淆 keep 掉
-keep class com.lippi.recorder.iirfilterdesigner.** {*; }
#友盟
-keep class com.umeng.**{*;}
#项目特殊处理代码

#忽略警告
-dontwarn com.lippi.recorder.utils**
#保留一个完整的包
-keep class com.lippi.recorder.utils.** {
    *;
 }

-keep class  com.lippi.recorder.utils.AudioRecorder{*;}


#如果引用了v4或者v7包
-dontwarn android.support.**

#混淆保护自己项目的部分代码以及引用的第三方jar包library-end

-keep public class * extends android.view.View {
    public &lt;init&gt;(android.content.Context);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);
    public void set*(...);
}

#保持 native 方法不被混淆
-keepclasseswithmembernames class * {
    native &lt;methods&gt;;
}

#保持自定义控件类不被混淆
-keepclasseswithmembers class * {
    public &lt;init&gt;(android.content.Context, android.util.AttributeSet);
}

#保持自定义控件类不被混淆
-keepclassmembers class * extends android.app.Activity {
   public void *(android.view.View);
}

#保持 Parcelable 不被混淆
-keep class * implements android.os.Parcelable {
  public static final android.os.Parcelable$Creator *;
}

#保持 Serializable 不被混淆
-keepnames class * implements java.io.Serializable

#保持 Serializable 不被混淆并且enum 类也不被混淆
-keepclassmembers class * implements java.io.Serializable {
    static final long serialVersionUID;
    private static final java.io.ObjectStreamField[] serialPersistentFields;
    !static !transient &lt;fields&gt;;
    !private &lt;fields&gt;;
    !private &lt;methods&gt;;
    private void writeObject(java.io.ObjectOutputStream);
    private void readObject(java.io.ObjectInputStream);
    java.lang.Object writeReplace();
    java.lang.Object readResolve();
}

#保持枚举 enum 类不被混淆 如果混淆报错，建议直接使用上面的 -keepclassmembers class * implements java.io.Serializable即可
#-keepclassmembers enum * {
#  public static **[] values();
#  public static ** valueOf(java.lang.String);
#

-keepclassmembers class * {
    public void *ButtonClicked(android.view.View);
}

#不混淆资源类
-keepclassmembers class **.R$* {
    public static &lt;fields&gt;;
}

#避免混淆泛型 如果混淆报错建议关掉
#–keepattributes Signature

#移除log 测试了下没有用还是建议自己定义一个开关控制是否输出日志
#-assumenosideeffects class android.util.Log {
#    public static boolean isLoggable(java.lang.String, int);
#    public static int v(...);
#    public static int i(...);
#    public static int w(...);
#    public static int d(...);
#    public static int e(...);
#

#如果用用到Gson解析包的，直接添加下面这几行就能成功混淆，不然会报错。
#gson
#-libraryjars libs/gson-2.2.2.jar
-keepattributes Signature
# Gson specific classes
-keep class sun.misc.Unsafe { *; }
# Application classes that will be serialized/deserialized over Gson
-keep class com.google.gson.examples.android.model.** { *; }
</code></pre><hr>
<p>参考文献：<a href="http://tools.android.com/tech-docs/new-build-system/tips" target="_blank" rel="external">Android Tools Project Site</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在Ubuntu下安装和编译LaTex]]></title>
      <url>http://www.ezlippi.com/blog/2015/03/install-texlive-in-ubuntu.html</url>
      <content type="html"><![CDATA[<h2 id="LaTex简介"><a href="#LaTex简介" class="headerlink" title="LaTex简介"></a>LaTex简介</h2><p>1、LaTeX 是由美国计算机学家Lamport博士于1985年开发成功的。<br>2、它是当今世界上最流行和使用最为广泛,以 TeX 为引擎的高质量格式化排版系统。<br>3、它构筑在 TeX 的基础之上,并且加进了很多新功能,使得使用者可以更为方便的利用 TeX 的强大功能。<br>即使使用者并不是很了解 TeX,也可以在很短的时间内制成高质量的文件。</p>
<p>LaTex有很多发行版，Linux下的发行版为TexLive，本文安装环境为 Ubuntu 14.04.1 64 位系统，软件版本为 TeXLive 2014，更详细的教程请看官方<a href="http://tug.org/texlive/doc/texlive-zh-cn/texlive-zh-cn.pdf" target="_blank" rel="external">TeXLive 指南</a><br><a id="more"></a></p>
<h2 id="安装前准备"><a href="#安装前准备" class="headerlink" title="安装前准备"></a>安装前准备</h2><h3 id="下载-TeXLive-2014-镜像文件"><a href="#下载-TeXLive-2014-镜像文件" class="headerlink" title="下载 TeXLive 2014 镜像文件"></a>下载 TeXLive 2014 镜像文件</h3><p>下载地址：<a href="http://www.ctan.org/tex-archive/systems/texlive/Images" target="_blank" rel="external">TeXLive 2014</a><br>推荐厦门大学开源软件镜像，下载速度很可观:<a href="http://mirrors.xmu.edu.cn/CTAN/systems/texlive/Images/&quot;" target="_blank" rel="external">TEXLive</a></p>
<h3 id="删除旧版"><a href="#删除旧版" class="headerlink" title="删除旧版"></a>删除旧版</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge tex-common</span><br></pre></td></tr></table></figure>
<h3 id="安装-Perl-TK-模块"><a href="#安装-Perl-TK-模块" class="headerlink" title="安装 Perl::TK 模块"></a>安装 Perl::TK 模块</h3><p>install-tl 是一个 Perl 脚本，要在专家 GUI 模式下安装，需要加入 XFT 支持的 Perl::TK 模块，可用以下方法添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install perl-tk</span><br></pre></td></tr></table></figure></p>
<h2 id="安装主程序"><a href="#安装主程序" class="headerlink" title="安装主程序"></a>安装主程序</h2><h3 id="挂载-iso-镜像文件"><a href="#挂载-iso-镜像文件" class="headerlink" title="挂载 iso 镜像文件"></a>挂载 iso 镜像文件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mount -o loop path_to.iso /mnt</span><br><span class="line"><span class="built_in">cd</span> /mnt</span><br></pre></td></tr></table></figure>
<h3 id="启动安装程序"><a href="#启动安装程序" class="headerlink" title="启动安装程序"></a>启动安装程序</h3><p>在加入了 XFT 支持的 Perl::TK 模块后，可以用以下方法启动专家 GUI 模式进行安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ./install-tl -gui</span><br></pre></td></tr></table></figure></p>
<p>在图形界面中将<code>Create symlinks in system directories</code>选项更改为<code>Yes</code>，点击 <code>Install TeX Live</code> 开始安装。</p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>可根据安装结束时的文本提示进行相应的环境变量配置，我在安装时进行了如下配置。</p>
<p>在 ～/.bashrc 和 ～/.profile 文件结尾添加如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#自己为texlive配置的环境变量</span></span><br><span class="line">PATH=/usr/<span class="built_in">local</span>/texlive/2014/bin/x86_64-linux:<span class="variable">$PATH</span>; <span class="built_in">export</span> PATH</span><br><span class="line">MANPATH=/usr/<span class="built_in">local</span>/texlive/2014/texmf-dist/doc/man:<span class="variable">$MANPATH</span>; <span class="built_in">export</span> MANPATH</span><br><span class="line">INFOPATH=/usr/<span class="built_in">local</span>/texlive/2014/texmf-dist/doc/info:<span class="variable">$INFOPATH</span>; <span class="built_in">export</span> INFOPATH</span><br></pre></td></tr></table></figure>
<p>为了配置全局的环境变量，可在 /etc/manpath.config 文件的 <em># set up PATH to MANPATH mapping.</em> 下添加:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MANPATH_MAP /usr/<span class="built_in">local</span>/texlive/2014/bin/x86_64-linux /usr/<span class="built_in">local</span>/texlive/2014/texmf-dist/doc/man</span><br></pre></td></tr></table></figure></p>
<p>之后注销即可。</p>
<blockquote>
<p>注：如果环境变量配置出错导致无法登录，可以参见最下面的Linux配置环境变量后无法登录的解决方案</p>
</blockquote>
<h2 id="测试安装是否成功"><a href="#测试安装是否成功" class="headerlink" title="测试安装是否成功"></a>测试安装是否成功</h2><p>首先确认你可以执行 tex 程序:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tex --version</span><br><span class="line">    TeX 3.14159265 (TeX Live ...)</span><br><span class="line">    Copyright ... D.E. Knuth.</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p>
<p>如果你安装了 xetex 包,可以按如下步骤测试它能否访问系统字体（会生成文件，可在无用目录下执行）:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xetex opentype-info.tex</span><br><span class="line">    This is XeTeX, Version 3.14...</span><br><span class="line">    ...</span><br><span class="line">    Output written on opentype-info.pdf (1 page).</span><br><span class="line">    Transcript written on opentype-info.log.</span><br></pre></td></tr></table></figure></p>
<p>如果你收到 “Invalid fontname ‘Latin Modern Roman/ICU’…” 这样的错误信息,就说明需要配置系统才能找到 TEX Live 自带的字体。</p>
<h3 id="XeTEX-和-LuaTEX-的系统字体配置"><a href="#XeTEX-和-LuaTEX-的系统字体配置" class="headerlink" title="XeTEX 和 LuaTEX 的系统字体配置"></a>XeTEX 和 LuaTEX 的系统字体配置</h3><p>XeTEX 和 LuaTEX 可以使用任何系统安装的字体,而不只是 TEX 目录树中的那些。它们使用类似但不完全一致的方式实现这一功能。</p>
<p>在 Windows 下 TEX Live 提供的字体会自动为 XeTEX 所用。但如果你在 Unix 兼容的系统中安装了 xetex 软件包,则需要把系统配置一番 XeTEX 才能找到随 TEX Live 安装的那些字体。</p>
<p>要在整个系统中使用 TEX Live 的字体 (假定你有足够的权限),请依照下面的步骤来做:</p>
<ul>
<li><p>将 texlive-fontconfig.conf 文件复制到 /etc/fonts/conf.d/09-texlive.conf。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp /usr/<span class="built_in">local</span>/texlive/2014/texmf-var/fonts/conf/texlive-fontconfig.conf /etc/fonts/conf.d/09-texlive.conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>运行 fc-cache -fsv。<br>如果你没有足够的权限执行上述操作,或者只需要把 TEX Live 字体提供给你自己,可以这么做:</p>
</li>
<li><p>将 texlive-fontconfig.conf 文件复制到 ~/.fonts.conf,其中 ~ 是你的主目录。</p>
</li>
<li>运行 fc-cache -fv。<br>此时执行第2步，问题已经解决。</li>
</ul>
<h2 id="中文字体安装与配置"><a href="#中文字体安装与配置" class="headerlink" title="中文字体安装与配置"></a>中文字体安装与配置</h2><h3 id="中文字体安装"><a href="#中文字体安装" class="headerlink" title="中文字体安装"></a>中文字体安装</h3><p>先写一个简单的测试 tex 文件。起名为 test.tex<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">\documentclass[UTF8]&#123;ctexart&#125;</span><br><span class="line">\begin&#123;document&#125;</span><br><span class="line">我爱中国！</span><br><span class="line">\end&#123;document&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行如下命令编译<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ xelatex test.tex</span><br></pre></td></tr></table></figure></p>
<p>系统会报错，大致信息如下：</p>
<pre><code>! fontspec error: &quot;font-not-found&quot;

! The font &quot;SimSun&quot; cannot be found.
! See the fontspec documentation for further information.

! For immediate help type H 
!...............................................
</code></pre><p>下面就要解决这个问题，错误里说了，”font-not-found”!</p>
<ul>
<li>首先创建字体文件夹<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/share/fonts/winfonts</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>然后把 Windows 下的六种中意字体复制到该文件夹，比如从Windows的C:/Windows/Fonts下拷贝最常使用的几种字体：<br>msyh.ttf（微软雅黑）  simfang.ttf（仿宋）  simhei.ttf（黑体）  simkai.ttf（楷体）  simsun.ttc（宋体）,并更改字体权限<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 644 /usr/share/fonts/winfonts/*</span><br></pre></td></tr></table></figure></p>
<ul>
<li>刷新字体库 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo mkfontscale</span><br><span class="line">$ sudo mkfontdir</span><br><span class="line">$ sudo <span class="built_in">fc</span>-cache -fsv</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="xeLaTeX-中文字体配置"><a href="#xeLaTeX-中文字体配置" class="headerlink" title="xeLaTeX 中文字体配置"></a>xeLaTeX 中文字体配置</h3><p>如果使用 xeLaTeX 的话，需要 xeCJK 宏包的支持，需要修改 /usr/local/texlive/2014/texmf-dist/tex/latex/ctex/fontset 下的 ctex-xecjk-winfonts.def 文件。</p>
<p>下面，打开新的终端，执行如下命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fc</span>-list :lang=zh-cn</span><br></pre></td></tr></table></figure></p>
<p>输出大约如下</p>
<pre><code>NSimSun,新宋体:style=Regular  
KaiTi,楷             体:style=Regular,Normal,obyčejné,Standard,Κανονικά,Normaali,Normál,Normale,Standaard,Normalny,Обычный,Normálne,Navadno,Arrunta  
SimSun,宋体:style=RegularUnibit:style=Regular  
</code></pre><p>WenQuanYi Zen Hei,文泉驛正黑,文泉驿正黑:style=Regular<br>    ……</p>
<p>下面需要做的就是将 ctex-xecjk-winfonts.def 中的字体名字改成上面四行的行首的内容，注意，要将原文件中的 [SIMKAI.TTF] 中括号同时删去。<br>重新编译以下，发现成功了。</p>
<p>另外，若想添加 Adobe 字体，设置方法与 Windows 字体大致相同，此处不再赘述。</p>
<h3 id="pdfLaTeX-中文字体配置"><a href="#pdfLaTeX-中文字体配置" class="headerlink" title="pdfLaTeX 中文字体配置"></a>pdfLaTeX 中文字体配置</h3><p>在上边添加了 Windows 字体的基础之上可以为 pdfLaTeX 添加中文字体支持 </p>
<p>在 /usr/local/texlive/2014/texmf.cnf 文件中设置 OSFONTDIR 变量，即添加如下信息：<br>    自己为pdflatex设置的OSFONTDIR变量指向中文字体文件<br>    OSFONTDIR=/usr/share/fonts/winfonts<br>    论文中正常显示中文</p>
<p>新建一个.tex文件，在文件里面添加下面两句就能正常显示中文了：<br>    \usepackage{xeCJK}<br>    \setCJKmainfont{STSong}</p>
<h2 id="LaTeX-学习文档下载："><a href="#LaTeX-学习文档下载：" class="headerlink" title="LaTeX 学习文档下载："></a>LaTeX 学习文档下载：</h2><p><a href="http://download.csdn.net/detail/longerzone/4703133" target="_blank" rel="external">http://download.csdn.net/detail/longerzone/4703133</a></p>
<h2 id="Linux-配置环境变量后无法登录的解决方案"><a href="#Linux-配置环境变量后无法登录的解决方案" class="headerlink" title="Linux 配置环境变量后无法登录的解决方案"></a>Linux 配置环境变量后无法登录的解决方案</h2><h2 id="Linux-的环境变量读取机制"><a href="#Linux-的环境变量读取机制" class="headerlink" title="Linux 的环境变量读取机制"></a>Linux 的环境变量读取机制</h2><ul>
<li>在登陆时，操作系统定制用户环境时读取的第一个文件是 /etc/profile，此文件为系统的每个用户设置环境信息，当用户第一次登陆时，该文件被执行。 </li>
<li>在登陆时操作系统读取的第二个文件是 /etc/environment，系统在读取用户自己的 profile 前，设置环境文件的环境变量。 </li>
<li>在登陆时用到的第三个文件是 ～/.profile 文件，每个用户都可使用该文件输入专用于自己使用的 shell 信息，该文件仅仅执行一次。默认情况下，它设置一些环境变量，执行用户的 .bashrc 文件。/etc/bashrc 为每一个运行 bash shell 的用户执行此文件，当 bash shell 被打开时，该文件被读取。 </li>
</ul>
<h2 id="无法登录的原因"><a href="#无法登录的原因" class="headerlink" title="无法登录的原因"></a>无法登录的原因</h2><p>由上可知，系统启动时会先读取 /etc/profile，然后读取 /etc/environment，最后才是 ～/.profile 文件，而在 /etc/environment 中也设置有环境变量 PATH，如果你在 ~/.profile 中也设置了环境变量 PATH，那么就会覆盖原来的 /etc/environment 中设置的环境变量 PATH。</p>
<p>因此，～/.profile 文件中的环境变量设置一定不可大意，且在其设置的环境变量中要重新载入之前的环境变量，即添加 $PATH，且以冒号分割。</p>
<p>比如以我安装的 TeXLive 为例，正确的环境变量设置应该为:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PATH=/usr/<span class="built_in">local</span>/texlive/2014/bin/x86_64-linux:<span class="variable">$PATH</span>; <span class="built_in">export</span> PATH</span><br><span class="line">MANPATH=/usr/<span class="built_in">local</span>/texlive/2014/texmf-dist/doc/man:<span class="variable">$MANPATH</span>; <span class="built_in">export</span> MANPATH</span><br><span class="line">INFOPATH=/usr/<span class="built_in">local</span>/texlive/2014/texmf-dist/doc/info:<span class="variable">$INFOPATH</span>; <span class="built_in">export</span> INFOPATH</span><br></pre></td></tr></table></figure>
<h2 id="解决方法一"><a href="#解决方法一" class="headerlink" title="解决方法一"></a>解决方法一</h2><p>在登录界面可以通过 <code>Ctrl + Alt + F1～F6&lt;</code> 的方式进入命令行，再通过<code>Ctrl + Alt + F7</code>的方式进入图形界面。</p>
<p>因此我们可以进入图形界面登录 root 账户，将之前修改的环境变量删除或者更正即可。</p>
<p>注意事项：我们在登录不同的账户时，～所对应的目录是不同的，例如 John 用户对应 /home/John/，而 root 用户对应 /root/，因此在以 root 用户登陆时，一定要注意环境变量文件的路径。</p>
<h2 id="解决方法二"><a href="#解决方法二" class="headerlink" title="解决方法二"></a>解决方法二</h2><p>若命令行下打开文件乱码，可考虑新建用户并登录，然后以 root 权限修改之前用户的配置文件，关于如何新建用户此处不再赘述。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[利用github-pages建立个人博客]]></title>
      <url>http://www.ezlippi.com/blog/2015/03/github-pages-blog.html</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。<br><a id="more"></a><br>Github Pages有以下几个优点：</p>
<ul>
<li>轻量级的博客系统，没有麻烦的配置</li>
<li>使用标记语言，比如Markdown 无需自己搭建服务器</li>
<li>根据Github的限制，对应的每个站有300MB空间</li>
<li><p>可以绑定自己的域名</p>
<!-- more -->
<p>当然他也有缺点：</p>
</li>
<li><p>使用Jekyll模板系统，相当于静态页发布，适合博客，文档介绍等。</p>
</li>
<li>动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。</li>
<li>基于Git，很多东西需要动手，不像Wordpress有强大的后台</li>
</ul>
<p>大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。</p>
<h2 id="购买、绑定独立域名"><a href="#购买、绑定独立域名" class="headerlink" title="购买、绑定独立域名"></a>购买、绑定独立域名</h2><p>虽说Godaddy曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。</p>
<p>域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。</p>
<p>流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在BeiYuu也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。</p>
<p>我们选择DNSPod的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）：</p>
<p>首先添加域名记录，可参考DNSPod的帮助文档：<a href="https://www.dnspod.cn/Support" target="_blank" rel="external">https://www.dnspod.cn/Support</a><br>在DNSPod自己的域名下添加一条A记录，地址就是Github Pages的服务IP地址：<code>192.30.252.153</code><br>在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址： <code>f1g1ns1.dnspod.net、f1g1ns2.dnspod.net</code>。</p>
<h2 id="配置和使用Github"><a href="#配置和使用Github" class="headerlink" title="配置和使用Github"></a>配置和使用Github</h2><p>git是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本<a href="http://git-scm.com/book/zh" target="_blank" rel="external">Git中文教程</a>。</p>
<p>要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。下载地址在这里：<a href="http://code.google.com/p/msysgit/downloads/list" target="_blank" rel="external">http://code.google.com/p/msysgit/downloads/lis
</a>。其他系统的安装也可以参考官方的安装教程。</p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<pre><code>$ git config --global user.name &quot;Your Name&quot;
$ git config --global user.email &quot;email@example.com&quot;
</code></pre><h3 id="检查SSH-keys的设置"><a href="#检查SSH-keys的设置" class="headerlink" title="检查SSH keys的设置"></a>检查SSH keys的设置</h3><p>首先我们需要检查你电脑上现有的ssh key：</p>
<pre><code>$ cd ~/.ssh
</code></pre><p>如果显示“No such file or directory”，跳到第三步，否则继续。</p>
<h3 id="备份和移除原来的ssh-key设置"><a href="#备份和移除原来的ssh-key设置" class="headerlink" title="备份和移除原来的ssh key设置"></a>备份和移除原来的ssh key设置</h3><p>因为已经存在key文件，所以需要备份旧的数据并删除：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br><span class="line">config  id_rsa  id_rsa.pub  known_hosts</span><br><span class="line">mkdir key_backup</span><br><span class="line">cp id_rsa* key_backup</span><br><span class="line">rm id_rsa*</span><br></pre></td></tr></table></figure>
<h3 id="生成新的SSH-Key"><a href="#生成新的SSH-Key" class="headerlink" title="生成新的SSH Key"></a>生成新的SSH Key</h3><p>输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">"邮件地址@youremail.com"</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/	your_user_directory/.ssh/id_rsa):&lt;回车就好&gt;</span><br></pre></td></tr></table></figure>
<p>然后系统会要你输入加密串（Passphrase）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):&lt;输入加密串&gt;</span><br><span class="line">Enter same passphrase again:&lt;再次输入加密串&gt;</span><br></pre></td></tr></table></figure>
<p>最后看到ssh key success，就成功设置ssh key了. </p>
<h3 id="添加SSH-Key到GitHub"><a href="#添加SSH-Key到GitHub" class="headerlink" title="添加SSH Key到GitHub"></a>添加SSH Key到GitHub</h3><p>在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。</p>
<p>用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。</p>
<p>在GitHub的主页上点击设置按钮： github account setting</p>
<p>选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可：<br><img src="/images/images/githubpages/bootcamp_1_ssh.jpg" alt="set ssh keys"></p>
<p>PS：如果需要配置多个GitHub账号，可以参看这个<a href="http://ju.outofmemory.cn/entry/16775" target="_blank" rel="external">多个github帐号的SSH key切换</a>，不过需要提醒一下的是，如果你只是通过这篇文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令<code>git config --global --unset user.email</code>删除用户账户设置，在每一个repo下面使用<code>git config --local user.email &#39;你的github邮箱@mail.com&#39;</code>命令单独设置用户账户信息</p>
<h3 id="测试一下"><a href="#测试一下" class="headerlink" title="测试一下"></a>测试一下</h3><p>可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改：</p>
<pre><code>$ ssh -T git@github.com
</code></pre><p>如果是下面的反应：</p>
<pre><code>The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)?
</code></pre><p>不要紧张，输入yes就好，然后会看到：</p>
<pre><code>Hi &lt;em&gt;username&lt;/em&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access.
</code></pre><h3 id="设置你的账号信息"><a href="#设置你的账号信息" class="headerlink" title="设置你的账号信息"></a>设置你的账号信息</h3><p>现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。</p>
<p>Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">"你的名字"</span></span><br><span class="line">$ git config --global user.email <span class="string">"your_email@youremail.com"</span></span><br></pre></td></tr></table></figure>
<p>好了，你已经可以成功连接GitHub了。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="帐号注册"><a href="#帐号注册" class="headerlink" title="帐号注册"></a>帐号注册</h3><p>在创建博客之前，当然必须有GitHub的帐号，该帐号将用来创建项目，默认的域名<code>username.github.com/projectName</code>中的username也要用到这个帐号。<br>注意：下面涉及到的一些命令凡是更用户名和项目名有关的一律会用这里的username和projectName代替，注意替换<br>访问：<a href="http://www.github.com/" target="_blank" rel="external">http://www.github.com/ </a>sign up for free的意思就是“免费注册登录”，注册你的username和邮箱，邮箱十分重要，GitHub上很多通知都是通过邮箱的。比如你的主页上传并构建成功会通过邮箱通知，更重要的是，如果构建失败的话也会在邮件中说明原因。</p>
<h3 id="创建项目仓库"><a href="#创建项目仓库" class="headerlink" title="创建项目仓库"></a>创建项目仓库</h3><p>在创建博客之前，还需要用已有的帐号创建一个项目，上面那个链接的projectName将是这里即将创建的项目名称。在Git中，项目被称为仓库(Repository)，仓库顾名思义，当然可以包含代码或者非代码。将来我们的网页或者模板实际上都是保存在这个仓库中的。</p>
<p>登录后，访问<a href="https://github.com/new" target="_blank" rel="external">https://github.com/new</a>，创建仓库如下图：<br><img src="/images/images/githubpages/build-github-blog-page-02-img0.png" alt="image1"></p>
<p>创建了仓库后，我们就需要管理它，无论是管理本地仓库还是远程仓库都需要Git客户端。Git客户端实际上十分强大，它本身就可以offline的创建本地仓库，而本地仓库和远程仓库之间的同步也是通过Git客户端完成的。</p>
<p>这里省略了windows下安装和使用Git客户端的基本技巧，您应该已经掌握此技能了。虽然，您仍然可以按照本教程的指引完成一个简单的网站，但是后期的维护工作无论如何都不能少了这项技能。</p>
<p>下面的步骤假设您已经安装好了Git客户端，安装和使用技巧请参见：Git学习资源</p>
<h3 id="本地编辑及上传"><a href="#本地编辑及上传" class="headerlink" title="本地编辑及上传"></a>本地编辑及上传</h3><p>在磁盘上创建一个目录，该目录与上面的项目名同名，在该目录下启用Git Bash命令行，并输入如下命令</p>
<pre><code>$git init
</code></pre><p>该命令实际上是在该目录下初始化一个本地的仓库，会在目录下新建一个.git的隐藏文件夹，可以看成是一个仓库数据库。</p>
<p>创建一个没有父节点的分支gh-pages，并自动切换到这个分支上。</p>
<pre><code>$git checkout --orphan gh-pages
</code></pre><p>在Git中，分支(branch)的概念非常重要，Git之所以强大，很大程度上就是因为它强大的分支体系。这里的分支名字必须是gh-pages，因为github规定，只有该分支中的页面，才会生成网页文件。</p>
<p>在该目录下手动创建如下文件和文件夹，最终形成这样的结构：</p>
<p><img src="/images/images/githubpages/build-github-blog-page-02-img1.png" alt=""></p>
<ul>
<li>_includes：默认的在模板中可以引用的文件的位置，后面会提到</li>
<li>_layouts：默认的公共页面的位置，后面会提到</li>
<li>_posts：博客文章默认的存放位置</li>
<li>.gitignore：git将忽略这个文件中列出的匹配的文件或文件夹，不将这些纳入源码管理</li>
<li>_config.yml：关于jekyll模板引擎的配置文件</li>
<li>index.html：默认的主页</li>
</ul>
<p>在_layouts目录下创建一个default.html，在其中输入如下内容，注意：文件本身要以UTF-8 without BOM的格式保存，以防止各种编码问题，建议使用notepad++或者VIM编辑</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
　&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
　&lt;title&gt;一步步在GitHub上创建博客主页(2)&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
　
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>编辑index.html</p>
<pre><code>---
layout: default
title: test title
---
&lt;p&gt;Hello world!&lt;/p&gt;
</code></pre><p>再次打开Git Bash，先后输入如下命令：</p>
<pre><code>$ git add .
$ git commit -m &quot;first post&quot;
$ git remote add origin https://github.com/username/projectName.git
$ git push origin gh-pages
</code></pre><p>据网友反应，如果是初次安装git的话，在commit的时候会提示需要配置username和email，请读者注意根据提示配置一下，至于username和email可以随便填</p>
<ul>
<li>将当前的改动暂存在本地仓库</li>
<li>将暂存的改动提交到本地仓库，并写入本次提交的注释是”first post“</li>
<li>将远程仓库在本地添加一个引用：origin</li>
<li>向origin推送gh-pages分支，该命令将会将本地分支gh-pages推送到github的远程仓库，并在远程仓库创建一个同名的分支。该命令后会提示输入用户名和密码。</li>
</ul>
<p>现在，你只需要稍等半分钟时间，访问<code>http://username.github.com/projectName</code>就可以看到生成的博客了</p>
<p>另外上面提到的，如果生成失败，Github会向你的邮箱发送一封邮件说明，请注意查收。</p>
<h2 id="域名扫盲"><a href="#域名扫盲" class="headerlink" title="域名扫盲"></a>域名扫盲</h2><p>说实话，虽然明白什么是域名以及域名解析的原理，但是在实际的互联网环境中，域名的问题其实比理论上说的要复杂些。这里对一些概念稍作整理。</p>
<h3 id="A（Address）记录"><a href="#A（Address）记录" class="headerlink" title="A（Address）记录"></a>A（Address）记录</h3><p>是用来指定主机名（或域名）对应的IP地址记录。用户可以将该域名下的网站服务器指向到自己的web server上。同时也可以设置您域名的二级域名。</p>
<h3 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h3><p>也被称为规范名字。这种记录允许您将多个名字映射到同一台计算机。 通常用于同时提供WWW和MAIL服务的计算机。例如，有一台计算机名为<code>“host.mydomain.com”</code>（A记录）。 它同时提供WWW和MAIL服务，为了便于用户访问服务。可以为该计算机设置两个别名（CNAME）：WWW和MAIL。 这两个别名的全称就是<code>“www.mydomain.com”</code>和<code>“mail.mydomain.com”</code>。实际上他们都指向<code>“host.mydomain.com”</code>。 同样的方法可以用于当您拥有多个域名需要指向同一服务器IP，此时您就可以将一个域名做A记录指向服务器IP然后将其他的域名做别名到之前做A记录的域名上，那么当您的服务器IP地址变更时您就可以不必麻烦的一个一个域名更改指向了 只需要更改做A记录的那个域名其他做别名的那些域名的指向也将自动更改到新的IP地址上了。</p>
<h3 id="TTL"><a href="#TTL" class="headerlink" title="TTL"></a>TTL</h3><p>TTL值全称是“生存时间（Time To Live)”，简单的说它表示DNS记录在DNS服务器上缓存时间。要理解TTL值，请先看下面的一个例子：<br>假设，有这样一个域名<code>myhost.cnMonkey.com</code>（其实，这就是一条DNS记录，通常表示在abc.com域中有一台名为myhost的主机）对应IP地 址为1.1.1.1，它的TTL为10分钟。这个域名或称这条记录存储在一台名为dns.cnMonkey.com的DNS服务器上。<br>现在有一个用户键入一下地址（又称URL）：<code>http://myhost.cnMonkey.com</code> 这时会发生什么呢？<br>该 访问者指定的DNS服务器（或是他的ISP,互联网服务商, 动态分配给他的)8.8.8.8就会试图为他解释myhost.cnMonkey.com，当然8.8.8.8这台DNS服务器由于没有包含 myhost.cnMonkey.com这条信息，因此无法立即解析，但是通过全球DNS的递归查询后，最终定位到dns.cnMonkey.com这台DNS服务器， dns.cnMonkey.com这台DNS服务器将myhost.cnMonkey.com对应的IP地址1.1.1.1告诉8.8.8.8这台DNS服务器，然有再由 8.8.8.8告诉用户结果。8.8.8.8为了以后加快对myhost.cnMonkey.com这条记录的解析，就将刚才的1.1.1.1结果保留一段时间，这 就是TTL时间，在这段时间内如果用户又有对myhost.cnMonkey.com这条记录的解析请求，它就直接告诉用户1.1.1.1，当TTL到期则又会重复 上面的过程。</p>
<h3 id="域名分级"><a href="#域名分级" class="headerlink" title="域名分级"></a>域名分级</h3><p>子域名是个相对的概念，是相对父域名来说的。域名有很多级，中间用点分开。例如中国国家顶级域名CN，所有以 CN 结尾的域名便都是它的子域。例如：www.zzy.cn 便是 zzy.cn 的子域，而 zzy.cn 是 cn 的子域。</p>
<p>“二级域名”：目前有很多用户认为“二级域名”是自己所注册域名的下一级域名，实际上这里所谓的“二级域名”并非真正的“二级”，而应该称为“次级”(相对次级)</p>
<p>例如您注册的域名是abc.cn来说：CN为顶级域，abc.cn为二级域，www.abc.cn、mail.abc.cn、help.zzy.cn为三级域。</p>
<p>还有一些特殊的二级域被用来作顶级域使用，例如：com.cn、net.cn、org.cn、gov.cn（包括地区域名bj.cn、fj.cn等）。那么此时用户所注册的就应该是三级域了，例如114.com.cn。（备注：www.gov.cn实际上是以gov.cn为后缀的www域名，就是说如果您在域名Whois信息查询中输入gov.cn是查询不到注册信息的因为gov.cn是作为顶级域来使用的域名后缀，真正开放注册的是www.gov.cn）。然而当前有很多用户还是习惯地将可以允许用户注册的域名称为顶级域名，而所注册域名的下一级域名称为“二级域名”，其实从严格意义上来讲这是不对的，所以我们前面会说“子域名”、“二级域名”是相对的概念，准确的应该称为“次级域名”。</p>
<h3 id="域名购买"><a href="#域名购买" class="headerlink" title="域名购买"></a>域名购买</h3><p>众所周知，域名是要购买的，国内用域名访问主机大概是要备案的，有些麻烦。所以现在很多人从国外的域名注册商那儿买域名，比如goddady。如果是新手想在国外买域名的话，最好准备一张VISA信用卡，并用paypal来支付（可以省手续费）。goddady现在也支持支付宝，支付起来也很方便。</p>
<h3 id="绑定域名到GitHub-Page"><a href="#绑定域名到GitHub-Page" class="headerlink" title="绑定域名到GitHub-Page"></a>绑定域名到GitHub-Page</h3><p>其实十分简单，假设我们购买了域名<a href="coolshell.info">coolshell.info</a>，想用coolshell.info访问你的站点<code>http://username.github.com/projectname</code>，你可以参考这个链接：<a href="https://help.github.com/articles/setting-up-a-custom-domain-with-github-pages/" target="_blank" rel="external">Setting up a custom domain with Pages</a></p>
<p>在你的域名提供商那边，设置一条A记录：</p>
<p>colshell.info  204.232.175.78（注意：这个IP难保不会变，所以要及时关注上面这个链接中给出的IP，并及时更新A记录）。下面这个截图是goddady上的A记录配置：</p>
<p><img src="/images/images/githubpages/build-github-blog-page-03-img0.png" alt=""></p>
<p>然后在你的gh-pages分支的根目录中创建一个CNAME文件，其中只能有一行，就是coolshell.info，用Git客户端上传更改，大约等十几分钟就能生效了。</p>
<p>可以先ping一下coolshell.info，如果返回的IP地址更配置的A记录一样的话，说明域名已经注册好了，就等GitHub生效了。不过别急，你还需要把_config.yml中的baseurl设置如下</p>
<pre><code>baseurl : /
</code></pre><p>或者是</p>
<pre><code>baseurl :
</code></pre><p>这取决于你的模板如何引用baseurl，总之指向根目录就好了。</p>
<p>刚开始的时候我比较困惑的是，为什么A记录都指向的是同一个IP，GitHub是如何知道应该返回哪个用户的页面的。其实很简单，秘密就是上面提到的CNAME文件，GitHub应该会缓存所有gh-pages分支中的CNAME文件，用户对域名的请求被定向到GitHub住服务器的IP地址后，再根据用户请求的域名，判断对应哪个gh-pages，而且它会自动带上项目名，所以baseurl需要改为根目录。</p>
<h2 id="jekyll的安装"><a href="#jekyll的安装" class="headerlink" title="jekyll的安装"></a>jekyll的安装</h2><p>前几篇介绍了GitHub-Page的基本原理和使用方法，还介绍了如何将购买的域名绑定博客主页。然而，当需要正儿八经的将一个博客构建起来，不仅要知道如何上传我们的文件，还要能够高效的更好的设计博客。因此，必须能够在上传之前在本地完成测试；另一方面，完全靠html来编辑博客，显然工作量太大，随着博客越来越复杂，简直不可能维护，因此，需要用jekyll这个模板引擎来帮忙。本篇先介绍如何搭建一个本地的测试环境。</p>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><ol>
<li>根据网友的反应，需要注意的是Ruby的版本和RubyDevKit的版本要对应，不要装错；</li>
<li>另外，目前新版的Ruby自带gem了，所以gem安装可以跳过；</li>
<li>由于国内的网络（你们懂的），gem官方的源基本上是没法用了，参考文中的链接，使用淘宝的镜像比较靠谱；</li>
<li><p>jekyll有一个问题，可能需要修改下面这个文件，否则会出现GBK错误<br><code>D:\Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-1.2.1\lib\jekyll\convertible.rb</code><br>将它改成<br><code>self.content = File.read(File.join(base, name),:encoding =&gt; &quot;utf-8&quot;)</code><br><code>D:\Ruby193\lib\ruby\gems\1.9.1\gems\jekyll-1.2.1\lib\jekyll\tags\include.rb</code>中的最后几行的地方改成<br><code>File.read_with_options(file,:encoding =&gt; &quot;utf-8&quot;)</code></p>
</li>
<li><p>最新的jekyll修改了命令行参数，需使用如下命令行 <code>jekyll serve --safe --watch</code></p>
</li>
<li>jekyll 1.4.3在windows下本地生成的时候可能会出现<code>&#39;fileutils.rb:247:in mkdir Invalid argument&#39;</code>的错误</li>
<li>jekyll 1.4.3在–watch参数的情况下可能会出现<code>&#39;cannot load such file -- wdm (LoadError)&#39;</code>的错误，用gem安装wdm就好了：     gem install wdm</li>
</ol>
<h3 id="Ruby安装"><a href="#Ruby安装" class="headerlink" title="Ruby安装"></a>Ruby安装</h3><p>jekyll本身基于Ruby开发，因此，想要在本地构建一个测试环境需要具有Ruby的开发和运行环境。在windows下，可以使用Rubyinstaller安装</p>
<p>ruby安装说明：<a href="http://www.ruby-lang.org/zh_cn/downloads/" target="_blank" rel="external">http://www.ruby-lang.org/zh_cn/downloads/</a></p>
<p>ruby安装下载(windows)：<a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external">http://rubyinstaller.org/downloads/</a><br>windows的安装还是一如既往的“无脑”，不多说了。</p>
<p>如果想要快速体验ruby开发，可以参考：<a href="https://www.ruby-lang.org/zh_cn/documentation/quickstart/" target="_blank" rel="external">20分钟体验 Ruby</a></p>
<h3 id="RubyDevKit安装"><a href="#RubyDevKit安装" class="headerlink" title="RubyDevKit安装"></a>RubyDevKit安装</h3><p>从这个页面下载DevKit：<a href="http://rubyinstaller.org/downloads/" target="_blank" rel="external">http://rubyinstaller.org/downloads/</a></p>
<p>下载下来的是一个很有意思的sfx文件，如果你安装有7-zip吧，可以直接双击，它会自解压到你所选择的目录。</p>
<p>解压完成之后，用cmd进入到刚才解压的目录下，运行下面命令，该命令会生成config.yml。（这种安装方式让我想起了，linux下安装三步走<code>config-&gt;make-&gt;make install中的config</code>）</p>
<pre><code>$ruby dk.rb init
</code></pre><p>config.yml文件实际上是检测系统安装的ruby的位置并记录在这个文件中，以便稍后使用。但上面的命令只针对使用rubyinstall安装的ruby有效，如果是其他方式安装的话，需要手动修改config.yml。我生成的config.yml文件内容如下：（注意路径用的是linux的斜杠方向）</p>
<pre><code># This configuration file contains the absolute path locations of all
# installed Rubies to be enhanced to work with the DevKit. This config
# file is generated by the &apos;ruby dk.rb init&apos; step and may be modified
# before running the &apos;ruby dk.rb install&apos; step. To include any installed
# Rubies that were not automagically discovered, simply add a line below
# the triple hyphens with the absolute path to the Ruby root directory.
#
# Example:
#
# ---
# - C:/ruby19trunk
# - C:/ruby192dev
#
---
- C:/Ruby193
</code></pre><p>最后，执行如下命令，执行安装：</p>
<pre><code>$ruby setup.rb
</code></pre><p>如果没有setup.rb的话，执行：</p>
<pre><code>$ruby dk.rb install
</code></pre><h3 id="Rubygems"><a href="#Rubygems" class="headerlink" title="Rubygems"></a>Rubygems</h3><p>Rubygems是类似Radhat的RPM、centOS的Yum、Ubuntu的apt-get的应用程序打包部署解决方案。Rubygems本身基于Ruby开发，在Ruby命令行中执行。我们需要它主要是因为jekyll的执行需要依赖很多Ruby应用程序，如果一个个手动安装比较繁琐。jekyll作为一个Ruby的应用，也实现了Rubygems打包标准。只要通过简单的命令就可以自动下载其依赖。</p>
<p>gems下载地址：<a href="http://rubyforge.org/frs/?group_id=126" target="_blank" rel="external">http://rubyforge.org/frs/?group_id=126</a></p>
<p>解压后，用cmd进入到解压后的目录，执行命令即可：</p>
<pre><code>$ruby setup.rb
</code></pre><p>就像yum仓库一样，仓库本身有很多，如果希望加快应用程序的下载速度，特别绕过“天朝”的网络管理制度，可以选择国内的仓库镜像，taobao有一个：<a href="http://ruby.taobao.org/" target="_blank" rel="external">http://ruby.taobao.org/</a>。配置方法这个链接里面很完全。</p>
<h3 id="安装jekyll"><a href="#安装jekyll" class="headerlink" title="安装jekyll"></a>安装jekyll</h3><p>有了上面的基础，安装jekyll就十分轻松了，在此之前，建议国内用户换成淘宝服务器，速度更快：</p>
<pre><code>$ sudo gem sources --remove http://rubygems.org/
$ sudo gem sources -a http://ruby.taobao.org/
</code></pre><p>执行下面gem命令即可全自动搞定：</p>
<pre><code>$gem install jekyll
</code></pre><p>jekyll依赖的组件如下：</p>
<pre><code class="bash">- directory_watcher
- liquid
- open4
- maruku
- classifier
</code></pre>
<p>测试jekyll服务</p>
<p>安装好之后就可以测试我们的环境了。用cmd进入到上一节我们创建的目录，执行下面命令：</p>
<pre><code>$jekyll --server --safe
</code></pre><p>jekyll此时会在localhost的4000端口监听http请求，用浏览器访问<a href="http://localhost:4000/index.html" target="_blank" rel="external">http://localhost:4000/index.html</a>，之前的页面出现了！</p>
<p><strong>更新</strong><br>jekyll最新的动态和文档现在可以在<a href="http://jekyllrb.com/" target="_blank" rel="external">jekyllrb</a>上找到</p>
<h2 id="jekyll介绍"><a href="#jekyll介绍" class="headerlink" title="jekyll介绍"></a>jekyll介绍</h2><p>在前几篇中，多多少少对jekyll有所涉及，在这篇中将带读者进一步了解jekyll以及模板引擎liquid。</p>
<p>jekyll是一个基于ruby开发的，专用于构建静态网站的程序。它能够将一些动态的组件：模板、liquid代码等构建成静态的页面集合，Github-Page全面引入jekyll作为其构建引擎，这也是学习jekyll的主要动力。同时，除了jekyll引擎本身，它还提供一整套功能，比如web server。我们用jekyll –server启动本地调试就是此项功能。读者可能已经发现，在启动server后，之前我们的项目目录下会多出一个_site目录。jekyll默认将转化的静态页面保存在_site目录下，并以某种方式组织。使用jekyll构建博客是十分适合的，因为其内建的对象就是专门为blog而生的，在后面的逐步介绍中读者会体会到这一点。但是需要强调的是，jekyll并不是博客软件，跟workpress之类的完全两码事，它仅仅是个一次性的模板解析引擎，它不能像动态服务端脚本那样处理请求。</p>
<p>更多关于jekyll请看<a href="https://github.com/jekyll/jekyll/wiki/Liquid-Extensions" target="_blank" rel="external">这里</a></p>
<h3 id="jekyll是如何工作的"><a href="#jekyll是如何工作的" class="headerlink" title="jekyll是如何工作的"></a>jekyll是如何工作的</h3><p>在jekyll解析你的网站结构前，需要确保网站目录像下面那样：</p>
<pre><code>|-- _config.yml
|-- _includes
|-- _layouts
|   |-- default.html
|   |-- post.html
|-- _posts
|   |-- 20011-10-25-open-source-is-good.html
|   |-- 20011-04-26-hello-world.html
|-- _site
|-- index.html
|-- images
   |-- css
       |-- style.css
   |-- javascripts
</code></pre><ul>
<li><p>_config.yml：保存配置，该配置将影响jekyll构造网站的各种行为。</p>
</li>
<li><p>_includes：该目录下的文件可以用来作为公共的内容被其他文章引用，就跟C语言include头文件的机制完全一样，jekyll在解析时会对<code>{ % include file.ext %}</code>标记扩展成对应的在_includes文件夹中的文件</p>
</li>
<li><p>_layouts：该目录下的文件作为主要的模板文件</p>
</li>
<li><p>_posts：文章或网页应当放在这个目录中，但需要注意的是，文章的文件名必须是YYYY-MM-DD-title</p>
</li>
<li><p>_site：上面提到过，这是jekyll默认的转化结果存放的目录</p>
</li>
<li><p>images：这个目录没有强制的要求，主要目的是存放你的资源文件，图片、样式表、脚本等。</p>
</li>
</ul>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>完成一个例子总是最快的入门方式。</p>
<p>对于基于静态页面的网站，你显然不希望每篇文章都要写html、head等与文章本身无关的重复的东西，那么容易想到的是将这些东西作为模板提取出来，以便复用，_layouts文件夹中的文件可以作为这样的模板。现在我们在_layouts文件夹中创建一个模板文件，default.html：</p>
<pre><code>&lt;html&gt;
   &lt;head&gt;
       &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
       &lt;title&gt;My blog&lt;/title&gt;
   &lt;/head&gt;
   &lt;body&gt;

   &lt;/body&gt;
&lt;html&gt;
</code></pre><p>default.html包含了每个html都需要的一些标记，以及一个个liquid标记。<code>{ { … }}</code>是liquid中用来表示“内容”的标记，其中的对象在解析时会被替换成文件到页面中</p>
<p>content：表示在这里的地方用子页面的内容替换。</p>
<p>现在我们来实现一个主页，在根目录下，创建一个index.html</p>
<pre><code>---
layout: default
---
&lt;h1&gt;Hello jekyll&lt;/h1&gt;
&lt;p&gt;This is the index page&lt;/p&gt;
</code></pre><p>除了普通的html标记外，开头这一段称为YAML格式，以一行“—”开头，一行“—”结尾，在虚线的中间以key-value的形式对一些全局变量进行赋值。</p>
<p>layout变量表示该文章应当使用_layouts/default这个文件作为父模板，并将index.html中的内容替换父模板中的<code>{ { content }}</code>标记。</p>
<p>在根目录中启动jekyll –server，并访问<a href="http://localhost:4000/index.html，你将得到下面页面" target="_blank" rel="external">http://localhost:4000/index.html，你将得到下面页面</a></p>
<p><img src="/images/images/githubpages/build-github-blog-page-05-img0.png" alt=""></p>
<p>该页面的Html源码如下，可以看到，index.html中的内容替换了default.html中的content`</p>
<pre><code>&lt;html&gt;
  &lt;head&gt;
      &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;
      &lt;title&gt;My blog&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
  &lt;h1&gt;Hello jekyll&lt;/h1&gt;
&lt;p&gt;This is the index page&lt;/p&gt;
  &lt;/body&gt;
&lt;html&gt;
</code></pre><p>现在请观察一下_site中的index.html，就是上面的Html代码！OK，现在你明白jekyll的工作方式了吧，它仅仅一次性的完成静态页面的转化，其余的事情全都交给普通的web server了！</p>
<p>需要注意的是，如果你失败了，请确保你的文件都是UTF-8 without BOM的格式。</p>
<p>在windows中，为了甄别UTF-8编码格式的文本文件，默认会在文件头插入两个字节的标识，被称为BOM。事实证明这是个“歪门邪道”，jekyll不识别这种特殊的标记，所以可以使用Notepad++或其他的工具将UTF-8编码文件开头的BOM去掉。</p>
<h3 id="第一篇文章"><a href="#第一篇文章" class="headerlink" title="第一篇文章"></a>第一篇文章</h3><p>现在我们来创建一篇博客文章，并在index.html页面添加文章的链接。</p>
<p>在 _posts目录下创建2014-06-21-first-post.html</p>
<pre><code>---
layout: default
title: my first post
---
&lt;h1&gt;{{ page.title }}&lt;/h1&gt;
&lt;p&gt;This is my first post.Click the link below to go back to index:&lt;/p&gt;
&lt;a href=&quot;{{ site.baseurl }}/index.html&quot;&gt;Go back&lt;/a&gt;
</code></pre><p>修改index.html</p>
<pre><code>---
layout: default
---
&lt;h1&gt;Hello jekyll&lt;/h1&gt;
&lt;p&gt;This is the index page&lt;/p&gt;
&lt;p&gt;My post list:&lt;/p&gt;
</code></pre><p>最终效果如下：</p>
<p><img src="/images/images/githubpages/build-github-blog-page-05-img1.png" alt=""></p>
<p>这个是略微复杂的例子，这里涉及到两个主要的对象</p>
<ol>
<li>site：全局站点对象。比如site.posts返回当前站点所有在_post目录下的文章，上面的例子结合for循环来罗列所有的文章</li>
<li>page：文章对象。比如page.url将返回page对象的url，上面的例子用该对象和属性返回了文章的链接<br>另外要补充的是site.baseurl，该值就是我们在_config.yml中配置的baseurl啦！</li>
</ol>
<p>这些对象被称为“模板数据API”，更多API文档请参见<a href="http://jekyllbootstrap.com/api/template-data-api.html" target="_blank" rel="external">这里</a></p>
<h3 id="liquid"><a href="#liquid" class="headerlink" title="liquid"></a>liquid</h3><p>liquid是jekyll底层用于解析的引擎，我们用到的<code>{ { .. }}</code>亦或是<code>{ % … %}</code>标记其实是靠liquid去解析的。本节将详细介绍liquid的使用。</p>
<p>liquid包含两种标记，理解他们的机理是十分重要的：</p>
<p><code>{ { .. }}</code>：输入标记，其中的内容将被文本输出<br><code>{ % … %}</code>：操作标记，通常包含控制流代码</p>
<p>另外liquid还包含一种叫filter的机制。这是种对输出标记的扩展，通过它可以对输出标记中的内容进行更细致的处理，例如：</p>
<p>返回字符串大写的结果：TOBI<br>返回字符串的长度：4<br>将当前时间格式化输出<br>liquid内置了一些filter，并且该机制可以被扩展，jekyll便扩展了liquid的filter。</p>
<p>更多关于liquid的使用方法，请参见<a href="https://github.com/Shopify/liquid/wiki/Liquid-for-Designers" target="_blank" rel="external">这里</a></p>
<p>更多关于jekyll对liquid的扩展，请参见<a href="https://github.com/Shopify/liquid/wiki/Liquid-for-Designers" target="_blank" rel="external">这里</a></p>
<h2 id="样式、分类、标签"><a href="#样式、分类、标签" class="headerlink" title="样式、分类、标签"></a>样式、分类、标签</h2><p>在前一篇中我们实际使用jekyll做了一个略微“复杂”的模板。并用它生成了站点。但是这样的blog显然太粗糙了，别说不能吸引别人了，自己都看不下去啊。作为自己的“门户”，当然要把美化工作放在第一位啦。</p>
<p>网站的美观十分重要，这当然要依靠CSS咯。因为完全基于静态页面，所以没有现成的动态模板可以使用，我们只能手写CSS了，这里不介绍CSS了，因为这是设计师的范畴了，屌丝程序员搞不来了。我的blog的样式是从网上找过来改的。</p>
<p>从功能的角度blog除了文章以外，对文章的分类、标签、归档都是主流的功能。</p>
<p>分类和标签功能是jekyll的yaml-format的内置功能，在每篇文章上方可以设置：这里需要注意的是如果多个分类或者tag的话，用逗号分隔，并且要紧跟一个空格。分类可以任意添加，Jekyll在解析网站的时候会统计所有的分类，并放到site.categories中；换句话说，不能脱离文章而设置分类。</p>
<pre><code>---
layout: default
title: Title
description: 这里的description是自定义属性。
categories: [web-build]
tags: [github-page, jekyll, liquid]
---
</code></pre><p>下面是本站罗列分类的代码，供大家参考</p>
<pre><code>&lt;div id=&quot;categories-3&quot; class=&quot;left&quot;&gt;
     &lt;h3&gt;Categories&lt;/h3&gt;
     &lt;ul&gt;
         {% for cat in site.categories %}
             <li class="cat-item cat-item-6">
             	<a href="{{ site.baseurl }}/categories/{{ cat[0] }}.html">{{ cat[0] }}</a></li>
             {% endfor %}
     &lt;/ul&gt;
 &lt;/div&gt;
</code></pre><p>注意到分类的url链接，这里的categories目录以及其中的html不会自动生成，需要手动添加的，也就是说每增加一个分类，都需要在categories下添加一个该分类的html。当然你可以选择其他目录，甚至考虑其他解决方案，不过我还没想到更简单的方法。Tag的处理方式类似，这里就省略了。</p>
<p>推荐大家下载jekyll原作者推荐的简单例子来学习：</p>
<pre><code>$git clone https://github.com/plusjade/jekyll-bootstrap.git
</code></pre><p>下载的目录里面是一个完整的网站，可以使用我们本地的jekyll –server启动。另外，作者的网站：<a href="http://jekyllbootstrap.com/" target="_blank" rel="external">http://jekyllbootstrap.com/
</a></p>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><h3 id="安装Python-Pygments"><a href="#安装Python-Pygments" class="headerlink" title="安装Python Pygments"></a>安装Python Pygments</h3><p>Ubtuntu下：sudo apt-get install python-pygments</p>
<h3 id="设置代码高亮的样式"><a href="#设置代码高亮的样式" class="headerlink" title="设置代码高亮的样式"></a>设置代码高亮的样式</h3><p>通过下面的命令可以查看当前支持的样式<br>    from pygments.styles import STYLE_MAP<br>    STYLE_MAP.keys()<br>输出：<br>        [‘monokai’, ‘manni’, ‘rrt’, ‘perldoc’, ‘borland’, ‘colorful’,         ‘default’, ‘murphy’, ‘vs’, ‘trac’, ‘tango’, ‘fruity’, ‘autumn’,     ‘bw’, ‘emacs’, ‘vim’, ‘pastie’, ‘friendly’, ‘native’] </p>
<h3 id="生成指定样式的css文件"><a href="#生成指定样式的css文件" class="headerlink" title="生成指定样式的css文件"></a>生成指定样式的css文件</h3><pre><code>pygmentize -S native -f html &gt; pygments.css
</code></pre><p>将生成的css文件拷贝到主题的css目录下，如：</p>
<pre><code>%github pages project folder%\assets\themes\twitter\css\
</code></pre><p>引入default.html中引入css文件：</p>
<pre><code>// default目录如
    %github pages project folder%\includes\themes\twitter\

// 引入如下代码
    &lt;link href=&apos;/css/pygments.css&apos; rel=&quot;stylesheet&quot; media=&quot;all&quot;&gt;
</code></pre><p>在文章中高亮代码:</p>
<pre><code>public class HelloWorld { 
public static void main(String args[]) { 
    System.out.println(&quot;Hello World!&quot;); 
} 
} 
</code></pre><h3 id="给文章添加目录"><a href="#给文章添加目录" class="headerlink" title="给文章添加目录"></a>给文章添加目录</h3><p>如你所见，我的这个博客里，稍长点的文章，都会生成目录树（Table of Content），并且配合有Bootstrap的<a href="http://www.zfanw.com/blog/twitter-bootstrap-affix-js.html" target="_blank" rel="external">affix</a>、<a href="http://www.zfanw.com/blog/bootstrap-scrollspy.html" target="_blank" rel="external">ScrollSpy</a> 效果。同样地，在Jekyll构建的静态博客上，我一样想生成目录树。<br>Jekyll的Plugins页面中有提到一个插件 <a href="https://github.com/dafi/jekyll-toc-generator" target="_blank" rel="external">jekyll-toc-generator</a>，但其实没有必要使用插件，因为 Jekyll 的 Markdown 渲染器 <a href="http://kramdown.gettalong.org/converter/html.html#toc" target="_blank" rel="external">kramdown</a> 已经具备这个功能。我们只需要启用它即可。</p>
<p><strong>启用 kramdown</strong></p>
<p>打开 _config.yml 文件，确保以下一行存在：<br>    markdown: kramdown</p>
<p><strong>生成 TOC</strong></p>
<p>接下来是在文章中标识 toc 的生成位置：</p>
<pre><code>* 目录
{:toc}
# 陈三
## 陈三的博客
</code></pre><ol>
<li>请注意，<code>* 目录</code>这一行是必需的，它表示目录树列表，至于星号后面写什么请随意</li>
<li>如果要把某标题从目录树中排除，则在该标题的下一行写上 <code>{:.no_toc}</code></li>
<li>目录深度可以通过 config.yml 文件中添加 <code>toc_levels</code> 选项来定制，默认为 <code>1..6</code>，表示标题一至标题六全部渲染</li>
<li>{:toc} 默认生成的目录列表会添加 id 值 <code>markdown-toc</code>，我们可以自定义 id 值，比如 {:toc #chen}，生成的目录列表添加的 id 将会是 chen。</li>
</ol>
<h3 id="评论功能"><a href="#评论功能" class="headerlink" title="评论功能"></a>评论功能</h3><p>静态的网站不可能自己存放评论，于是只能考虑外挂评论了，查了一下比较靠谱和广泛的就是DISQUS了;<br>Disqus是一个社会化的评论解决方案，请允许我使用这个烂透了的词，调用它的接口非常简单，在自己的页面加载他的一段JS代码即可，如果别人注册了Disqus，那么就可以方便的留言，交流，一处登录，处处方便，而且Disqus也提供了一些spam等策略，不用自己操心了，并且可以和一些现有的博客系统很好的转换对接。越来越多的网站开始使用Disqus的服务了，这是一个非常不错的趋势，Jekyll配合<a href="http://disqus.com" title="Disqus" target="_blank" rel="external">Disqus</a>实在是完美了。我别无所求了。</p>
<p>点击<img src="/images/images/githubpages/build-github-blog-page-06-img0.png" alt="">，在下面的页面中填写相关的信息，注意先在右侧注册登录信息，然后再在左侧增加一个站点：</p>
<p><img src="/images/images/githubpages/build-github-blog-page-06-img1.png" alt=""></p>
<p>填写完成后点击“Continue”，在接下来的页面中选择Universal Code，然后根据提示完成接下来的操作，后面的操作就十分简单了：主要就是把产生的脚本文件复制到你的站点页面中即可。</p>
<p>DISQUS还有一个Dashboard，可以用来管理评论，这里就不再详述了。最后的效果就是本blog文章下方的评论咯，还是挺好看的，国内的还有个多说的评论引擎，支持国内的各大网站帐号。</p>
<h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>blog当然不能缺少站内搜索功能。主流的站内搜索都是主流的搜索引擎提供的。作为一个google控，当然必须选择google啊。当然你必须拥有一个google帐号。</p>
<p>google的站内搜索叫：custome search engine：<a href="http://www.google.com/cse" target="_blank" rel="external">http://www.google.com/cse</a></p>
<p>创建一个自定义搜索与添加评论类似只要三步：</p>
<ol>
<li>填写自定义搜索的名字、描述、语言、站点信息，这些信息中唯一需要注意的是站点信息，建议使用mydomain.com作为搜索范围，因为这样的话，会自动转化成<em>.mydomain.com/</em>，能包含全站的内容</li>
<li>选择样式和尝试搜索。尝试搜索有时不能成功，但是不要紧</li>
<li>将生成脚本写到网页中</li>
</ol>
<p>这时，可能搜索功能仍然无法使用，尤其是你的网站没有什么名气，也没有什么外链。因为google的爬虫不可能很快的抓到你的网站。但这里有个技巧可以让你的网站立刻被google收录（姑且不论排名），那就是google的Webmaster Tools工具，该工具是免费的，而且还集成了站点流量统计功能，十分强大。</p>
<p>进入地址：<a href="https://www.google.com/webmasters/tools/home" target="_blank" rel="external">https://www.google.com/webmasters/tools/home</a></p>
<p><img src="/images/images/githubpages/build-github-blog-page-06-img5.png" alt=""><br>它会要你认证你对网站的所有权，下载一个HTML文件，把它上传到你的网站上，<br>设置完成之后基本上立刻就生效了，无需等待一天。</p>
<p>认证成功后，进入<a href="http://www.xml-sitemaps.com/" target="_blank" rel="external">sitemaps网站</a>,在下面填入你的网站后点击start，<br><img src="/images/images/githubpages/sitemap.jpg" alt=""><br>接下来下载sitemap文件，把它上传到你的域名根目录，<br>打开Optimization-&gt;Sitemaps，点击Add/TEST SITEMAP，输入指向你的站点的sitemap地址，本博客的sitemap是：<a href="http://coolshell.info/sitemap.xml" target="_blank" rel="external">http://coolshell.info/sitemap.xml</a>,过几分钟就看到下面的结果：<br>！<a href="/images/images/githubpages/sitemap2.jpg"></a></p>
<p>sitemap是网站所有链接的集合，最简单的sitemap可以是一个文本文件，其中只存放你网站的所有可用资源的链接，这有利于搜索引擎收录你的网站内容。复杂的sitemap还可以利用sitemap的专用格式来标注资源的形式，更多关于sitemap可以参考：<a href="http://www.sitemaps.org/" target="_blank" rel="external">http://www.sitemaps.org/</a><br>完成站点认证和sitemap测试后，我们回到自定义搜索的页面，进入到control panel-&gt;Indexing，在其中使用sitemap来迫使google索引你的网站。这样，你的网站就算被google收录了。</p>
<p>至于我们的站内搜索应该是可以用的了，试试本站点上方的搜索就知道啦～</p>
<h3 id="站点统计"><a href="#站点统计" class="headerlink" title="站点统计"></a>站点统计</h3><p>这里介绍的站点统计是google的analytics，analytics的使用十分简单，同样的原理，利用注入脚本来实现流量统计的外挂，统计功能十分强大，谁用谁知道。这里就不再唠叨了。。</p>
<h2 id="GoDaddy-amp-DNSPod"><a href="#GoDaddy-amp-DNSPod" class="headerlink" title="GoDaddy &amp; DNSPod"></a>GoDaddy &amp; DNSPod</h2><p><a href="http://godaddy.com" title="Godaddy" target="_blank" rel="external">GoDaddy</a>是一家非常不错的域名注册商，良好的用户体验，飞快的生效速度，给力的优惠码，也支持支付宝，永远不用担心国内那些流氓厂商的流氓行为，注册了域名，就可以放心不会被别人抢走。在Godaddy注册域名是一件很简单的事情，按照提示走就完全没有问题，唯一需要动脑筋的可能是，你要想一个既有个人标识，又没有被别人注册的域名了。</p>
<p>Godaddy一切都很完美，直到遇到了GFW，原因你肯定懂。前段时间推上风传Godaddy的DNS服务器被墙，导致域名不能解析，看起来好像自己的站被墙了一样，这个确实是个闹心的事情，还好国内有DNS服务的替代产品，而且做得还非常的不错，也是免费的，功能强大，速度快，不用担心被和谐，所以隆重推荐<a href="http://dnspod.cn" title="DNSPod" target="_blank" rel="external">DNSPod</a>给大家，可以试用一下，把DNS服务迁移到DNSPod来，解决后顾之忧，配置比较简单，不懂的可以等我后面的博客啦，哈。</p>
<h2 id="GitHub-amp-Jekyll"><a href="#GitHub-amp-Jekyll" class="headerlink" title="GitHub &amp; Jekyll"></a>GitHub &amp; Jekyll</h2><p><a href="http://github.com" title="Github:social coding" target="_blank" rel="external">GitHub</a>是一个非常优秀的产品，爆发式的增长，各大优质开源软件的蜂涌而至，只能说明人们太需要他了。<strong>Social Coding</strong>是他的Slogan，产品的设计确实解决了很多代码交流的难题，让世界更平，让交流更畅，关于Git的学习，大家可以移步这里<a href="http://progit.org/book/zh/" title="Pro Git" target="_blank" rel="external">Pro Git中文版</a>，这也是一个本身就在Github维护的一个项目，高质量的翻译了Git入门书，讲解详细，是学习Git的好资料。</p>
<p>GitHub是一个伟大的产品，<a href="http://pages.github.com" title="GitHub Pages" target="_blank" rel="external">GitHub Pages</a>是他伟大的一部分，GitHub Pages基于<a href="https://github.com/mojombo/jekyll" target="_blank" rel="external">Jekyll</a>博客引擎，当我深入的研究了他之后，我深深的想给Jekyll的作者一个拥抱，列举一下Jekyll的优点：</p>
<ul>
<li>可以单独放在自己的服务器上，他也是GitHub Pages的基础，质量可靠</li>
<li>将博客最重要的功能抽取出来，去除了<a href="http://wordpress.org" title="WordPress" target="_blank" rel="external">WordPress</a>的复杂、烦躁的东西，一切都是清晰可控的 </li>
<li>可以方便的使用<a href="http://markdown.tw/" title="Markdown语法" target="_blank" rel="external">Markdown</a>等其他标记语言 </li><li>清晰、简洁的文件组织，完美的永久链接方案，既漂亮、又可定制</li><br><li>博客静态化，速度快</li>
<li><a href="https://github.com/mojombo/jekyll" target="_blank" rel="external">Jekyll</a>是完美的 </li>
</ul>
<p>写到这里，基本的点已经介绍完毕，现在介绍下怎么获取别人的博客模板来建立自己的博客。</p>
<p><strong>获取并修改别人的博客</strong></p>
<p>Jekyll官方建立了一个<a href="https://github.com/mojombo/jekyll/wiki/sites" target="_blank" rel="external">页面</a>，里面有许多的模板可供参考。接下来我们就要奉行“拿来主义”了，将别人的模板为我们所用。</p>

<p>我自己用了Yukang’s Page，他采用了一个叫做<a href="http://themes.jekyllbootstrap.com/preview/twitter/" target="_blank" rel="external">twitter</a>的Jekyll Bootstrap的模板。下面假设你已经安装了git，我们把他人的网站代码clone下来，为了举例方便，还是选取了Yukang’s Page：</p>

<pre><code>git clone https://github.com/chenyukang/chenyukang.github.com.git
</code></pre>

<p>然后删去别人的.git文件夹：</p>

<pre><code>rm -rf .git
</code></pre>

<p>接着，我们参考<a href="http://jekyllrb.com/docs/structure/" target="_blank" rel="external">jekyll的文件目录</a>，可以把他人的博客删去，并且做一些小的调整。接下来，我们把改头换面的博客上传到自己的GitHub帐号中去。一般情况下，假设你的帐号名是USERNAME，你需要建一个名为USERNAME.github.io的帐号，分支为master。这样，在你将本地的网站push上去之后，不到10分钟，访问USERNAME.github.io，就可以看到你新鲜出炉的网站了：</p>

<pre><code>git init
git add -A
git commit -m "first commit"
git remote add origin https://github.com/USERNAME/USERNAME.github.io.git
git push -u origin master
</code></pre>

<p>Git博大精深，我还没有熟练掌握。具体的命令可以参考下面一些参考资料：</p>

<ul><br>  <li><br>    <p>入门：<a href="http://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="external">git - 简易指南</a></p><br>  </li><br>  <li><br>    <p>进阶：<a href="http://think-like-a-git.net/epic.html" target="_blank" rel="external">Think Like (a) Git</a></p><br>  </li><br>  <li><br>    <p>参考图解：<a href="http://marklodato.github.io/visual-git-guide/index-en.html" target="_blank" rel="external">A Visual Git Reference</a></p><br>  </li><br></ul>

<p>如果你想要在push之前就在本地预览一下网站，可以使用<br><code>jekyll serve –watch</code><br>命令。默认设置下，可以在浏览器中访问localhost:4000预览。详细情况请<a href="http://jekyllrb.com/docs/usage/" target="_blank" rel="external">点击这里</a>。</p>

<p>那么，我们如何撰写新的博客呢？下面，我们隆重推出Markdown。</p>

<p>##Markdown语法</p>
<p>根据<a href="http://zh.wikipedia.org/zh-cn/Markdown" target="_blank" rel="external">维基百科上的介绍</a></p>

<blockquote><br>  <p>Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）和亚伦·斯沃茨（Aaron Swartz）。</p><br></blockquote>

<p>想到<a href="http://zh.wikipedia.org/wiki/%E4%BA%9A%E4%BC%A6%C2%B7%E6%96%AF%E6%B2%83%E8%8C%A8" target="_blank" rel="external">Aaron Swartz</a>已经故去，不禁一阵伤感。</p>

<p>Markdown的介绍有许多，个人推荐：</p>

<ul><br>  <li><br>    <p>入门：<a href="http://jianshu.io/p/q81RER" target="_blank" rel="external">献给写作者的 Markdown 新手指南</a></p><br>  </li><br>  <li><br>    <p>另一份入门文档：<a href="https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet" target="_blank" rel="external">Markdown Cheatsheet</a></p><br>  </li><br>  <li><br>    <p>进阶：<a href="http://wowubuntu.com/markdown/" target="_blank" rel="external">Markdown 语法说明 (简体中文版) </a></p><br>  </li><br>  <li><br>    <p>kramdown使用心得：<a href="http://mindspill.net/computing/web-development-notes/kramdown-notes/" target="_blank" rel="external">Kramdown notes</a></p><br>  </li><br></ul>

<p>备注：如何在Markdown中写注释呢？<a href="https://twitter.com/denialduan/status/180532937358454784" target="_blank" rel="external">这里</a>提供了最原始的一种解决方法：</p>

<blockquote><br>  <p>看来在Markdown文件里写注释的唯一方法就是用&lt;!– –&gt;了，好吧。</p><br></blockquote>

]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谈谈缓存和基本的缓存算法]]></title>
      <url>http://www.ezlippi.com/blog/2015/02/cache.html</url>
      <content type="html"><![CDATA[<p>   很久很久以前，在还没有缓存的时候……用户经常是去请求一个对象，而这个对象是从数据库去取，然后，这个对象变得越来越大，这个用户每次的请求时间也越来越长了，这也把数据库弄得很痛苦，他无时不刻不在工作。所以，这个事情就把用户和数据库弄得很生气，接着就有可能发生下面两件事情： </p>
<ol>
<li>用户很烦，在抱怨，甚至不去用这个应用了（这是大多数情况下都会发生的） </li>
<li>数据库为打包回家，离开这个应用，然后，就出现了大麻烦（没地方去存储数据了）（发生在极少数情况下） <a id="more"></a>
</li>
</ol>
<h2 id="上帝派来了缓存"><a href="#上帝派来了缓存" class="headerlink" title="上帝派来了缓存"></a>上帝派来了缓存</h2><p>在几年之后，IBM（60年代）的研究人员引进了一个新概念，它叫“缓存”。</p>
<h2 id="什么是缓存？"><a href="#什么是缓存？" class="headerlink" title="什么是缓存？"></a>什么是缓存？</h2><p>通俗来说，缓存是“存贮数据（使用频繁的数据）的临时地方，因为取原始数据的代价太大了，所以我可以取得快一些。<br>我们都听说过线程池、对象池，缓存可以认为是数据的池，这些数据是从数据库里的真实数据复制出来的，并且为了能别取回，被标上了标签（键 ID）。</p>
<h3 id="命中"><a href="#命中" class="headerlink" title="命中"></a>命中</h3><p>当客户发起一个请求（我们说他想要查看一个产品信息），我们的应用接受这个请求，并且如果是在第一次检查缓存的时候，需要去数据库读取产品信息。<br>如果在缓存中，一个条目通过一个标记被找到了，这个条目就会被使用、我们就叫它缓存命中。所以，命中率也就不难理解了。</p>
<h3 id="Cache-Miss"><a href="#Cache-Miss" class="headerlink" title="Cache Miss"></a>Cache Miss</h3><p>但是这里需要注意两点：<br>１. 如果还有缓存的空间，那么，没有命中的对象会被存储到缓存中来。<br>２. 如果缓存慢了，而又没有命中缓存，那么就会按照某一种策略，把缓存中的旧对象踢出，而把新的对象加入缓存池。而这些策略统称为<em>替代策略</em>（缓存算法），这些策略会决定到底应该提出哪些对象。</p>
<h3 id="存储成本"><a href="#存储成本" class="headerlink" title="存储成本"></a>存储成本</h3><p>当没有命中时，我们会从数据库取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。</p>
<h3 id="索引成本："><a href="#索引成本：" class="headerlink" title="索引成本："></a>索引成本：</h3><p>和存储成本相仿。 </p>
<h3 id="失效"><a href="#失效" class="headerlink" title="失效"></a>失效</h3><p>当存在缓存中的数据需要更新时，就意味着缓存中的这个数据失效了。</p>
<h3 id="替代策略"><a href="#替代策略" class="headerlink" title="替代策略"></a>替代策略</h3><p>当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中踢出一个老的条目，加入一条新的条目，而到底应该踢出什么条目，就由替代策略决定。<br>最优替代策略：<br>最优的替代策略就是想把缓存中最没用的条目给踢出去，但是未来是不能够被预知的，所以这种策略是不可能实现的。但是有很多策略，都是朝着这个目前去努力。</p>
<h2 id="缓存算法"><a href="#缓存算法" class="headerlink" title="缓存算法"></a>缓存算法</h2><p>没有人能说清哪种缓存算法优于其他的缓存算法</p>
<h3 id="Least-Frequently-Used（LFU）："><a href="#Least-Frequently-Used（LFU）：" class="headerlink" title="Least Frequently Used（LFU）："></a>Least Frequently Used（LFU）：</h3><p>大家好，我是 LFU，我会计算为每个缓存对象计算他们被使用的频率。我会把最不常用的缓存对象踢走。</p>
<h3 id="Least-Recently-User（LRU）："><a href="#Least-Recently-User（LRU）：" class="headerlink" title="Least Recently User（LRU）："></a>Least Recently User（LRU）：</h3><p>我是 LRU 缓存算法，我把最近最少使用的缓存对象给踢走。<br>我总是需要去了解在什么时候，用了哪个缓存对象。如果有人想要了解我为什么总能把最近最少使用的对象踢掉，是非常困难的。<br>浏览器就是使用了我（LRU）作为缓存算法。新的对象会被放在缓存的顶部，当缓存达到了容量极限，我会把底部的对象踢走，而技巧就是：我会把最新被访问的缓存对象，放到缓存池的顶部。<br>所以，经常被读取的缓存对象就会一直呆在缓存池中。有两种方法可以实现我，array 或者是 linked list。<br>我的速度很快，我也可以被数据访问模式适配。我有一个大家庭，他们都可以完善我，甚至做的比我更好（我确实有时会嫉妒，但是没关系）。我家庭的一些成员包括 LRU2 和 2Q，他们就是为了完善 LRU 而存在的。</p>
<h3 id="Least-Recently-Used-2（LRU2）："><a href="#Least-Recently-Used-2（LRU2）：" class="headerlink" title="Least Recently Used 2（LRU2）："></a>Least Recently Used 2（LRU2）：</h3><p>我是 Least Recently Used 2，有人叫我最近最少使用 twice，我更喜欢这个叫法。我会把被两次访问过的对象放入缓存池，当缓存池满了之后，我会把有两次最少使用的缓存对象踢走。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。如果把我用在大容量的缓存池中，就会有问题。另外，我还需要跟踪那么不在缓存的对象，因为他们还没有被第二次读取。我比LRU好，而且是 adoptive to access 模式 </p>
<h3 id="Two-Queues（2Q）："><a href="#Two-Queues（2Q）：" class="headerlink" title="Two Queues（2Q）："></a>Two Queues（2Q）：</h3><p>我是 Two Queues；我把被访问的数据放到 LRU 的缓存中，如果这个对象再一次被访问，我就把他转移到第二个、更大的 LRU 缓存。<br>我踢走缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把 LRU 换成 LRU2，就比增加缓存的容量更好。这种机制使得我比 LRU2 更好，我也是 LRU 家族中的一员，而且是 adoptive to access 模式 。 </p>
<h3 id="Adaptive-Replacement-Cache（ARC）："><a href="#Adaptive-Replacement-Cache（ARC）：" class="headerlink" title="Adaptive Replacement Cache（ARC）："></a>Adaptive Replacement Cache（ARC）：</h3><p>我是 ARC，有人说我是介于 LRU 和 LFU 之间，为了提高效果，我是由2个 LRU 组成，第一个，也就是 L1，包含的条目是最近只被使用过一次的，而第二个 LRU，也就是 L2，包含的是最近被使用过两次的条目。因此， L1 放的是新的对象，而 L2 放的是常用的对象。所以，别人才会认为我是介于 LRU 和 LFU 之间的，不过没关系，我不介意。<br>我被认为是性能最好的缓存算法之一，能够自调，并且是低负载的。我也保存着历史对象，这样，我就可以记住那些被移除的对象，同时，也让我可以看到被移除的对象是否可以留下，取而代之的是踢走别的对象。我的记忆力很差，但是我很快，适用性也强。</p>
<h3 id="Most-Recently-Used（MRU）："><a href="#Most-Recently-Used（MRU）：" class="headerlink" title="Most Recently Used（MRU）："></a>Most Recently Used（MRU）：</h3><p>我是 MRU，和 LRU 是对应的。我会移除最近最多被使用的对象，你一定会问我为什么。好吧，让我告诉你，当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这就是为什么我是最好的选择。<br>我是数据库内存缓存中是多么的常见！每当一次缓存记录的使用，我会把它放到栈的顶端。当栈满了的时候，你猜怎么着？我会把栈顶的对象给换成新进来的对象！</p>
<h3 id="First-in-First-out（FIFO）："><a href="#First-in-First-out（FIFO）：" class="headerlink" title="First in First out（FIFO）："></a>First in First out（FIFO）：</h3><p>我是先进先出，我是一个低负载的算法，并且对缓存对象的管理要求不高。我通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。我很快，但是我并不适用。</p>
<h3 id="Second-Chance："><a href="#Second-Chance：" class="headerlink" title="Second Chance："></a>Second Chance：</h3><p>大家好，我是 second chance，我是通过 FIFO 修改而来的，被大家叫做 second chance 缓存算法，我比 FIFO 好的地方是我改善了 FIFO 的成本。我是 FIFO 一样也是在观察队列的前端，但是很FIFO的立刻踢出不同，我会检查即将要被踢出的对象有没有之前被使用过的标志（1一个 bit 表示），没有没有被使用过，我就把他踢出；否则，我会把这个标志位清除，然后把这个缓存对象当做新增缓存对象加入队列。你可以想象就这就像一个环队列。当我再一次在队头碰到这个对象时，由于他已经没有这个标志位了，所以我立刻就把他踢开了。我在速度上比 FIFO 快。</p>
<h3 id="CLock："><a href="#CLock：" class="headerlink" title="CLock："></a>CLock：</h3><p>我是 Clock，一个更好的 FIFO，也比 second chance 更好。因为我不会像 second chance 那样把有标志的缓存对象放到队列的尾部，但是也可以达到 second chance 的效果。<br>我持有一个装有缓存对象的环形列表，头指针指向列表中最老的缓存对象。当缓存 miss 发生并且没有新的缓存空间时，我会问问指针指向的缓存对象的标志位去决定我应该怎么做。如果标志是0，我会直接用新的缓存对象替代这个缓存对象；如果标志位是1，我会把头指针递增，然后重复这个过程，知道新的缓存对象能够被放入。我比 second chance 更快。</p>
<h3 id="Simple-time-based："><a href="#Simple-time-based：" class="headerlink" title="Simple time-based："></a>Simple time-based：</h3><p>我是 simple time-based 缓存算法，我通过绝对的时间周期去失效那些缓存对象。对于新增的对象，我会保存特定的时间。我很快，但是我并不适用。</p>
<h3 id="Extended-time-based-expiration："><a href="#Extended-time-based-expiration：" class="headerlink" title="Extended time-based expiration："></a>Extended time-based expiration：</h3><p>我是 extended time-based expiration 缓存算法，我是通过相对时间去失效缓存对象的；对于新增的缓存对象，我会保存特定的时间，比如是每5分钟，每天的12点。 </p>
<h3 id="Sliding-time-based-expiration："><a href="#Sliding-time-based-expiration：" class="headerlink" title="Sliding time-based expiration："></a>Sliding time-based expiration：</h3><p>我是 sliding time-based expiration，与前面不同的是，被我管理的缓存对象的生命起点是在这个缓存的最后被访问时间算起的。我很快，但是我也不太适用。 </p>
<h3 id="其他的缓存算法还考虑到了下面几点："><a href="#其他的缓存算法还考虑到了下面几点：" class="headerlink" title="其他的缓存算法还考虑到了下面几点："></a>其他的缓存算法还考虑到了下面几点：</h3><p>成本：如果缓存对象有不同的成本，应该把那些难以获得的对象保存下来。<br>容量：如果缓存对象有不同的大小，应该把那些大的缓存对象清除，这样就可以让更多的小缓存对象进来了。<br>时间：一些缓存还保存着缓存的过期时间。电脑会失效他们，因为他们已经过期了。<br>根据缓存对象的大小而不管其他的缓存算法可能是有必要的。 </p>
<p>在这一部分中，我们来看看如何实现这些著名的缓存算法。以下的代码只是示例用的，如果你想自己实现缓存算法，可能自己还得加上一些额外的工作。 </p>
<h3 id="Random-Cache"><a href="#Random-Cache" class="headerlink" title="Random Cache"></a>Random Cache</h3><p>我是随机缓存，我随意的替换缓存实体，没人敢抱怨。你可以说那个被替换的实体很倒霉。通过这些行为，我随意的去处缓存实体。我比 FIFO 机制好，在某些情况下，我甚至比 LRU 好，但是，通常LRU都会比我好。 </p>
<h3 id="看看缓存元素（缓存实体）"><a href="#看看缓存元素（缓存实体）" class="headerlink" title="看看缓存元素（缓存实体）"></a>看看缓存元素（缓存实体）</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> CacheElement </span><br><span class="line">&#123; </span><br><span class="line"><span class="keyword">private</span> Object objectValue; </span><br><span class="line"><span class="keyword">private</span> Object objectKey; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> index; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hitCount; <span class="comment">// getters and setters </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个缓存实体拥有缓存的key和value，这个实体的数据结构会被以下所有缓存算法用到。 </p>
<h3 id="缓存算法的公用代码"><a href="#缓存算法的公用代码" class="headerlink" title="缓存算法的公用代码"></a>缓存算法的公用代码</h3><pre><code>public final synchronized void addElement(Object key, Object         value)
{
int index;
Object obj;
// get the entry from the table
obj = table.get(key);
// If we have the entry already in our table
// then get it and replace only its value.
obj = table.get(key);
if (obj != null)
{
CacheElement element;
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
｝
</code></pre><p>上面的代码会被所有的缓存算法实现用到。这段代码是用来检查缓存元素是否在缓存中了，如果是，我们就替换它，但是如果我们找不到这个 key 对应的缓存，我们会怎么做呢？那我们就来深入的看看会发生什么吧！ </p>
<h3 id="看看随机缓存的实现"><a href="#看看随机缓存的实现" class="headerlink" title="看看随机缓存的实现"></a>看看随机缓存的实现</h3><pre><code>public final synchronized void addElement(Object key, Object         value)
{
int index;
Object obj;
obj = table.get(key);
if (obj != null)
{
CacheElement element;// Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}// If we haven&apos;t filled the cache yet, put it at the end.
if (!isFull())
{
index = numEntries;
++numEntries;
}
else { // Otherwise, replace a random entry.
index = (int) (cache.length * random.nextFloat());
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}
</code></pre><h3 id="看看FIFO缓算法的实现"><a href="#看看FIFO缓算法的实现" class="headerlink" title="看看FIFO缓算法的实现"></a>看看FIFO缓算法的实现</h3><pre><code>public final synchronized void addElement(Objectkey, Object         value)
{
int index;
Object obj;
obj = table.get(key);
if (obj != null)
{
CacheElement element; // Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
// If we haven&apos;t filled the cache yet, put it at the end.
if (!isFull())
{
index = numEntries;
++numEntries;
}
else { // Otherwise, replace the current pointer,
// entry with the new one.
index = current;
// in order to make Circular FIFO
if (++current &gt;= cache.length)
current = 0;
table.remove(cache[index].getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
table.put(key, cache[index]);
}
</code></pre><h3 id="看看LFU缓存算法的实现"><a href="#看看LFU缓存算法的实现" class="headerlink" title="看看LFU缓存算法的实现"></a>看看LFU缓存算法的实现</h3><pre><code>public synchronized Object getElement(Object key)
{
Object obj;
obj = table.get(key);
if (obj != null)
{
CacheElement element = (CacheElement) obj;
element.setHitCount(element.getHitCount() + 1);
return element.getObjectValue();
}
return null;
}
public final synchronized void addElement(Object key, Object         value)
{
Object obj;
obj = table.get(key);
if (obj != null)
{
CacheElement element; // Just replace the value.
element = (CacheElement) obj;
element.setObjectValue(value);
element.setObjectKey(key);
return;
}
if (!isFull())
{
index = numEntries;
++numEntries;
}
else
{
CacheElement element = removeLfuElement();
index = element.getIndex();
table.remove(element.getObjectKey());
}
cache[index].setObjectValue(value);
cache[index].setObjectKey(key);
cache[index].setIndex(index);
table.put(key, cache[index]);
}
public CacheElement removeLfuElement()
{
CacheElement[] elements = getElementsFromTable();
CacheElement leastElement = leastHit(elements);
return leastElement;
}
public static CacheElement leastHit(CacheElement[] elements)
{
CacheElement lowestElement = null;
for (int i = 0; i &lt; elements.length; i++)
{
CacheElement element = elements[i];
if (lowestElement == null)
{
lowestElement = element;
}
else {
if (element.getHitCount() &lt; lowestElement.getHitCount())
{
lowestElement = element;
}
    }
}
return lowestElement;
}
</code></pre><p>最重点的代码，就应该是 leastHit 这个方法，这段代码就是把<br>hitCount 最低的元素找出来，然后删除，给新进的缓存元素留位置。 </p>
<h3 id="看看LRU缓存算法实现"><a href="#看看LRU缓存算法实现" class="headerlink" title="看看LRU缓存算法实现"></a>看看LRU缓存算法实现</h3><pre><code> private void moveToFront(int index)
 {
 int nextIndex, prevIndex;
 if(head != index)
 {
 nextIndex = next[index];
 prevIndex = prev[index];
 // Only the head has a prev entry that is an invalid index
 // so we don&apos;t check.
 next[prevIndex] = nextIndex;
 // Make sure index is valid. If it isn&apos;t, we&apos;re at the tail
 // and don&apos;t set prev[next].
 if(nextIndex &gt;= 0)
 prev[nextIndex] = prevIndex;
 else
 tail = prevIndex;
 prev[index] = -1;
 next[index] = head;
 prev[head] = index;
 head = index;
 }
 }
public final synchronized void addElement(Object key, Object         value)
   {
  int index;Object obj;
 obj = table.get(key);
 if(obj != null)
 {
 CacheElement entry;
 // Just replace the value, but move it to the front.
 entry = (CacheElement)obj;
 entry.setObjectValue(value);
 entry.setObjectKey(key);
 moveToFront(entry.getIndex());
 return;
 }
 // If we haven&apos;t filled the cache yet, place in next available
 // spot and move to front.
 if(!isFull())
 {
 if(_numEntries&gt; 0)
 {
 prev[_numEntries] = tail;
 next[_numEntries] = -1;
 moveToFront(numEntries);
 }
 ++numEntries;
 }
 else { // We replace the tail of the list.
 table.remove(cache[tail].getObjectKey());
 moveToFront(tail);
 }
 cache[head].setObjectValue(value);
 cache[head].setObjectKey(key);
 table.put(key, cache[head]);
 }
</code></pre><p>这段代码的逻辑如 LRU算法 的描述一样，把再次用到的缓存提取到最前面，而每次删除的都是最后面的元素。 </p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们已经看到 LFU缓存算法 和 LRU缓存算法的实现方式，至于如何实现，采用数组还是 LinkedHashMap，都由你决定，不够我一般是小的缓存容量用数组，大的用 LinkedHashMap。 </p>
<h2 id="几个著名Java开源缓存框架介绍"><a href="#几个著名Java开源缓存框架介绍" class="headerlink" title="几个著名Java开源缓存框架介绍"></a>几个著名Java开源缓存框架介绍</h2><p>1.OSCache</p>
<p>　　OSCache是个一个广泛采用的高性能的J2EE缓存框架，OSCache能用于任何Java应用程序的普通的缓存解决方案。 OSCache有以下特点：缓存任何对象，你可以不受限制的缓存部分jsp页面或HTTP请求，任何java对象都可以缓存。拥有全面的API–OSCache API给你全面的程序来控制所有的OSCache特性。永久缓存–缓存能随意的写入硬盘，因此允许昂贵的创建(expensive-to-create)数据来保持缓存，甚至能让应用重启。支持集群–集群缓存数据能被单个的进行参数配置，不需要修改代码。缓存记录的过期–你可以有最大限度的控制缓存对象的过期，包括可插入式的刷新策略(如果默认性能不需要时)。</p>
<p>2.Java Caching system</p>
<p>　　JSC(Java Caching system)是一个用分布式的缓存系统，是基于服务器的java应用程序。它是通过提供管理各种动态缓存数据来加速动态web应用。 JCS和其他缓存系统一样，也是一个用于高速读取，低速写入的应用程序。动态内容和报表系统能够获得更好的性能。如果一个网站，有重复的网站结构，使用间歇性更新方式的数据库(而不是连续不断的更新数据库)，被重复搜索出相同结果的，就能够通过执行缓存方式改进其性能和伸缩性。</p>
<p>3.EHCache</p>
<p>　　EHCache 是一个纯java的在进程中的缓存，它具有以下特性：快速，简单，为Hibernate2.1充当可插入的缓存，最小的依赖性，全面的文档和测试。</p>
<p>4.JCache</p>
<p>　　JCache是个开源程序，正在努力成为JSR-107开源规范，JSR-107规范已经很多年没改变了。这个版本仍然是构建在最初的功能定义上。</p>
<p>5.ShiftOne</p>
<p>　　ShiftOne Java Object Cache是一个执行一系列严格的对象缓存策略的Java lib，就像一个轻量级的配置缓存工作状态的框架。</p>
<p>6.SwarmCache</p>
<p>　　SwarmCache是一个简单且有效的分布式缓存，它使用IP multicast与同一个局域网的其他主机进行通讯，是特别为集群和数据驱动web应用程序而设计的。SwarmCache能够让典型的读操作大大超过写操作的这类应用提供更好的性能支持。 SwarmCache使用JavaGroups来管理从属关系和分布式缓存的通讯。</p>
<p>7.TreeCache / JBossCache</p>
<p>　　JBossCache是一个复制的事务处理缓存，它允许你缓存企业级应用数据来更好的改善性能。缓存数据被自动复制，让你轻松进行JBoss服务器之间的集群工作。JBossCache能够通过JBoss应用服务或其他J2EE容器来运行一个MBean服务，当然，它也能独立运行。 JBossCache包括两个模块：TreeCache和TreeCacheAOP。 TreeCache –是一个树形结构复制的事务处理缓存。TreeCacheAOP –是一个“面向对象”缓存，它使用AOP来动态管理POJO(Plain Old Java Objects) 注：AOP是OOP的延续，是Aspect Oriented Programming的缩写，意思是面向方面编程。</p>
<p>8.WhirlyCache</p>
<p>　　Whirlycache是一个快速的、可配置的、存在于内存中的对象的缓存。它能够通过缓存对象来加快网站或应用程序的速度，否则就必须通过查询数据库或其他代价较高的处理程序来建立。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C代码优化小贴士]]></title>
      <url>http://www.ezlippi.com/blog/2014/12/c-code-opt.html</url>
      <content type="html"><![CDATA[<p>虽然对于优化C代码有很多有效的指导方针，但是对于彻底地了解编译器和你工作的机器依然无法取代，通常，加快程序的速度也会加大代码量。这些增加的代码也会影响一个程序的复杂度和可读性，这是不可接受的，比如你在一些小型的设备上编程，例如：移动设备、PDA……，这些有着严格的内存限制，于是，在优化的座右铭是:写代码在内存和速度都应该优化。<br><a id="more"></a></p>
<h2 id="整型数-Integers"><a href="#整型数-Integers" class="headerlink" title="整型数/Integers"></a>整型数/Integers</h2><p>在我们知道使用的数不可能是负数的时候，应该使用unsigned int取代int，一些处理器处理整数算数运算的时候unsigned int比int快，于是，在一个紧致的循环里面定义一个整型变量，最好这样写代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> variable_name;</span><br></pre></td></tr></table></figure></p>
<p>然而，我们不能保证编译器会注意到那个register关键字，也有可能，对某种处理器来说，有没有unsigned是一样的。这两个关键字并不是可以在所有的编译器中应用。<strong>记住，整形数运算要比浮点数运算快得多，因为处理器可以直接进行整型数运算，浮点数运算需要依赖于外部的浮点数处理器或者浮点数数学库。</strong>我们处理小数的时候要精确点些（比如我们在做一个简单的统计程序时），要限制结果不能超过100，要尽可能晚的把它转化成浮点数。<br>还有一个整形提升的问题，比如下面这个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> i ;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">-1</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这段代码实际上什么也不会输出，因为size_t是unsigned int类型，i会自动转换成unsigned int就变成了一个很大的正数，所以和n比较自然什么都不会输出。</p>
<p>在算术运算中，char和short会自动转换成int，转换的原则就是如果int类型能过包括操作数类型的所有范围，则操作数（比如unsigned short）转换成int，否则转换成unsigned int，int和long类型运算以此类推，<strong>总是向着精度更高、位更长的类型转换。</strong></p>
<h2 id="除法和余数-Division-and-Remainder"><a href="#除法和余数-Division-and-Remainder" class="headerlink" title="除法和余数 / Division and Remainder"></a>除法和余数 / Division and Remainder</h2><p>在标准的处理器中，根据分子和分母的不同，一个32位的除法需要20-140个时钟周期来执行完成，等于一个固定的时间加上每个位被除的时间。<br>Time (分子/ 分母) = C0 + C1<em> log&lt;2(分子/分母)= C0 + C1 </em> (log2 (分子) log2 (分母)).<br>现在的ARM处理器需要消耗20+4.3N个时钟周期，这是一个非常费时的操作，要尽可能的避免。在有些情况下，除法表达式可以用乘法表达是来重写。比方说，(a/b)&gt;c可以写成a&gt;(c<em>b),条件是我们已经知道b为非负数而且b</em>c不会超过整型数的取值范围。如果我们能够确定其中的一个操作数为unsigned，那么使用无符号除法将会更好，因为它要比有符号除法快得多。</p>
<h2 id="合并除法运算和取余运算-Combining-division-and-remainder"><a href="#合并除法运算和取余运算-Combining-division-and-remainder" class="headerlink" title="合并除法运算和取余运算 / Combining division and remainder"></a>合并除法运算和取余运算 / Combining division and remainder</h2><p>在一些情况下，除法运算和取余运算都需要用到，在这种情况下，编译器会将除法运算和取余运算合并，因为除法运算总是同时返回商和余数。如果两个运算都要用到，我们可以将他们写到一起。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> uint;</span><br><span class="line"><span class="function">uint <span class="title">div32u</span> <span class="params">(uint a)</span> </span>&#123;</span><br><span class="line">     return a / <span class="number">32</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div32s</span> <span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">     return a / <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这两种除法都会避免调用除法函数（进行移位操作），另外，无符号的除法要比有符号的除法使用更少的指令。有符号的除法要耗费更多的时间，因为这种除法是使最终结果趋向于零的，而移位则是趋向于负无穷。</p>
<h2 id="取模运算的替换-An-alternative-for-modulo-arithmetic"><a href="#取模运算的替换-An-alternative-for-modulo-arithmetic" class="headerlink" title="取模运算的替换 / An alternative for modulo arithmetic"></a>取模运算的替换 / An alternative for modulo arithmetic</h2><p>我们一般使用取余运算进行取模，不过，有时候使用 if 语句来重写也是可行的。考虑下面的两个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">modulo_func1</span> <span class="params">(uint count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return (++count % <span class="number">60</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">uint <span class="title">modulo_func2</span> <span class="params">(uint count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++count &gt;= <span class="number">60</span>)</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    return (count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第二个例子要比第一个更可取，因为由它产生的代码会更快，注意：这只是在count取值范围在0 – 59之间的时候才行。<br>但是我们可以使用如下的代码（笔者补充）实现等价的功能：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">uint <span class="title">modulo_func3</span> <span class="params">(uint count)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (++count &gt;= <span class="number">60</span>)</span><br><span class="line">        count %= <span class="number">60</span>;</span><br><span class="line">    return (count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用数组索引-Using-array-indices"><a href="#使用数组索引-Using-array-indices" class="headerlink" title="使用数组索引 / Using array indices"></a>使用数组索引 / Using array indices</h2><p>假设你要依据某个变量的值，设置另一个变量的取值为特定的字符，你可能会这样做：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(<span class="built_in">queue</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span> :   letter = W;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span> :   letter = S;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span> :   letter = U;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">queue</span> == <span class="number">0</span>)</span><br><span class="line">    letter = W;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( queue == <span class="number">1</span> )</span><br><span class="line">    letter = S;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    letter = U;</span><br></pre></td></tr></table></figure></p>
<p>有一个简洁且快速的方式是简单的将变量的取值做成一个字符串索引，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> *classes = WSU;</span><br><span class="line">letter = classes[<span class="built_in">queue</span>];</span><br></pre></td></tr></table></figure></p>
<h2 id="全局变量-Global-variables"><a href="#全局变量-Global-variables" class="headerlink" title="全局变量 / Global variables"></a>全局变量 / Global variables</h2><p>全局变量不会被分配在寄存器上，修改全局变量需要通过指针或者调用函数的方式间接进行。所以编译器不会将全局变量存储在寄存器中，那样会带来额外的、不必要的负担和存储空间。所以在比较关键的循环中，我们要不使用全局变量。<br><strong>如果一个函数要频繁的使用全局变量，我们可以使用局部变量，作为全局变量的拷贝，这样就可以使用寄存器了。条件是本函数调用的任何子函数不使用这些全局变量。</strong><br>举个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> errs;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test1</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    errs += f();</span><br><span class="line">    errs += g();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test2</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> localerrs = errs;</span><br><span class="line">    localerrs += f();</span><br><span class="line">    localerrs += g();</span><br><span class="line">    errs = localerrs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到test1()中每次加法都需要读取和存储全局变量errs，而在test2()中，localerrs分配在寄存器上，只需要一条指令。</p>
<h2 id="使用别名-Using-Aliases"><a href="#使用别名-Using-Aliases" class="headerlink" title="使用别名 / Using Aliases"></a>使用别名 / Using Aliases</h2><p>考虑下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">( <span class="keyword">int</span> *data )</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        anyfunc(*data, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>即使*data从来没有变化，编译器却不知道anyfunc()没有修改它，于是程序每次用到它的时候，都要把它从内存中读出来，可能它只是某些变量的别名，这些变量在程序的其他部分被修改。如果能够确定它不会被改变，我们可以这样写：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">( <span class="keyword">int</span> *data )</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">int</span> localdata;</span><br><span class="line">localdata = *data;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)</span><br><span class="line">anyfunc(localdata, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样会给编译器优化工作更多的选择余地。</p>
<h2 id="活跃变量和泄漏-Live-variables-and-spilling"><a href="#活跃变量和泄漏-Live-variables-and-spilling" class="headerlink" title="活跃变量和泄漏 / Live variables and spilling"></a>活跃变量和泄漏 / Live variables and spilling</h2><p>寄存器的数量在每个处理器当中都是固定的，所以在程序的某个特定的位置，可以保存在寄存器中的变量的数量是有限制的。有些编译器支持“生命周期分割”（live-range splitting），也就是说在函数的不同部分，变量可以被分配到不同的寄存器或者内存中。变量的生存范围被定义成：起点是对该变量的一次空间分配，终点是在下次空间分配之前的最后一次使用之间。在这个范围内，变量的值是合法的，是活的。在生存范围之外，变量不再被使用，是死的，它的寄存器可以供其他变量使用，这样，编译器就可以安排更多的变量到寄存器当中。<br>可分配到寄存器的变量需要的寄存器数量等于经过生命范围重叠的变量的数目，如果这个数目超过可用的寄存器的数量，有些变量就必须被暂时的存储到内存中。这种处理叫做“泄漏(spilling)”。<br>编译器优先释放最不频繁使用的变量，将释放的代价降到最低。可以通过以下方式避免变量的“释放”：</p>
<ul>
<li>限制活跃变量的最大数目：通常可以使用简单小巧的表达式，在函数内部不使用太多的变量。把大的函数分割成更加简单的、更加小巧的多个函数，也可能会有所帮助。</li>
<li>使用关键字register修饰最经常使用的变量：告诉编译器这个变量将会被经常用到，要求编译器使用非常高的优先级将此变量分配到寄存器中。尽管如此，在某些情况下，变量还是可能被泄漏。</li>
</ul>
<h2 id="变量类型-Variable-Types"><a href="#变量类型-Variable-Types" class="headerlink" title="变量类型 / Variable Types"></a>变量类型 / Variable Types</h2><p>C编译器支持基本的变量类型：char、short、int、long(signed、unsigned)、float、double。为变量定义最恰当的类型，非常重要，因为这样可以减少代码和数据的长度，可以非常显著的提高效率。</p>
<h2 id="局部变量-Local-variables"><a href="#局部变量-Local-variables" class="headerlink" title="局部变量 / Local variables"></a>局部变量 / Local variables</h2><p>如果可能，局部变量要避免使用char和short。对于char和short类型，编译器在每次分配空间以后，都要将这种局部变量的尺寸减少到8位或16位。这对于符号变量来说称为符号扩展，对无符号变量称为无符号扩展。这种操作是通过将寄存器左移24或16位，然后再有符号（或无符号的）右移同样的位数来实现的，需要两条指令（无符号字节变量的无符号扩展需要一条指令）。<br>这些移位操作可以通过使用int和unsigned int的局部变量来避免。这对于那些首先将数据调到局部变量然后利用局部变量进行运算的情况尤其重要。即使数据以8位或16位的形式输入或输出，把他们当作32位来处理仍是有意义的。<br>我们来考虑下面的三个例子函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">wordinc</span> <span class="params">(<span class="keyword">int</span> a)</span></span><br><span class="line"></span>&#123; </span><br><span class="line">    return a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">shortinc</span> <span class="params">(<span class="keyword">short</span> a)</span></span><br><span class="line"></span>&#123; </span><br><span class="line">    return a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charinc</span> <span class="params">(<span class="keyword">char</span> a)</span></span><br><span class="line"></span>&#123; </span><br><span class="line">    return a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他们的运算结果是相同的，但是第一个代码片断要比其他片断运行的要快。</p>
<h2 id="指针-Pointers"><a href="#指针-Pointers" class="headerlink" title="指针 / Pointers"></a>指针 / Pointers</h2><p>如果可能，我们应该使用结构体的引用作为参数，也就是结构体的指针，否则，整个结构体就会被压入堆栈，然后传递，这会降低速度。程序适用值传递可能需要几K字节，而一个简单的指针也可以达到同样的目的，只需要几个字节就可以了。<br>如果在函数内部不会改变结构体的内容，那么就应该将参数声明为const型的指针。举个例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_data_of_a_structure</span> <span class="params">(<span class="keyword">const</span> Thestruct  *data_pointer)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     ...<span class="built_in">printf</span> contents of the structure...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个例子代码告知编译器在函数内部不会改变外部结构体的内容，访问他们的时候，不需要重读。还可以确保编译器捕捉任何修改这个只读结构体的代码，给结构体以额外的保护。</p>
<h2 id="指针链-Pointer-chains"><a href="#指针链-Pointer-chains" class="headerlink" title="指针链 / Pointer chains"></a>指针链 / Pointer chains</h2><p>指针链经常被用来访问结构体的信息，比如，下面的这段常见的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; <span class="keyword">int</span> x, y, z; &#125; Point3;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123; Point3 *pos, *direction; &#125; Object;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPos1</span><span class="params">(Object *p)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    p-&gt;pos-&gt;x = <span class="number">0</span>;</span><br><span class="line">    p-&gt;pos-&gt;y = <span class="number">0</span>;</span><br><span class="line">    p-&gt;pos-&gt;z = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>代码中，处理器在每次赋值操作的时候都要重新装载p-&gt;pos，因为编译器不知道p-&gt;pos-&gt;x不是p-&gt;pos的别名。更好的办法是将p-&gt;pos缓存成一个局部变量，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitPos2</span><span class="params">(Object *p)</span></span><br><span class="line"></span>&#123; </span><br><span class="line">    Point3 *pos = p-&gt;pos;</span><br><span class="line">    pos-&gt;x = <span class="number">0</span>; </span><br><span class="line">    pos-&gt;y = <span class="number">0</span>;</span><br><span class="line">    pos-&gt;z = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个可能的方法是将Point3结构体包含在Object结构体中，完全避免指针的使用。</p>
<h2 id="条件的执行-Conditional-Execution"><a href="#条件的执行-Conditional-Execution" class="headerlink" title="条件的执行 / Conditional Execution"></a>条件的执行 / Conditional Execution</h2><p>条件执行主要用在if语句中，同时也会用到由关系运算(&lt;,==,&gt;等)或bool运算(&amp;&amp;, !等)组成的复杂的表达式。尽可能的保持if和else语句的简单是有好处的，这样才能很好的条件化。关系表达式应该被分成包含相似条件的若干块。<br>下面的例子演示了编译器如何使用条件执行：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; c &lt; <span class="number">0</span> &amp;&amp; d &lt; <span class="number">0</span>)  <span class="comment">//分组化的条件被捆绑在一起</span></span><br><span class="line">        return a + b + c + d;</span><br><span class="line">    return <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>条件被分组，便以其能够条件化他们。</p>
<h2 id="Boolean表达式和范围检查-Boolean-Expressions-amp-Range-checking"><a href="#Boolean表达式和范围检查-Boolean-Expressions-amp-Range-checking" class="headerlink" title="Boolean表达式和范围检查 / Boolean Expressions &amp; Range checking"></a>Boolean表达式和范围检查 / Boolean Expressions &amp; Range checking</h2><p>有一种常见的boolean表达式被用来检查是否一个变量取值在某个特定的范围内，比方说，检查一个点是否在一个窗口内。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PointInRectangelArea</span> <span class="params">(Point p, Rectangle *r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return (p.x &gt;= r-&gt;xmin &amp;&amp; p.x &lt; r-&gt;xmax &amp;&amp; p.y &gt;= r-&gt;ymin &amp;&amp; p.y &lt; r-&gt;ymax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里还有一个更快的方法：把(x &gt;= min &amp;&amp; x &lt; max) 转换成 (unsigned)(x-min) &lt; (max-min). 尤其是min为0时，更为有效。下面是优化后的代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PointInRectangelArea</span> <span class="params">(Point p, Rectangle *r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    return ((unsigned) (p.x - r-&gt;xmin) &lt; r-&gt;xmax &amp;&amp; (unsigned) (p.y - r-&gt;ymin) &lt; r-&gt;ymax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Boolean表达式-amp-与零的比较-Boolean-Expressions-amp-Compares-with-zero"><a href="#Boolean表达式-amp-与零的比较-Boolean-Expressions-amp-Compares-with-zero" class="headerlink" title="Boolean表达式&amp;与零的比较 / Boolean Expressions &amp; Compares with zero"></a>Boolean表达式&amp;与零的比较 / Boolean Expressions &amp; Compares with zero</h2><p>在比较(CMP)指令后，相应的处理器标志位就会被设置。这些标志位也可以被其他的指令设置，诸如MOV, ADD, AND, MUL, 也就是基本的数学和逻辑运算指令（数据处理指令）。假如一条数据处理指令要设置这些标志位，那么N和Z标志位的设置方法跟把数字和零比较的设置方法是一样的。N标志位表示结果是不是负数，Z标志位表示结果是不是零。<br>在C语言中，处理器中的N和Z标志位对应的有符号数的关系运算符是x &lt; 0, x &gt;= 0, x == 0, x != 0，无符号数对应的是x == 0, x != 0 (or x &gt; 0)。<br>C语言中，每用到一个关系运算符，编译器就会产生一个比较指令。如果关系运算符是上面的其中一个，在数据处理指令紧跟比较指令的情况下，编译器就会将比较指令优化掉。比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aFunction</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x + y &lt; <span class="number">0</span>)</span><br><span class="line">        return <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样做，会在关键循环中节省比较指令，使代码长度减少，效率增加。C语言中没有借位(carry)标志位和溢出(overflow)标志位的概念，所以如果不使用内嵌汇编语言，要访问C和V标志位是不可能的。尽管如此，编译器支持借位标志位（无符号数溢出），比方说：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> res;</span><br><span class="line">     res = x + y;</span><br><span class="line">     <span class="keyword">if</span> ((unsigned) res &lt; (unsigned) x) <span class="comment">// carry set?  //</span></span><br><span class="line">        res++;</span><br><span class="line">     return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="惰性评估计算-Lazy-Evaluation-Exploitation"><a href="#惰性评估计算-Lazy-Evaluation-Exploitation" class="headerlink" title="惰性评估计算 / Lazy Evaluation Exploitation"></a>惰性评估计算 / Lazy Evaluation Exploitation</h2><p>在类似与这样的 if(a&gt;10 &amp;&amp; b=4) 语句中, 确保AND表达式的第一部分最有可能为false, 结果第二部分极有可能不被执行.<br>用switch() 代替if&#8230;else&#8230;，在条件选择比较多的情况下，可以用if…else…else…，像这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( val == <span class="number">1</span>)</span><br><span class="line">    dostuff1();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == <span class="number">2</span>)</span><br><span class="line">    dostuff2();</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (val == <span class="number">3</span>)</span><br><span class="line">    dostuff3();</span><br></pre></td></tr></table></figure></p>
<p>使用switch可以更快：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>( val )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: dostuff1(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: dostuff2(); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>: dostuff3(); <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在if语句中，即使是最后一个条件成立，也要先判断所有前面的条件是否成立。Switch语句能够去除这些额外的工作。如果你不得不使用if…else，那就把最可能的成立的条件放在前面。</p>
<h2 id="二分分解-Binary-Breakdown"><a href="#二分分解-Binary-Breakdown" class="headerlink" title="二分分解 / Binary Breakdown"></a>二分分解 / Binary Breakdown</h2><p>把判断条件做成二进制的风格，比如，不要使用下面的列表：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a == <span class="number">1</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">3</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">4</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">5</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">6</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">7</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">8</span>) &#123; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而采用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt;= <span class="number">4</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">2</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">3</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">4</span>) &#123; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">5</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">6</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">7</span>) &#123; </span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(a == <span class="number">8</span>) &#123; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>甚至：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a &lt;= <span class="number">4</span>) &#123; </span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">1</span>) &#123; </span><br><span class="line">                <span class="comment">/* a is 1 */</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">/* a must be 2 */</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">3</span>) &#123; </span><br><span class="line">                <span class="comment">/* a is 3 */</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">/* a must be 4 */</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    <span class="keyword">if</span>(a &lt;= <span class="number">6</span>) &#123; </span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">5</span>) &#123; </span><br><span class="line">                <span class="comment">/* a is 5 */</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">/* a must be 6 */</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">if</span>(a == <span class="number">7</span>) &#123; </span><br><span class="line">                <span class="comment">/* a is 7 */</span> </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">                <span class="comment">/* a must be 8 */</span> </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>慢速、低效：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = getch();</span><br><span class="line"><span class="keyword">switch</span>(c)&#123;</span><br><span class="line">    <span class="keyword">case</span> A: &#123;</span><br><span class="line">        <span class="keyword">do</span> something;  </span><br><span class="line">        <span class="keyword">break</span>;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> H: &#123;</span><br><span class="line">        <span class="keyword">do</span> something;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">case</span> Z: &#123; </span><br><span class="line">        <span class="keyword">do</span> something; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>快速、高效：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">c = getch();</span><br><span class="line"><span class="keyword">switch</span>(c) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">        <span class="keyword">do</span> something;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">        <span class="keyword">do</span> something; </span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">        <span class="keyword">do</span> something; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上是两个case语句之间的比较</p>
<h2 id="switch语句和查找表-Switch-statement-vs-lookup-tables"><a href="#switch语句和查找表-Switch-statement-vs-lookup-tables" class="headerlink" title="switch语句和查找表 / Switch statement vs. lookup tables"></a>switch语句和查找表 / Switch statement vs. lookup tables</h2><p>switch语句通常用于以下情况：</p>
<ul>
<li>调用几个函数中的一个</li>
<li>设置一个变量或返回值</li>
<li>执行几个代码片断中的一个</li>
</ul>
<p>如果case表示是密集的，在使用switch语句的前两种情况中，可以使用效率更高的查找表。比如下面的两个实现汇编代码转换成字符串的例程：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Condition_String1</span><span class="params">(<span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(condition) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">0</span>: return EQ;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">1</span>: return NE;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">2</span>: return CS;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">3</span>: return CC;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">4</span>: return MI;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">5</span>: return PL;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">6</span>: return VS;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">7</span>: return VC;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">8</span>: return HI;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">9</span>: return LS;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">10</span>: return GE;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">11</span>: return LT;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">12</span>: return GT;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">13</span>: return LE;</span><br><span class="line">         <span class="keyword">case</span> <span class="number">14</span>: return ;</span><br><span class="line">         <span class="keyword">default</span>: return <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">Condition_String2</span><span class="params">(<span class="keyword">int</span> condition)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((unsigned) condition &gt;= <span class="number">15</span>) return <span class="number">0</span>;</span><br><span class="line">    return</span><br><span class="line">          EQNECSCCMIPLVSVCHILSGELTGTLE +</span><br><span class="line">           <span class="number">3</span> * condition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一个例程需要240个字节，第二个只需要72个。</p>
<h2 id="循环终止-Loop-termination"><a href="#循环终止-Loop-termination" class="headerlink" title="循环终止 / Loop termination"></a>循环终止 / Loop termination</h2><p>如果不加留意地编写循环终止条件，就可能会给程序带来明显的负担。我们应该尽量使用“倒数到零”的循环，使用简单的循环终止条件。循环终止条件相对简单，程序在执行的时候也会消耗相对少的时间。拿下面两个计算n!的例子来说，第一个例子使用递增循环，第二个使用递减循环。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact1_func</span> <span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, fact = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        fact *= i;</span><br><span class="line">    return (fact);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact2_func</span><span class="params">(<span class="keyword">int</span> n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, fact = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = n; i != <span class="number">0</span>; i--)</span><br><span class="line">        fact *= i;</span><br><span class="line">    return (fact);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果是，第二个例子要比第一个快得多。</p>
<h2 id="更快的for-循环-Faster-for-loops"><a href="#更快的for-循环-Faster-for-loops" class="headerlink" title="更快的for()循环 / Faster for() loops"></a>更快的for()循环 / Faster for() loops</h2><p>这是一个简单而有效的概念，通常情况下，我们习惯把for循环写成这样：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>( i = <span class="number">0</span>;  i &lt; <span class="number">10</span>;  i++)&#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">i</span> 值依次为：<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span></span><br><span class="line">在不在乎循环计数器顺序的情况下，我们可以这样：</span><br><span class="line">``` c</span><br><span class="line"><span class="function"><span class="title">for</span><span class="params">( i = <span class="number">10</span>;  i--; )</span></span> &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i 值依次为: <span class="number">9,8,7,6</span>,<span class="number">5,4,3,2</span>,<span class="number">1</span>,<span class="number">0</span>,而且循环要更快</span><br><span class="line">这种方法是可行的，因为它是用更快的i&amp;#<span class="number">8211</span><span class="comment">;作为测试条件的，也就是说“i是否为非零数，如果是减一，然后继续”。相对于原先的代码，处理器不得不“把i减去10，结果是否为非零数，如果是，增加i，然后继续”，在紧密循环(tight loop)中，这会产生显著的区别。</span></span><br><span class="line">这种语法看起来有一点陌生，却完全合法。循环中的第三条语句是可选的（无限循环可以写成这样for(<span class="comment">;;)）,下面的写法也可以取得同样的效果：</span></span><br><span class="line">``` c</span><br><span class="line">for(i = <span class="number">10</span><span class="comment">;  i;  i--)&#123;&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">或者:</span><br><span class="line">``` c</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">10</span>;  <span class="built_in">i</span> != <span class="number">0</span>;  <span class="built_in">i</span>--)&#123;&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">我们唯一要小心的地方是要记住循环需要停止在<span class="number">0</span>（如果循环是从<span class="number">50</span><span class="number">-80</span>，这样做就不行了），而且循环的计数器为倒计数方式。</span><br><span class="line">另外，我们还可以把计数器分配到寄存器上，可以产生更为有效的代码。这种将循环计数器初始化成循环次数，然后递减到零的方法，同样适用于<span class="keyword">while</span>和<span class="keyword">do</span>语句。</span><br><span class="line"><span class="attr">## 混合循环/ Loop jamming</span><br><span class="line">在可以使用一个循环的场合，决不要使用两个。但是如果你要在循环中进行大量的工作，超过处理器的指令缓冲区，在这种情况下，使用两个分开的循环可能会更快，因为有可能这两个循环都被完整的保存在指令缓冲区里了。</span><br><span class="line">``` c</span><br><span class="line">//原先的代码</span><br><span class="line">for(i = 0</span>; i &lt; <span class="number">100</span>; i++)&#123;</span><br><span class="line">    stuff<span class="comment">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">for<span class="comment">(i = 0; i &lt; 100; i++)</span>&#123;</span><br><span class="line">    morestuff<span class="comment">()</span>;</span><br><span class="line">&#125;        </span><br><span class="line"><span class="comment">//更好的做法</span></span><br><span class="line">for<span class="comment">(i = 0; i &lt; 100; i++)</span>&#123;</span><br><span class="line">    stuff<span class="comment">()</span>;</span><br><span class="line">    morestuff<span class="comment">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数循环-Function-Looping"><a href="#函数循环-Function-Looping" class="headerlink" title="函数循环 / Function Looping"></a>函数循环 / Function Looping</h2><p>调用函数的时候，在性能上就会付出一定的代价。不光要改变程序指针，还要将那些正在使用的变量压入堆栈，分配新的变量空间。为了提高程序的效率，在程序的函数结构上，有很多工作可以做。保证程序的可读性的同时，还要尽量控制程序的大小。<br>如果一个函数在一个循环中被频繁调用，就可以考虑将这个循环放在函数的里面，这样可以免去重复调用函数的负担，比如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">100</span> ; i++) </span><br><span class="line">&#123; </span><br><span class="line">    func(t,i); </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> w, d)</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">    lots of stuff. </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以写成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func(t);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(w)</span> </span><br><span class="line"></span>&#123; </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123; </span><br><span class="line">        <span class="comment">//lots of stuff. </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="展开循环-Loop-unrolling"><a href="#展开循环-Loop-unrolling" class="headerlink" title="展开循环 / Loop unrolling"></a>展开循环 / Loop unrolling</h2><p>为了提高效率，可以将小的循环解开，不过这样会增加代码的尺寸。循环被拆开后，会降低循环计数器更新的次数，减少所执行的循环的分支数目。如果循环只重复几次，那它完全可以被拆解开，这样，由循环所带来的额外开销就会消失。<br>比如:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123; </span><br><span class="line">    something(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更高效的方式：</span></span><br><span class="line">something(<span class="number">0</span>);</span><br><span class="line">something(<span class="number">1</span>);</span><br><span class="line">something(<span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为在每次的循环中，<span class="built_in">i</span> 的值都会增加，然后检查是否有效。编译器经常会把这种简单的循环解开，前提是这些循环的次数是固定的。对于这样的循环：</span><br><span class="line">``` c</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt;  limit; <span class="built_in">i</span>++) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">就不可能被拆解，因为我们不知道它循环的次数到底是多少。不过，将这种类型的循环拆解开并不是不可能的。</span><br><span class="line">与简单循环相比，下面的代码的长度要长很多，然而具有高得多的效率。选择<span class="number">8</span>作为分块大小，只是用来演示，任何合适的长度都是可行的。例子中，循环的成立条件每八次才被检验一次，而不是每次都要检验。如果需要处理的数组的大小是确定的，我们就可以使用数组的大小作为分块的大小（或者是能够整除数组长度的数值）。不过，分块的大小跟系统的缓存大小有关。</span><br><span class="line">``` c</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.H&gt;</span> #define BLOCKSIZE (8) 	</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span><br><span class="line"></span>&#123; </span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">    <span class="keyword">int</span> limit = <span class="number">33</span>;  <span class="comment">/* could be anything */</span> </span><br><span class="line">    <span class="keyword">int</span> blocklimit;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The limit may not be divisible by BLOCKSIZE, </span><br><span class="line">      go as near as we can first, then tidy up.</span><br><span class="line">     */</span> </span><br><span class="line">    blocklimit = (limit / BLOCKSIZE) * BLOCKSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* unroll the loop in blocks of 8 */</span> </span><br><span class="line">    <span class="keyword">while</span>(i &lt; blocklimit) &#123; </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i); </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i+<span class="number">1</span>); </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i+<span class="number">2</span>); </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i+<span class="number">3</span>); </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i+<span class="number">4</span>); </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i+<span class="number">5</span>); </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i+<span class="number">6</span>); </span><br><span class="line">        <span class="built_in">printf</span>(process(%d)\n, i+<span class="number">7</span>); </span><br><span class="line">        <span class="comment">/* update the counter */</span> </span><br><span class="line">        i += <span class="number">8</span>; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">/* </span><br><span class="line">     * There may be some left to do.</span><br><span class="line">     * This could be done as a simple for() loop, </span><br><span class="line">     * but a switch is faster (and more interesting) </span><br><span class="line">     */</span> </span><br><span class="line">    <span class="keyword">if</span>( i &lt; limit ) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">/* Jump into the case at the place that will allow</span><br><span class="line">         * us to finish off the appropriate number of items. </span><br><span class="line">         */</span> </span><br><span class="line">        <span class="keyword">switch</span>( limit - i ) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span> : <span class="built_in">printf</span>(process(%d)\n, i); i++; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span> : <span class="built_in">printf</span>(process(%d)\n, i); i++; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span> : <span class="built_in">printf</span>(process(%d)\n, i); i++; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span> : <span class="built_in">printf</span>(process(%d)\n, i); i++; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span> : <span class="built_in">printf</span>(process(%d)\n, i); i++; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span> : <span class="built_in">printf</span>(process(%d)\n, i); i++; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span> : <span class="built_in">printf</span>(process(%d)\n, i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&nbsp;</p>
<h2 id="计算非零位的个数-counting-the-number-of-bits-set"><a href="#计算非零位的个数-counting-the-number-of-bits-set" class="headerlink" title="计算非零位的个数 / counting the number of bits set"></a>计算非零位的个数 / counting the number of bits set</h2><p>例1：测试单个的最低位，计数，然后移位。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countbit1</span><span class="params">(uint n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>) bits++;</span><br><span class="line">            n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">      return bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>例2：先除4，然后计算被4处的每个部分。循环拆解经常会给程序优化带来新的机会。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//example - 2</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countbit2</span><span class="params">(uint n)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>) bits++;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">2</span>) bits++;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">4</span>) bits++;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">8</span>) bits++;</span><br><span class="line">            n &gt;&gt;= <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    return bits;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="尽早地退出循环-Early-loop-breaking"><a href="#尽早地退出循环-Early-loop-breaking" class="headerlink" title="尽早地退出循环 / Early loop breaking"></a>尽早地退出循环 / Early loop breaking</h2><p>通常没有必要遍历整个循环。举例来说，在数组中搜索一个特定的值，我们可以在找到我们需要值之后立刻退出循环。下面的例子在10000个数字中搜索-99。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">found = FALSE; </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>[i] == <span class="number">-99</span>) &#123; </span><br><span class="line">         found = TRUE; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>(found) <span class="built_in">printf</span>(Yes, there is a <span class="number">-99.</span> Hooray!\n);</span><br></pre></td></tr></table></figure></p>
<p>这样做是可行的，但是不管这个被搜索到的项目出现在什么位置，都会搜索整个数组。跟好的方法是，再找到我们需要的数字以后，立刻退出循环。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">found = FALSE; </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">list</span>[i] == <span class="number">-99</span> ) &#123; </span><br><span class="line">        found = TRUE; </span><br><span class="line">        <span class="keyword">break</span>; </span><br><span class="line">    &#125; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span>( found ) <span class="built_in">printf</span>(Yes, there is a <span class="number">-99.</span> Hooray!\n);</span><br></pre></td></tr></table></figure></p>
<p>如果数字出现在位置23上，循环就会终止，忽略剩下的9977个。</p>
<h2 id="函数设计-Function-Design"><a href="#函数设计-Function-Design" class="headerlink" title="函数设计 / Function Design"></a>函数设计 / Function Design</h2><p>保持函数短小精悍，是对的。这可以使编译器能够跟高效地进行其他的优化，比如寄存器分配。</p>
<h2 id="调用函数的开销-Function-call-overhead"><a href="#调用函数的开销-Function-call-overhead" class="headerlink" title="调用函数的开销 / Function call overhead"></a>调用函数的开销 / Function call overhead</h2><p>对处理器而言，调用函数的开销是很小的，通常，在被调用函数所进行的工作中，所占的比例也很小。能够使用寄存器传递的函数参数个数是有限制的。这些参数可以是整型兼容的（char,short,int以及float都占用一个字），或者是4个字以内的结构体（包括2个字的double和long long）。假如参数的限制是4，那么第5个及后面的字都会被保存到堆栈中。这会增加在调用函数是存储这些参数的，以及在被调用函数中恢复这些参数的代价。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d)</span> </span>&#123; </span><br><span class="line">    return a + b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">g1</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    return f1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="keyword">int</span> e, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    return a + b + c + d + e + f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ing <span class="title">g2</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    return f2(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>g2函数中，第5、6个参数被保存在堆栈中，在f2中被恢复，每个参数带来2次内存访问。</p>
<h2 id="最小化参数传递的开销-Minimizing-parameter-passing-overhead"><a href="#最小化参数传递的开销-Minimizing-parameter-passing-overhead" class="headerlink" title="最小化参数传递的开销 / Minimizing parameter passing overhead"></a>最小化参数传递的开销 / Minimizing parameter passing overhead</h2><p>为了将传递参数给函数的代价降至最低，我们可以：<br>尽可能确保函数的形参不多于四个，甚至更少，这样就不会使用堆栈来传递参数。<br>如果一个函数形参多于四个，那就确保在这个函数能够做大量的工作，这样就可以抵消由传递堆栈参数所付出的代价。<br>用指向结构体的指针作形参，而不是结构体本身。<br>把相关的参数放到一个结构里里面，然后把它的指针传给函数，可以减少参数的个数，增加程序的可读性。<br>将long类型的参数的个数降到最小，因为它使用两个参数的空间。对于double也同样适用。<br>避免出现参数的一部分使用寄存器传输，另一部分使用堆栈传输的情况。这种情况下参数将被全部压到堆栈里。<br>避免出现函数的参数个数不定的情况。这种情况下，所有参数都使用堆栈。</p>
<h2 id="叶子函数-Leaf-functions"><a href="#叶子函数-Leaf-functions" class="headerlink" title="叶子函数 / Leaf functions"></a>叶子函数 / Leaf functions</h2><p>如果一个函数不再调用其他函数，这样的函数被称为叶子函数。在许多应用程序中，大约一半的函数调用是对叶子函数的调用。叶子函数在所有平台上都可以得到非常高效的编译，因为他们不需要进行参数的保存和恢复。在入口压栈和在出口退栈的代价，跟一个足够复杂的需要4个或者5个参数的叶子函数所完成的工作相比，是非常小的。如果可能的话，我们就要尽量安排经常被调用的函数成为叶子函数。函数被调用的次数可以通过模型工具（profiling facility）来确定。这里有几种方法可以确保函数被编译成叶子函数：</p>
<ul>
<li>不调用其他函数：包括那些被转换成调用C语言库函数的运算，比如除法、浮点运算。</li>
<li>使用关键字__inline修饰小的函数。</li>
</ul>
<h2 id="内联函数-Inline-functions"><a href="#内联函数-Inline-functions" class="headerlink" title="内联函数 / Inline functions"></a>内联函数 / Inline functions</h2><p>对于所有调试选项，内嵌函数是被禁止的。使用inline关键字修饰函数后，跟普通的函数调用不同，代码中对该函数的调用将会被函数体本身代替。这会使代码更快，另一方面它会影响代码的长度，尤其是内嵌函数比较大而且经常被调用的情况下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">__<span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">square</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    return x * x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    return <span class="built_in">sqrt</span>(square(x) + square(y));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用内嵌函数有几个优点：</p>
<ul>
<li>没有调用函数的开销。</li>
</ul>
<p>因为函数被直接代替，没有任何额外的开销，比如存储和恢复寄存器。</p>
<ul>
<li>更低的参数赋值开销。</li>
</ul>
<p>参数传递的开销通常会更低，因为它不需要复制变量。如果其中一些参数是常量，编译器还可以作进一步的优化。<br>内嵌函数的缺点是如果函数在许多地方被调用，将会增加代码的长度。长度差别的大小非常依赖于内嵌函数的大小和调用的次数。<br>仅将少数关键函数设置成内嵌函数是明智的。如果设置得当，内嵌函数可以减少代码的长度，一次函数调用需要一定数量的指令，但是，使用优化过的内嵌函数可以编译成更少的指令。</p>
<h2 id="使用查找表-Using-Lookup-Tables"><a href="#使用查找表-Using-Lookup-Tables" class="headerlink" title="使用查找表 / Using Lookup Tables"></a>使用查找表 / Using Lookup Tables</h2><p>有些函数可以近似成查找表，这样可以显著的提高效率。查找表的精度一般比计算公式的精度低，不过在大多数程序中，这种精度就足够了。<br>许多信号处理软件（比如MODEM调制软件）会大量的使用sin和cos函数，这些函数会带来大量的数学运算。对于实时系统来说，精度不是很重要，sin/cos查找表显得更加实用。使用查找表的时候，尽量将相近的运算合并成一个查找表，这样要比使用多个查找表要更快和使用更少的空间。</p>
<h2 id="浮点运算-Floating-Point-Arithmetic"><a href="#浮点运算-Floating-Point-Arithmetic" class="headerlink" title="浮点运算 / Floating-Point Arithmetic"></a>浮点运算 / Floating-Point Arithmetic</h2><p>尽管浮点运算对于任何处理器来讲都是很费时间的，有的时候，我们还是不得不用到浮点运算，比方说实现信号处理。尽管如此，编写浮点运算代码的时候，我们要牢记：</p>
<ul>
<li>浮点除法是慢的</li>
</ul>
<p>除法要比加法或者乘法慢两倍，我们可以把被一个常数除的运算写成被这个数的倒数乘（比如，x=x/3.0写成x=x*(1.0/3.0)）。倒数的计算在编译阶段就被完成。</p>
<ul>
<li>使用float代替double</li>
</ul>
<p>Float型变量消耗更少的内存和寄存器，而且因为它的低精度所以具有更高的效率。在精度足够的情况下，就要使用float。</p>
<ul>
<li>不要使用先验函数（transcendental functions），</li>
</ul>
<p>先验函数（比如sin，cos，log）是通过使用一系列的乘法和加法实现的，所以这些运算会比普通的乘法慢10倍以上。</p>
<ul>
<li>简化浮点表达式</li>
</ul>
<p>编译器在整型跟浮点型混合的运算中不会进行太多的优化。比如3 * (x / 3) 不会被优化成x，因为浮点运算通常会导致精度的降低，甚至表达式的顺序都是重要的： (a + b) 　　  + c 不等于 a + (b + c)。因此，进行手动的优化是有好处的。<br>不过，在特定的场合下，浮点运算的效率达不到指定的水平，这种情况下，最好的办法可能是放弃浮点运算，转而使用定点运算。当变量的变化范围足够的小，定点运算要比浮点运算精度更高、速度更快。</p>
<h2 id="其他的技巧-Misc-tips"><a href="#其他的技巧-Misc-tips" class="headerlink" title="其他的技巧 / Misc tips"></a>其他的技巧 / Misc tips</h2><ul>
<li>一般情况下，可以用存储空间换取时间。你可以缓存那些经常用到的数据，而不是每次都重新计算、或者重新装载。比如sin/cos表，或者伪随机数的表（如果你不是真的需要随机数，你可以在开始的时候计算1000个，在随后的代码中重复利用就是了）</li>
<li>尽量少的使用全局变量。</li>
<li>将一个文件内部的变量声明成静态的，除非它有必要成为全局的。</li>
<li>不要使用递归。递归可以使代码非常整齐和美观，但会产生大量的函数调用和开销。</li>
<li>访问单维数组要比多维数组快</li>
<li>使用#defined宏代替经常用到的小函数。</li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[skip list跳跃表实现]]></title>
      <url>http://www.ezlippi.com/blog/2014/12/skip-list.html</url>
      <content type="html"><![CDATA[<p>跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。跳表的具体定义，<br> 跳表是由William Pugh发明的，这位确实是个大牛，搞出一些很不错的东西。简单说来跳表也是</p>
<p>链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(log n)的时间复杂<br><a id="more"></a><br>度。红黑树等这样的平衡数据结构查找的时间复杂度也是O(log n)，并且相对于红黑树这样的平衡二叉树skiplist的优点是更好的支持并</p>
<p>发操作，但是要实现像红黑树这样的数据结构并非易事,但是只要你熟悉链表的基本操作,再加之对跳表原理的理解，实现一个跳表数据</p>
<p>结构就是一个很自然的事情了。</p>
<p>此外，跳表在当前热门的开源项目中也有很多应用，比如LevelDB的核心数据结构memtable是用跳表实现的，redis的sorted set数据</p>
<p>结构也是有跳表实现的。</p>
<h2 id="skiplist主要思想"><a href="#skiplist主要思想" class="headerlink" title="skiplist主要思想"></a>skiplist主要思想</h2><p>先从链表开始，如果是一个简单的链表（不一定有序），那么我们在链表中查找一个元素X的话，需要将遍历整个链表直到找到元素X为止。</p>
<p>现在我们考虑一个有序的链表：</p>
<p> <img src="/images/images/githubpages/skiplist1.jpg" alt=""></p>
<p>从该有序表中搜索元素 {13, 39} ，需要比较的次数分别为 {3, 5}，总共比较的次数为 3 + 5 = 8 次。我们想下有没有更优的算法?  我们想到了对于</p>
<p>有序数组查找问题我们可以使用二分查找算法，但对于有序链表却不能使用二分查找。这个时候我们在想下平衡树,比如BST,他们都是通过把一些</p>
<p>节点取出来作为其节点下某种意义的索引，比如父节点一般大于左子节点而小于右子节点。因此这个时候我们想到类似二叉搜索树的做法把一些</p>
<p>节点提取出来，作为索引。得到如下结构：<br> <img src="/images/images/githubpages/skiplist2.jpg" alt=""></p>
<p>在这个结构里我们把{3, 18, 77}提取出来作为一级索引，这样搜索的时候就可以减少比较次数了,比如在搜索39时仅比较了3次(通过比较3,18,39)。</p>
<p>当然我们还可以再从一级索引提取一些元素出来，作为二级索引,这样更能加快元素搜索。</p>
<p>这基本上就是跳表的核心思想，其实是一种通过“空间来换取时间”的一个算法，通过在每个节点中增加了向前的指针(即层)，从而提升查找的效率。</p>
<p>跳跃列表是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的「快速跑道」，这里在层 i 中的元素按某个固定的概率 p (通常</p>
<p>为0.5或0.25)出现在层 i+1 中。平均起来，每个元素都在 1/(1-p) 个列表中出现, 而最高层的元素（通常是在跳跃列表前端的一个特殊的头元素）</p>
<p>在 O(log1/p n) 个列表中出现。</p>
<h2 id="SkipList基本数据结构及其实现"><a href="#SkipList基本数据结构及其实现" class="headerlink" title="SkipList基本数据结构及其实现"></a>SkipList基本数据结构及其实现</h2><p>一个跳表，应该具有以下特征：</p>
<p>1,一个跳表应该有几个层（level）组成；</p>
<p>2,跳表的第一层包含所有的元素；</p>
<p>3,每一层都是一个有序的链表；</p>
<p>4,如果元素x出现在第i层，则所有比i小的层都包含x；</p>
<p>5,每个节点包含key及其对应的value和一个指向同一层链表的下个节点的指针数组</p>
<p>如图所示。<br> <img src="/images/images/githubpages/skiplist3.jpg" alt=""></p>
<p><strong>跳表基本数据结构</strong></p>
<p>定义跳表数据类型：</p>
<pre><code>//跳表结构  
typedef struct skip_list  
{  
    int level;// 层数  
    Node *head;//指向头结点  
} skip_list;  
</code></pre><p>其中level是当前跳表最大层数,head是指向跳表的头节点如上图。</p>
<p>跳表的每个节点的数据结构：</p>
<pre><code>typedef struct node  
{  
    keyType key;// key值  
    valueType value;// value值  
    struct node *next[1];// 后继指针数组，柔性数组 可实现结构体的变长  
} Node;  
</code></pre><p>对于这个结构体重点说说，struct node *next[1] 其实它是个柔性数组，主要用于使结构体包含可变长字段。我们可以通过如下方法得到包含可变</p>
<p>层数(n)的Node *类型的内存空间:</p>
<pre><code>#define new_node(n)((Node*)malloc(sizeof(Node)+n*sizeof(Node*)))
</code></pre><p>通过上面我们可以根据层数n来申请指定大小的内存，从而节省了不必要的内存空间(比如固定大小的next数组就会浪费大量的内存空间)。</p>
<p><strong>跳表节点的创建</strong></p>
<pre><code>// 创建节点  
Node *create_node(int level, keyType key, valueType val)  
{  
    Node *p=new_node(level);  
    if(!p)  
        return NULL;  
    p-&gt;key=key;  
    p-&gt;value=val;  
    return p;  
}  
</code></pre><p><strong>跳表的创建</strong></p>
<p>列表的初始化需要初始化头部，并使头部每层（根据事先定义的MAX_LEVEL）指向末尾（NULL）</p>
<pre><code>//创建跳跃表  
skip_list *create_sl()  
{  
    skip_list *sl=(skip_list*)malloc(sizeof(skip_list));//申请跳表结构内存  
    if(NULL==sl)  
        return NULL;  

    sl-&gt;level=0;// 设置跳表的层level，初始的层为0层（数组从0开始）  

    Node *h=create_node(MAX_L-1, 0, 0);//创建头结点  
    if(h==NULL)  
    {  
        free(sl);  
        return NULL;  
    }  
    sl-&gt;head = h;  
    int i;  
     // 将header的next数组清空  
    for(i=0; i&lt;MAX_L; ++i)  
    {  
        h-&gt;next[i] = NULL;  
    }  
    srand(time(0));  
    return sl;  
}  
</code></pre><p><strong>跳表插入操作</strong></p>
<p>我们知道跳表是一种随机化数据结构，其随机化体现在插入元素的时候元素所占有的层数完全是随机的，层数是通过随机算法产生的:</p>
<pre><code>//插入元素的时候元素所占有的层数完全是随机算法  
int randomLevel()  
{  
    int level=1;  
    while (rand()%2)  
        level++;  
    level=(MAX_L&gt;level)? level:MAX_L;  
    return level;  
}  
</code></pre><p>相当与做一次丢硬币的实验，如果遇到正面(rand产生奇数)，继续丢，遇到反面，则停止，用实验中丢硬币的次数level作为元素占有的层数。</p>
<p>显然随机变量 level 满足参数为 p = 1/2 的几何分布，level 的期望值 E[level] = 1/p = 2. 就是说，各个元素的层数，期望值是 2 层。</p>
<p>由于跳表数据结构整体上是有序的，所以在插入时，需要首先查找到合适的位置，然后就是修改指针（和链表中操作类似），然后更新跳表的</p>
<p>level变量。 跳表的插入总结起来需要三步:</p>
<p>1:查找到待插入位置, 每层跟新update数组;</p>
<p>2:需要随机产生一个层数;</p>
<p>3:从高层至下插入,与普通链表的插入完全相同;</p>
<p>比如插入key为25的节点，如下图:<br> <img src="/images/images/githubpages/skiplist4.jpg" alt=""></p>
<p>对于步骤1,我们需要对于每一层进行遍历并保存这一层中下降的节点(其后继节点为NULL或者后继节点的key大于等于要插入的key)，如下图,<br> <img src="/images/images/githubpages/skiplist5.jpg" alt=""><br>节点中有白色星花标识的节点保存到update数组。</p>
<p>对于步骤2我们上面已经说明了是通过一个随机算法产生一个随机的层数，但是当这个随机产生的层数level大于当前跳表的最大层数时，我们</p>
<p>此时需要更新当前跳表最大层数到level之间的update内容，这时应该更新其内容为跳表的头节点head，想想为什么这么做,呵呵。然后就是更</p>
<p>新跳表的最大层数。</p>
<p>对于步骤3就和普通链表插入一样了，只不过现在是对每一层链表进行插入节点操作。最终的插入结果如图所示，因为新插入key为25的节点level随机</p>
<p>为4大于插入前的最大层数，所以此时跳表的层数为4。</p>
<p>  实现代码如下:</p>
<pre><code>bool insert(skip_list *sl, keyType key, valueType val)  
{  
    Node *update[MAX_L];  
    Node *q=NULL,*p=sl-&gt;head;//q,p初始化  
    int i=sl-&gt;level-1;  
    /******************step1*******************/  
    //从最高层往下查找需要插入的位置,并更新update  
    //即把降层节点指针保存到update数组  
    for( ; i&gt;=0; --i)  
    {  
        while((q=p-&gt;next[i])&amp;&amp; q-&gt;key&lt;key)  
            p=q;  
        update[i]=p;  
    }  
    if(q &amp;&amp; q-&gt;key == key)//key已经存在的情况下  
    {  
        q-&gt;value = val;  
        return true;  
    }  
    /******************step2*******************/  
    //产生一个随机层数level  
    int level = randomLevel();  
    //如果新生成的层数比跳表的层数大  
    if(level&gt;sl-&gt;level)  
    {  
        //在update数组中将新添加的层指向header  
        for(i=sl-&gt;level; i&lt;level; ++i)  
        {  
            update[i]=sl-&gt;head;  
        }  
        sl-&gt;level=level;  
    }  
    //printf(&quot;%d\n&quot;, sizeof(Node)+level*sizeof(Node*));  
    /******************step3*******************/  
    //新建一个待插入节点,一层一层插入  
    q=create_node(level, key, val);  
    if(!q)  
        return false;  

    //逐层更新节点的指针,和普通链表插入一样  
    for(i=level-1; i&gt;=0; --i)  
    {  
        q-&gt;next[i]=update[i]-&gt;next[i];  
            update[i]-&gt;next[i]=q;  
        }  
        return true;  
}  
</code></pre><p><strong>跳表删除节点操作</strong></p>
<p>删除节点操作和插入差不多，找到每层需要删除的位置，删除时和操作普通链表完全一样。不过需要注意的是，如果该节点的level是最大的，</p>
<p>则需要更新跳表的level。实现代码如下:</p>
<pre><code>bool erase(skip_list *sl, keyType key)  
{  
    Node *update[MAX_L];  
    Node *q=NULL, *p=sl-&gt;head;  
    int i = sl-&gt;level-1;  
    for(; i&gt;=0; --i)  
    {  
        while((q=p-&gt;next[i]) &amp;&amp; q-&gt;key &lt; key)  
        {  
            p=q;  
        }  
        update[i]=p;  
    }  
    //判断是否为待删除的key  
    if(!q || (q&amp;&amp;q-&gt;key != key))  
        return false;  

    //逐层删除与普通链表删除一样  
    for(i=sl-&gt;level-1; i&gt;=0; --i)  
    {  
        if(update[i]-&gt;next[i]==q)//删除节点  
        {  
            update[i]-&gt;next[i]=q-&gt;next[i];  
            //如果删除的是最高层的节点,则level--  
            if(sl-&gt;head-&gt;next[i]==NULL)  
                sl-&gt;level--;  
        }  
    }  
    free(q);  
    q=NULL;  
    return true;  
}  
</code></pre><p><strong>跳表的查找操作</strong></p>
<p>跳表的优点就是查找比普通链表快，其实查找操已经在插入、删除操作中有所体现，代码如下：</p>
<pre><code>valueType *search(skip_list *sl, keyType key)  
{  
    Node *q,*p=sl-&gt;head;  
    q=NULL;  
    int i=sl-&gt;level-1;  
    for(; i&gt;=0; --i)  
    {  
        while((q=p-&gt;next[i]) &amp;&amp; q-&gt;key&lt;key)  
        {  
            p=q;  
        }  
        if(q &amp;&amp; key==q-&gt;key)  
            return &amp;(q-&gt;value);  
    }  
    return NULL;  
}  
</code></pre><p><strong>跳表的销毁</strong></p>
<p>上面分别介绍了跳表的创建、节点插入、节点删除，其中涉及了内存的动态分配，在使用完跳表后别忘了释放所申请的内存，不然会内存泄露的。</p>
<p>不多说了，代码如下:</p>
<pre><code>// 释放跳跃表  
void sl_free(skip_list *sl)  
{  
    if(!sl)  
        return;  

    Node *q=sl-&gt;head;  
    Node *next;  
    while(q)  
    {  
        next=q-&gt;next[0];  
        free(q);  
        q=next;  
    }  
    free(sl);  
}  
</code></pre><p>skiplist复杂度分析</p>
<p>skiplist分析如下图<br>  <img src="/images/images/githubpages/skiplist6.jpg" alt=""></p>
<p>参考:</p>
<p><a href="https://www.cs.auckland.ac.nz/software/AlgAnim/niemann/s_skl.htm" target="_blank" rel="external">https://www.cs.auckland.ac.nz/software/AlgAnim/niemann/s_skl.htm</a></p>
<p><a href="http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html" target="_blank" rel="external">http://www.cnblogs.com/xuqiang/archive/2011/05/22/2053516.html</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[值得推荐的C/C++框架和库]]></title>
      <url>http://www.ezlippi.com/blog/2014/12/c-open-project.html</url>
      <content type="html"><![CDATA[<h2 id="值得学习的C语言开源项目"><a href="#值得学习的C语言开源项目" class="headerlink" title="值得学习的C语言开源项目"></a>值得学习的C语言开源项目</h2><h3 id="Libevent"><a href="#Libevent" class="headerlink" title="Libevent"></a>Libevent</h3><p>libev是一个开源的事件驱动库，基于epoll，kqueue等OS提供的基础设施。其以高效出名，它可以将IO事件，定时器，和信号统一起来，统一放在事件处理这一套框架下处理。基于Reactor模式，效率较高，并且代码精简（4.15版本8000多行），是学习事件驱动编程的很好的资源。<br><a id="more"></a><br>下载链接：<a href="https://github.com/libevent/libevent" target="_blank" rel="external">https://github.com/libevent/libevent</a></p>
<h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>Memcached 是一个高性能的分布式内存对象缓存系统，用于动态Web应用以减轻数据库负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提供动态数据库驱动网站的速度。Memcached 基于一个存储键/值对的 hashmap。Memcached-1.4.7的代码量还是可以接受的，只有10K行左右。<br>下载地址：<a href="http://memcached.org/" target="_blank" rel="external">http://memcached.org/</a></p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。Redis支持的操作和数据类型比Memcached要多，现在主要用于缓存，支持主从同步机制，Redis的学习可以参考&lt;<redis设计与实现>&gt;一书。</redis设计与实现></p>
<p>下载地址：<a href="http://redis.io/" target="_blank" rel="external">http://redis.io/</a></p>
<h3 id="Webbench"><a href="#Webbench" class="headerlink" title="Webbench"></a>Webbench</h3><p>Webbench是一个在linux下使用的非常简单的网站压测工具。它使用fork()模拟多个客户端同时访问我们设定的URL，测试网站在压力下工作的性能，最多可以模拟3万个并发连接去测试网站的负载能力。Webbench使用C语言编写, 代码实在太简洁，源码加起来不到600行。</p>
<p>下载链接：<a href="https://github.com/LippiOuYang/WebBench" target="_blank" rel="external">https://github.com/LippiOuYang/WebBenchl</a></p>
<h3 id="APR（Apache-Portable-Runtime）"><a href="#APR（Apache-Portable-Runtime）" class="headerlink" title="APR（Apache Portable Runtime）"></a>APR（Apache Portable Runtime）</h3><p>这是由 Apache 社区维护的 C 开源库，主要提供操作系统相关的功能（文件系统、进程、线程、用户、IPC）。此外还提供了一些网络相关的功能。</p>
<p>APR 原先是 Apache Web 服务器的一个组成部分，后来独立出来，成为一个单独的开源项目。<br>主页：<a href="https://apr.apache.org/" target="_blank" rel="external">https://apr.apache.org</a></p>
<h3 id="NGINX"><a href="#NGINX" class="headerlink" title="NGINX"></a>NGINX</h3><p>Nginx是由俄罗斯软件工程师Igor Sysoev开发的一个高性能的HTTP和反向代理服务器，具备IMAP/POP3和SMTP服务器功能。Nginx最大的特点是对高并发的支持和高效的负载均衡，在高并发的需求场景下，是Apache服务器不错的替代品。目前，包括新浪、腾讯等知名网站已经开始使用Nginx作为Web应用服务器。<br>主页：<a href="http://nginx.org/en/download.html" target="_blank" rel="external">http://nginx.org/en/download.html</a></p>
<h3 id="Tinyhttpd"><a href="#Tinyhttpd" class="headerlink" title="Tinyhttpd"></a>Tinyhttpd</h3><p>tinyhttpd是一个超轻量型Http Server，使用C语言开发，全部代码只有502行(包括注释)，附带一个简单的Client，可以通过阅读这段代码理解一个 Http Server 的本质。</p>
<p>下载链接：<a href="https://github.com/LippiOuYang/Tinyhttpd" target="_blank" rel="external">https://github.com/LippiOuYang/Tinyhttpd</a></p>
<h3 id="cJSON"><a href="#cJSON" class="headerlink" title="cJSON"></a>cJSON</h3><p>cJSON是C语言中的一个JSON编解码器，非常轻量级，C文件只有500多行，速度也非常理想。<br>cJSON也存在几个弱点，虽然功能不是非常强大，但cJSON的小身板和速度是最值得赞赏的。其代码被非常好地维护着，结构也简单易懂，可以作为一个非常好的C语言项目进行学习。</p>
<p>项目主页:<a href="http://sourceforge.net/projects/cjson/" target="_blank" rel="external">http://sourceforge.net/projects/cjson/</a></p>
<h3 id="CMockery"><a href="#CMockery" class="headerlink" title="CMockery"></a>CMockery</h3><p>cmockery是google发布的用于C单元测试的一个轻量级的框架。它很小巧，对其他开源包没有依赖，对被测试代码侵入性小。cmockery的源代码行数不到3K，你阅读一下will_return和mock的源代码就一目了然了。<br>主要特点：</p>
<ul>
<li>免费且开源，google提供技术支持；</li>
<li>轻量级的框架，使测试更加快速简单；</li>
<li>避免使用复杂的编译器特性，对老版本的编译器来讲，兼容性好;</li>
<li>并不强制要求待测代码必须依赖C99标准，这一特性对许多嵌入式系统的开发很有用</li>
</ul>
<p>下载链接：<a href="http://code.google.com/p/cmockery/downloads/list" target="_blank" rel="external">http://code.google.com/p/cmockery/downloads/list</a></p>
<h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><p>Lua很棒，Lua是巴西人发明的，这些都令我不爽，但是还不至于脸红，最多眼红。<br>让我脸红的是Lua的源代码，百分之一百的ANSI C，一点都不掺杂。在任何支持ANSI C编译器的平台上都可以轻松编译通过。我试过，真是一点废话都没有。Lua的代码数量足够小，5.1.4仅仅1.5W行，去掉空白行和注释估计能到1W行。<br>下载地址：<a href="http://www.lua.org/" target="_blank" rel="external">http://www.lua.org/</a></p>
<h3 id="SQLite"><a href="#SQLite" class="headerlink" title="SQLite"></a>SQLite</h3><p>SQLite是一个开源的嵌入式关系数据库，实现自包容、零配置、支持事务的SQL数据库引擎。 其特点是高度便携、使用方便、结构紧凑、高效、可靠。足够小，大致3万行C代码，250K。<br> 下载地址：<a href="http://www.sqlite.org/" target="_blank" rel="external">http://www.sqlite.org/</a> 。</p>
<h3 id="UNIX-v6"><a href="#UNIX-v6" class="headerlink" title="UNIX v6"></a>UNIX v6</h3><p>UNIX V6 的内核源代码包括设备驱动程序在内 约有1 万行，这个数量的源代码，初学者是能够充分理解的。有一种说法是一个人所能理解的代码量上限为1 万行，UNIX V6的内核源代码从数量上看正好在这个范围之内。看到这里，大家是不是也有“如果只有1万行的话没准儿我也能学会”的想法呢？<br>另一方面，最近的操作系统，例如Linux 最新版的内核源代码据说超过了1000 万行。就算不是初学者，想完全理解全部代码基本上也是不可能的。</p>
<p>下载地址：<a href="http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6" target="_blank" rel="external">http://minnie.tuhs.org/cgi-bin/utree.pl?file=V6</a></p>
<h3 id="NETBSD"><a href="#NETBSD" class="headerlink" title="NETBSD"></a>NETBSD</h3><p>NetBSD是一个免费的，具有高度移植性的 UNIX-like 操作系统，是现行可移植平台最多的操作系统，可以在许多平台上执行，从 64bit alpha 服务器到手持设备和嵌入式设备。NetBSD计划的口号是：”Of course it runs NetBSD”。它设计简洁，代码规范，拥有众多先进特性，使得它在业界和学术界广受好评。由于简洁的设计和先进的特征，使得它在生产和研究方面，都有卓越的表现，而且它也有受使用者支持的完整的源代码。许多程序都可以很容易地通过NetBSD Packages Collection获得。</p>
<p>下载地址：<a href="http://www.netbsd.org/" target="_blank" rel="external">http://www.netbsd.org/</a></p>
<h2 id="值得学习的C-开源项目"><a href="#值得学习的C-开源项目" class="headerlink" title="值得学习的C++开源项目"></a>值得学习的C++开源项目</h2><h3 id="LevelDb"><a href="#LevelDb" class="headerlink" title="LevelDb"></a>LevelDb</h3><p>  LevelDb是谷歌两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。<br>  它是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。<br>　　其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。</p>
<p>主页:<a href="https://github.com/google/leveldb" target="_blank" rel="external">https://github.com/google/leveldb</a></p>
<h3 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost.Asio"></a>Boost.Asio</h3><p>  它是异步输入输出的核心。 名字本身就说明了一切：Asio 意即异步输入/输出。该库可以让 C++ 异步地处理数据，且平台独立。异步数据处理就是指，任务触发后不需要等待它们完成。相反，Boost.Asio 会在任务完成时触发一个应用。异步任务的主要优点在于，在等待任务完成时不需要阻塞应用程序，可以去执行其它任务。</p>
<p>异步任务的典型例子是网络应用。如果数据被发送出去了，比如发送至 Internet，通常需要知道数据是否发送成功。 如果没有一个象 Boost.Asio 这样的库，就必须对函数的返回值进行求值。但是，这样就要求待至所有数据发送完毕，并得到一个确认或是错误代码。而使用 Boost.Asio，这个过程被分为两个单独的步骤：第一步是作为一个异步任务开始数据传输。 一旦传输完成，不论成功或是错误，应用程序都会在第二步中得到关于相应的结果通知.主要的区别在于，应用程序无需阻塞至传输完成，而可以在这段时间里执行其它操作。</p>
<p>主页：<a href="http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio.html" target="_blank" rel="external">http://www.boost.org/doc/libs/1_58_0/doc/html/boost_asio.html</a></p>
<h3 id="SGI-STL"><a href="#SGI-STL" class="headerlink" title="SGI STL"></a>SGI STL</h3><p>SGI STL是STL代码的经典实现版本，虽然很多编译器不直接使用这个版本，但是很多却在此基础之上进行改进的。比如GNU C++的标准库就是在此基础之上改进的。这份代码还有一个好处是有注释，代码书写非常规范，只要花些时间读懂它并非难事。</p>
<p>主页：<a href="https://www.sgi.com/tech/stl/download.html" target="_blank" rel="external">https://www.sgi.com/tech/stl/download.html</a></p>
<h4 id="Muduo"><a href="#Muduo" class="headerlink" title="Muduo"></a>Muduo</h4><p>muduo 是一个基于 Reactor 模式的现代 C++ 网络库，它采用非阻塞 IO 模型，基于事件驱动和回调，原生支持多核多线程，适合编写 Linux 服务端多线程网络应用程序。</p>
<p>主页:<a href="https://github.com/chenshuo/muduo" target="_blank" rel="external">https://github.com/chenshuo/muduo</a></p>
<h2 id="C-资源大全"><a href="#C-资源大全" class="headerlink" title="C++ 资源大全"></a>C++ 资源大全</h2><p></p><p>关于 C++ 框架、库和资源的一些汇总列表，内容包括：标准库、Web应用框架、人工智能、数据库、图片处理、机器学习、日志、代码分析等。</p><p></p>
<p></p><p>&nbsp;</p><p></p>
<p></p><h3>标准库</h3><p></p>
<p></p><p>C++标准库，包括了STL容器，算法和函数等。</p><p></p>
<ul><br><li><a href="http://en.wikipedia.org/wiki/C%2B%2B_Standard_Library" target="_blank">C++ Standard Library</a>：是一系列类和函数的集合，使用核心语言编写，也是C++ISO自身标准的一部分。</li><br><li><a href="http://en.wikipedia.org/wiki/Standard_Template_Library" target="_blank">Standard Template Library</a>：标准模板库</li><br><li><a href="http://en.wikipedia.org/wiki/C_POSIX_library" target="_blank">C POSIX library</a> ： POSIX系统的C标准库规范</li><br><li><a href="https://github.com/cplusplus" target="_blank">ISO C++ Standards Committee</a> ：C++标准委员会</li><br></ul><br><p>&nbsp;</p><br><h3>框架</h3><br><p>C++通用框架和库</p><br><ul><br><li><a href="http://stdcxx.apache.org/" target="_blank">Apache C++ Standard Library</a>：是一系列算法，容器，迭代器和其他基本组件的集合</li><br><li><a href="http://stlab.adobe.com/" target="_blank">ASL</a> ：Adobe源代码库提供了同行的评审和可移植的C++源代码库。</li><br><li><a href="https://github.com/boostorg" target="_blank">Boost</a> ：大量通用C++库的集合。</li><br><li><a href="https://github.com/bloomberg/bde" target="_blank">BDE</a> ：来自于彭博资讯实验室的开发环境。</li><br><li><a href="http://libcinder.org/" target="_blank">Cinder</a>：提供专业品质创造性编码的开源开发社区。</li><br><li><a href="http://ryan.gulix.cl/fossil.cgi/cxxomfort/" target="_blank">Cxxomfort</a>：轻量级的，只包含头文件的库，将C++ 11的一些新特性移植到C++03中。</li><br><li><a href="http://dlib.net/" target="_blank">Dlib</a>：使用契约式编程和现代C++科技设计的通用的跨平台的C++库。</li><br><li><a href="https://github.com/paulhodge/EASTL" target="_blank">EASTL</a> ：EA-STL公共部分</li><br><li><a href="https://github.com/sumeetchhetri/ffead-cpp" target="_blank">ffead-cpp</a> ：企业应用程序开发框架</li><br><li><a href="https://github.com/facebook/folly" target="_blank">Folly</a>：由Facebook开发和使用的开源C++库</li><br><li><a href="https://github.com/julianstorer/JUCE" target="_blank">JUCE</a> ：包罗万象的C++类库，用于开发跨平台软件</li><br><li><a href="https://github.com/facebook/libphenom" target="_blank">libPhenom</a>：用于构建高性能和高度可扩展性系统的事件框架。</li><br><li><a href="https://github.com/sourcey/libsourcey" target="_blank">LibSourcey</a> ：用于实时的视频流和高性能网络应用程序的C++11 evented IO</li><br><li><a href="https://github.com/koanlogic/libu" target="_blank">LibU</a> ： C语言写的多平台工具库</li><br><li><a href="http://loki-lib.sourceforge.net/" target="_blank">Loki</a> ：C++库的设计，包括常见的设计模式和习语的实现。</li><br><li><a href="https://code.google.com/p/mili/" target="_blank">MiLi</a> ：只含头文件的小型C++库</li><br><li><a href="http://www.openframeworks.cc/" target="_blank">openFrameworks</a> ：开发C++工具包，用于创意性编码。</li><br><li><a href="http://qt-project.org/" target="_blank">Qt</a> ：跨平台的应用程序和用户界面框架</li><br><li><a href="http://code.google.com/p/reason/" target="_blank">Reason</a> ：跨平台的框架，使开发者能够更容易地使用Java，.Net和Python，同时也满足了他们对C++性能和优势的需求。</li><br><li><a href="http://root.cern.ch/" target="_blank">ROOT</a> ：具备所有功能的一系列面向对象的框架，能够非常高效地处理和分析大量的数据，为欧洲原子能研究机构所用。</li><br><li><a href="http://www.stlport.org/" target="_blank">STLport</a>：是STL具有代表性的版本</li><br><li><a href="http://stxxl.sourceforge.net/" target="_blank">STXXL</a>：用于额外的大型数据集的标准模板库。</li><br><li><a href="http://www.ultimatepp.org/" target="_blank">Ultimate++</a> ：C++跨平台快速应用程序开发框架</li><br><li><a href="http://sourceforge.net/projects/wtl/" target="_blank">Windows Template Library</a>：用于开发Windows应用程序和UI组件的C++库</li><br><li><a href="https://github.com/jll63/yomm11" target="_blank">Yomm11</a> ：C++11的开放multi-methods.</li><br></ul><br><p>&nbsp;</p><br><h3>人工智能</h3><br><ul><br><li><a href="https://github.com/aigamedev/btsk" target="_blank">btsk</a> ：游戏行为树启动器工具</li><br><li><a href="http://eodev.sourceforge.net/" target="_blank">Evolving Objects</a>：基于模板的，ANSI C++演化计算库，能够帮助你非常快速地编写出自己的随机优化算法。</li><br><li><a href="https://github.com/andrometa/neu" target="_blank">Neu</a>：C++11框架，编程语言集，用于创建人工智能应用程序的多用途软件系统。</li><br></ul><br><p>&nbsp;</p><br><h3>异步事件循环</h3><br><ul><br><li><a href="http://think-async.com/" target="_blank">Boost.Asio</a>：用于网络和底层I/O编程的跨平台的C++库。</li><br><li><a href="http://libev.schmorp.de/" target="_blank">libev</a> ：功能齐全，高性能的时间循环，轻微地仿效libevent，但是不再像libevent一样有局限性，也修复了它的一些bug。</li><br><li><a href="http://libevent.org/" target="_blank">libevent</a> ：事件通知库</li><br><li><a href="https://github.com/joyent/libuv" target="_blank">libuv</a> ：跨平台异步I/O。</li><br></ul><br><p>&nbsp;</p><br><h3>音频</h3><br><p>音频，声音，音乐，数字化音乐库</p><br><ul><br><li><a href="http://www.fmod.org/" target="_blank">FMOD</a> ：易于使用的跨平台的音频引擎和音频内容的游戏创作工具。</li><br><li><a href="https://github.com/micknoise/Maximilian" target="_blank">Maximilian</a> ：C++音频和音乐数字信号处理库</li><br><li><a href="http://www.openal.org/" target="_blank">OpenAL</a> ：开源音频库&#8212;跨平台的音频API</li><br><li><a href="http://opus-codec.org/" target="_blank">Opus</a>：一个完全开放的，免版税的，高度通用的音频编解码器</li><br><li><a href="http://www.speex.org/" target="_blank">Speex</a>：免费编解码器，为Opus所废弃</li><br><li><a href="https://github.com/TonicAudio/Tonic" target="_blank">Tonic</a>： C++易用和高效的音频合成</li><br><li><a href="http://xiph.org/vorbis/" target="_blank">Vorbis</a>： Ogg Vorbis是一种完全开放的，非专有的，免版税的通用压缩音频格式。</li><br></ul><br><p>&nbsp;</p><br><h3>生态学</h3><br><p>生物信息，基因组学和生物技术</p><br><ul><br><li><a href="http://molpopgen.github.io/libsequence/" target="_blank">libsequence</a>：用于表示和分析群体遗传学数据的C++库。</li><br><li><a href="http://www.seqan.de/" target="_blank">SeqAn</a>：专注于生物数据序列分析的算法和数据结构。</li><br><li><a href="https://github.com/ekg/vcflib" target="_blank">Vcflib</a> ：用于解析和处理VCF文件的C++库</li><br><li><a href="https://github.com/jewmanchue/wham" target="_blank">Wham</a>：直接把联想测试应用到BAM文件的基因结构变异。</li><br></ul><br><p>&nbsp;</p><br><h3>压缩</h3><br><p>压缩和归档库</p><br><ul><br><li><a href="http://www.bzip.org/" target="_blank">bzip2</a>：一个完全免费，免费专利和高质量的数据压缩</li><br><li><a href="https://bitbucket.org/attila_afra/doboz/overview" target="_blank">doboz</a>：能够快速解压缩的压缩库</li><br><li><a href="https://icculus.org/physfs/" target="_blank">PhysicsFS</a>：对各种归档提供抽象访问的库，主要用于视频游戏，设计灵感部分来自于Quake3的文件子系统。</li><br><li><a href="https://projects.kde.org/projects/frameworks/karchive" target="_blank">KArchive</a>：用于创建，读写和操作文件档案（例如zip和 tar）的库，它通过QIODevice的一系列子类，使用gzip格式，提供了透明的压缩和解压缩的数据。</li><br><li><a href="https://code.google.com/p/lz4/" target="_blank">LZ4</a> ：非常快速的压缩算法</li><br><li><a href="https://code.google.com/p/lzham/" target="_blank">LZHAM</a> ：无损压缩数据库，压缩比率跟LZMA接近，但是解压缩速度却要快得多。</li><br><li><a href="http://www.7-zip.org/sdk.html" target="_blank">LZMA</a> ：7z格式默认和通用的压缩方法。</li><br><li><a href="http://www.matcode.com/lzmat.htm" target="_blank">LZMAT</a> ：及其快速的实时无损数据压缩库</li><br><li><a href="https://code.google.com/p/miniz/" target="_blank">miniz</a>：单一的C源文件，紧缩/膨胀压缩库，使用zlib兼容API，ZIP归档读写，PNG写方式。</li><br><li><a href="https://github.com/nmoinvaz/minizip" target="_blank">Minizip</a>：Zlib最新bug修复，支持PKWARE磁盘跨越，AES加密和IO缓冲。</li><br><li><a href="https://code.google.com/p/snappy/" target="_blank">Snappy</a> ：快速压缩和解压缩</li><br><li><a href="http://zlib.net/" target="_blank">ZLib</a> ：非常紧凑的数据流压缩库</li><br><li><a href="http://zziplib.sourceforge.net/" target="_blank">ZZIPlib</a>：提供ZIP归档的读权限。</li><br></ul><br><p>&nbsp;</p><br><h3>并发性</h3><br><p>并发执行和多线程</p><br><ul><br><li><a href="https://github.com/kylelutz/compute" target="_blank">Boost.Compute</a> ：用于OpenCL的C++GPU计算库</li><br><li><a href="https://github.com/HSA-Libraries/Bolt" target="_blank">Bolt</a> ：针对GPU进行优化的C++模板库</li><br><li><a href="https://github.com/schlangster/cpp.react" target="_blank">C++React</a> ：用于C++11的反应性编程库</li><br><li><a href="https://www.threadingbuildingblocks.org/" target="_blank">Intel TBB</a> ：Intel线程构件块</li><br><li><a href="https://github.com/libclsph/libclsph" target="_blank">Libclsph</a>：基于OpenCL的GPU加速SPH流体仿真库</li><br><li><a href="https://www.khronos.org/opencl/" target="_blank">OpenCL</a> ：并行编程的异构系统的开放标准</li><br><li><a href="http://openmp.org/" target="_blank">OpenMP</a>：OpenMP API</li><br><li><a href="http://thrust.github.io/" target="_blank">Thrust</a> ：类似于C++标准模板库的并行算法库</li><br><li><a href="https://github.com/STEllAR-GROUP/hpx/" target="_blank">HPX</a> ：用于任何规模的并行和分布式应用程序的通用C++运行时系统</li><br><li><a href="https://github.com/ddemidov/vexcl" target="_blank">VexCL</a> ：用于OpenCL/CUDA 的C++向量表达式模板库。</li><br></ul><br><p>&nbsp;</p><br><h3>容器</h3><br><ul><br><li><a href="https://code.google.com/p/cpp-btree/" target="_blank">C++ B-tree</a> ：基于B树数据结构，实现命令内存容器的模板库</li><br><li><a href="https://github.com/goossaert/hashmap" target="_blank">Hashmaps</a>： C++中开放寻址哈希表算法的实现</li><br></ul><br><p>&nbsp;</p><br><h3>密码学</h3><br><ul><br><li><a href="http://bcrypt.sourceforge.net/" target="_blank">Bcrypt</a> ：一个跨平台的文件加密工具，加密文件可以移植到所有可支持的操作系统和处理器中。</li><br><li><a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank">BeeCrypt</a>：</li><br><li><a href="http://botan.randombit.net/" target="_blank">Botan</a>： C++加密库</li><br><li><a href="http://www.cryptopp.com/" target="_blank">Crypto++</a>：一个有关加密方案的免费的C++库</li><br><li><a href="https://www.gnupg.org/" target="_blank">GnuPG</a>： OpenPGP标准的完整实现</li><br><li><a href="http://www.gnutls.org/" target="_blank">GnuTLS</a> ：实现了SSL，TLS和DTLS协议的安全通信库</li><br><li><a href="http://www.gnu.org/software/libgcrypt/" target="_blank">Libgcrypt</a></li><br><li><a href="https://github.com/fffaraz/awesome-cpp/blob/master" target="_blank">libmcrypt</a></li><br><li><a href="http://www.libressl.org/" target="_blank">LibreSSL</a>：免费的SSL/TLS协议，属于2014 OpenSSL的一个分支</li><br><li><a href="https://github.com/libtom/libtomcrypt" target="_blank">LibTomCrypt</a>：一个非常全面的，模块化的，可移植的加密工具</li><br><li><a href="https://github.com/jedisct1/libsodium" target="_blank">libsodium</a>：基于NaCI的加密库，固执己见，容易使用</li><br><li><a href="http://www.lysator.liu.se/~nisse/nettle/" target="_blank">Nettle</a> 底层的加密库</li><br><li><a href="http://www.openssl.org/" target="_blank">OpenSSL</a> ： 一个强大的，商用的，功能齐全的，开放源代码的加密库。</li><br><li><a href="https://github.com/kokke/tiny-AES128-C" target="_blank">Tiny AES128 in C</a> ：用C实现的一个小巧，可移植的实现了AES128ESB的加密算法</li><br></ul><br><p>&nbsp;</p><br><h3>数据库</h3><br><p>数据库，SQL服务器，ODBC驱动程序和工具</p><br><ul><br><li><a href="https://github.com/paulftw/hiberlite" target="_blank">hiberlite</a> ：用于Sqlite3的C++对象关系映射</li><br><li><a href="https://github.com/redis/hiredis" target="_blank">Hiredis</a>： 用于Redis数据库的很简单的C客户端库</li><br><li><a href="https://github.com/google/leveldb" target="_blank">LevelDB</a>： 快速键值存储库</li><br><li><a href="http://symas.com/mdb/" target="_blank">LMDB</a>：符合数据库四大基本元素的嵌入键值存储</li><br><li><a href="http://www.tangentsoft.net/mysql++/" target="_blank">MySQL++</a>：封装了MySql的C API的C++ 包装器</li><br><li><a href="https://github.com/facebook/rocksdb" target="_blank">RocksDB</a>：来自Facebook的嵌入键值的快速存储</li><br><li><a href="http://www.sqlite.org/" target="_blank">SQLite</a>：一个完全嵌入式的，功能齐全的关系数据库，只有几百KB，可以正确包含到你的项目中。</li><br></ul><br><p>&nbsp;</p><br><h3>调试</h3><br><p>调试库， 内存和资源泄露检测，单元测试</p><br><ul><br><li><a href="http://www.boost.org/doc/libs/master/libs/test/doc/html/index.html" target="_blank">Boost.Test</a>：Boost测试库</li><br><li><a href="https://github.com/philsquared/Catch" target="_blank">Catch</a>：一个很时尚的，C++原生的框架，只包含头文件，用于单元测试，测试驱动开发和行为驱动开发。</li><br><li><a href="http://www.freedesktop.org/wiki/Software/cppunit/" target="_blank">CppUnit</a>：由JUnit移植过来的C++测试框架</li><br><li><a href="http://www.cmake.org/cmake/help/v2.8.8/ctest.html" target="_blank">CTest</a>：CMake测试驱动程序</li><br><li><a href="http://code.google.com/p/googletest/" target="_blank">googletest</a>：谷歌C++测试框架</li><br><li><a href="https://github.com/deplinenoise/ig-debugheap" target="_blank">ig-debugheap</a>：用于跟踪内存错误的多平台调试堆</li><br><li><a href="https://github.com/zorgnax/libtap" target="_blank">libtap</a>：用C语言编写测试</li><br><li><a href="http://www.almostinfinite.com/memtrack.html" target="_blank">MemTrack</a> —用于C++跟踪内存分配</li><br><li><a href="https://bitbucket.org/jonasmeyer/microprofile/overview" target="_blank">microprofile</a>- 跨平台的网络试图分析器</li><br><li><a href="http://www.jera.com/techinfo/jtns/jtn002.html" target="_blank">minUnit</a> ：使用C写的迷你单元测试框架，只使用了两个宏</li><br><li><a href="https://github.com/Celtoys/Remotery" target="_blank">Remotery</a>：用于web视图的单一C文件分析器</li><br><li><a href="http://unittest-cpp.sourceforge.net/" target="_blank">UnitTest++</a>：轻量级的C++单元测试框架</li><br></ul><br><p>&nbsp;</p><br><h3>游戏引擎</h3><br><ul><br><li><a href="http://www.cocos2d-x.org/" target="_blank">Cocos2d-x</a> ：一个跨平台框架，用于构建2D游戏，互动图书，演示和其他图形应用程序。</li><br><li><a href="http://gritengine.com/" target="_blank">Grit</a> ：社区项目，用于构建一个免费的游戏引擎，实现开放的世界3D游戏。</li><br><li><a href="http://irrlicht.sourceforge.net/" target="_blank">Irrlicht</a> ：C++语言编写的开源高性能的实时#D引擎</li><br><li><a href="http://polycode.org/" target="_blank">Polycode</a>：C++实现的用于创建游戏的开源框架（与Lua绑定）。</li><br></ul><br><p>&nbsp;</p><br><h3>图形用户界面</h3><br><ul><br><li><a href="http://cegui.org.uk/" target="_blank">CEGUI</a> ： 很灵活的跨平台GUI库</li><br><li><a href="http://www.fltk.org/index.php" target="_blank">FLTK</a> ：快速，轻量级的跨平台的C++GUI工具包。</li><br><li><a href="http://www.gtk.org/" target="_blank">GTK+</a>： 用于创建图形用户界面的跨平台工具包</li><br><li><a href="http://www.gtkmm.org/en/" target="_blank">gtkmm</a> ：用于受欢迎的GUI库GTK+的官方C++接口。</li><br><li><a href="https://github.com/ocornut/imgui" target="_blank">imgui</a>：拥有最小依赖关系的立即模式图形用户界面</li><br><li><a href="http://librocket.com/" target="_blank">libRocket</a> ：<a href="http://librocket.com/" target="_blank">libRocket</a> 是一个C++ HTML/CSS 游戏接口中间件</li><br><li><a href="http://mygui.info/" target="_blank">MyGUI</a> ：快速，灵活，简单的GUI</li><br><li><a href="http://invisible-island.net/ncurses/" target="_blank">Ncurses</a>：终端用户界面</li><br><li><a href="http://qcustomplot.com/" target="_blank">QCustomPlot</a> ：没有更多依赖关系的Qt绘图控件</li><br><li><a href="http://qwt.sourceforge.net/" target="_blank">Qwt</a> ：用户与技术应用的Qt 控件</li><br><li><a href="http://qwtplot3d.sourceforge.net/" target="_blank">QwtPlot3D</a> ：功能丰富的基于Qt/OpenGL的C++编程库，本质上提供了一群3D控件</li><br><li><a href="https://github.com/Twolewis/OtterUI" target="_blank">OtterUI</a> ：<a href="https://github.com/Twolewis/OtterUI" target="_blank">OtterUI</a> 是用于嵌入式系统和互动娱乐软件的用户界面开发解决方案</li><br><li><a href="http://pdcurses.sourceforge.net/" target="_blank">PDCurses</a> 包含源代码和预编译库的公共图形函数库</li><br><li><a href="http://wxwidgets.org/" target="_blank">wxWidgets</a> C++库，允许开发人员使用一个代码库可以为widows， Mac OS X，Linux和其他平台创建应用程序</li><br></ul><br><p>&nbsp;</p><br><h3>图形</h3><br><ul><br><li><a href="https://github.com/bkaradzic/bgfx" target="_blank">bgfx</a>：跨平台的渲染库</li><br><li><a href="http://www.cairographics.org/" target="_blank">Cairo</a>：支持多种输出设备的2D图形库</li><br><li><a href="https://github.com/horde3d/Horde3D" target="_blank">Horde3D</a> 一个小型的3D渲染和动画引擎</li><br><li><a href="https://github.com/mosra/magnum" target="_blank">magnum</a> C++11和OpenGL 2D/3D 图形引擎</li><br><li><a href="http://www.ogre3d.org/" target="_blank">Ogre 3D</a> 用C++编写的一个面向场景，实时，灵活的3D渲染引擎（并非游戏引擎）</li><br><li><a href="http://www.openscenegraph.org/" target="_blank">OpenSceneGraph</a> 具有高性能的开源3D图形工具包</li><br><li><a href="http://www.panda3d.org/" target="_blank">Panda3D</a> 用于3D渲染和游戏开发的框架，用Python和C++编写。</li><br><li><a href="https://github.com/google/skia" target="_blank">Skia</a> 用于绘制文字，图形和图像的完整的2D图形库</li><br><li><a href="https://github.com/urho3d/Urho3D" target="_blank">urho3d</a> 跨平台的渲染和游戏引擎。</li><br></ul><br><p>&nbsp;</p><br><h3>图像处理</h3><br><ul><br><li><a href="http://www.boost.org/doc/libs/1_56_0/libs/gil/doc/index.html" target="_blank">Boost.GIL</a>：通用图像库</li><br><li><a href="http://cimg.sourceforge.net/" target="_blank">CImg</a> ：用于图像处理的小型开源C++工具包</li><br><li><a href="http://www.xdp.it/cximage.htm" target="_blank">CxImage</a> ：用于加载，保存，显示和转换的图像处理和转换库，可以处理的图片格式包括 BMP, JPEG, GIF, PNG, TIFF, MNG, ICO, PCX, TGA, WMF, WBMP, JBG, J2K。</li><br><li><a href="http://freeimage.sourceforge.net/" target="_blank">FreeImage</a> ：开源库，支持现在多媒体应用所需的通用图片格式和其他格式。</li><br><li><a href="http://gdcm.sourceforge.net/wiki/index.php/Main_Page" target="_blank">GDCM</a>：Grassroots DICOM 库</li><br><li><a href="http://www.itk.org/" target="_blank">ITK</a>：跨平台的开源图像分析系统</li><br><li><a href="http://www.imagemagick.org/script/api.php" target="_blank">Magick++</a>：ImageMagick程序的C++接口</li><br><li><a href="http://www.imagemagick.org/script/api.php" target="_blank">MagickWnd</a>：ImageMagick程序的C++接口</li><br><li><a href="http://opencv.org/" target="_blank">OpenCV</a> ： 开源计算机视觉类库</li><br><li><a href="https://code.google.com/p/tesseract-ocr/" target="_blank">tesseract-ocr</a>：OCR引擎</li><br><li><a href="https://github.com/ukoethe/vigra" target="_blank">VIGRA</a> ：用于图像分析通用C++计算机视觉库</li><br><li><a href="http://www.vtk.org/" target="_blank">VTK</a> ：用于3D计算机图形学，图像处理和可视化的开源免费软件系统。</li><br></ul><br><p>&nbsp;</p><br><h3>国际化</h3><br><ul><br><li><a href="http://www.gnu.org/software/gettext/" target="_blank">gettext</a> ：GNU `gettext&#8217;</li><br><li><a href="http://site.icu-project.org/" target="_blank">IBM ICU</a>：提供Unicode 和全球化支持的C、C++ 和Java库</li><br><li><a href="http://www.gnu.org/software/libiconv/" target="_blank">libiconv</a> ：用于不同字符编码之间的编码转换库</li><br></ul><br><p>&nbsp;</p><br><h3>Jason</h3><br><ul><br><li><a href="https://github.com/cesanta/frozen" target="_blank">frozen</a> ： C/C++的Jason解析生成器</li><br><li><a href="https://github.com/akheron/jansson" target="_blank">Jansson</a> ：进行编解码和处理Jason数据的C语言库</li><br><li><a href="https://github.com/chrismanning/jbson" target="_blank">jbson</a> ：C++14中构建和迭代BSON data,和Json 文档的库</li><br><li><a href="https://github.com/jeaye/jeayeson" target="_blank">JeayeSON</a>：非常健全的C++ JSON库，只包含头文件</li><br><li><a href="https://github.com/hjiang/jsonxx" target="_blank">JSON++</a> ： C++ JSON 解析器</li><br><li><a href="https://github.com/udp/json-parser" target="_blank">json-parser</a>：用可移植的ANSI C编写的JSON解析器，占用内存非常少</li><br><li><a href="https://github.com/dropbox/json11" target="_blank">json11</a> ：一个迷你的C++11 JSON库</li><br><li><a href="https://github.com/amir-s/jute" target="_blank">jute</a> ：非常简单的C++ JSON解析器</li><br><li><a href="https://github.com/vincenthz/libjson" target="_blank">ibjson</a>：C语言中的JSON解析和打印库，很容易和任何模型集成。</li><br><li><a href="http://sourceforge.net/projects/libjson/" target="_blank">libjson</a>：轻量级的JSON库</li><br><li><a href="https://github.com/kazuho/picojson" target="_blank">PicoJSON</a>：C++中JSON解析序列化，只包含头文件</li><br><li><a href="https://github.com/gaudecker/qt-json" target="_blank">qt-json</a> ：用于JSON数据和 QVariant层次间的相互解析的简单类</li><br><li><a href="https://github.com/flavio/qjson" target="_blank">QJson</a>：将JSON数据映射到QVariant对象的基于Qt的库</li><br><li><a href="https://github.com/miloyip/rapidjson" target="_blank">RapidJSON</a>： 用于C++的快速JSON 解析生成器，包含SAX和DOM两种风格的API</li><br><li><a href="https://github.com/lloyd/yajl" target="_blank">YAJL</a> ：C语言中快速流JSON解析库</li><br></ul><br><p>&nbsp;</p><br><h3>日志</h3><br><ul><br><li><a href="http://www.boost.org/doc/libs/1_56_0/libs/log/doc/html/index.html" target="_blank">Boost.Log</a> ：设计非常模块化，并且具有扩展性</li><br><li><a href="https://github.com/easylogging/easyloggingpp" target="_blank">easyloggingpp</a>：C++日志库，只包含单一的头文件。</li><br><li><a href="http://log4cpp.sourceforge.net/" target="_blank">Log4cpp</a> ：一系列C++类库，灵活添加日志到文件，系统日志，IDSA和其他地方。</li><br><li><a href="http://www.templog.org/" target="_blank">templog</a>：轻量级C++库，可以添加日志到你的C++应用程序中</li><br></ul><br><p>&nbsp;</p><br><h3>机器学习</h3><br><ul><br><li><a href="https://github.com/BVLC/caffe" target="_blank">Caffe</a> ：快速的神经网络框架</li><br><li><a href="https://github.com/liuliu/ccv" target="_blank">CCV</a> ：以C语言为核心的现代计算机视觉库</li><br><li><a href="http://www.mlpack.org/" target="_blank">mlpack</a> ：可扩展的C++机器学习库</li><br><li><a href="https://github.com/Itseez/opencv" target="_blank">OpenCV</a>：开源计算机视觉库</li><br><li><a href="https://github.com/GHamrouni/Recommender" target="_blank">Recommender</a>：使用协同过滤进行产品推荐/建议的C语言库。</li><br><li><a href="https://github.com/shogun-toolbox/shogun" target="_blank">SHOGUN</a>：Shogun 机器学习工具</li><br><li><a href="https://code.google.com/p/sofia-ml/" target="_blank">sofia-ml</a> ：用于机器学习的快速增量算法套件</li><br></ul><br><p>&nbsp;</p><br><h3>数学</h3><br><ul><br><li><a href="http://arma.sourceforge.net/" target="_blank">Armadillo</a> ：高质量的C++线性代数库，速度和易用性做到了很好的平衡。语法和MatlAB很相似</li><br><li><a href="https://code.google.com/p/blaze-lib/" target="_blank">blaze</a>：高性能的C++数学库，用于密集和稀疏算法。</li><br><li><a href="http://ceres-solver.org/" target="_blank">ceres-solver</a> ：来自谷歌的C++库，用于建模和解决大型复杂非线性最小平方问题。</li><br><li><a href="http://www.cgal.org/" target="_blank">CGal</a>： 高效，可靠的集合算法集合</li><br><li><a href="http://cmldev.net/" target="_blank">cml</a> ：用于游戏和图形的免费C++数学库</li><br><li><a href="http://eigen.tuxfamily.org/" target="_blank">Eigen</a> ：高级C++模板头文件库，包括线性代数，矩阵，向量操作，数值解决和其他相关的算法。</li><br><li><a href="http://ggt.sourceforge.net/" target="_blank">GMTL</a>：数学图形模板库是一组广泛实现基本图形的工具。</li><br><li><a href="https://gmplib.org/" target="_blank">GMP</a>：用于个高精度计算的C/C++库，处理有符号整数，有理数和浮点数。</li><br></ul><br><p>&nbsp;</p><br><h3>多媒体</h3><br><ul><br><li><a href="http://gstreamer.freedesktop.org/" target="_blank">GStreamer</a> ：构建媒体处理组件图形的库</li><br><li><a href="http://www.live555.com/liveMedia/" target="_blank">LIVE555 Streaming Media</a> ：使用开放标准协议(RTP/RTCP, RTSP, SIP) 的多媒体流库</li><br><li><a href="https://wiki.videolan.org/LibVLC" target="_blank">libVLC</a> ：libVLC (VLC SDK)媒体框架</li><br><li><a href="https://github.com/wang-bin/QtAV" target="_blank">QtAv</a>：基于Qt和FFmpeg的多媒体播放框架，能够帮助你轻而易举地编写出一个播放器</li><br><li><a href="http://www.libsdl.org/" target="_blank">SDL</a> ：简单直控媒体层</li><br><li><a href="http://www.sfml-dev.org/" target="_blank">SFML</a> ：快速，简单的多媒体库</li><br></ul><br><p>&nbsp;</p><br><h3>网络</h3><br><ul><br><li><a href="http://www.cs.wustl.edu/~schmidt/ACE.html" target="_blank">ACE</a>：C++面向对象网络变成工具包</li><br><li><a href="http://think-async.com/" target="_blank">Boost.Asio</a>：用于网络和底层I/O编程的跨平台的C++库</li><br><li><a href="http://casablanca.codeplex.com/" target="_blank">Casablanca</a>：C++ REST SDK</li><br><li><a href="http://cpp-netlib.org/" target="_blank">cpp-netlib</a>：高级网络编程的开源库集合</li><br><li><a href="https://github.com/rxi/dyad" target="_blank">Dyad.c</a>：C语言的异步网络</li><br><li><a href="http://curl.haxx.se/libcurl/" target="_blank">libcurl</a> :多协议文件传输库</li><br><li><a href="https://github.com/cesanta/mongoose" target="_blank">Mongoose</a><span style="text-decoration: underline;">：</span>非常轻量级的网络服务器</li><br><li><a href="https://github.com/chenshuo/muduo" target="_blank">Muduo</a> ：用于Linux多线程服务器的C++非阻塞网络库</li><br><li><a href="https://github.com/cesanta/net_skeleton" target="_blank">net_skeleton</a> ：C/C++的TCP 客户端/服务器库</li><br><li><a href="https://github.com/riolet/nope.c" target="_blank">nope.c</a> ：基于C语言的超轻型软件平台，用于可扩展的服务器端和网络应用。 对于C编程人员，可以考虑node.js</li><br><li><a href="https://github.com/davidmoreno/onion" target="_blank">Onion</a> :C语言HTTP服务器库，其设计为轻量级，易使用。</li><br><li><a href="https://github.com/pocoproject" target="_blank">POCO</a>：用于构建网络和基于互联网应用程序的C++类库，可以运行在桌面，服务器，移动和嵌入式系统。</li><br><li><a href="https://github.com/OculusVR/RakNet" target="_blank">RakNet</a>：为游戏开发人员提供的跨平台的开源C++网络引擎。</li><br><li><a href="https://github.com/vinipsmaker/tufao" target="_blank">Tuf o</a> ：用于Qt之上的C++构建的异步Web框架。</li><br><li><a href="https://github.com/zaphoyd/websocketpp" target="_blank">WebSocket++</a> ：基于C++/Boost Aiso的websocket 客户端/服务器库</li><br><li><a href="http://zeromq.org/" target="_blank">ZeroMQ</a> ：高速，模块化的异步通信库</li><br></ul><br><p>&nbsp;</p><br><h3>物理学</h3><br><p>动力学仿真引擎</p><br><ul><br><li><a href="https://code.google.com/p/box2d/" target="_blank">Box2D</a>：2D的游戏物理引擎。</li><br><li><a href="https://github.com/bulletphysics/bullet3" target="_blank">Bullet</a> ：3D的游戏物理引擎。</li><br><li><a href="https://github.com/slembcke/Chipmunk2D" target="_blank">Chipmunk</a> ：快速，轻量级的2D游戏物理库</li><br><li><a href="https://github.com/google/liquidfun" target="_blank">LiquidFun</a>：2D的游戏物理引擎</li><br><li><a href="http://www.ode.org/" target="_blank">ODE</a> ：开放动力学引擎-开源，高性能库，模拟刚体动力学。</li><br><li><a href="https://github.com/vanderlin/ofxBox2d" target="_blank">ofxBox2d</a>：Box2D开源框架包装器。</li><br><li><a href="https://github.com/simbody/simbody" target="_blank">Simbody</a> ：高性能C++多体动力学/物理库，模拟关节生物力学和机械系统，像车辆，机器人和人体骨骼。</li><br></ul><br><p>&nbsp;</p><br><h3>机器人学</h3><br><ul><br><li><a href="http://moos-ivp.org/" target="_blank">MOOS-IvP</a> ：一组开源C++模块，提供机器人平台的自主权，尤其是自主的海洋车辆。</li><br><li><a href="http://www.mrpt.org/" target="_blank">MRPT</a>：移动机器人编程工具包</li><br><li><a href="https://github.com/PointCloudLibrary/pcl" target="_blank">PCL</a> ：点云库是一个独立的，大规模的开放项目，用于2D/3D图像和点云处理。</li><br><li><a href="http://www.roboticslibrary.org/" target="_blank">Robotics Library (RL)</a>： 一个独立的C++库，包括机器人动力学，运动规划和控制。</li><br><li><a href="http://www.robwork.dk/jrobwork/" target="_blank">RobWork</a>：一组C++库的集合，用于机器人系统的仿真和控制。</li><br><li><a href="http://wiki.ros.org/" target="_blank">ROS</a> ：机器人操作系统，提供了一些库和工具帮助软件开发人员创建机器人应用程序。</li><br></ul><br><p>&nbsp;</p><br><h3>科学计算</h3><br><ul><br><li><a href="http://www.fftw.org/" target="_blank">FFTW</a> :用一维或者多维计算DFT的C语言库。</li><br><li><a href="http://www.gnu.org/software/gsl/" target="_blank">GSL</a>：GNU科学库。</li><br></ul><br><p>&nbsp;</p><br><h3>脚本</h3><br><ul><br><li><a href="https://github.com/ChaiScript/ChaiScript/" target="_blank">ChaiScript</a> ：用于C++的易于使用的嵌入式脚本语言。</li><br><li><a href="http://www.lua.org/" target="_blank">Lua</a> ：用于配置文件和基本应用程序脚本的小型快速脚本引擎。</li><br><li><a href="https://github.com/dafrito/luacxx" target="_blank">luacxx</a>：用于创建Lua绑定的C++ 11 API</li><br><li><a href="http://www.swig.org/" target="_blank">SWIG</a> ：一个可以让你的C++代码链接到JavaScript，Perl，PHP，Python，Tcl和Ruby的包装器/接口生成器</li><br><li><a href="https://github.com/cesanta/v7" target="_blank">V7</a>：嵌入式的JavaScript 引擎。</li><br><li><a href="http://code.google.com/p/v8/" target="_blank">V8</a> ：谷歌的快速JavaScript引擎，可以被嵌入到任何C++应用程序中。</li><br></ul><br><p>&nbsp;</p><br><h3>序列化</h3><br><ul><br><li><a href="http://kentonv.github.io/capnproto/" target="_blank">Cap&#8217;n Proto</a> ：快速数据交换格式和RPC系统。</li><br><li><a href="https://github.com/USCiLab/cereal" target="_blank">cereal</a> ：C++11 序列化库</li><br><li><a href="https://github.com/google/flatbuffers" target="_blank">FlatBuffers</a> ：内存高效的序列化库</li><br><li><a href="https://github.com/msgpack/msgpack-c" target="_blank">MessagePack</a> ：C/C++的高效二进制序列化库，例如 JSON</li><br><li><a href="http://code.google.com/p/protobuf/" target="_blank">protobuf</a> ：协议缓冲，谷歌的数据交换格式。</li><br><li><a href="https://github.com/protobuf-c/protobuf-c" target="_blank">protobuf-c</a> ：C语言的协议缓冲实现</li><br><li><a href="https://github.com/real-logic/simple-binary-encoding" target="_blank">SimpleBinaryEncoding</a>：用于低延迟应用程序的对二进制格式的应用程序信息的编码和解码。</li><br><li><a href="https://thrift.apache.org/" target="_blank">Thrift</a> ：高效的跨语言IPC/RPC，用于C++，Java，Python，PHP，C#和其它多种语言中，最初由Twitter开发。</li><br></ul><br><p>&nbsp;</p><br><h3>视频</h3><br><ul><br><li><a href="http://www.webmproject.org/code/" target="_blank">libvpx</a> ：VP8/VP9编码解码SDK</li><br><li><a href="https://www.ffmpeg.org/" target="_blank">FFmpeg</a> ：一个完整的，跨平台的解决方案，用于记录，转换视频和音频流。</li><br><li><a href="https://github.com/strukturag/libde265" target="_blank">libde265</a> ：开放的h.265视频编解码器的实现。</li><br><li><a href="https://github.com/cisco/openh264" target="_blank">OpenH264</a>：开源H.364 编解码器。</li><br><li><a href="http://www.theora.org/" target="_blank">Theora</a> ：免费开源的视频压缩格式。</li><br></ul><br><p>&nbsp;</p><br><h3>虚拟机</h3><br><ul><br><li><a href="https://github.com/tekknolagi/carp" target="_blank">CarpVM</a>：C中有趣的VM，让我们一起来看看这个。</li><br><li><a href="https://github.com/micropython/micropython" target="_blank">MicroPython</a> ：旨在实现单片机上Python3.x的实现</li><br><li><a href="https://github.com/jakogut/tinyvm" target="_blank">TinyVM</a>：用纯粹的ANSI C编写的小型，快速，轻量级的虚拟机。</li><br></ul><br><p>&nbsp;</p><br><h3>Web应用框架</h3><br><ul><br><li><a href="https://github.com/bel2125/civetweb" target="_blank">Civetweb</a> ：提供易于使用，强大的，C/C++嵌入式Web服务器，带有可选的CGI，SSL和Lua支持。</li><br><li><a href="http://cppcms.com/" target="_blank">CppCMS</a> ：免费高性能的Web开发框架（不是 CMS）.</li><br><li><a href="https://github.com/ipkn/crow" target="_blank">Crow</a> ：一个C++微型web框架（灵感来自于Python Flask）</li><br><li><a href="https://kore.io/" target="_blank">Kore</a> :使用C语言开发的用于web应用程序的超快速和灵活的web服务器/框架。</li><br><li><a href="http://www.coralbits.com/libonion/" target="_blank">libOnion</a>：轻量级的库，帮助你使用C编程语言创建web服务器。</li><br><li><a href="https://github.com/jlaine/qdjango/" target="_blank">QDjango</a>：使用C++编写的，基于Qt库的web框架，试图效仿Django API，因此得此名。</li><br><li><a href="http://www.webtoolkit.eu/wt" target="_blank">Wt</a> ：开发Web应用的C++库。</li><br></ul><br><p>&nbsp;</p><br><h3>XML</h3><br><p>XML就是个垃圾，xml的解析很烦人，对于计算机它也是个灾难。这种糟糕的东西完全没有存在的理由了。-Linus Torvalds</p><br><ul><br><li><a href="http://www.libexpat.org/" target="_blank">Expat</a> ：用C语言编写的xml解析库</li><br><li><a href="http://xmlsoft.org/" target="_blank">Libxml2</a> ：Gnome的xml C解析器和工具包</li><br><li><a href="http://libxmlplusplus.sourceforge.net/" target="_blank">libxml++</a> ：C++的xml解析器</li><br><li><a href="http://pugixml.org/" target="_blank">PugiXML</a> ：用于C++的，支持XPath的轻量级，简单快速的XML解析器。</li><br><li><a href="http://rapidxml.sourceforge.net/" target="_blank">RapidXml</a> ：试图创建最快速的XML解析器，同时保持易用性，可移植性和合理的W3C兼容性。</li><br><li><a href="http://sourceforge.net/projects/tinyxml/" target="_blank">TinyXML</a> ：简单小型的C++XML解析器，可以很容易地集成到其它项目中。</li><br><li><a href="https://github.com/leethomason/tinyxml2" target="_blank">TinyXML2</a>：简单快速的C++CML解析器，可以很容易集成到其它项目中。</li><br><li><a href="https://code.google.com/p/ticpp/" target="_blank">TinyXML++</a>：TinyXML的一个全新的接口，使用了C++的许多许多优势，模板，异常和更好的异常处理。</li><br><li><a href="http://xerces.apache.org/xerces-c/" target="_blank">Xerces-C++</a> ：用可移植的C++的子集编写的XML验证解析器。</li><br></ul><br><p>&nbsp;</p><br><h3>多项混杂</h3><br><p>一些有用的库或者工具，但是不适合上面的分类，或者还没有分类。</p><br><ul><br><li><a href="https://github.com/cppformat/cppformat" target="_blank">C++ Format</a> ：C++的小型，安全和快速格式化库</li><br><li><a href="https://code.google.com/p/casacore/" target="_blank">casacore</a> ：从aips++ 派生的一系列C++核心库</li><br><li><a href="https://github.com/louisdx/cxx-prettyprint" target="_blank">cxx-prettyprint</a>：用于C++容器的打印库</li><br><li><a href="http://www.dynaforms.com/" target="_blank">DynaPDF</a> ：易于使用的PDF生成库</li><br><li><a href="https://github.com/leafsr/gcc-poison" target="_blank">gcc-poison</a> ：帮助开发人员禁止应用程序中的不安全的C/C++函数的简单的头文件。</li><br><li><a href="http://code.google.com/p/googlemock/" target="_blank">googlemock</a>：编写和使用C++模拟类的库</li><br><li><a href="https://github.com/joyent/http-parser" target="_blank">HTTP Parser</a> ：C的http请求/响应解析器</li><br><li><a href="https://github.com/anrieff/libcpuid" target="_blank">libcpuid</a> ：用于x86 CPU检测盒特征提取的小型C库</li><br><li><a href="https://github.com/avati/libevil" target="_blank">libevil</a> ：许可证管理器</li><br><li><a href="http://www.libusb.org/" target="_blank">libusb</a>：允许移动访问USB设备的通用USB库</li><br><li><a href="http://pcre.org/" target="_blank">PCRE</a>：正则表达式C库，灵感来自于Perl中正则表达式的功能。</li><br><li><a href="http://www.deltavsoft.com/" target="_blank">Remote Call Framework</a> ：C++的进程间通信框架。</li><br><li><a href="http://scintilla.org/" target="_blank">Scintilla</a> ：开源的代码编辑控件</li><br><li><a href="https://github.com/wjwwood/serial" target="_blank">Serial Communication Library</a> ：C++语言编写的跨平台，串口库。</li><br><li><a href="https://github.com/antirez/sds" target="_blank">SDS</a>：C的简单动态字符串库</li><br><li><a href="https://github.com/cesanta/sldr" target="_blank">SLDR</a> ：超轻的DNS解析器</li><br><li><a href="https://github.com/cesanta/slre" target="_blank">SLRE</a>： 超轻的正则表达式库</li><br><li><a href="https://github.com/rtv/Stage" target="_blank">Stage</a> ：移动机器人模拟器</li><br><li><a href="https://code.google.com/p/vartypes/" target="_blank">VarTypes</a>：C++/Qt4功能丰富，面向对象的管理变量的框架。</li><br><li><a href="http://zbar.sourceforge.net/" target="_blank">ZBar</a>：‘条形码扫描器’库，可以扫描照片，图片和视频流中的条形码，并返回结果。</li><br><li><a href="https://github.com/VerbalExpressions/CppVerbalExpressions" target="_blank">CppVerbalExpressions</a> ：易于使用的C++正则表达式</li><br><li><a href="https://github.com/VerbalExpressions/QtVerbalExpressions" target="_blank">QtVerbalExpressions</a>：基于C++ VerbalExpressions 库的Qt库</li><br><li><a href="https://github.com/CopernicaMarketingSoftware/PHP-CPP" target="_blank">PHP-CPP</a>：使用C++来构建PHP扩展的库</li><br><li><a href="http://bstring.sourceforge.net/" target="_blank">Better String</a> ：C的另一个字符串库，功能更丰富，但是没有缓冲溢出问题，还包含了一个C++包装器。</li><br></ul><br><p>&nbsp;</p><br><h3>软件</h3><br><p>用于创建开发环境的软件</p><br><h3>编译器</h3><br><p>C/C++编译器列表</p><br><ul><br><li><a href="http://clang.llvm.org/" target="_blank">Clang</a> :由苹果公司开发的</li><br><li><a href="https://gcc.gnu.org/" target="_blank">GCC</a>：GNU编译器集合</li><br><li><a href="https://software.intel.com/en-us/c-compilers" target="_blank">Intel C++ Compiler</a> ：由英特尔公司开发</li><br><li><a href="http://llvm.org/" target="_blank">LLVM</a> ：模块化和可重用编译器和工具链技术的集合</li><br><li><a href="http://msdn.microsoft.com/en-us/vstudio/hh386302.aspx" target="_blank">Microsoft Visual C++</a> ：MSVC，由微软公司开发</li><br><li><a href="http://www.openwatcom.org/index.php/Main_Page" target="_blank">Open WatCom</a> ：Watcom，C，C++和Fortran交叉编译器和工具</li><br><li><a href="http://bellard.org/tcc/" target="_blank">TCC</a> ：轻量级的C语言编译器</li><br></ul><br><p>&nbsp;</p><br><h3>在线编译器</h3><br><p>在线C/C++编译器列表</p><br><ul><br><li><a href="http://codepad.org/" target="_blank">codepad</a> ：在线编译器/解释器，一个简单的协作工具</li><br><li><a href="http://codetwist.com/" target="_blank">CodeTwist</a>：一个简单的在线编译器/解释器，你可以粘贴的C,C++或者Java代码，在线执行并查看结果</li><br><li><a href="http://coliru.stacked-crooked.com/" target="_blank">coliru</a> ：在线编译器/shell， 支持各种C++编译器</li><br><li><a href="http://gcc.godbolt.org/" target="_blank">Compiler Explorer</a>：交互式编译器，可以进行汇编输出</li><br><li><a href="http://www.compileonline.com/compile_cpp11_online.php" target="_blank">CompileOnline</a>：Linux上在线编译和执行C++程序</li><br><li><a href="http://ideone.com/" target="_blank">Ideone</a> ：一个在线编译器和调试工具，允许你在线编译源代码并执行，支持60多种编程语言。</li><br></ul><br><p>&nbsp;</p><br><h3>调试器</h3><br><p>C/C++调试器列表</p><br><ul><br><li><a href="http://en.wikipedia.org/wiki/Comparison_of_debuggers" target="_blank">Comparison of debuggers</a> ：来自维基百科的调试器列表</li><br><li><a href="https://www.gnu.org/software/gdb" target="_blank">GDB</a> ：GNU调试器</li><br><li><a href="http://valgrind.org/" target="_blank">Valgrind</a>：内存调试，内存泄露检测，性能分析工具。</li><br></ul><br><p>&nbsp;</p><br><h3>集成开发环境（IDE）</h3><br><p>C/C++集成开发环境列表</p><br><ul><br><li><a href="http://www.jetbrains.com/objc/" target="_blank">AppCode</a> ：构建与JetBrains’ IntelliJ IDEA 平台上的用于Objective-C，C,C++，Java和Java开发的集成开发环境</li><br><li><a href="http://www.jetbrains.com/clion/" target="_blank">CLion</a>：来自JetBrains的跨平台的C/C++的集成开发环境</li><br><li><a href="http://www.codeblocks.org/" target="_blank">Code::Blocks</a> ：免费C，C++和Fortran的集成开发环境</li><br><li><a href="http://codelite.org/" target="_blank">CodeLite</a> ：另一个跨平台的免费的C/C++集成开发环境</li><br><li><a href="http://sourceforge.net/projects/orwelldevcpp/" target="_blank">Dev-C++</a>：可移植的C/C++/C++11集成开发环境</li><br><li><a href="http://www.eclipse.org/cdt/" target="_blank">Eclipse CDT</a>：基于Eclipse平台的功能齐全的C和C++集成开发环境</li><br><li><a href="http://www.geany.org/" target="_blank">Geany</a> ：轻量级的快速，跨平台的集成开发环境。</li><br><li><a href="http://www-03.ibm.com/software/products/en/visgen" target="_blank">IBM VisualAge</a> ：来自IBM的家庭计算机集成开发环境。</li><br><li><a href="https://github.com/Sarcasm/irony-mode" target="_blank">Irony-mode</a>：由libclang驱动的用于Emacs的C/C++微模式</li><br><li><a href="https://www.kdevelop.org/" target="_blank">KDevelop</a>：免费开源集成开发环境</li><br><li><a href="http://www.visualstudio.com/" target="_blank">Microsoft Visual Studio</a> ：来自微软的集成开发环境</li><br><li><a href="https://netbeans.org/" target="_blank">NetBeans</a> ：主要用于Java开发的的集成开发环境，也支持其他语言，尤其是PHP，C/C++和HTML5。</li><br><li><a href="http://qt-project.org/" target="_blank">Qt Creator</a>：跨平台的C++，Javascript和QML集成开发环境，也是Qt SDK的一部分。</li><br><li><a href="https://github.com/Andersbakken/rtags" target="_blank">rtags</a>：C/C++的客户端服务器索引，用于 跟基于clang的emacs的集成</li><br><li><a href="https://developer.apple.com/xcode/" target="_blank">Xcode</a> ：由苹果公司开发</li><br><li><a href="https://valloric.github.io/YouCompleteMe/" target="_blank">YouCompleteMe</a>：一个用于Vim的根据你敲的代码快速模糊搜索并进行代码补全的引擎。</li><br></ul><br><p>&nbsp;</p><br><h3>构建系统</h3><br><ul><br><li><a href="https://github.com/rizsotto/Bear" target="_blank">Bear</a> ：用于为clang工具生成编译数据库的工具</li><br><li><a href="https://www.biicode.com/" target="_blank">Biicode</a>：基于文件的简单依赖管理器。</li><br><li><a href="http://www.cmake.org/" target="_blank">CMake</a> ：跨平台的免费开源软件用于管理软件使用独立编译的方法进行构建的过程。</li><br><li><a href="https://github.com/iauns/cpm" target="_blank">CPM</a>：基于CMake和Git的C++包管理器</li><br><li><a href="http://www.fastbuild.org/docs/home.html" target="_blank">FASTBuild</a>：高性能，开源的构建系统，支持高度可扩展性的编译，缓冲和网络分布。</li><br><li><a href="http://martine.github.io/ninja/" target="_blank">Ninja</a> ：专注于速度的小型构建系统</li><br><li><a href="http://www.scons.org/" target="_blank">Scons</a> ：使用Python scipt 配置的软件构建工具</li><br><li><a href="https://github.com/deplinenoise/tundra" target="_blank">tundra</a> ：高性能的代码构建系统，甚至对于非常大型的软件项目，也能提供最好的增量构建次数。</li><br><li><a href="http://gittup.org/tup/" target="_blank">tup</a>：基于文件的构建系统，用于后台监控变化的文件。</li><br></ul><br><p>&nbsp;</p><br><h3>静态代码分析</h3><br><p>提高质量，减少瑕疵的代码分析工具列表</p><br><ul><br><li><a href="http://cppcheck.sourceforge.net/" target="_blank">Cppcheck</a> ：静态C/C++代码分析工具</li><br><li><a href="https://code.google.com/p/include-what-you-use/" target="_blank">include-what-you-use</a> ：使用clang进行代码分析的工具，可以#include在C和C++文件中。</li><br><li><a href="http://oclint.org/" target="_blank">OCLint</a> ：用于C，C++和Objective-C的静态源代码分析工具，用于提高质量，减少瑕疵。</li><br><li><a href="http://clang-analyzer.llvm.org/index.html" target="_blank">Clang Static Analyzer</a>：查找C，C++和Objective-C程序bug的源代码分析工具</li><br><li><a href="http://en.wikipedia.org/wiki/List_of_tools_for_static_code_analysis#C.2FC.2B.2B" target="_blank">List of tools for static code analysis</a> ：来自维基百科的静态代码分析工具列表</li><br></ul>


<p>感谢平凡之路和fffaraz 的整理，转载请注明出处。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[谈谈如何提高web服务器并发性能]]></title>
      <url>http://www.ezlippi.com/blog/2014/12/improve-webServer-performance.html</url>
      <content type="html"><![CDATA[<p>任何一名web工程师都希望自己做的web应用能被越来越多的人使用，如果我们所做的web应用随着用户的增多而宕机了，那么越来越多的人就会变得越来越少了，为了让我们的web应用能有更多人使用，我们就得提升web应用服务端的并发能力。那么我们如何做到这点了，根据现有的并发技术我们会有如下选择：<br><a id="more"></a></p>
<h2 id="为每个连接创建一个线程"><a href="#为每个连接创建一个线程" class="headerlink" title="为每个连接创建一个线程"></a>为每个连接创建一个线程</h2><p>　　第一个做法：为了每个客户端发送给服务端的请求都开启一个线程，等请求处理完毕后该线程就被销毁掉，这种做法很直观，但是在现代的web服务器里这种做法已经很少使用了，原因是<strong>创建一个线程，销毁一个线程的开销（开销是指占用计算机系统资源例如：CPU、内存等）是很大的</strong>，它时常会大于实际处理请求本身的开销，因此这种方式不能充分利用计算机资源，提升并发的效率是有效的，要是还碰到线程安全的问题，使用到线程的锁机制，数据同步技术，并发提升就会受到更大的限制；除此之外，来一个请求就开启一个线程，对线程数量没有任何控制，这就会很容易导致计算机资源被用尽，对于web服务端的稳定性产生很大的威胁。</p>
<h2 id="采用线程池技术"><a href="#采用线程池技术" class="headerlink" title="采用线程池技术"></a>采用线程池技术</h2><p>　　第二个做法：鉴于上面的问题，我们就产生了第二种提高服务端并发量的方法，首先我们不再是一个客户端请求过来就开启一个新线程，请求处理完毕就销毁线程，而是使用一种池技术即线程池技术，线程池技术就是事先创建一批线程，这批线程被放入到一个池子里，在没有请求到达服务端时候，这些线程都是处于待命状态，当请求到达时候，程序会从线程池里取出一个线程，这个线程处理到达的请求，请求处理完毕，该线程不会被销毁，而是被线程池回收，这种方式使用线程我们<strong>降低了随意创建线程和销毁线程所导致系统开销，同时也控制了服务端线程的数量</strong>，一般一个线程对应一个请求，也就控制了并发请求的个数，该方案比第一种方案提升了系统的稳定性（控制并发数量，防止并发过多导致服务程序宕机）同时也提升了并发的数量（原因是减少了创建线程和销毁线程的开销，更充分的利用了计算机的系统资源）。但是做法二也是有很大的问题的，具体如下：</p>
<hr>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>做法二和做法一相比，做法二要好多了，但是这只是和做法一比，如果按照我们设计的目标，做法二并非完美，原因如下：首先做法二会让很多技术不扎实人认为线程池开启多少线程就决定了系统并发的数量，因此出于让系统能处理更多请求以及充分利用计算机资源的考虑，有些人会一开始就把线程池里新建线程的个数设置为最大，一个web应用的并发量在一定时间里都是一个曲线形式，峰值在一定时间范围内都是少数情况，因此一开始就开启最大线程数，自然在大多数时间内都是在浪费系统资源，如果这些被浪费被闲置的计算资源能用来处理请求，或许这些请求处理的效率会更高。此外，一个服务器到底预先开启多少个线程，这个标准很难把控，还有就是不管你用线程池技术还是新建线程的方式，处理请求的数量和线程数量数量是一一对应的关系，如果有一个时间点过来的请求数量正好超出了线程池里线程数量，例如就多了一个，那么这个请求因为找不到对应线程很有可能会被程序所遗弃掉，其实这多的一个请求并没有超出计算机所能承受的负载，而是因为我们程序设计不合理才被遗弃的，这肯定是开发人员所不愿意发生的事情，针对这些问题在java的JDK里提供的线程池做了很好的解决（线程池技术是博大精深的，如果我们没有研究透池技术，还是不要自己去写个而是用现成的）。</p>
<hr>
<h2 id="Java线程池相关实现"><a href="#Java线程池相关实现" class="headerlink" title="Java线程池相关实现"></a>Java线程池相关实现</h2><p>jdk里的线程池对线程池大小的设定使用两个参数，一个是核心线程个数，一个是最大线程个数，核心线程在系统启动时候就会被创建，如果用户请求没有超过核心线程处理能力，那么线程池不会再创建新线程，如果核心线程个数已经处理不过来了，线程池就会开启新线程，新线程第一次创建后，使用完毕后也不是立即对其销毁，也是被会收到线程池里，当线程池里的线程总数超过了最大线程个数，线程池将不会再创建新线程，这种做法让线程数量根据实际请求的情况进行调整，这样既达到了充分利用计算机资源的目的，同时也避免了系统资源的浪费，jdk的线程池还有个超时时间，当超出核心线程的线程在一定时间内一直未被使用，那么这些线程将会被销毁，资源就会被释放，这样就让线程池的线程的数量总是处在一个合理的范围里；如果请求实在太多了，线程池里的线程暂时处理不过来了，jdk的线程池还提供一个队列机制，让这些请求排队等待，当某个线程处理完毕，该线程又会从这个队列里取出一个请求进行处理，这样就避免请求的丢失，jdk的线程池对队列的管理有很多策略，有兴趣的童鞋可以谷歌，这里我还要说的是jdk线程池的安全策略做的很好，如果队列的容量超出了计算机的处理能力，队列会抛弃无法处理的请求，这个也叫做线程池的拒绝策略。</p>
<p>实际上做法二并非最高效的方案，做法二也没有充分利用好计算机的系统资源，我这里还有做法三了，其具体做法如下：</p>
<p>首先我要提出一个问题，并发处理一个任务和单线程的处理同样一个任务，那种方式的效率更高？也许有很多人会认为当然是并发处理任务效率更高了，两个人做一件事情总比一个人要厉害吧，这个问题的答案是要看场景的，在单核时代，单线程处理一个任务的效率往往会比并发方式效率更高，为什么呢？因为多线程在单核即单个cpu上运算，cpu并不是也可以并发处理的，cpu每次都只能处理一个计算任务，因此并发任务对于cpu而言就有线程的上下文切换操作，而这种线程上下文的开销是比较大的，因此单核上处理并发请求不一定会比单线程更有效率，但是如果到了多核的计算机，并发任务平均分配给每一个cpu，那么并发处理的效率就会比单线程处理要高很多，因为此时可以避免线程上下文的切换。</p>
<hr>
<h2 id="网络请求处理的瓶颈在哪？"><a href="#网络请求处理的瓶颈在哪？" class="headerlink" title="网络请求处理的瓶颈在哪？"></a>网络请求处理的瓶颈在哪？</h2><p>对于一个网络请求的处理，是由两个不同类型的操作共同完成，这两个操作是CPU的计算操作和IO操作，如果我们以处理效率角度来评判这两个操作，CPU操作效率是光速的，而IO操作就不尽然了，计算机里的IO操作就是对存储数据介质的操作，计算机里有如下几个介质可以存储数据，它们分别是：CPU的一级缓存、二级缓存、内存、硬盘和网络，一级缓存存储和读取数据的能力接近光速，它比二级缓存快个5倍到6倍，但是不管是一级缓存还是二级缓存，它们存储数据量太少了，做不了什么大事情，下面就是内存了，以一级缓存的效率做参照，一级缓存比内存速度快100多倍，到了硬盘存储和读取数据效率就更慢了，一级缓存比硬盘要快1000多万倍，到了网络就慢的更不像话了，一级缓存比网络要快一亿多倍，可见<strong>一个请求处理的效率瓶颈都是由IO引起的</strong>，而CPU虽然处理很快但是CPU对任务的计算都是一个接着一个处理，假如一个请求首先要等待网络数据的处理再进行CPU运算，那么必然就拖慢了CPU的处理的整体效率，这一慢就是上亿倍了，但是现实中一个网络请求处理就是由这两个操作组合而成的。</p>
<p>对于IO操作在java里有两种方式，一种方式叫做阻塞的IO，一种方式叫做非阻塞的IO（nio），阻塞的IO就是在做IO操作时候，CPU要等待IO操作，这就造成了CPU计算资源的浪费，浪费的程度上文里已经写到了，是很可怕的，因此我们就想当一个请求一个线程做IO操作时候，CPU不用等待它而是接着处理其他的线程和请求，这种做法效率必然很高，这时候非阻塞IO就登场了，非阻塞IO可以在线程进行IO操作时候让CPU去处理别的线程，那么非阻塞IO怎么做到这一点的呢？非阻塞IO操作在请求和cpu计算之间添加了一个中间层（Selector），请求先发到这个中间层，中间层获取了请求后就直接通知请求发送者，请求接收到了，注意这个时候中间层啥都没干，只是接收了请求，真正的计算任务还没开始哦，这个时候中间层如果要CPU处理那么就让cpu处理，如果计算过程到了要进行IO操作，中间层就告诉cpu不用等我了，中间层就让请求做IO操作，CPU这时候可以处理别的请求，等IO操作做完了，中间层再把任务交给CPU去处理，处理完成后，中间层将处理结果再发送给客户端，这种方式就可以充分利用CPU的计算机资源，有了非阻塞IO其实使用单线程也可以开发多线程任务，甚至这个单线程的处理效率可能比多线程更高，因为它没有线程创建销毁的开销，也没有线程上下文切换的开销。</p>
<hr>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实实现一个非阻塞的请求是个大课题，里面使用到了很多先进和复杂的技术例如：回调函数和轮询等，不里要提到的是像java里netty技术，Apache Mina，nginx，php的并发处理都用到这种机制的原理，特别是现在很火的nodejs它产生的原因就是依靠这种非阻塞的技术来编写更高效的web服务器，可以说nodejs把这种技术用到了极致，不过这里要纠正下，非阻塞是针对IO操作的技术，对于nodejs，netty的实现机制有更好的术语描述就是事件驱动（其实就是使用回调函数，观察者模式实现的）以及异步的IO技术（就是非阻塞的IO技术）。现在我们回到做法三的描述，做法三的核心思想就是让每个线程资源利用率更加有效，做法三是建立在做法二的基础上，使用事件驱动的开发思想，采用非阻塞的IO编程模式，当客户端多个请求发到服务端，服务端可以只用一个线程对这些请求进行处理，利用IO操作的性能瓶颈，充分利用CPU的计算能力，这样就达到一个线程处理多个请求的效率并不比多线程差，甚至还高，同时单线程处理能力的增强也会导致整个web服务并发性能的提升。大家可以想想，按这种方式在一个多核服务器下，假如这个服务器有8个内核，每个内核开启一个线程，这8个线程也许就能承载数千并发量，同时也充分利用每个CPU计算能力，如果我们开启线程越多（当然新增的线程数最好是8的倍数，这样对多核利用率更好）那么并发的效率也就更高，提升是按几何倍数进行的，大家想想nginx，它就采用此模式，所以它刚推出来的时候其并发处理能力是apache服务器的数倍，现在nginx已经和apache一样普及了，事件驱动的异步机制功不可没。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[计算机算法--图算法介绍]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/graph.html</url>
      <content type="html"><![CDATA[<h2 id="图的定义："><a href="#图的定义：" class="headerlink" title="图的定义："></a>图的定义：</h2><p>图（graph）由顶点（vertex）和边（edge）的集合组成，每一条边就是一个点对（v,w)。</p>
<p>图的种类：地图，电路图，调度图，事物，网络，程序结构<br><a id="more"></a><br>图的属性：有V个顶点的图最多有V*（V-1）/2条边<br><img src="/images/images/githubpages/graph/graph1.jpg" alt=""><br><img src="/images/images/githubpages/graph/graph2.jpg" alt=""></p>
<h3 id="邻接矩阵："><a href="#邻接矩阵：" class="headerlink" title="邻接矩阵："></a>邻接矩阵：</h3><p>邻接矩阵是一个元素为bool值的V<em>V矩阵，若图中存在一条连接顶点V和W的边，折矩阵adj[v][w]=1,否则为0。占用的空间为V</em>V，当图是稠密时，邻接矩阵是比较合适的表达方法。<br><img src="/images/images/githubpages/graph/graph3.jpg" alt=""></p>
<h3 id="邻接表的表示"><a href="#邻接表的表示" class="headerlink" title="邻接表的表示"></a>邻接表的表示</h3><p>对于非稠密的图，使用邻接矩阵有点浪费存储空间，可以使用邻接表，我们维护一个链表向量，给定一个顶点时，可以立即访问其链表,占用的空间为O(V+E)。<br><img src="/images/images/githubpages/graph/graph4.jpg" alt=""></p>
<hr>
<hr>
<h2 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h2><h3 id="深度优先搜索介绍"><a href="#深度优先搜索介绍" class="headerlink" title="深度优先搜索介绍"></a>深度优先搜索介绍</h3><p>图的深度优先搜索(Depth First Search)，和树的先序遍历比较类似。</p>
<p>它的思想：假设初始状态是图中所有顶点均未被访问，则从某个顶点v出发，首先访问该顶点，然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和v有路径相通的顶点都被访问到。 若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
<p>显然，深度优先搜索是一个递归的过程。</p>
<h3 id="深度优先搜索图解"><a href="#深度优先搜索图解" class="headerlink" title="深度优先搜索图解"></a>深度优先搜索图解</h3><h4 id="无向图的深度优先搜索"><a href="#无向图的深度优先搜索" class="headerlink" title="无向图的深度优先搜索"></a>无向图的深度优先搜索</h4><p>下面以”无向图”为例，来对深度优先搜索进行演示。<br><img src="/images/images/githubpages/graph/graph5.jpg" alt=""><br>对上面的图G1进行深度优先遍历，从顶点A开始。<br><img src="/images/images/githubpages/graph/graph6.jpg" alt=""></p>
<ul>
<li>第1步：访问A。</li>
<li><p>第2步：访问(A的邻接点)C。</p>
<p> 在第1步访问A之后，接下来应该访问的是A的邻接点，即”C,D,F”中的一个。但在本文的实现中，顶点ABCDEFG是按照顺序存储，C在”D和F”的前面，因此，先访问C。 </p>
</li>
<li><p>第3步：访问(C的邻接点)B。</p>
<p> 在第2步访问C之后，接下来应该访问C的邻接点，即”B和D”中一个(A已经被访问过，就不算在内)。而由于B在D之前，先访问B。 </p>
</li>
<li><p>第4步：访问(C的邻接点)D。</p>
<p> 在第3步访问了C的邻接点B之后，B没有未被访问的邻接点；因此，返回到访问C的另一个邻接点D。 </p>
</li>
<li><p>第5步：访问(A的邻接点)F。</p>
<p> 前面已经访问了A，并且访问完了”A的邻接点B的所有邻接点(包括递归的邻接点在内)”；因此，此时返回到访问A的另一个邻接点F。 </p>
</li>
<li><p>第6步：访问(F的邻接点)G。</p>
</li>
<li><p>第7步：访问(G的邻接点)E。</p>
</li>
</ul>
<p>因此访问顺序是：A -&gt; C -&gt; B -&gt; D -&gt; F -&gt; G -&gt; E</p>
<h4 id="有向图的深度优先搜索"><a href="#有向图的深度优先搜索" class="headerlink" title="有向图的深度优先搜索"></a>有向图的深度优先搜索</h4><p>下面以”有向图”为例，来对深度优先搜索进行演示。<br><img src="/images/images/githubpages/graph/graph7.jpg" alt=""><br>对上面的图G2进行深度优先遍历，从顶点A开始。<br><img src="/images/images/githubpages/graph/graph8.jpg" alt=""></p>
<ul>
<li>第1步：访问A。</li>
<li><p>第2步：访问B。</p>
<p> 在访问了A之后，接下来应该访问的是A的出边的另一个顶点，即顶点B。 </p>
</li>
<li><p>第3步：访问C。</p>
<p> 在访问了B之后，接下来应该访问的是B的出边的另一个顶点，即顶点C,E,F。在本文实现的图中，顶点ABCDEFG按照顺序存储，因此先访问C。 </p>
</li>
<li><p>第4步：访问E。</p>
<p> 接下来访问C的出边的另一个顶点，即顶点E。 </p>
</li>
<li><p>第5步：访问D。</p>
</li>
</ul>
<pre><code>接下来访问E的出边的另一个顶点，即顶点B,D。顶点B已经被访问过，因此访问顶点D。 
</code></pre><ul>
<li><p>第6步：访问F。</p>
<p> 接下应该回溯”访问A的出边的另一个顶点F”。 </p>
</li>
<li><p>第7步：访问G。</p>
</li>
</ul>
<p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; D -&gt; F -&gt; G</p>
<hr>
<hr>
<h2 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h2><h3 id="广度优先搜索介绍"><a href="#广度优先搜索介绍" class="headerlink" title="广度优先搜索介绍"></a>广度优先搜索介绍</h3><p>广度优先搜索算法(Breadth First Search)，又称为”宽度优先搜索”或”横向优先搜索”，简称BFS。</p>
<p>它的思想是：从图中某顶点v出发，在访问了v之后依次访问v的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。</p>
<p>换句话说，广度优先搜索遍历图的过程是以v为起点，由近至远，依次访问和v有路径相通且路径长度为1,2…的顶点。</p>
<h3 id="广度优先搜索图解"><a href="#广度优先搜索图解" class="headerlink" title="广度优先搜索图解"></a>广度优先搜索图解</h3><h4 id="无向图的广度优先搜索"><a href="#无向图的广度优先搜索" class="headerlink" title="无向图的广度优先搜索"></a>无向图的广度优先搜索</h4><p>下面以”无向图”为例，来对广度优先搜索进行演示。还是以上面的图G1为例进行说明。<br><img src="/images/images/githubpages/graph/graph9.jpg" alt=""></p>
<ul>
<li>第1步：访问A。</li>
<li><p>第2步：依次访问C,D,F。</p>
<p> 在访问了A之后，接下来访问A的邻接点。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，C在”D和F”的前面，因此，先访问C。再访问完C之后，再依次访问D,F。 </p>
</li>
<li><p>第3步：依次访问B,G。</p>
<p> 在第2步访问完C,D,F之后，再依次访问它们的邻接点。首先访问C的邻接点B，再访问F的邻接点G。 </p>
</li>
<li><p>第4步：访问E。</p>
<p> 在第3步访问完B,G之后，再依次访问它们的邻接点。只有G有邻接点E，因此访问G的邻接点E。</p>
</li>
</ul>
<p>因此访问顺序是：A -&gt; C -&gt; D -&gt; F -&gt; B -&gt; G -&gt; E</p>
<h4 id="有向图的广度优先搜索"><a href="#有向图的广度优先搜索" class="headerlink" title="有向图的广度优先搜索"></a>有向图的广度优先搜索</h4><p>下面以”有向图”为例，来对广度优先搜索进行演示。还是以上面的图G2为例进行说明。<br><img src="/images/images/githubpages/graph/graph10.jpg" alt=""></p>
<ul>
<li>第1步：访问A。</li>
</ul>
<ul>
<li>第2步：访问B。</li>
<li>第3步：依次访问C,E,F。</li>
</ul>
<pre><code>在访问了B之后，接下来访问B的出边的另一个顶点，即C,E,F。前面已经说过，在本文实现中，顶点ABCDEFG按照顺序存储的，因此会先访问C，再依次访问E,F。 
</code></pre><ul>
<li><p>第4步：依次访问D,G。</p>
<p> 在访问完C,E,F之后，再依次访问它们的出边的另一个顶点。还是按照C,E,F的顺序访问，C的已经全部访问过了，那么就只剩下E,F；先访问E的邻接点D，再访问F的邻接点G。</p>
</li>
</ul>
<p>因此访问顺序是：A -&gt; B -&gt; C -&gt; E -&gt; F -&gt; D -&gt; G</p>
<h2 id="搜索算法的源码"><a href="#搜索算法的源码" class="headerlink" title="搜索算法的源码"></a>搜索算法的源码</h2><p>1.邻接矩阵表示的”无向图</p>
<pre><code>    /**
    * C++: 邻接矩阵表示的&quot;无向图(Matrix Undirected Graph)&quot;
    *
    * @author LippiOuYang
    * @date 2013/04/19
    */

        #include &lt;iomanip&gt;
        #include &lt;iostream&gt;
        #include &lt;vector&gt;
        using namespace std;

    #define MAX 100
    class MatrixUDG {
    private:
        char mVexs[MAX];    // 顶点集合
        int mVexNum;             // 顶点数
        int mEdgNum;             // 边数
        int mMatrix[MAX][MAX];   // 邻接矩阵

    public:
        // 创建图(自己输入数据)
        MatrixUDG();
        // 创建图(用已提供的矩阵)
        MatrixUDG(char vexs[], int vlen, char edges[][2], int elen);
        ~MatrixUDG();

        // 深度优先搜索遍历图
        void DFS();
        // 广度优先搜索（类似于树的层次遍历）
        void BFS();
        // 打印矩阵队列图
        void print();

    private:
        // 读取一个输入字符
        char readChar();
        // 返回ch在mMatrix矩阵中的位置
        int getPosition(char ch);
        // 返回顶点v的第一个邻接顶点的索引，失败则返回-1
        int firstVertex(int v);
        // 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1
        int nextVertex(int v, int w);
        // 深度优先搜索遍历图的递归实现
        void DFS(int i, int *visited);

};

/* 
 * 创建图(自己输入数据)
 */
MatrixUDG::MatrixUDG()
{
    char c1, c2;
    int i, p1, p2;

    // 输入&quot;顶点数&quot;和&quot;边数&quot;
    cout &lt;&lt; &quot;input vertex number: &quot;;
    cin &gt;&gt; mVexNum;
    cout &lt;&lt; &quot;input edge number: &quot;;
    cin &gt;&gt; mEdgNum;
    if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1))))
    {
        cout &lt;&lt; &quot;input error: invalid parameters!&quot; &lt;&lt; endl;
        return ;
    }

    // 初始化&quot;顶点&quot;
    for (i = 0; i &lt; mVexNum; i++)
    {
        cout &lt;&lt; &quot;vertex(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;
        mVexs[i] = readChar();
    }

    // 初始化&quot;边&quot;
    for (i = 0; i &lt; mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        cout &lt;&lt; &quot;edge(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;
        c1 = readChar();
        c2 = readChar();

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        if (p1==-1 || p2==-1)
        {
            cout &lt;&lt; &quot;input error: invalid edge!&quot; &lt;&lt; endl;
            return ;
        }

        mMatrix[p1][p2] = 1;
        mMatrix[p2][p1] = 1;
    }
}

/*
 * 创建图(用已提供的矩阵)
 *
 * 参数说明：
 *     vexs  -- 顶点数组
 *     vlen  -- 顶点数组的长度
 *     edges -- 边数组
 *     elen  -- 边数组的长度
 */
MatrixUDG::MatrixUDG(char vexs[], int vlen, char edges[][2], int elen)
{
    int i, p1, p2;

    // 初始化&quot;顶点数&quot;和&quot;边数&quot;
    mVexNum = vlen;
    mEdgNum = elen;
    // 初始化&quot;顶点&quot;
    for (i = 0; i &lt; mVexNum; i++)
        mVexs[i] = vexs[i];

    // 初始化&quot;边&quot;
    for (i = 0; i &lt; mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        p1 = getPosition(edges[i][0]);
        p2 = getPosition(edges[i][1]);

        mMatrix[p1][p2] = 1;
        mMatrix[p2][p1] = 1;
    }
}

/* 
 * 析构函数
 */
MatrixUDG::~MatrixUDG() 
{
}

/*
 * 返回ch在mMatrix矩阵中的位置
 */
int MatrixUDG::getPosition(char ch)
{
    int i;
    for(i=0; i&lt;mVexNum; i++)
        if(mVexs[i]==ch)
            return i;
    return -1;
}

/*
 * 读取一个输入字符
 */
char MatrixUDG::readChar()
{
    char ch;

    do {
        cin &gt;&gt; ch;
    } while(!((ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;) || (ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;)));

    return ch;
}


/*
 * 返回顶点v的第一个邻接顶点的索引，失败则返回-1
 */
int MatrixUDG::firstVertex(int v)
{
    int i;

    if (v&lt;0 || v&gt;(mVexNum-1))
        return -1;

    for (i = 0; i &lt; mVexNum; i++)
        if (mMatrix[v][i] == 1)
            return i;

    return -1;
}

/*
 * 返回顶点v相对于w的下一个邻接顶点的索引，失败则返回-1
 */
int MatrixUDG::nextVertex(int v, int w)
{
    int i;

    if (v&lt;0 || v&gt;(mVexNum-1) || w&lt;0 || w&gt;(mVexNum-1))
        return -1;

    for (i = w + 1; i &lt; mVexNum; i++)
        if (mMatrix[v][i] == 1)
            return i;

    return -1;
}

/*
 * 深度优先搜索遍历图的递归实现
 */
void MatrixUDG::DFS(int i, int *visited)
{
    int w;

    visited[i] = 1;
    cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;
    // 遍历该顶点的所有邻接顶点。若是没有访问过，那么继续往下走
    for (w = firstVertex(i); w &gt;= 0; w = nextVertex(i, w))
    {
        if (!visited[w])
            DFS(w, visited);
    }

}

/*
 * 深度优先搜索遍历图
 */
void MatrixUDG::DFS()
{
    int i;
    int visited[MAX];       // 顶点访问标记

    // 初始化所有顶点都没有被访问
    for (i = 0; i &lt; mVexNum; i++)
        visited[i] = 0;

    cout &lt;&lt; &quot;DFS: &quot;;
    for (i = 0; i &lt; mVexNum; i++)
    {
        //printf(&quot;\n== LOOP(%d)\n&quot;, i);
        if (!visited[i])
            DFS(i, visited);
    }
    cout &lt;&lt; endl;
}

/*
 * 广度优先搜索（类似于树的层次遍历）
 */
void MatrixUDG::BFS()
{
    int head = 0;
    int rear = 0;
    int queue[MAX];     // 辅组队列
    int visited[MAX];   // 顶点访问标记
    int i, j, k;

    for (i = 0; i &lt; mVexNum; i++)
        visited[i] = 0;

    cout &lt;&lt; &quot;BFS: &quot;;
    for (i = 0; i &lt; mVexNum; i++)
    {
        if (!visited[i])
        {
            visited[i] = 1;
            cout &lt;&lt; mVexs[i] &lt;&lt; &quot; &quot;;
            queue[rear++] = i;  // 入队列
        }
        while (head != rear) 
        {
            j = queue[head++];  // 出队列
            for (k = firstVertex(j); k &gt;= 0; k = nextVertex(j, k)) //k是为访问的邻接顶点
            {
                if (!visited[k])
                {
                    visited[k] = 1;
                    cout &lt;&lt; mVexs[k] &lt;&lt; &quot; &quot;;
                    queue[rear++] = k;
                }
            }
        }
    }
    cout &lt;&lt; endl;
}

/*
 * 打印矩阵队列图
 */
void MatrixUDG::print()
{
    int i,j;

    cout &lt;&lt; &quot;Martix Graph:&quot; &lt;&lt; endl;
    for (i = 0; i &lt; mVexNum; i++)
    {
        for (j = 0; j &lt; mVexNum; j++)
            cout &lt;&lt; mMatrix[i][j] &lt;&lt; &quot; &quot;;
        cout &lt;&lt; endl;
    }
}


int main()
{
    char vexs[] = {&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;};
    char edges[][2] = {
        {&apos;A&apos;, &apos;C&apos;}, 
        {&apos;A&apos;, &apos;D&apos;}, 
        {&apos;A&apos;, &apos;F&apos;}, 
        {&apos;B&apos;, &apos;C&apos;}, 
        {&apos;C&apos;, &apos;D&apos;}, 
        {&apos;E&apos;, &apos;G&apos;}, 
        {&apos;F&apos;, &apos;G&apos;}};
    int vlen = sizeof(vexs)/sizeof(vexs[0]);
    int elen = sizeof(edges)/sizeof(edges[0]);
    MatrixUDG* pG;

    // 自定义&quot;图&quot;(输入矩阵队列)
    //pG = new MatrixUDG();
    // 采用已有的&quot;图&quot;
    pG = new MatrixUDG(vexs, vlen, edges, elen);

    pG-&gt;print();   // 打印图
    pG-&gt;DFS();     // 深度优先遍历
    pG-&gt;BFS();     // 广度优先遍历

    return 0;
}
</code></pre><p>2.邻接表表示的”无向图</p>
<pre><code>/**
 * C++: 邻接表表示的&quot;无向图(List Undirected Graph)&quot;
 *
 * @author LippiOuYang
 * @date 2013/04/19
 */

    #include &lt;iomanip&gt;
    #include &lt;iostream&gt;
    #include &lt;vector&gt;
    using namespace std;

#define MAX 100
// 邻接表
class ListUDG
{
    private: // 内部类
        // 邻接表中表对应的链表的顶点
        class ENode
        {
            public:
                int ivex;           // 该边所指向的顶点的位置
                ENode *nextEdge;    // 指向下一条弧的指针
        };

        // 邻接表中表的顶点
        class VNode
        {
            public:
                char data;          // 顶点信息
                ENode *firstEdge;   // 指向第一条依附该顶点的弧
        };

    private: // 私有成员
        int mVexNum;             // 图的顶点的数目
        int mEdgNum;             // 图的边的数目
        VNode mVexs[MAX];

    public:
        // 创建邻接表对应的图(自己输入)
        ListUDG();
        // 创建邻接表对应的图(用已提供的数据)
        ListUDG(char vexs[], int vlen, char edges[][2], int elen);
        ~ListUDG();

        // 深度优先搜索遍历图
        void DFS();
        // 广度优先搜索（类似于树的层次遍历）
        void BFS();
        // 打印邻接表图
        void print();

    private:
        // 读取一个输入字符
        char readChar();
        // 返回ch的位置
        int getPosition(char ch);
        // 深度优先搜索遍历图的递归实现
        void DFS(int i, int *visited);
        // 将node节点链接到list的最后
        void linkLast(ENode *list, ENode *node);
};

/*
 * 创建邻接表对应的图(自己输入)
 */
ListUDG::ListUDG()
{
    char c1, c2;
    int v, e;
    int i, p1, p2;
    ENode *node1, *node2;

    // 输入&quot;顶点数&quot;和&quot;边数&quot;
    cout &lt;&lt; &quot;input vertex number: &quot;;
    cin &gt;&gt; mVexNum;
    cout &lt;&lt; &quot;input edge number: &quot;;
    cin &gt;&gt; mEdgNum;
    if ( mVexNum &lt; 1 || mEdgNum &lt; 1 || (mEdgNum &gt; (mVexNum * (mVexNum-1))))
    {
        cout &lt;&lt; &quot;input error: invalid parameters!&quot; &lt;&lt; endl;
        return ;
    }

    // 初始化&quot;邻接表&quot;的顶点
    for(i=0; i&lt;mVexNum; i++)
    {
        cout &lt;&lt; &quot;vertex(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;
        mVexs[i].data = readChar();
        mVexs[i].firstEdge = NULL;
    }

    // 初始化&quot;邻接表&quot;的边
    for(i=0; i&lt;mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        cout &lt;&lt; &quot;edge(&quot; &lt;&lt; i &lt;&lt; &quot;): &quot;;
        c1 = readChar();
        c2 = readChar();

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        // 初始化node1
        node1 = new ENode();
        node1-&gt;ivex = p2;
        // 将node1链接到&quot;p1所在链表的末尾&quot;
        if(mVexs[p1].firstEdge == NULL)
          mVexs[p1].firstEdge = node1;
        else
            linkLast(mVexs[p1].firstEdge, node1);
        // 初始化node2
        node2 = new ENode();
        node2-&gt;ivex = p1;
        // 将node2链接到&quot;p2所在链表的末尾&quot;
        if(mVexs[p2].firstEdge == NULL)
          mVexs[p2].firstEdge = node2;
        else
            linkLast(mVexs[p2].firstEdge, node2);
    }
}

/*
 * 创建邻接表对应的图(用已提供的数据)
 */
ListUDG::ListUDG(char vexs[], int vlen, char edges[][2], int elen)
{
    char c1, c2;
    int i, p1, p2;
    ENode *node1, *node2;

    // 初始化&quot;顶点数&quot;和&quot;边数&quot;
    mVexNum = vlen;
    mEdgNum = elen;
    // 初始化&quot;邻接表&quot;的顶点
    for(i=0; i&lt;mVexNum; i++)
    {
        mVexs[i].data = vexs[i];
        mVexs[i].firstEdge = NULL;
    }

    // 初始化&quot;邻接表&quot;的边
    for(i=0; i&lt;mEdgNum; i++)
    {
        // 读取边的起始顶点和结束顶点
        c1 = edges[i][0];
        c2 = edges[i][1];

        p1 = getPosition(c1);
        p2 = getPosition(c2);
        // 初始化node1
        node1 = new ENode();
        node1-&gt;ivex = p2;
        // 将node1链接到&quot;p1所在链表的末尾&quot;
        if(mVexs[p1].firstEdge == NULL)
          mVexs[p1].firstEdge = node1;
        else
            linkLast(mVexs[p1].firstEdge, node1);
        // 初始化node2
        node2 = new ENode();
        node2-&gt;ivex = p1;
        // 将node2链接到&quot;p2所在链表的末尾&quot;
        if(mVexs[p2].firstEdge == NULL)
          mVexs[p2].firstEdge = node2;
        else
            linkLast(mVexs[p2].firstEdge, node2);
    }
}

/* 
 * 析构函数
 */
ListUDG::~ListUDG() 
{
}

/*
 * 将node节点链接到list的最后
 */
void ListUDG::linkLast(ENode *list, ENode *node)
{
    ENode *p = list;

    while(p-&gt;nextEdge)
        p = p-&gt;nextEdge;
    p-&gt;nextEdge = node;
}

/*
 * 返回ch的位置
 */
int ListUDG::getPosition(char ch)
{
    int i;
    for(i=0; i&lt;mVexNum; i++)
        if(mVexs[i].data==ch)
            return i;
    return -1;
}

/*
 * 读取一个输入字符
 */
char ListUDG::readChar()
{
    char ch;

    do {
        cin &gt;&gt; ch;
    } while(!((ch&gt;=&apos;a&apos;&amp;&amp;ch&lt;=&apos;z&apos;) || (ch&gt;=&apos;A&apos;&amp;&amp;ch&lt;=&apos;Z&apos;)));

    return ch;
}


/*
 * 深度优先搜索遍历图的递归实现
 */
void ListUDG::DFS(int i, int *visited)
{
    ENode *node;

    visited[i] = 1;
    cout &lt;&lt; mVexs[i].data &lt;&lt; &quot; &quot;;
    node = mVexs[i].firstEdge;
    while (node != NULL)
    {
        if (!visited[node-&gt;ivex])
            DFS(node-&gt;ivex, visited);
        node = node-&gt;nextEdge;
    }
}

/*
 * 深度优先搜索遍历图
 */
void ListUDG::DFS()
{
    int i;
    int visited[MAX];       // 顶点访问标记

    // 初始化所有顶点都没有被访问
    for (i = 0; i &lt; mVexNum; i++)
        visited[i] = 0;

    cout &lt;&lt; &quot;DFS: &quot;;
    for (i = 0; i &lt; mVexNum; i++)
    {
        if (!visited[i])
            DFS(i, visited);
    }
    cout &lt;&lt; endl;
}

/*
 * 广度优先搜索（类似于树的层次遍历）
 */
void ListUDG::BFS()
{
    int head = 0;
    int rear = 0;
    int queue[MAX];     // 辅组队列
    int visited[MAX];   // 顶点访问标记
    int i, j, k;
    ENode *node;

    for (i = 0; i &lt; mVexNum; i++)
        visited[i] = 0;

    cout &lt;&lt; &quot;BFS: &quot;;
    for (i = 0; i &lt; mVexNum; i++)
    {
        if (!visited[i])
        {
            visited[i] = 1;
            cout &lt;&lt; mVexs[i].data &lt;&lt; &quot; &quot;;
            queue[rear++] = i;  // 入队列
        }
        while (head != rear) 
        {
            j = queue[head++];  // 出队列
            node = mVexs[j].firstEdge;
            while (node != NULL)
            {
                k = node-&gt;ivex;
                if (!visited[k])
                {
                    visited[k] = 1;
                    cout &lt;&lt; mVexs[k].data &lt;&lt; &quot; &quot;;
                    queue[rear++] = k;
                }
                node = node-&gt;nextEdge;
            }
        }
    }
    cout &lt;&lt; endl;
}

/*
 * 打印邻接表图
 */
void ListUDG::print()
{
    int i,j;
    ENode *node;

    cout &lt;&lt; &quot;List Graph:&quot; &lt;&lt; endl;
    for (i = 0; i &lt; mVexNum; i++)
    {
        cout &lt;&lt; i &lt;&lt; &quot;(&quot; &lt;&lt; mVexs[i].data &lt;&lt; &quot;): &quot;;
        node = mVexs[i].firstEdge;
        while (node != NULL)
        {
            cout &lt;&lt; node-&gt;ivex &lt;&lt; &quot;(&quot; &lt;&lt; mVexs[node-&gt;ivex].data &lt;&lt; &quot;) &quot;;
            node = node-&gt;nextEdge;
        }
        cout &lt;&lt; endl;
    }
}

int main()
{
    char vexs[] = {&apos;A&apos;, &apos;B&apos;, &apos;C&apos;, &apos;D&apos;, &apos;E&apos;, &apos;F&apos;, &apos;G&apos;};
    char edges[][2] = {
        {&apos;A&apos;, &apos;C&apos;}, 
        {&apos;A&apos;, &apos;D&apos;}, 
        {&apos;A&apos;, &apos;F&apos;}, 
        {&apos;B&apos;, &apos;C&apos;}, 
        {&apos;C&apos;, &apos;D&apos;}, 
        {&apos;E&apos;, &apos;G&apos;}, 
        {&apos;F&apos;, &apos;G&apos;}};
    int vlen = sizeof(vexs)/sizeof(vexs[0]);
    int elen = sizeof(edges)/sizeof(edges[0]);
    ListUDG* pG;

    // 自定义&quot;图&quot;(输入矩阵队列)
    //pG = new ListUDG();
    // 采用已有的&quot;图&quot;
    pG = new ListUDG(vexs, vlen, edges, elen);

    pG-&gt;print();   // 打印图
    pG-&gt;DFS();     // 深度优先遍历
    pG-&gt;BFS();     // 广度优先遍历

    return 0;
}
</code></pre><hr>
<p>##迪杰斯特拉算法</p>
<p>迪杰斯特拉(Dijkstra)算法是典型最短路径算法，用于计算一个节点到其他节点的最短路径。<br>它的主要特点是以起始点为中心向外层层扩展(广度优先搜索思想)，直到扩展到终点为止。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p> 通过Dijkstra计算图G中的最短路径时，需要指定起点s(即从顶点s开始计算)。</p>
<p> 此外，引进两个集合S和U。S的作用是记录已求出最短路径的顶点(以及相应的最短路径长度)，而U则是记录还未求出最短路径的顶点(以及该顶点到起点s的距离)。</p>
<p>初始时，S中只有起点s；U中是除s之外的顶点，并且U中顶点的路径是”起点s到该顶点的路径”。然后，从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 然后，再从U中找出路径最短的顶点，并将其加入到S中；接着，更新U中的顶点和顶点对应的路径。 … 重复该操作，直到遍历完所有顶点。</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><ul>
<li>(1)<br>初始时，S只包含起点s；U包含除s外的其他顶点，且U中顶点的距离为”起点s到该顶点的距离”[例如，U中顶点v的距离为(s,v)的长度，然后s和v不相邻，则v的距离为∞]。</li>
<li>(2) 从U中选出”距离最短的顶点k”，并将顶点k加入到S中；同时，从U中移除顶点k。</li>
<li>(3)<br>更新U中各个顶点到起点s的距离。之所以更新U中顶点的距离，是由于上一步中确定了k是求出最短路径的顶点，从而可以利用k来更新其它顶点的距离；例如，(s,v)的距离可能大于(s,k)+(k,v)的距离。</li>
<li>(4) 重复步骤(2)和(3)，直到遍历完所有顶点。</li>
</ul>
<p>单纯的看上面的理论可能比较难以理解，下面通过实例来对该算法进行说明。</p>
<p>5.3迪杰斯特拉算法图解<br><img src="/images/images/githubpages/graph/graph11.jpg" alt=""><br>以上图G4为例，来对迪杰斯特拉进行算法演示(以第4个顶点D为起点)。<br><img src="/images/images/githubpages/graph/graph12.jpg" alt=""></p>
<ul>
<li>初始状态：S是已计算出最短路径的顶点集合，U是未计算除最短路径的顶点的集合！</li>
</ul>
<ul>
<li><p>第1步：将顶点D加入到S中。</p>
<p> 此时，S={D(0)}, U={A(∞),B(∞),C(3),E(4),F(∞),G(∞)}。     注:C(3)表示C到起点D的距离是3。</p>
</li>
<li><p>第2步：将顶点C加入到S中。</p>
<p> 上一步操作之后，U中顶点C到起点D的距离最短；因此，将C加入到S中，同时更新U中顶点的距离。以顶点F为例，之前F到D的距离为∞；但是将C加入到S之后，F到D的距离为9=(F,C)+(C,D)。<br> 此时，S={D(0),C(3)}, U={A(∞),B(23),E(4),F(9),G(∞)}。</p>
</li>
<li><p>第3步：将顶点E加入到S中。</p>
<p> 上一步操作之后，U中顶点E到起点D的距离最短；因此，将E加入到S中，同时更新U中顶点的距离。还是以顶点F为例，之前F到D的距离为9；但是将E加入到S之后，F到D的距离为6=(F,E)+(E,D)。<br> 此时，S={D(0),C(3),E(4)}, U={A(∞),B(23),F(6),G(12)}。</p>
</li>
<li><p>第4步：将顶点F加入到S中。</p>
</li>
</ul>
<pre><code>此时，S={D(0),C(3),E(4),F(6)}, U={A(22),B(13),G(12)}。
</code></pre><ul>
<li><p>第5步：将顶点G加入到S中。</p>
<p> 此时，S={D(0),C(3),E(4),F(6),G(12)}, U={A(22),B(13)}。</p>
</li>
<li><p>第6步：将顶点B加入到S中。</p>
<p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13)}, U={A(22)}。</p>
</li>
<li><p>第7步：将顶点A加入到S中。</p>
<p> 此时，S={D(0),C(3),E(4),F(6),G(12),B(13),A(22)}。</p>
</li>
</ul>
<p>此时，起点D到各个顶点的最短距离就计算出来了：A(22) B(13) C(3) D(0) E(4) F(6) G(12)。</p>
<hr>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><hr>
<p>本文以”邻接矩阵”为例对迪杰斯特拉算法进行说明，</p>
<h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><pre><code>// 邻接矩阵
typedef struct _graph
{
    char vexs[MAX];       // 顶点集合
    int vexnum;           // 顶点数
    int edgnum;           // 边数
    int matrix[MAX][MAX]; // 邻接矩阵
}Graph, *PGraph;

// 边的结构体
typedef struct _EdgeData
{
    char start; // 边的起点
    char end;   // 边的终点
    int weight; // 边的权重
}EData;
</code></pre><p>Graph是邻接矩阵对应的结构体。<br>vexs用于保存顶点，vexnum是顶点数，edgnum是边数；matrix则是用于保存矩阵信息的二维数组。例如，matrix[i][j]=1，则表示”顶点i(即vexs[i])”和”顶点j(即vexs[j])”是邻接点；matrix[i][j]=0，则表示它们不是邻接点。<br>EData是邻接矩阵边对应的结构体。</p>
<p>####迪杰斯特拉算法</p>
<pre><code>/*
 * Dijkstra最短路径。
 * 即，统计图(G)中&quot;顶点vs&quot;到其它各个顶点的最短路径。
 *
 * 参数说明：
 *        G -- 图
 *       vs -- 起始顶点(start vertex)。即计算&quot;顶点vs&quot;到其它顶点的最短路径。
 *     prev -- 前驱顶点数组。即，prev[i]的值是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径所经历的全部顶点中，位于&quot;顶点i&quot;之前的那个顶点。
 *     dist -- 长度数组。即，dist[i]是&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径的长度。
 */

    void dijkstra(Graph G, int vs, int prev[], int dist[])
    {
        int i,j,k;
        int min;
        int tmp;
    int flag[MAX];      // flag[i]=1表示&quot;顶点vs&quot;到&quot;顶点i&quot;的最短路径已成功获取。

    // 初始化
    for (i = 0; i &lt; G.vexnum; i++)
    {
        flag[i] = 0;              // 顶点i的最短路径还没获取到。


           prev[i] = 0;              // 顶点i的前驱顶点为0。
            dist[i] = G.matrix[vs][i];// 顶点i的最短路径为&quot;顶点vs&quot;到&quot;顶点i&quot;的权。
        }

        // 对&quot;顶点vs&quot;自身进行

    初始化
    flag[vs] = 1;
    dist[vs] = 0;

    // 遍历G.vexnum-1次；每次找出一个顶点的最短路径。
    for (i = 1; i &lt; G.vexnum; i++)
    {
    // 寻找当前最小的路径；
    // 即，在未获取最短路径的顶点中，找到离vs最近的顶点(k)。
    min = INF;
    for (j = 0; j &lt; G.vexnum; j++)
    {
        if (flag[j]==0 &amp;&amp; dist[j]&lt;min)
        {
            min = dist[j];
            k = j;
        }
    }
    // 标记&quot;顶点k&quot;为已经获取到最短路径
    flag[k] = 1;

    // 修正当前最短路径和前驱顶点
    // 即，当已经&quot;顶点k的最短路径&quot;之后，更新&quot;未获取最短路径的顶点的最短路径和前驱顶点&quot;。
    for (j = 0; j &lt; G.vexnum; j++)
    {
        tmp = (G.matrix[k][j]==INF ? INF : (min + G.matrix[k][j])); // 防止溢出
        if (flag[j] == 0 &amp;&amp; (tmp  &lt; dist[j]) )
        {
            dist[j] = tmp;
            prev[j] = k;
        }
    }
}

    // 打印dijkstra最短路径的结果
    printf(&quot;dijkstra(%c): \n&quot;, G.vexs[vs]);
    for (i = 0; i &lt; G.vexnum; i++)
        printf(&quot;  shortest(%c, %c)=%d\n&quot;, G.vexs[vs], G.vexs[i], dist[i]);
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[也谈如何构建高性能服务端程序]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/web-server.html</url>
      <content type="html"><![CDATA[<blockquote>
<p>引子：我接触过很多编程语言，接触过各种各样的服务器端开发，Java，Go，Ruby，Javascript等语言，Spring，Node.js，Rails<br>等等常见服务器端框架和编程模型都有接触。这里谈一下我个人对高性能服务器端程序的一些看法，希望给各位读者一些认识。</p>
</blockquote>
<p>此外，阅读这篇文章，有如下几个前提：不谈硬件，不评论编程语言以及框架的好坏，不谈高级算法，可拍砖，拒绝喷子<br><a id="more"></a><br><strong>三个关键词</strong></p>
<p>Cache，Asynchronous，Concurrent</p>
<p>我们一个一个来讲。</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>Cache 翻译成中文就是缓存，台湾的叫法叫做快取，其本质是将获取缓慢或者计算缓慢的数据结果暂时存储起来，以便以后再次获取或者计算同样的数据可以直接从存储中取得结果，从而可能提升性能的一种手段。Cache 最早是应用在计算机的 CPU 中，这篇文章不谈硬件，所以有需要了解 CPU 的缓存的同学可自行搜索。</p>
<p>可以想象，如果让一个人一遍一遍的从 1+2+3+4+…+99+100=？ 这样去算，他加到最后发现等于5050，而这个过程耗费了他大量的时间，耗费了大量的脑力，在此期间，他可能把所有精力都放在这个计算上面而无暇顾及其他事情。等到他累得满头大汗，加完了结果，他告诉你是 5050。没过多久，你又让他做同样的事情，我相信这家伙会不加思索的再次告诉你 5050。为什么？你会笑我说，人又不是傻子，这为同学肯定记得这个结果是5050啊。</p>
<p>可是，计算机不一样，计算机就是你上面要嘲笑的那个傻子，他傻到，完全不会记得刚在做了什么事情，他会傻乎乎的再重新算一遍告诉你结果。没错如果你问他一万遍，这头没有脑子的机器会算一万遍的。虽然上面这个从1加到100这个例子对于一款现代化的计算机来讲简直是小菜一碟，但是计算机往往面临的计算难题是我们人类所无法企及的。</p>
<p>Cache 就是为了来解决这个事情的，因为事情往往是这样的：你会发现一些非常复杂的过程的计算结果是可重用的，而且把这个结果暂时存储在某些地方，查找起来也是极为方便的。</p>
<p>所以，现在你理解了缓存，那可以来思考一些缓存的设计策略了。这里做一点说明，不同的缓存策略跟具体的业务系统关系非常大，制定缓存策略需要根据具体的情况来分析。常用的策略：</p>
<ul>
<li>最终结果型缓存。这种缓存往往提升性能效果最为明显，但是命中率却低，也就是可重用性不高。</li>
<li>中间结果型缓存。</li>
</ul>
<p>还拿上面的例子来说，1加到100，你可以构建出是个缓存分别是1加到10，10加到20，20加到30 … 一直到 90加到100 这9个缓存。好处是你如果被请求到 1加到60 的时候，仍然可以使用这些缓存结果。可坏处也很明显，你取到几个缓存的结果后不得不再进行一次运算。所以实际情况，往往是在最终结果和中间结果之间找到平衡点，或者是两者配合使用。<br>不知不觉中，你有没有发现，1+2+3+4+…+99+100=5050 是个永远都成立的事实，这也就意味着，它永远不用被清除。可事实是往往是，缓存是有有效期的，例如需要缓存今天的天气情况，今天是 2014年11月16日，到了明天就是 11月17日，天气就不一样了。再例如需要缓存 Coding 的最新冒泡列表，当有人发布了新的冒泡，那么这个列表就得被更新。从这个角度来看，缓存的策略又有如下常见的几种：</p>
<ul>
<li>永久式缓存：结果在任何情况下都不发生改变，无需清除或者更新</li>
<li>有有效期的缓存：在特定时间点或者时间段后失效</li>
<li>触发式失效缓存：当某一事件产生时，缓存失效，当然有有效期式缓存也可以理解成时间点和时间段到期为触发条件的触发式失效缓存</li>
</ul>
<p>嗯，既然提到了缓存的更新或者清除，那么就牵扯到缓存的更新策略。例子永远好过大段的理论：假如我们要缓存 Coding 的冒泡列表。有这么一种策略：当用户请求时我们检查下是否已存在这样的缓存，如果有直接返回缓存数据，否则我们生成这个列表（计算机的计算过程），返回给用户并且把冒泡列表（计算结果）存储起来，以便以后的用户访问时直接获取。当用户发布了一个新的冒泡的时候，我们清除这个缓存，再有用户请求时将重复以上过程。这是其中一种完整的缓存清除策略。另外一种是，每当我们收到一个用户发布的冒泡时，都重新构建这个缓存，用户每次查看冒泡列表都是取的缓存数据。这两种缓存分别称之为：</p>
<ul>
<li>被动式缓存：需要用到时才构建</li>
<li>主动式缓存：预先构建</li>
</ul>
<p>关于 Cache 还有很多很多需要注意和设计上的思路和策略，这里不再一一赘述。这些缓存在不同的维度有不同的策略，我们需要根据具体的业务情况来选择合适的策略。Coding 的很多业务中使用了上述很多种策略，例如我们常见的分支列表和标签列表就是使用触发式失效缓存，我们的广场项目列表就是使用主动式缓存构建。</p>
<h2 id="Asynchronous"><a href="#Asynchronous" class="headerlink" title="Asynchronous"></a>Asynchronous</h2><p>Asynchronous 的意思是异步。什么是异步呢？就是不在第一时间告知调用者结果，告诉他我已经收到这个任务了，我会处理，处理完毕后通知你结果，如果你不是等不到结果就无法进行下去的话，你完全可以先干别的事情。<br>嗯，好像我描述的比较拉杂。还是例子：你去咖啡厅点一杯咖啡，服务员告诉你现磨咖啡需要15分钟才可做好，那么在咖啡做好之前，你不可能盯着服务员或者咖啡师15分钟，你肯定会干点别的，比如说玩手机上一下网，或者跟你女朋友商量下去看电影什么的，总之你不会傻乎乎等着的。等到咖啡做好了，服务员会记得给你端过来的。这就是异步过程，你的大脑不必为一个漫长的过程卡住，可以继续其他的事情。</p>
<p>服务端程序设计往往也是这样，在你等待一个很缓慢的过程的时候，如果你不是必须要得到这个过程的结果才能继续下去，你完全可以先进行别的过程，等到那个缓慢的过程执行完毕后，它会通知你结果的。</p>
<p>异步已经在现在的各种编程领域有了很广泛的应用，例如 Ajax 技术，就是一种异步的手段，在浏览器和服务器交互的时候，完全不影响你在网页上的其他操作。</p>
<p>异步在各种编程语言和框架中都有相应的支持，这里简单介绍一下 Javascript 的异步支持。熟悉它的人的人请无视这段。它使用回调的方式支持异步，大致意思是，A 交代给 B 一个任务，并且告知 B 任务完成后继续执行哪段程序（往往包装成一个匿名function），B执行完任务后，执行这个匿名的 function，这样来完成异步过程。在 Javascript 中大量的使用这种回调的异步方案，已经不再局限于对一个缓慢的过程了，可以对几乎所有的过程都采用异步处理。</p>
<p>在服务端程序中，除了使用线程，协程，回调之外，另外一种常见的异步的支持方式就是消息队列。其原理是，生产者发送消息到消息队列中，消费者从中取出消息，做出相应处理，并把结果存储起来或者通过某种方式告知生产者。</p>
<p>异步在很多时候可以运用现代化计算机 CPU 的多核特性和分布式计算特性，能显著的提升应用的性能，但是一个前提就是，异步的任务的结果必须是主进程进行下一步操作所不依赖的，否则主进程必须等待，直到这个任务执行结束，拿到结果再进行下一步，这时就变成了传统的同步计算了。</p>
<p>异步操作在 Coding 中也有非常广泛的应用。例如当用户执行完一次 Push，Coding 需要生成一条 Push 的动态，需要清理掉相应的缓存，需要触发相关的 WebHook 等等，这些操作都是通过消息队列来异步完成的。因为这些操作非常的耗时，而且完全不需要即时完成，所以用户在 Push 的时候等待着这些操作完成是很不合理的。异步操作在这里即展示出了其应用多核和多台服务器的优势，在某种程度上还能提升用户体验。</p>
<p>Golang 是 Google 2009 年发布的一门现代化语言，其语言特性对异步提供了良好的支持。这里举个例子体现一下异步的魅力：</p>
<pre><code>//一个查询结构体
type project struct {
    //参数Channel
    name chan string
    result chan string
}

//addProject
func addProject(u user, p project) {

    //检查用户权限
    checkPermission(u)

    //启动协程
    go func() {
        //获取输入
        name := &lt;-p.name
        //访问数据库，输出结果通道
        q.result &lt;- &quot;add project :&quot; + name
    }()

}

//主进程
func main() {
    //初始化project
    p := project{ make(chan string, 1), make(chan string, 1) }
    //某位用户
    u := user{} 
    //执行addProject，注意执行的时候还不需要告知要创建的项目名字
    addProject(u,p)

    //准备参数
    p.name &lt;- &quot;an-asynchronous-project&quot;
    //获取结果
    fmt.Println(&lt;-p.result)
}
</code></pre><p>这一段程序涉及到了 Golang 的 goroutine 和 channel，不了解的可以去查一下相关资料。<br>这段程序实现了在还为准备好参数时就已经调用一个 function 。当我们调用 addProject 的时候还不知道项目的名字，但是这完全不影响我们去检查用户权限。程序完全可以一边去检查权限，一边去获取项目名字，当程序执行到不得不拿到项目的名字才能继续的时候，它将阻塞，直到我们告诉他项目名字。</p>
<h2 id="Concurrent"><a href="#Concurrent" class="headerlink" title="Concurrent"></a>Concurrent</h2><p>Concurrent 的意思是并行。现代化的 CPU 往往具有多个核心，而且有些 CPU 也具有超线程能力。如果我们可以将单个过程拆分成小的任务，交给 CPU 的多个核心，或者是分布式计算系统的多个计算节点，就可以充分利用并行计算来提升性能。前提是这些任务相互之间不要有相互依赖的关系。依然是例子：需要计算网站上某一批用户的活跃度积分，传统的，我们会查出这一批用户，然后写一个循环，然后轮流计算他们的积分，最后得到结果。其实每个用户的积分的计算都是独立的，相互不依赖，那么我们就可以利用这一点来并行化这个计算。</p>
<p>下面给出一段 Coding 代码托管中的程序，这段程序是指定条件获取一个提交列表，使用了并行计算的一种 并发循环：</p>
<pre><code>public List&lt;Commit&gt; getCommits(String objectId, String path, int offset, int maxCount) {
        List&lt;String&gt; shas = getCommitsSha(this, objectId, path, offset, maxCount);
        List&lt;Commit&gt; commits = new ArrayList&lt;&gt;();

        if (shas != null) {
            List&lt;GetCommit&gt; getCommits = new ArrayList&lt;&gt;();
            for (String sha : shas) {
                getCommits.add(new GetCommit(this, sha));
            }

            //声明一个自适应的线程池
            ExecutorService executor = Executors.newFixedThreadPool(8);

            List&lt;Future&lt;Commit&gt;&gt; futureList = null;

        //并发的调用getCommit
        futureList = executor.invokeAll(getCommits);
        executor.shutdown();
    for (Future&lt;Commit&gt; future : futureList) {
        Commit commit = future.get();
        commits.add(commit);
    }        
}
return commits;
</code></pre><p>}</p>
<p>//Java 是一个啰嗦的语言，还要声明一个类来包装一下这个过程。</p>
<pre><code>class GetCommit implements Callable&lt;Commit&gt; {
    private Repo repo;
    private String sha;

public GetCommit(Repo repo, String sha) {
    this.repo = repo;
    this.sha = sha;
}

@Override
public Commit call() throws Exception {
    return repo.getCommit(sha);
    }
}
</code></pre><p>这段程序是一个并发循环的例子，例子中需要根据一些参数查询到 Commit 的列表，而 repo.getCommit 这个过程完全不需要一个一个轮流查询，因为他们是完全独立的，所以可以使用 Java 的 Cocurrent 包来做并发循环，充分利用多核来尽快得到执行结果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于高性能服务器程序需要关注的点还有很多，这里只是简单的介绍了下三个利器（Cache，Asynchronous，Concurrent）。而即便是这三个利器，我的介绍也只是冰山一角，但是请相信你看懂了我介绍的这些东西，重新去思考服务端编程会获得不少收获的。<br>这三者也是相辅相成的关系，很多时候都是配合着使用才能起到很好的效果。异步和并行在某种程度上是有重叠的，而我们经常使用异步的方式去主动构建缓存。</p>
<p>最后再给一些小提示：</p>
<ul>
<li>不要让 CPU 闲着（CPU<br>正常情况下压力大的时候自然不会闲着，这里指的是CPU负载低谷时，可以让他主动的构建缓存，或者做一些准备工作等等。）</li>
<li>提升 CPU 效率，即不要总让 CPU 做重复的劳动，用空间换时间的理念去减轻 CPU 的压力</li>
<li>不要让无关紧要的附属的任务卡住主进程，让他们在后台慢慢做,可以提前做好准备工作，这个比较抽象，但是举例子就很明白，连接池，主动缓存，以及我举得那个 Golang 的例子都是很好的</li>
</ul>
<p>本文出自 Coding 官方技术博客:<br>作者: Coding 架构师 王振威</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[leveldb原理剖析]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/leveldb.html</url>
      <content type="html"><![CDATA[<p>在说LevelDb之前，先认识两位大牛，Jeff Dean和Sanjay Ghemawat，这两位是Google公司重量级的工程师，为数甚少的Google Fellow之二。</p>
<p>　　Jeff Dean其人：<a href="http://research.google.com/people/jeff/index.html" target="_blank" rel="external">http://research.google.com/people/jeff/index.html</a>，Google大规模分布式平台Bigtable和MapReduce主要设计和实现者。</p>
<p>　　Sanjay Ghemawat其人：<a href="http://research.google.com/people/sanjay/index.html" target="_blank" rel="external">http://research.google.com/people/sanjay/index.html</a>，Google大规模分布式平台GFS，Bigtable和MapReduce主要设计和实现工程师。<br><a id="more"></a><br>　　LevelDb就是这两位大神级别的工程师发起的开源项目，简而言之，LevelDb是能够处理十亿级别规模Key-Value型数据持久性存储的C++ 程序库。正像上面介绍的，这二位是Bigtable的设计和实现者，如果了解Bigtable的话，应该知道在这个影响深远的分布式存储系统中有两个核心的部分：Master Server和Tablet Server。其中Master Server做一些管理数据的存储以及分布式调度工作，实际的分布式数据存储以及读写操作是由Tablet Server完成的，而LevelDb则可以理解为一个简化版的Tablet Server。</p>
<hr>
<h2 id="LevelDb剖析之一：介绍"><a href="#LevelDb剖析之一：介绍" class="headerlink" title="LevelDb剖析之一：介绍"></a>LevelDb剖析之一：介绍</h2><p>　　LevelDb有如下一些特点：</p>
<p>　　　　首先，LevelDb是一个持久化存储的KV系统，和Redis这种内存型的KV系统不同，LevelDb不会像Redis一样狂吃内存，而是将大部分数据存储到磁盘上。</p>
<p>　　　　其次，LevleDb在存储数据时，是根据记录的key值有序存储的，就是说相邻的key值在存储文件中是依次顺序存储的，而应用可以自定义key大小比较函数，LevleDb会按照用户定义的比较函数依序存储这些记录。</p>
<p>　　　　再次，像大多数KV系统一样，LevelDb的操作接口很简单，基本操作包括写记录，读记录以及删除记录。也支持针对多条操作的原子批量操作。</p>
<p>　　　　另外，LevelDb支持数据快照（snapshot）功能，使得读取操作不受写操作影响，可以在读操作过程中始终看到一致的数据。</p>
<p>　　除此外，LevelDb还支持数据压缩等操作，这对于减小存储空间以及增快IO效率都有直接的帮助。</p>
<p>　　LevelDb性能非常突出，官方网站报道其随机写性能达到40万条记录每秒，而随机读性能达到6万条记录每秒。总体来说，LevelDb的写操作要大大快于读操作，而顺序读写操作则大大快于随机读写操作。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之二：整体架构"><a href="#LevelDb剖析之二：整体架构" class="headerlink" title="LevelDb剖析之二：整体架构"></a>LevelDb剖析之二：整体架构</h2><p>LevelDb本质上是一套存储系统以及在这套存储系统上提供的一些操作接口。为了便于理解整个系统及其处理流程，我们可以从两个不同的角度来看待LevleDb：静态角度和动态角度。从静态角度，可以假想整个系统正在运行过程中（不断插入删除读取数据），此时我们给LevelDb照相，从照片可以看到之前系统的数据在内存和磁盘中是如何分布的，处于什么状态等；从动态的角度，主要是了解系统是如何写入一条记录，读出一条记录，删除一条记录的，同时也包括除了这些接口操作外的内部操作比如compaction，系统运行时崩溃后如何恢复系统等等方面。</p>
<p>本节所讲的整体架构主要从静态角度来描述，之后接下来的几节内容会详述静态结构涉及到的文件或者内存数据结构，LevelDb剖析后半部分主要介绍动态视角下的LevelDb，就是说整个系统是怎么运转起来的。</p>
<p>LevelDb作为存储系统，数据记录的存储介质包括内存以及磁盘文件，如果像上面说的，当LevelDb运行了一段时间，此时我们给LevelDb进行透视拍照，那么您会看到如下一番景象：<br><img src="/images/images/githubpages/level1.png" alt=""><br>图1.1：LevelDb结构</p>
<p>从图中可以看出，构成LevelDb静态结构的包括六个主要部分：内存中的MemTable和Immutable MemTable以及磁盘上的几种主要文件：Current文件，Manifest文件，log文件以及SSTable文件。当然，LevelDb除了这六个主要部分还有一些辅助的文件，但是以上六个文件和数据结构是LevelDb的主体构成元素。</p>
<p>LevelDb的Log文件和Memtable与Bigtable论文中介绍的是一致的，当应用写入一条Key:Value记录的时候，LevelDb会先往log文件里写入，成功后将记录插进Memtable中，这样基本就算完成了写入操作，因为一次写入操作只涉及一次磁盘顺序写和一次内存写入，所以这是为何说LevelDb写入速度极快的主要原因。</p>
<p>Log文件在系统中的作用主要是用于系统崩溃恢复而不丢失数据，假如没有Log文件，因为写入的记录刚开始是保存在内存中的，此时如果系统崩溃，内存中的数据还没有来得及Dump到磁盘，所以会丢失数据（Redis就存在这个问题）。为了避免这种情况，LevelDb在写入内存前先将操作记录到Log文件中，然后再记入内存中，这样即使系统崩溃，也可以从Log文件中恢复内存中的Memtable，不会造成数据的丢失。</p>
<p>当Memtable插入的数据占用内存到了一个界限后，需要将内存的记录导出到外存文件中，LevleDb会生成新的Log文件和Memtable，原先的Memtable就成为Immutable Memtable，顾名思义，就是说这个Memtable的内容是不可更改的，只能读不能写入或者删除。新到来的数据被记入新的Log文件和Memtable，LevelDb后台调度会将Immutable Memtable的数据导出到磁盘，形成一个新的SSTable文件。SSTable就是由内存中的数据不断导出并进行Compaction操作后形成的，而且SSTable的所有文件是一种层级结构，第一层为Level 0，第二层为Level 1，依次类推，层级逐渐增高，这也是为何称之为LevelDb的原因。</p>
<p>SSTable中的文件是Key有序的，就是说在文件中小key记录排在大Key记录之前，各个Level的SSTable都是如此，但是这里需要注意的一点是：Level 0的SSTable文件（后缀为.sst）和其它Level的文件相比有特殊性：这个层级内的.sst文件，两个文件可能存在key重叠，比如有两个level 0的sst文件，文件A和文件B，文件A的key范围是：{bar, car}，文件B的Key范围是{blue,samecity}，那么很可能两个文件都存在key=”blood”的记录。对于其它Level的SSTable文件来说，则不会出现同一层级内.sst文件的key重叠现象，就是说Level L中任意两个.sst文件，那么可以保证它们的key值是不会重叠的。这点需要特别注意，后面您会看到很多操作的差异都是由于这个原因造成的。</p>
<p>  SSTable中的某个文件属于特定层级，而且其存储的记录是key有序的，那么必然有文件中的最小key和最大key，这是非常重要的信息，LevelDb应该记下这些信息。Manifest就是干这个的，它记载了SSTable各个文件的管理信息，比如属于哪个Level，文件名称叫啥，最小key和最大key各自是多少。下图是Manifest所存储内容的示意：<br><img src="/images/images/githubpages/level2.png" alt=""><br>图2.1：Manifest存储示意图</p>
<p>图中只显示了两个文件（manifest会记载所有SSTable文件的这些信息），即Level 0的test.sst1和test.sst2文件，同时记载了这些文件各自对应的key范围，比如test.sstt1</p>
<p>的key范围是“an”到 “banana”，而文件test.sst2的key范围是“baby”到“samecity”，可以看出两者的key范围是有重叠的。</p>
<p>Current文件是干什么的呢？这个文件的内容只有一个信息，就是记载当前的manifest文件名。因为在LevleDb的运行过程中，随着Compaction的进行，SSTable文件会发生变化，会有新的文件产生，老的文件被废弃，Manifest也会跟着反映这种变化，此时往往会新生成Manifest文件来记载这种变化，而Current则用来指出哪个Manifest文件才是我们关心的那个Manifest文件。</p>
<p>以上介绍的内容就构成了LevelDb的整体静态结构，在LevelDb剖析接下来的内容中，我们会首先介绍重要文件或者内存数据的具体数据布局与结构。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之三：log文件"><a href="#LevelDb剖析之三：log文件" class="headerlink" title="LevelDb剖析之三：log文件"></a>LevelDb剖析之三：log文件</h2><p>上节内容讲到log文件在LevelDb中的主要作用是系统故障恢复时，能够保证不会丢失数据。因为在将记录写入内存的Memtable之前，会先写入Log文件，这样即使系统发生故障，Memtable中的数据没有来得及Dump到磁盘的SSTable文件，LevelDB也可以根据log文件恢复内存的Memtable数据结构内容，不会造成系统丢失数据，在这点上LevelDb和Bigtable是一致的。</p>
<p>下面我们带大家看看log文件的具体物理和逻辑布局是怎样的，LevelDb对于一个log文件，会把它切割成以32K为单位的物理Block，每次读取的单位以一个Block作为基本读取单位，下图展示的log文件由3个Block构成，所以从物理布局来讲，一个log文件就是由连续的32K大小Block构成的。<br><img src="/images/images/githubpages/level3.png" alt=""><br>图3.1 log文件布局</p>
<p>在应用的视野里是看不到这些Block的，应用看到的是一系列的Key:Value对，在LevelDb内部，会将一个Key:Value对看做一条记录的数据，另外在这个数据前增加一个记录头，用来记载一些管理信息，以方便内部处理</p>
<p>记录头包含三个字段，ChechSum是对“类型”和“数据”字段的校验码，为了避免处理不完整或者是被破坏的数据，当LevelDb读取记录数据时候会对数据进行校验，如果发现和存储的CheckSum相同，说明数据完整无破坏，可以继续后续流程。“记录长度”记载了数据的大小，“数据”则是上面讲的Key:Value数值对，“类型”字段则指出了每条记录的逻辑结构和log文件物理分块结构之间的关系，具体而言，主要有以下四种类型：FULL/FIRST/MIDDLE/LAST。</p>
<p> 如果记录类型是FULL，代表了当前记录内容完整地存储在一个物理Block里，没有被不同的物理Block切割开；如果记录被相邻的物理Block切割开，则类型会是其他三种类型中的一种。我们以图3.1所示的例子来具体说明。</p>
<p>假设目前存在三条记录，Record A，Record B和Record C，其中Record A大小为10K，Record B 大小为80K，Record C大小为12K，那么其在log文件中的逻辑布局会如图3.1所示。Record A是图中蓝色区域所示，因为大小为10K&lt;32K，能够放在一个物理Block中，所以其类型为FULL；Record B 大小为80K，而Block 1因为放入了Record A，所以还剩下22K，不足以放下Record B，所以在Block 1的剩余部分放入Record B的开头一部分，类型标识为FIRST，代表了是一个记录的起始部分；Record B还有58K没有存储，这些只能依次放在后续的物理Block里面，因为Block 2大小只有32K，仍然放不下Record B的剩余部分，所以Block 2全部用来放Record B，且标识类型为MIDDLE，意思是这是Record B中间一段数据；Record B剩下的部分可以完全放在Block 3中，类型标识为LAST，代表了这是Record B的末尾数据；图中黄色的Record C因为大小为12K，Block 3剩下的空间足以全部放下它，所以其类型标识为FULL。</p>
<p>从这个小例子可以看出逻辑记录和物理Block之间的关系，LevelDb一次物理读取为一个Block，然后根据类型情况拼接出逻辑记录，供后续流程处理。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之四：SSTable文件"><a href="#LevelDb剖析之四：SSTable文件" class="headerlink" title="LevelDb剖析之四：SSTable文件"></a>LevelDb剖析之四：SSTable文件</h2><p> 　　SSTable是Bigtable中至关重要的一块，对于LevelDb来说也是如此，对LevelDb的SSTable实现细节的了解也有助于了解Bigtable中一些实现细节。</p>
<p>本节内容主要讲述SSTable的静态布局结构，我们曾在“LevelDb剖析之二：整体架构”中说过，SSTable文件形成了不同Level的层级结构，至于这个层级结构是如何形成的我们放在后面Compaction一节细说。本节主要介绍SSTable某个文件的物理布局和逻辑布局结构，这对了解LevelDb的运行过程很有帮助。</p>
<p>　　LevelDb不同层级有很多SSTable文件（以后缀.sst为特征），所有.sst文件内部布局都是一样的。上节介绍Log文件是物理分块的，SSTable也一样会将文件划分为固定大小的物理存储块，但是两者逻辑布局大不相同，根本原因是：Log文件中的记录是Key无序的，即先后记录的key大小没有明确大小关系，而.sst文件内部则是根据记录的Key由小到大排列的，从下面介绍的SSTable布局可以体会到Key有序是为何如此设计.sst文件结构的关键。<br><img src="/images/images/githubpages/level4.png" alt=""><br>图4.1 .sst文件的分块结构</p>
<p>　　图4.1展示了一个.sst文件的物理划分结构，同Log文件一样，也是划分为固定大小的存储块，每个Block分为三个部分，红色部分是数据存储区， 蓝色的Type区用于标识数据存储区是否采用了数据压缩算法（Snappy压缩或者无压缩两种），CRC部分则是数据校验码，用于判别数据是否在生成和传输中出错。</p>
<p>　　以上是.sst的物理布局，下面介绍.sst文件的逻辑布局，所谓逻辑布局，就是说尽管大家都是物理块，但是每一块存储什么内容，内部又有什么结构等。图4.2展示了.sst文件的内部逻辑解释。<br><img src="/images/images/githubpages/level5.png" alt=""><br>图4.2 逻辑布局</p>
<p>　　从图4.2可以看出，从大的方面，可以将.sst文件划分为数据存储区和数据管理区，数据存储区存放实际的Key:Value数据，数据管理区则提供一些索引指针等管理数据，目的是更快速便捷的查找相应的记录。两个区域都是在上述的分块基础上的，就是说文件的前面若干块实际存储KV数据，后面数据管理区存储管理数据。管理数据又分为四种不同类型：紫色的Meta Block，红色的MetaBlock 索引和蓝色的数据索引块以及一个文件尾部块。</p>
<p>　　LevelDb 1.2版对于Meta Block尚无实际使用，只是保留了一个接口，估计会在后续版本中加入内容，下面我们看看数据索引区和文件尾部Footer的内部结构。<br><img src="/images/images/githubpages/level6.png" alt=""><br>图4.3 数据索引</p>
<p>　　图4.3是数据索引的内部结构示意图。再次强调一下，Data Block内的KV记录是按照Key由小到大排列的，数据索引区的每条记录是对某个Data Block建立的索引信息，每条索引信息包含三个内容，以图4.3所示的数据块i的索引Index i来说：红色部分的第一个字段记载大于等于数据块i中最大的Key值的那个Key，第二个字段指出数据块i在.sst文件中的起始位置，第三个字段指出Data Block i的大小（有时候是有数据压缩的）。后面两个字段好理解，是用于定位数据块在文件中的位置的，第一个字段需要详细解释一下，在索引里保存的这个Key值未必一定是某条记录的Key,以图4.3的例子来说，假设数据块i 的最小Key=“samecity”，最大Key=“the best”;数据块i+1的最小Key=“the fox”,最大Key=“zoo”,那么对于数据块i的索引Index i来说，其第一个字段记载大于等于数据块i的最大Key(“the best”)同时要小于数据块i+1的最小Key(“the fox”)，所以例子中Index i的第一个字段是：“the c”，这个是满足要求的；而Index i+1的第一个字段则是“zoo”，即数据块i+1的最大Key。</p>
<p>　　文件末尾Footer块的内部结构见图4.4，metaindex_handle指出了metaindex block的起始位置和大小；inex_handle指出了index Block的起始地址和大小；这两个字段可以理解为索引的索引，是为了正确读出索引值而设立的，后面跟着一个填充区和魔数。</p>
<p>　　上面主要介绍的是数据管理区的内部结构，下面我们看看数据区的一个Block的数据部分内部是如何布局的（图4.1中的红色部分），图4.5是其内部布局示意图。<br><img src="/images/images/githubpages/level7.png" alt=""><br>图4.5 数据Block内部结构</p>
<p>　　从图中可以看出，其内部也分为两个部分，前面是一个个KV记录，其顺序是根据Key值由小到大排列的，在Block尾部则是一些“重启点”（Restart Point）,其实是一些指针，指出Block内容中的一些记录位置。</p>
<p>　　“重启点”是干什么的呢？我们一再强调，Block内容里的KV记录是按照Key大小有序的，这样的话，相邻的两条记录很可能Key部分存在重叠，比如key i=“the Car”，Key i+1=“the color”,那么两者存在重叠部分“the c”，为了减少Key的存储量，Key i+1可以只存储和上一条Key不同的部分“olor”，两者的共同部分从Key i中可以获得。记录的Key在Block内容部分就是这么存储的，主要目的是减少存储开销。“重启点”的意思是：在这条记录开始，不再采取只记载不同的Key部分，而是重新记录所有的Key值，假设Key i+1是一个重启点，那么Key里面会完整存储“the color”，而不是采用简略的“olor”方式。Block尾部就是指出哪些记录是这些重启点的。<br><img src="/images/images/githubpages/level8.png" alt=""><br>图4.6 记录格式</p>
<p>　　在Block内容区，每个KV记录的内部结构是怎样的？图4.6给出了其详细结构，每个记录包含5个字段：key共享长度，比如上面的“olor”记录， 其key和上一条记录共享的Key部分长度是“the c”的长度，即5；key非共享长度，对于“olor”来说，是4；value长度指出Key:Value中Value的长度，在后面的Value内容字段中存储实际的Value值；而key非共享内容则实际存储“olor”这个Key字符串。</p>
<p>　　上面讲的这些就是.sst文件的全部内部奥秘。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之五：MemTable详解"><a href="#LevelDb剖析之五：MemTable详解" class="headerlink" title="LevelDb剖析之五：MemTable详解"></a>LevelDb剖析之五：MemTable详解</h2><p> 　　LevelDb剖析前述小节大致讲述了磁盘文件相关的重要静态结构，本小节讲述内存中的数据结构Memtable，Memtable在整个体系中的重要地位也不言而喻。总体而言，所有KV数据都是存储在Memtable，Immutable Memtable和SSTable中的，Immutable Memtable从结构上讲和Memtable是完全一样的，区别仅仅在于其是只读的，不允许写入操作，而Memtable则是允许写入和读取的。当Memtable写入的数据占用内存到达指定数量，则自动转换为Immutable Memtable，等待Dump到磁盘中，系统会自动生成新的Memtable供写操作写入新数据，理解了Memtable，那么Immutable Memtable自然不在话下。</p>
<p> 　　LevelDb的MemTable提供了将KV数据写入，删除以及读取KV记录的操作接口，但是事实上Memtable并不存在真正的删除操作,删除某个Key的Value在Memtable内是作为插入一条记录实施的，但是会打上一个Key的删除标记，真正的删除操作是Lazy的，会在以后的Compaction过程中去掉这个KV。</p>
<p> 　　需要注意的是，LevelDb的Memtable中KV对是根据Key大小有序存储的，在系统插入新的KV时，LevelDb要把这个KV插到合适的位置上以保持这种Key有序性。其实，LevelDb的Memtable类只是一个接口类，真正的操作是通过背后的SkipList来做的，包括插入操作和读取操作等，所以Memtable的核心数据结构是一个SkipList。</p>
<p> 　　SkipList是由William Pugh发明。他在Communications of the ACM June 1990, 33(6) 668-676 发表了Skip lists: a probabilistic alternative to balanced trees，在该论文中详细解释了SkipList的数据结构和插入删除操作。</p>
<p>SkipList是平衡树的一种替代数据结构，但是和红黑树不相同的是，SkipList对于树的平衡的实现是基于一种随机化的算法的，这样也就是说SkipList的插入和删除的工作是比较简单的。</p>
<p>关于SkipList的详细介绍可以参考这篇文章，<a href="http://coolshell.info/skip-list/" target="_blank" rel="external">skip-list原理解析</a>讲述的很清楚，LevelDb的SkipList基本上是一个具体实现，并无特殊之处。</p>
<p>　　SkipList不仅是维护有序数据的一个简单实现，而且相比较平衡树来说，在插入数据的时候可以避免频繁的树节点调整操作，所以写入效率是很高的，LevelDb整体而言是个高写入系统，SkipList在其中应该也起到了很重要的作用。Redis为了加快插入操作，也使用了SkipList来作为内部实现数据结构。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之六-写入与删除记录"><a href="#LevelDb剖析之六-写入与删除记录" class="headerlink" title="LevelDb剖析之六 写入与删除记录"></a>LevelDb剖析之六 写入与删除记录</h2><p>在之前的五节LevelDb剖析中，我们介绍了LevelDb的一些静态文件及其详细布局，从本节开始，我们看看LevelDb的一些动态操作，比如读写记录，Compaction，错误恢复等操作。</p>
<p>本节介绍levelDb的记录更新操作，即插入一条KV记录或者删除一条KV记录。levelDb的更新操作速度是非常快的，源于其内部机制决定了这种更新操作的简单性。<br><img src="/images/images/githubpages/level9.png" alt=""><br>图6.1 LevelDb写入记录</p>
<p>图6.1是levelDb如何更新KV数据的示意图，从图中可以看出，对于一个插入操作Put(Key,Value)来说，完成插入操作包含两个具体步骤：首先是将这条KV记录以顺序写的方式追加到之前介绍过的log文件末尾，因为尽管这是一个磁盘读写操作，但是文件的顺序追加写入效率是很高的，所以并不会导致写入速度的降低；第二个步骤是:如果写入log文件成功，那么将这条KV记录插入内存中的Memtable中，前面介绍过，Memtable只是一层封装，其内部其实是一个Key有序的SkipList列表，插入一条新记录的过程也很简单，即先查找合适的插入位置，然后修改相应的链接指针将新记录插入即可。完成这一步，写入记录就算完成了，所以一个插入记录操作涉及一次磁盘文件追加写和内存SkipList插入操作，这是为何levelDb写入速度如此高效的根本原因。</p>
<p>从上面的介绍过程中也可以看出：log文件内是key无序的，而Memtable中是key有序的。那么如果是删除一条KV记录呢？对于levelDb来说，并不存在立即删除的操作，而是与插入操作相同的，区别是，插入操作插入的是Key:Value 值，而删除操作插入的是“Key:删除标记”，并不真正去删除记录，而是后台Compaction的时候才去做真正的删除操作。</p>
<p>levelDb的写入操作就是如此简单。真正的麻烦在后面将要介绍的读取操作中。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之七：读取记录"><a href="#LevelDb剖析之七：读取记录" class="headerlink" title="LevelDb剖析之七：读取记录"></a>LevelDb剖析之七：读取记录</h2><p> 　　LevelDb是针对大规模Key/Value数据的单机存储库，从应用的角度来看，LevelDb就是一个存储工具。而作为称职的存储工具，常见的调用接口无非是新增KV，删除KV，读取KV，更新Key对应的Value值这么几种操作。LevelDb的接口没有直接支持更新操作的接口，如果需要更新某个Key的Value,你可以选择直接生猛地插入新的KV，保持Key相同，这样系统内的key对应的value就会被更新；或者你可以先删除旧的KV， 之后再插入新的KV，这样比较委婉地完成KV的更新操作。</p>
<p>假设应用提交一个Key值，下面我们看看LevelDb是如何从存储的数据中读出其对应的Value值的。图7-1是LevelDb读取过程的整体示意图。<br><img src="/images/images/githubpages/level10.png" alt=""><br>图7-1  LevelDb读取记录流程</p>
<p>　　LevelDb首先会去查看内存中的Memtable，如果Memtable中包含key及其对应的value，则返回value值即可；如果在Memtable没有读到key，则接下来到同样处于内存中的Immutable Memtable中去读取，类似地，如果读到就返回，若是没有读到,那么只能万般无奈下从磁盘中的大量SSTable文件中查找。因为SSTable数量较多，而且分成多个Level，所以在SSTable中读数据是相当蜿蜒曲折的一段旅程。总的读取原则是这样的：首先从属于level 0的文件中查找，如果找到则返回对应的value值，如果没有找到那么到level 1中的文件中去找，如此循环往复，直到在某层SSTable文件中找到这个key对应的value为止（或者查到最高level，查找失败，说明整个系统中不存在这个Key)。</p>
<p> 　　那么为什么是从Memtable到Immutable Memtable，再从Immutable Memtable到文件，而文件中为何是从低level到高level这么一个查询路径呢？道理何在？之所以选择这么个查询路径，是因为从信息的更新时间来说，很明显Memtable存储的是最新鲜的KV对；Immutable Memtable中存储的KV数据对的新鲜程度次之；而所有SSTable文件中的KV数据新鲜程度一定不如内存中的Memtable和Immutable Memtable的。对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。也就是说，上面列出的查找路径就是按照数据新鲜程度排列出来的，越新鲜的越先查找。</p>
<p> 　　为啥要优先查找新鲜的数据呢？这个道理不言而喻，举个例子。比如我们先往levelDb里面插入一条数据 {key=”www.samecity.com”  value=”我们”},过了几天，samecity网站改名为：69同城，此时我们插入数据{key=”www.samecity.com”  value=”69同城”}，同样的key,不同的value；逻辑上理解好像levelDb中只有一个存储记录，即第二个记录，但是在levelDb中很可能存在两条记录，即上面的两个记录都在levelDb中存储了，此时如果用户查询key=”www.samecity.com”,我们当然希望找到最新的更新记录，也就是第二个记录返回，这就是为何要优先查找新鲜数据的原因。</p>
<p>　　前文有讲：对于SSTable文件来说，如果同时在level L和Level L+1找到同一个key，level L的信息一定比level L+1的要新。这是一个结论，理论上需要一个证明过程，否则会招致如下的问题：为神马呢？从道理上讲呢，很明白：因为Level L+1的数据不是从石头缝里蹦出来的，也不是做梦梦到的，那它是从哪里来的？Level L+1的数据是从Level L 经过Compaction后得到的（如果您不知道什么是Compaction，那么……..也许以后会知道的），也就是说，您看到的现在的Level L+1层的SSTable数据是从原来的Level L中来的，现在的Level L比原来的Level L数据要新鲜，所以可证，现在的Level L比现在的Level L+1的数据要新鲜。</p>
<p>　　SSTable文件很多，如何快速地找到key对应的value值？在LevelDb中，level 0一直都爱搞特殊化，在level 0和其它level中查找某个key的过程是不一样的。因为level 0下的不同文件可能key的范围有重叠，某个要查询的key有可能多个文件都包含，这样的话LevelDb的策略是先找出level 0中哪些文件包含这个key（manifest文件中记载了level和对应的文件及文件里key的范围信息，LevelDb在内存中保留这种映射表）， 之后按照文件的新鲜程度排序，新的文件排在前面，之后依次查找，读出key对应的value。而如果是非level 0的话，因为这个level的文件之间key是不重叠的，所以只从一个文件就可以找到key对应的value。</p>
<p>　　最后一个问题,如果给定一个要查询的key和某个key range包含这个key的SSTable文件，那么levelDb是如何进行具体查找过程的呢？levelDb一般会先在内存中的Cache中查找是否包含这个文件的缓存记录，如果包含，则从缓存中读取；如果不包含，则打开SSTable文件，同时将这个文件的索引部分加载到内存中并放入Cache中。 这样Cache里面就有了这个SSTable的缓存项，但是只有索引部分在内存中，之后levelDb根据索引可以定位到哪个内容Block会包含这条key，从文件中读出这个Block的内容，在根据记录一一比较，如果找到则返回结果，如果没有找到，那么说明这个level的SSTable文件并不包含这个key，所以到下一级别的SSTable中去查找。</p>
<p>　　从之前介绍的LevelDb的写操作和这里介绍的读操作可以看出，相对写操作，读操作处理起来要复杂很多，所以写的速度必然要远远高于读数据的速度，也就是说，LevelDb比较适合写操作多于读操作的应用场合。而如果应用是很多读操作类型的，那么顺序读取效率会比较高，因为这样大部分内容都会在缓存中找到，尽可能避免大量的随机读取操作。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之八：Compaction操作"><a href="#LevelDb剖析之八：Compaction操作" class="headerlink" title="LevelDb剖析之八：Compaction操作"></a>LevelDb剖析之八：Compaction操作</h2><p>前文有述，对于LevelDb来说，写入记录操作很简单，删除记录仅仅写入一个删除标记就算完事，但是读取记录比较复杂，需要在内存以及各个层级文件中依照新鲜程度依次查找，代价很高。为了加快读取速度，levelDb采取了compaction的方式来对已有的记录进行整理压缩，通过这种方式，来删除掉一些不再有效的KV数据，减小数据规模，减少文件数量等。</p>
<p>levelDb的compaction机制和过程与Bigtable所讲述的是基本一致的，Bigtable中讲到三种类型的compaction: minor ，major和full。所谓minor Compaction，就是把memtable中的数据导出到SSTable文件中；major compaction就是合并不同层级的SSTable文件，而full compaction就是将所有SSTable进行合并。</p>
<p> LevelDb包含其中两种，minor和major。</p>
<p>我将为大家详细叙述其机理。</p>
<p>先来看看minor Compaction的过程。Minor compaction 的目的是当内存中的memtable大小到了一定值时，将内容保存到磁盘文件中，图8.1是其机理示意图。 <img src="/images/images/githubpages/level11.png" alt=""><br>图8.1 minor compaction</p>
<p>从8.1可以看出，当memtable数量到了一定程度会转换为immutable memtable，此时不能往其中写入记录，只能从中读取KV内容。之前介绍过，immutable memtable其实是一个多层级队列SkipList，其中的记录是根据key有序排列的。所以这个minor compaction实现起来也很简单，就是按照immutable memtable中记录由小到大遍历，并依次写入一个level 0 的新建SSTable文件中，写完后建立文件的index 数据，这样就完成了一次minor compaction。从图中也可以看出，对于被删除的记录，在minor compaction过程中并不真正删除这个记录，原因也很简单，这里只知道要删掉key记录，但是这个KV数据在哪里?那需要复杂的查找，所以在minor compaction的时候并不做删除，只是将这个key作为一个记录写入文件中，至于真正的删除操作，在以后更高层级的compaction中会去做。</p>
<p>当某个level下的SSTable文件数目超过一定设置值后，levelDb会从这个level的SSTable中选择一个文件（level&gt;0），将其和高一层级的level+1的SSTable文件合并，这就是major compaction。</p>
<p>我们知道在大于0的层级中，每个SSTable文件内的Key都是由小到大有序存储的，而且不同文件之间的key范围（文件内最小key和最大key之间）不会有任何重叠。Level 0的SSTable文件有些特殊，尽管每个文件也是根据Key由小到大排列，但是因为level 0的文件是通过minor compaction直接生成的，所以任意两个level 0下的两个sstable文件可能再key范围上有重叠。所以在做major compaction的时候，对于大于level 0的层级，选择其中一个文件就行，但是对于level 0来说，指定某个文件后，本level中很可能有其他SSTable文件的key范围和这个文件有重叠，这种情况下，要找出所有有重叠的文件和level 1的文件进行合并，即level 0在进行文件选择的时候，可能会有多个文件参与major compaction。</p>
<p>　　levelDb在选定某个level进行compaction后，还要选择是具体哪个文件要进行compaction，levelDb在这里有个小技巧， 就是说轮流来，比如这次是文件A进行compaction，那么下次就是在key range上紧挨着文件A的文件B进行compaction，这样每个文件都会有机会轮流和高层的level 文件进行合并。</p>
<p>如果选好了level L的文件A和level L+1层的文件进行合并，那么问题又来了，应该选择level L+1哪些文件进行合并？levelDb选择L+1层中和文件A在key range上有重叠的所有文件来和文件A进行合并。</p>
<p> 　　也就是说，选定了level L的文件A,之后在level L+1中找到了所有需要合并的文件B,C,D…..等等。剩下的问题就是具体是如何进行major 合并的？就是说给定了一系列文件，每个文件内部是key有序的，如何对这些文件进行合并，使得新生成的文件仍然Key有序，同时抛掉哪些不再有价值的KV 数据。</p>
<p>图8.2说明了这一过程。<br><img src="/images/images/githubpages/level12.png" alt=""><br>图8.2 SSTable Compaction</p>
<p>　　Major compaction的过程如下：对多个文件采用多路归并排序的方式，依次找出其中最小的Key记录，也就是对多个文件中的所有记录重新进行排序。之后采取一定的标准判断这个Key是否还需要保存，如果判断没有保存价值，那么直接抛掉，如果觉得还需要继续保存，那么就将其写入level L+1层中新生成的一个SSTable文件中。就这样对KV数据一一处理，形成了一系列新的L+1层数据文件，之前的L层文件和L+1层参与compaction 的文件数据此时已经没有意义了，所以全部删除。这样就完成了L层和L+1层文件记录的合并过程。</p>
<p>　　那么在major compaction过程中，判断一个KV记录是否抛弃的标准是什么呢？其中一个标准是:对于某个key来说，如果在小于L层中存在这个Key，那么这个KV在major compaction过程中可以抛掉。因为我们前面分析过，对于层级低于L的文件中如果存在同一Key的记录，那么说明对于Key来说，有更新鲜的Value存在，那么过去的Value就等于没有意义了，所以可以删除。</p>
<hr>
<hr>
<h2 id="LevelDb剖析之九-levelDb中的Cache"><a href="#LevelDb剖析之九-levelDb中的Cache" class="headerlink" title="LevelDb剖析之九 levelDb中的Cache"></a>LevelDb剖析之九 levelDb中的Cache</h2><p>　　书接前文，前面讲过对于levelDb来说，读取操作如果没有在内存的memtable中找到记录，要多次进行磁盘访问操作。假设最优情况，即第一次就在level 0中最新的文件中找到了这个key，那么也需要读取2次磁盘，一次是将SSTable的文件中的index部分读入内存，这样根据这个index可以确定key是在哪个block中存储；第二次是读入这个block的内容，然后在内存中查找key对应的value。</p>
<p>　　levelDb中引入了两个不同的Cache:Table Cache和Block Cache。其中Block Cache是配置可选的，即在配置文件中指定是否打开这个功能。<br><img src="/images/images/githubpages/level3.png" alt=""><br>图9.1 table cache</p>
<p> 　　图9.1是table cache的结构。在Cache中，key值是SSTable的文件名称，Value部分包含两部分，一个是指向磁盘打开的SSTable文件的文件指针，这是为了方便读取内容；另外一个是指向内存中这个SSTable文件对应的Table结构指针，table结构在内存中，保存了SSTable的index内容以及用来指示block cache用的cache_id ,当然除此外还有其它一些内容。</p>
<p>　　比如在get(key)读取操作中，如果levelDb确定了key在某个level下某个文件A的key range范围内，那么需要判断是不是文件A真的包含这个KV。此时，levelDb会首先查找Table Cache，看这个文件是否在缓存里，如果找到了，那么根据index部分就可以查找是哪个block包含这个key。如果没有在缓存中找到文件，那么打开SSTable文件，将其index部分读入内存，然后插入Cache里面，去index里面定位哪个block包含这个Key 。如果确定了文件哪个block包含这个key，那么需要读入block内容，这是第二次读取。</p>
<p> 　　Block Cache是为了加快这个过程的，图9.2是其结构示意图。其中的key是文件的cache_id加上这个block在文件中的起始位置block_offset。而value则是这个Block的内容。</p>
<p>　　如果levelDb发现这个block在block cache中，那么可以避免读取数据，直接在cache里的block内容里面查找key的value就行，如果没找到呢？那么读入block内容并把它插入block cache中。levelDb就是这样通过两个cache来加快读取速度的。从这里可以看出，如果读取的数据局部性比较好，也就是说要读的数据大部分在cache里面都能读到，那么读取效率应该还是很高的，而如果是对key进行顺序读取效率也应该不错，因为一次读入后可以多次被复用。但是如果是随机读取，您可以推断下其效率如何。</p>
<h2 id="LevelDb剖析之十-Version、VersionEdit、VersionSet"><a href="#LevelDb剖析之十-Version、VersionEdit、VersionSet" class="headerlink" title="LevelDb剖析之十 Version、VersionEdit、VersionSet"></a>LevelDb剖析之十 Version、VersionEdit、VersionSet</h2><p>　　Version 保存了当前磁盘以及内存中所有的文件信息，一般只有一个Version叫做”current” version（当前版本）。Leveldb还保存了一系列的历史版本，这些历史版本有什么作用呢？</p>
<p>当一个Iterator创建后，Iterator就引用到了current version(当前版本)，只要这个Iterator不被delete那么被Iterator引用的版本就会一直存活。这就意味着当你用完一个Iterator后，需要及时删除它。</p>
<p>　　当一次Compaction结束后（会生成新的文件，合并前的文件需要删除），Leveldb会创建一个新的版本作为当前版本，原先的当前版本就会变为历史版本。</p>
<p>　　VersionSet 是所有Version的集合，管理着所有存活的Version。</p>
<p>　　VersionEdit 表示Version之间的变化，相当于delta 增量，表示有增加了多少文件，删除了文件。下图表示他们之间的关系。</p>
<p>Version0 +VersionEdit–&gt;Version1</p>
<p>　　VersionEdit会保存到MANIFEST文件中，当做数据恢复时就会从MANIFEST文件中读出来重建数据。</p>
<p>　　leveldb的这种版本的控制，让我想到了双buffer切换，双buffer切换来自于图形学中，用于解决屏幕绘制时的闪屏问题，在服务器编程中也有用处。</p>
<p>　　比如我们的服务器上有一个字典库，每天我们需要更新这个字典库，我们可以新开一个buffer，将新的字典库加载到这个新buffer中，等到加载完毕，将字典的指针指向新的字典库。</p>
<p>leveldb的version管理和双buffer切换类似，但是如果原version被某个iterator引用，那么这个version会一直保持，直到没有被任何一个iterator引用，此时就可以删除这个version。</p>
<p>注：本文参考了这篇文章：<a href="http://www.samecity.com/blog/Index.asp?SortID=12" target="_blank" rel="external">http://www.samecity.com/blog/Index.asp?SortID=12</a><br>参考资料：1.<a href="http://zh.wikipedia.org/wiki/LevelDB" target="_blank" rel="external">维基百科</a><br>　　　　　2.<a href="http://code.google.com/p/leveldb/" target="_blank" rel="external">google code</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java中内部类]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/java-inner-class.html</url>
      <content type="html"><![CDATA[<p>最近在想一个问题，Java语言为什么要设计内部类呢，经过查阅相关的书籍后在这里总结一下。</p>
<hr>
<h2 id="从多继承的角度来分析"><a href="#从多继承的角度来分析" class="headerlink" title="从多继承的角度来分析"></a>从多继承的角度来分析</h2><p>C++作为比较早期的面向对象编程语言，摸着石头过河，不幸的当了炮灰，比如多重继承，在使用的过程中会出现死亡菱形的情况，而Java的设计者意识到了这个问题，所以Java是不支持多重继承的，想要扩展功能可以使用interface，但是后来Java的设计者意识到多重继承也不是一无是处，比如说当你的父类和实现的接口有相同签名的方法时，接口的方法会覆盖父类的方法，怎么办呢，这个时候内部类就应运而生了。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><a id="more"></a></h2><p>java的非静态内部类可以使用外部类的所有成员方法和变量。这给继承多个类的同名成员并共享带来可能。同时非匿名内部类可以继承一个父类和实现多个接口，因此外部类想要多继承的类可以分别由内部类继承，并进行Override或者直接复用。然后外部类通过创建内部类的对象来使用该内部对象的方法和成员，从而达到复用的目的，这样外部内就具有多个父类的所有特征。这里的多继承可以说是外部类继承自一个内部类对象，而不是类，内部类 is in a 外部类，外部内的所有行为都是通过内部类对象动态获得的。</p>
<hr>
<p>上面所说的多继承是站在外部类的角度来看的，即它们是通过外部类引用内部类来达到多态与复用的目的。反过来，内部类继承了一个类，同时拥有了外部类的所有成员方法和属性，我们是否可以认为内部类集成了两个类呢？——一个是类层面的，一个是对象层面的（因为非静态内部类使用前一定有外部类的对象来创建它，它持有外部类某个对象的引用）。如果外部类还继承了其他类呢？内部类还是可以访问其他类的方法与属性。</p>
<hr>
<p>如果你想继承一个类或实现一个接口，但是这个接口或类中的一个方法和你构想的这个类中的一个方法的名称，参数相同，但访问权限缩小了或者是在继承时不想覆盖签名相同但功能不同的方法，所以你不能直接继承与实现它，你应该怎么办？这时候，你可以建一个内部类继承这个类或实现这个接口（当然你可以修改访问权限是可以的）。由于内部类对外部类的所有内容都是可访问的，内部类可以通过调用外部类的这个方法来重写那个类或接口。</p>
<hr>
<h2 id="从回调的角度来分析"><a href="#从回调的角度来分析" class="headerlink" title="从回调的角度来分析"></a>从回调的角度来分析</h2><p>编程上来说，一般使用一个库或类时，是你主动调用人家的API，这个叫Call，有的时候这样不能满足需要，需要你注册（注入）你自己的程序（比如一个对象)，然后让人家在合适的时候来调用你，这叫Callback(回调)。</p>
<p>设计模式中的Observer就是例子：所有的观察者都需要向自己关心的主题Observable注册，然后主题在适当时机（主题类对象的属性发生变化时）通知所有订阅它的观察者并更新，其中观察者都实现了一个统一的Observer接口中的。事件驱动机制也是这样的，你给感兴趣的事件注册相应的回调函数，当对应的事件发生了会调用回调函数，比如libevent的实现就是这样的。</p>
<p>再举个安卓开发的例子，安卓的button组件需要注册相应的按钮按下事件监听器，在按钮按下的时候调用注册的事件，</p>
<pre><code>button.setOnClickListener(new Button.OnClickListener(){
    @override
    public void click(View v){
    .........
    }
    });
</code></pre><p>new OnClickListener(…)这里是个匿名内部类，实现了onClick接口，我们给Button注册相应的回调事件，当按钮被按下时调用click里面的代码。</p>
<hr>
<h2 id="从闭包的角度"><a href="#从闭包的角度" class="headerlink" title="从闭包的角度"></a>从闭包的角度</h2><p>javaScript中闭包的产生是由于JavaScript中允许内部function，也就是在一个function内部声明的function。内部function可以访问外部 function中的局部变量、传入的参数和其它内部function。当内部 function可以在包含它的外部 function之外被引用时，就形成了一个闭包。这个时候，即便外部 function 已经执行完成，该内部 function 仍然可以被执行，并且其中所用到的外部function的局部变量、传入的参数等仍然保留外部function执行结束时的值。下面是一个例子：</p>
<pre><code>function Outer(){  
var i=0;  
function Inner(){  
alert(++i);  
}  
return Inner;  
}  
var inner = Outer();  
inner();  
</code></pre><p>因为函数Outer外的变量inner引用了函数Outer内的函数Inner，就是说：当函数Outer的内部函数Inner被函数Outer外的一个变量inner引用的时候，就创建了一个闭包。</p>
<p>闭包有什么作用：简而言之，闭包的作用就是在Outer执行完并返回后，闭包使得Javascript的垃圾回收机制GC不会收回Outer所占用的资源，因为Outer的内部函数Inner的执行需要依赖Outer中的变量。</p>
<p>闭包是一个可调用的对象，它记录了一些信息，这些信息来自于创建它的作用域。通过这个定义，可以看出内部类是面向对象的闭包，因为它不仅包含创建内部类的作用域的信息，还自动拥有一个指向此外围类对象的引用，在此作用域内，内部类有权操作所有的成员，包括private成员。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java同步容器与并发容器]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/java-concurrent-collections.html</url>
      <content type="html"><![CDATA[<p>在编程的时候经常会用到容器，当容器被多线程读取的时候我们就要考虑线程安全的问题，哪些容器是线程是线程安全的，容器的哪些操作又是线程安全的，这些安全机制是怎么实现的，本文将一一介绍。<br><a id="more"></a></p>
<h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><h3 id="1-vector和hashtable"><a href="#1-vector和hashtable" class="headerlink" title="1. vector和hashtable"></a>1. vector和hashtable</h3><p>jdk很早的时候就支持vector和hashtable，vector内部是一个数组，它的同步是在所有对元素的存取操作上进行synchronized的，也就是说每个时刻只能由一个线程可以访问容器的元素，这种线程安全是比较粗粒度的。<br>比如你在进行vector容器的迭代操作(iterator.next())时再调用vector.put(object o)时会抛出ConcurrentModificationException</p>
<hr>
<p>hashtable的内部实现：<br>  首先回顾下hashmap的实现，我们初始化一个hashmap时有两个参数inital capacity用来定义hashmap的初始化buckets数，reload factor加载因子，初始值为0.75，当hashmap中entry的数量超过这个比值时hashmap就会进行扩容，然后所有的entry进行rehash，这两个初始参数都必须选择合适的值，如果inital capacity选择太小，由于容器是开链的，会给查找元素增加额外的负担，reload factor不能选的过大，否则插入元素时出现碰撞的几率会增大。<br>hashtable就是在hashmap的基础上对所有元素的访问和插入操作用synchronized关键字同步，同样，在对容器元素迭代访问时进行插入操作会抛出ConcurrentModificationException。</p>
<hr>
<h3 id="2-collections-synchronizedXXX工厂方法创建"><a href="#2-collections-synchronizedXXX工厂方法创建" class="headerlink" title="2. collections.synchronizedXXX工厂方法创建"></a>2. collections.synchronizedXXX工厂方法创建</h3><p>  collections.synchronizedXXX是在jdk2引入的，和vector,hashtable一样，都是在整个容器上进行同步操作。<br>举个例子，下面这个是jdk7种collections.synchronizedMap的实现，这里只列出部分代码：</p>
<pre><code>private static class SynchronizedMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Serializable {
    private static final long serialVersionUID = 1978198479659022715L;

    private final Map&lt;K,V&gt; m;     // Backing Map
    final Object      mutex;        // Object on which to synchronize

    SynchronizedMap(Map&lt;K,V&gt; m) {
        this.m = Objects.requireNonNull(m);
        mutex = this;
    }

    SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {
        this.m = m;
        this.mutex = mutex;
    }
    //所有的操作都是在同一个监视器上进行同步
    public int size() {
        synchronized (mutex) {return m.size();}
    }
    public boolean isEmpty() {
        synchronized (mutex) {return m.isEmpty();}
    }
    public boolean containsKey(Object key) {
        synchronized (mutex) {return m.containsKey(key);}
    }
    public boolean containsValue(Object value) {
        synchronized (mutex) {return m.containsValue(value);}
    }
    public V get(Object key) {
        synchronized (mutex) {return m.get(key);}
    }

    public V put(K key, V value) {
        synchronized (mutex) {return m.put(key, value);}
    }
    public V remove(Object key) {
        synchronized (mutex) {return m.remove(key);}
    }
    public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
        synchronized (mutex) {m.putAll(map);}
    }
    public void clear() {
        synchronized (mutex) {m.clear();}
    }
</code></pre><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>JDK5中添加了新的concurrent包，其中包含了很多并发容器，这些容器针对多线程环境进行了优化，大大提高了容器类在并发环境下的执行效率。<br>下面所有的代码都是来源于jdk7。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList类是一个线程安全的List接口的实现，在该类的内部进行元素的<strong>写操作时，底层的数组将被完整的复制</strong>，这对于读操作远远多于写操作的应用非常适合。在CopyOnWriteArrayList上进行操作时，<strong>读操作不需要加锁，而写操作类实现中对其进行了加锁</strong>。</p>
<p>底层实现如下：</p>
<pre><code>public class CopyOnWriteArrayList&lt;E&gt;  
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {  

/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

/** The array, accessed only via getArray/setArray. */
private transient volatile Object[] array;
 final Object[] getArray() {
    return array;
}

  ...  
}  
</code></pre><p>读写操作：</p>
<pre><code> @SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}

public E get(int index) {
    return get(getArray(), index);
}
//使用ReentrantLock加锁保护
 public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        E oldValue = get(elements, index);

        if (oldValue != element) {
            int len = elements.length;
//创建一个新的数组，复制原来的元素
            Object[] newElements = Arrays.copyOf(elements, len);
//set的元素
            newElements[index] = element;
            setArray(newElements);
        } else {
// 替换底层的数组
            setArray(elements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre><p> 特别注意：在CopyOnWriteArrayList上获得的Iterator是不能进行set和remove操作的，否则会抛出ConcurrentModificationException。</p>
<hr>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>BlockingQueue接口定义了一种阻塞的FIFO queue，基于生产者消费者模式，每一个BlockingQueue都有一个容量，让容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。</p>
<p>ArrayBlockingQueue是对BlockingQueue的一个数组实现，它使用一把全局的锁并行对queue的读写操作，同时使用两个Condition阻塞容量为空时的取操作和容量满时的写操作。<br>底层实现：</p>
<pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

// 使用循环数组来实现queue，初始时takeIndex和putIndex均为0  
private final E[] items;  
private transient int takeIndex;  
private transient int putIndex;  
private int count;  

// 用于并发的锁和条件  
private final ReentrantLock lock;  
private final Condition notEmpty;  
private final Condition notFull;  

/** 
 * 循环数组 
 * Circularly increment i. 
 */  
final int inc(int i) {  
    return (++i == items.length)? 0 : i;  
}  

public ArrayBlockingQueue(int capacity, boolean fair) {  
    if (capacity &lt;= 0)  
        throw new IllegalArgumentException();  
    this.items = (E[]) new Object[capacity];  
    // 分配锁及该锁上的condition  
    lock = new ReentrantLock(fair);  
    notEmpty = lock.newCondition();  
    notFull =  lock.newCondition();  
}  

  ...  
}  
</code></pre><p> ArrayBlockingQueue的取操作：</p>
<pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private E extract() {  
    final E[] items = this.items;  
    E x = items[takeIndex];  
    items[takeIndex] = null;  
    takeIndex = inc(takeIndex);  
    --count;  
   // 激发notFull条件  
    notFull.signal();  
    return x;  
}  

 /** 
 * condition的await的语义如下： 
 *　与condition相关的锁以原子方式释放，并禁用该线程 
 *　方法返回时，线程必须获得与该condition相关的锁 
 */  
public E take() throws InterruptedException {  
    final ReentrantLock lock = this.lock;  
    lock.lockInterruptibly();  
    try {  
        try {  
              // 等待notEmpty的条件  
            while (count == 0)  
                notEmpty.await();  
        } catch (InterruptedException ie) {  
        // 唤醒其他正在等待的线程  
            notEmpty.signal(); 

            throw ie;  
        }  
        E x = extract();  
        return x;  
    } finally {  
        lock.unlock();  
    }  
}  

  ...  
}  
</code></pre><p>ArrayBlockingQueue的写操作：</p>
<pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private void insert(E x) {  
    items[putIndex] = x;  
    putIndex = inc(putIndex);  
    ++count;  
    notEmpty.signal();  
}  

public void put(E o) throws InterruptedException {  
    if (o == null) throw new NullPointerException();  
    final E[] items = this.items;  
    final ReentrantLock lock = this.lock;  
    lock.lockInterruptibly();  
    try {  
        try {  
              // 等待notFull条件  
       while (count == items.length)  
                notFull.await();  
        } catch (InterruptedException ie) {  
    // 唤醒其他正在等待的线程      
              notFull.signal(); 

            throw ie;  
        }  
        insert(o);  
    } finally {  
        lock.unlock();  
    }  
}  

  ...  
}  
</code></pre><p>注意：ArrayBlockingQueue<strong>在读写操作上都需要锁住整个容器</strong>，因此吞吐量与一般的实现是相似的，适合于实现“生产者消费者”模式。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是BlockingQueue的一种使用Link List的实现，它<strong>对头和尾（取和添加操作）采用两把不同的锁</strong>，相对于ArrayBlockingQueue提高了吞吐量。它也是一种阻塞型的容器，适合于实现“消费者生产者”模式。</p>
<p>  LinkedBlockingQueue底层的定义如下：</p>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

static class Node&lt;E&gt; {  
    /** The item, volatile to ensure barrier separating write and read */  

    volatile E item;  
    Node&lt;E&gt; next;  
    Node(E x) { item = x; }  
}  

// 支持原子操作  
private final AtomicInteger count = new AtomicInteger(0);  

// 链表的头和尾  
private transient Node&lt;E&gt; head;  
private transient Node&lt;E&gt; last;  

// 针对取和添加操作的两把锁及其上的条件  
private final ReentrantLock takeLock = new ReentrantLock();  
private final Condition notEmpty = takeLock.newCondition();  

private final ReentrantLock putLock = new ReentrantLock();  
private final Condition notFull = putLock.newCondition();  

   ...  
} 
</code></pre><p>  LinkedBlockingQueue的添加操作：</p>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private void insert(E x) {  
    last = last.next = new Node&lt;E&gt;(x);  
}  

/** 
 * signal方法在被调用时，当前线程必须拥有该condition相关的锁! 
 * Signal a waiting take. Called only from put/offer (which do not otherwise ordinarily lock takeLock.) 
 */  
private void signalNotEmpty() {  
    final ReentrantLock takeLock = this.takeLock;  
    takeLock.lock();  
    try {  
        notEmpty.signal();  
    } finally {  
        takeLock.unlock();  
    }  
}  

public void put(E o) throws InterruptedException {  
    if (o == null) throw new NullPointerException();  
    int c = -1;  
    final ReentrantLock putLock = this.putLock;  
    final AtomicInteger count = this.count;  
    // 使用putLock  
    putLock.lockInterruptibly();  
    try {  
        try {  
              // 当容量已满时，等待notFull条件  
        while (count.get() == capacity)  
                notFull.await();  
        } catch (InterruptedException ie) {  
            notFull.signal(); // propagate to a non-interrupted thread  
            throw ie;  
        }  
        insert(o);  
        // 取出当前值，并将原数据增加1  
        c = count.getAndIncrement();  
        // 容量不满，再次激活notFull上等待的put线程  
    if (c + 1 &lt; capacity)  
            notFull.signal();  
    } finally {  
        putLock.unlock();  
    }  
    // 必须先释放putLock再在notEmpty上signal，否则会造成死锁  
 if (c == 0)  
        signalNotEmpty();  
}  

  ...  
}   
</code></pre><p> LinkedBlockingQueue的取操作：</p>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private E extract() {  
    Node&lt;E&gt; first = head.next;  
    head = first;  
    E x = first.item;  
    first.item = null;  
    return x;  
}  

private void signalNotFull() {  
    final ReentrantLock putLock = this.putLock;  
    putLock.lock();  
    try {  
        notFull.signal();  
    } finally {  
        putLock.unlock();  
    }  
}  

public E take() throws InterruptedException {  
    E x;  
    int c = -1;  
    final AtomicInteger count = this.count;  
    final ReentrantLock takeLock = this.takeLock;  
    // 使用takeLock  
    takeLock.lockInterruptibly();  
    try {  
        try {  
              // 若容量为空，等待notEmpty  
            while (count.get() == 0)  
                notEmpty.await();  
        } catch (InterruptedException ie) {  
            notEmpty.signal(); // propagate to a non-interrupted thread  
            throw ie;  
        }  

        x = extract();  
        c = count.getAndDecrement();  
        // 再次激活notEmpty  
        if (c &gt; 1)  
            notEmpty.signal();  
    } finally {  
        takeLock.unlock();  
    }  
    // take执行之前容量已满，则激活notFull  
    if (c == capacity)  
        signalNotFull();  
    return x;  
}  

  ...  
}  
</code></pre><hr>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p> ConcurrentHashMap是Map的一种并发实现，在该类中<strong>元素的read操作都是无锁了，而write操作需要被同步</strong>。这非常适合于读操作远大于写操作的情况。在实现过程中，ConcurrentHashMap将所有元素分成了若干个segment，每个segment是独立的，在一个segment上加锁并不影响其他segment的操作。segment本身是一个hashtable，对于一个加入ConcurrentHashMap的<key, value="">对，key的hash值中的高位被用来索引segment，而低位用于segment中的索引。</key,></p>
<p>虽然读操作不阻塞，但是读到的值可能不是最新的值，因为可能有其他线程又更新了元素，Iterator操作也是一样，包括size(),isEmpty(),containValue()返回的结果可能是错误的，而且每个时刻只有一个线程可以访问迭代器。</p>
<p>  segment是ConcurrentHashMap存储元素的基本段，它本身是一个hashtable的实现，read操作时无锁的，write需要同步，定义如下：</p>
<pre><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  


/** 
 *  key, hash, next都是不可改的 
*  value值可被重写 
*/  
static final class HashEntry&lt;K,V&gt; {  
    final K key;  
    final int hash;  
    volatile V value;  
    final HashEntry&lt;K,V&gt; next;  

    ...  
 }  

   static final class Segment&lt;K,V&gt; extends ReentrantLock   implements Serializable {  

    transient volatile int count;  
    transient volatile HashEntry[] table;  
    // 当segment中元素个数达到threshold时，需要rehash  
    transient int threshold;  
}  

  ...  
}
</code></pre><p> segment的read操作：</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

  HashEntry&lt;K,V&gt; getFirst(int hash) {  
      HashEntry[] tab = table;  
      return (HashEntry&lt;K,V&gt;) tab[hash &amp; (tab.length - 1)];  
  }  

 V get(Object key, int hash) { // 该操作是无锁的  
      if (count != 0) { // read-volatile  
          HashEntry&lt;K,V&gt; e = getFirst(hash);  
          while (e != null) {  
              if (e.hash == hash &amp;&amp; key.equals(e.key)) {  
                  V v = e.value;  
                  if (v != null)  
                      return v;  
                    // recheck  
                  return readValueUnderLock(e);

              }  
              e = e.next;  
          }  
      }  
      return null;  
  }  

...  
} 
</code></pre><p>  由于HashEntry当中的key和next都是final的，所以segment之上的操作不可能影响HashEntry列表之间相对的顺序，而value是可变的，当第一次读值失败时，尝试加锁读。<br>  segment的replace操作：  </p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

   /** 
   * replace操作是就地替换，HashEntry的value是非final的 
   */  
    boolean replace(K key, int hash, V oldValue, V newValue) {  
        lock();  // replace操作是同步的  
    try {  
            // 得到该hash值对应的entry列表  
       HashEntry&lt;K,V&gt; e = getFirst(hash);  
       while (e != null &amp;&amp; (e.hash != hash || !                key.equals(e.key)))  
             e = e.next;  

            boolean replaced = false;  
            if (e != null &amp;&amp; oldValue.equals(e.value)) {     // 替换  
                  replaced = true;  
                 e.value = newValue;  
            }  
            return replaced;  
        } finally {  
            unlock();  
        }  
    }  

  ...  
}  
</code></pre><p>segment的remove操作一种copy on write 的方法，保留被删元素之后的列表，copy被删元素之前的hashEntry：</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

    V remove(Object key, int hash, Object value) {  
        lock();  
        try {  
            int c = count - 1;  
            HashEntry[] tab = table;  
            int index = hash &amp; (tab.length - 1);  
            HashEntry&lt;K,V&gt; first = (HashEntry&lt;K,V&gt;)tab[index];  
            HashEntry&lt;K,V&gt; e = first;  
            while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))  
                e = e.next;  

            V oldValue = null;  
            if (e != null) {  
                V v = e.value;  
                if (value == null || value.equals(v)) { // copy on write  
                    oldValue = v;  
                    ++modCount;  
                    // e之后的列表可以保留，只需要重新创建e之前的HashEntry即可  
             HashEntry&lt;K,V&gt; newFirst = e.next;  
                    // copy on write e之前的HashEntry  
                    for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)  
                        newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash,    
                                                      newFirst, p.value);  
                    tab[index] = newFirst;  
                    count = c; // write-volatile  
                }  
            }  
            return oldValue;  
        } finally {  
            unlock();  
        }  
    }  

  ...  
}  
</code></pre><p>segment的rehash操作实现比较特别，为了保证rehash过程中copy的元素尽可能少，segment在rehash时Entry入口的个数是以2的倍数增长，这可以保证一个entry在rehash之后要么在原来的列表中，要么在下一个列表中：</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

    void rehash() {  
        // 局部变量引用table  
        HashEntry[] oldTable = table;              
        int oldCapacity = oldTable.length;  
        if (oldCapacity &gt;= MAXIMUM_CAPACITY)  
            return;  

        // 右移1位相当于乘以2  
        HashEntry[] newTable = new HashEntry[oldCapacity &lt;&lt; 1];  
        threshold = (int)(newTable.length * loadFactor);  
        int sizeMask = newTable.length - 1;  
        for (int i = 0; i &lt; oldCapacity ; i++) {  
            // 第i个entry列表  
       HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;)oldTable[i];  

            if (e != null) {  
                HashEntry&lt;K,V&gt; next = e.next;  
                // 在新table上的索引  
                int idx = e.hash &amp; sizeMask;  

                if (next == null)  
                    newTable[idx] = e;  
                else {  
                    // 寻找该entry列表末端，rehash之后idx相同的元素  
                    // 这些元素不需要被copy  
                    HashEntry&lt;K,V&gt; lastRun = e;  
                    int lastIdx = idx;  
                    for (HashEntry&lt;K,V&gt; last = next;  
                         last != null;  
                         last = last.next) {  
                        int k = last.hash &amp; sizeMask;  
                        if (k != lastIdx) {  
                            lastIdx = k;  
                            lastRun = last;  
                        }  
                    }  
                    // 将lastRun之后的整个列表挂到新位置上  
                    newTable[lastIdx] = lastRun;  

                    // Clone all remaining nodes  
                    for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {  
                        int k = p.hash &amp; sizeMask;  
                        HashEntry&lt;K,V&gt; n = (HashEntry&lt;K,V&gt;)newTable[k];  
                        newTable[k] = new HashEntry&lt;K,V&gt;(p.key, p.hash,  
                                                         n, p.value);  
                    }  
                }  
            }  
        }  
        table = newTable;  
    }  

  ...  
}
</code></pre><p> ConcurrentHashMap在Segment的基础上，通过首先将<key, value="">对hash到一个segment，再由segment实现对entry的管理。</key,></p>
<p>ConcurrentHashMap的get实现：</p>
<pre><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  

final Segment&lt;K,V&gt; segmentFor(int hash) {  
    return (Segment&lt;K,V&gt;) segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];  
}  

public V get(Object key) {  
    int hash = hash(key); // throws NullPointerException if key null  
    return segmentFor(hash).get(key, hash);  
}  

  ...  
}  
</code></pre><p>ConcurrentHashMap的put和get方法：</p>
<pre><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  

public V put(K key, V value) {  
    if (value == null)  
        throw new NullPointerException();  
    int hash = hash(key);  
    return segmentFor(hash).put(key, hash, value, false);  
}  

public V remove(Object key) {  
    int hash = hash(key);  
    return segmentFor(hash).remove(key, hash, null);  
}  
</code></pre><p>  …<br>}</p>
<hr>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue充分使用了atomic包的实现<strong>打造了一个无锁并发线程安全的队列</strong>。对比锁机制的实现，个人认为使用无锁机制的难点在于要充分考虑线程间的协调。简单的说就是多个线程对内部数据结构进行访问时，如果其中一个线程执行的中途因为一些原因出现故障，其他的线程能够检测并帮助完成剩下的操作。这就需要把对数据结构的操作过程精细的划分成多个状态或阶段，考虑每个阶段或状态多线程访问会出现的情况。上述的难点在此次分析的并发Queue的实现中有很好的说明。</p>
<p>对于多线程同时访问容器元素的情况，concurrentLinkedQueue是一个很好的选择，因为所有的操作都是非阻塞的，所以它的迭代操作返回的结果并不是最新的，不会出现concurrentmodificationException。</p>
<p>而且不像很多其他容器，ConcurrentLinkedQueue的size()操作不是常量时间，返回的结果也不一定是准确的。</p>
<pre><code>public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements Queue&lt;E&gt;, java.io.Serializable {  
private static final long serialVersionUID = 196745693267521676L;  

private static class Node&lt;E&gt; {  
    private volatile E item;  
    private volatile Node&lt;E&gt; next;  

    private static final  
        AtomicReferenceFieldUpdater&lt;Node, Node&gt;  
        nextUpdater =  
        AtomicReferenceFieldUpdater.newUpdater  
        (Node.class, Node.class, &quot;next&quot;);  
    private static final  
        AtomicReferenceFieldUpdater&lt;Node, Object&gt;  
        itemUpdater =  
        AtomicReferenceFieldUpdater.newUpdater  
        (Node.class, Object.class, &quot;item&quot;);  

    Node(E x) { item = x; }  

    Node(E x, Node&lt;E&gt; n) { item = x; next = n; }  

    E getItem() {  
        return item;  
    }  

    boolean casItem(E cmp, E val) {  
        return itemUpdater.compareAndSet(this, cmp, val);  
    }  

    void setItem(E val) {  
        itemUpdater.set(this, val);  
    }  

    Node&lt;E&gt; getNext() {  
        return next;  
    }  

    boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
        return nextUpdater.compareAndSet(this, cmp, val);  
    }  

    void setNext(Node&lt;E&gt; val) {  
        nextUpdater.set(this, val);  
    }  

}  

private static final  
    AtomicReferenceFieldUpdater&lt;ConcurrentLinkedQueue, Node&gt;  
    tailUpdater =  
    AtomicReferenceFieldUpdater.newUpdater  
    (ConcurrentLinkedQueue.class, Node.class, &quot;tail&quot;);  
private static final  
    AtomicReferenceFieldUpdater&lt;ConcurrentLinkedQueue, Node&gt;  
    headUpdater =  
    AtomicReferenceFieldUpdater.newUpdater  
    (ConcurrentLinkedQueue.class,  Node.class, &quot;head&quot;);  

private boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
    return tailUpdater.compareAndSet(this, cmp, val);  
}  

private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
    return headUpdater.compareAndSet(this, cmp, val);  
}  

private transient volatile Node&lt;E&gt; head = new Node&lt;E&gt;(null, null);  

private transient volatile Node&lt;E&gt; tail = head;  
...  
}  
</code></pre><p>先看看其内部数据结构Node的实现。由于使用了原子字段更新器<code>AtomicReferenceFieldUpdater&lt;T,V&gt;</code>（其中T表示持有字段的类的类型，V表示字段的类型），所以其对应的需要更新的字段要使用volatile进行声明。其<code>newUpdater(Class&lt;U&gt; tclass, Class&lt;W&gt; vclass, String fieldName)</code>方法实例化一个指定字段的更新器，参数分别表示：持有需要更新字段的类，字段的类，要更新的字段的名称。Node的内部变量item，next分别有对应自己的字段更新器，并且包含了对其原子性操作的方法<code>compareAndSet(T obj, V expect, V update)</code>，其中T是持有被设置字段的对象，后两者分别是期望值和新值。 </p>
<p>对于ConcurrentLinkedQueue自身也有<strong>两个volatile的线程共享变量：head，tail分别对应队列的头指针和尾指针</strong>。要保证这个队列的线程安全就是保证对这两个Node的引用的访问（更新，查看）的原子性和可见性，由于volatile本身能够保证可见性，所以就是对其修改的原子性要被保证：</p>
<pre><code>public boolean offer(E e) {  
if (e == null) throw new NullPointerException();  
Node&lt;E&gt; n = new Node&lt;E&gt;(e, null);  
for (;;) {  
    Node&lt;E&gt; t = tail;  
    Node&lt;E&gt; s = t.getNext();  
    if (t == tail) { //-----------------------------a  
        if (s == null) { //-------------------------b  
            if (t.casNext(s, n)) { //---------------c  
                casTail(t, n); //-------------------d  
                return true;  
            }  
        } else {  
            casTail(t, s); //-----------------------e  
        }  
    }  
}  
</code></pre><p>}  </p>
<p>offer()方法都很熟悉了，就是入队的操作。涉及到改变尾指针的操作，所以要看这个方法实现是否保证了原子性。CAS操作配合循环是原子性操作的保证，这里也不例外。此方法的循环内首先获得尾指针和其next指向的对象，由于tail和Node的next均是volatile的，所以保证了获得的分别都是最新的值。 </p>
<hr>
<ul>
<li><p>代码a：<code>t==tail</code>是最上层的协调，如果其他线程改变了tail的引用，则说明现在获得不是最新的尾指针需要重新循环获得最新的值。 </p>
</li>
<li><p>代码b：<code>s==null</code>的判断。静止状态下tail的next一定是指向null的，但是多线程下的另一个状态就是中间态：tail的指向没有改变，但是其next已经指向新的结点，即完成tail引用改变前的状态，这时候<code>s!=null</code>。这里就是协调的典型应用，直接进入代码e去协调参与中间态的线程去完成最后的更新，然后重新循环获得新的tail开始自己的新一次的入队尝试。另外值得注意的是a,b之间，其他的线程可能会改变tail的指向，使得协调的操作失败。从这个步骤可以看到无锁实现的复杂性。</p>
</li>
<li><p>代码c：<code>t.casNext(s, n)</code>是入队的第一步，因为入队需要两步：更新Node的next，改变tail的指向。代码c之前可能发生tail引用指向的改变或者进入更新的中间态，这两种情况均会使得t指向的元素的next属性被原子的改变，不再指向null。这时代码c操作失败，重新进入循环。</p>
</li>
<li><p>代码d：这是完成更新的最后一步了，就是更新tail的指向，最有意思的协调在这儿又有了体现。从代码看<code>casTail(t, n)</code>不管是否成功都会接着返回true标志着更新的成功。首先如果成功则表明本线程完成了两步的更新，返回true是理所当然的；如果 <code>casTail(t, n)</code>不成功呢？要清楚的是完成代码c则代表着更新进入了中间态，代码d不成功则是tail的指向被其他线程改变。意味着对于其他的线程而言：它们得到的是中间态的更新，<code>s!=null</code>，进入代码e帮助本线程执行最后一步并且先于本线程成功。这样本线程虽然代码d失败了，但是是由于别的线程的协助先完成了，所以返回true也就理所当然了。 </p>
</li>
</ul>
<hr>
<p>通过分析这个入队的操作，可以清晰的看到无锁实现的每个步骤和状态下多线程之间的协调和工作。理解了入队的整个过程，出队的操作<code>poll()</code>的实现也就变得简单了。基本上是大同小异的，无非就是同时牵涉到了head和tail的状态，在改变head的同时照顾到tail的协调，在此不多赘述。下面介绍一下其无锁下的查看访问，其内部不单单是查看更包含了线程间的协调，这是无锁实现的一个特点。不管是<code>contains()，size()</code>还是isEmpty()，只要获得了head后面第一个最新的Node就可以很轻松的实现，毕竟Node的<code>getNext()和getItem()</code>返回的都是对应的最新值。所以先看看这些方法内部的first()如何获得最新的第一个Node： </p>
<pre><code>Node&lt;E&gt; first() {  
for (;;) {  
    Node&lt;E&gt; h = head;  
    Node&lt;E&gt; t = tail;  
    Node&lt;E&gt; first = h.getNext();  
    if (h == head) { //----------------  ---------a  
        if (h == t) { //--------------------------b  
            if (first ==null) --------------------c  
                return null;  
            else  
                casTail(t, first); //-------------d  
        } else {  
            if (first.getItem() != null) //-------e  
                return first;  
            else
             // remove deleted node and continue  
                casHead(h, first); //-------------f  
        }  
    }  
}  
</code></pre><p>}  </p>
<p>此方法在尝试获得最新的第一个非head结点的时候，在不同的阶段同样在协调着head和tail的更新任务，让人感觉无锁的世界没有纯粹的工作，呵呵。 </p>
<ul>
<li><p>代码a：还是最上层的协调，head指向没改变的情况下才继续下面的操作。这时侯head只可能是静止的，因为<code>poll()</code>出队操作的步骤是反着的：首先更新head的指向进入中间态，然后更新原head的next的item为null。 </p>
</li>
<li><p>代码b：之所以<code>h==t</code>的情况独立于其他的情况(在出队<code>poll()</code>方法中同样)，主要是因为<code>first!=null</code>时可能对应着某一个更新的中间态，而产生中间态的的必要条件就是代码b成立。如果<code>h==t</code>则表示当前线程获得的首尾指针指向同一个结点，当然代码b执行之后可能其他线程会进行head或者tail的更新。</p>
</li>
<li><p>代码c：<code>first==null</code>表明tail并没有进入更新的中间态而是处于静止状态，并且由于tail指向的是head的指向，所以返回null是唯一的选择。但是这美好的一切都是建立在代码b和代码c之间没有其他的线程更新tail。一旦有其他的线程执行了入队的操作并至少进入中间态的话，<code>h==t和first==null</code>都遗憾的成立，这就造成了取得幻象值，而实际上h.getNext()已经不再为null。个人认为代码c改成<code>if((first = h.getNext()) == null)</code>更能提高命中率。 </p>
</li>
<li><p>代码d：只要`first!=null，本线程则去尝试协调其他的线程先完成tail的更新，等待循环再次获取最新的head和tail。 </p>
</li>
<li><p>代码e：此处first一定不为null，tail更新与否不影响first的item的获取，但是head的更新会有影响。如果head正在被另一个线程更新并进入中间态，既是poll()内的<code>else if (casHead(h, first))</code> 成功，但是并没有执行first.setItem(null)之前。此时代码e是满足的，返回的也是当前的first的，但是随后head全部更新成功则first的item为null。所以此处返回的first的item并不一定是<code>item!=null</code>的结点，在使用此方法获得的结点的item时一定要再次的进行判断，这点在contains(…)等方法内都有体现。 </p>
</li>
<li><p>代码f：如果first的<code>item==null</code>，则更新head的指向。直观上看似乎多余，因为出队的操作是先更新head的指向再更新item为null的。但是另一个方法remove(…)则仅仅更新item的值而不改变head的指向，所以针对这样的多线程调用，代码f变得非常的必需了。 </p>
</li>
</ul>
<hr>
<p>这样通过这两个方法的分析可以推及对ConcurrentLinkedQueue共享变量的其他操作的实现，这样的无锁的实现印象最深的就是要考虑线程间的协调。不像锁机制的实现虽然牺牲了一定的性能，但是至少操作这些非线程安全的共享变量时不用过多的考虑其他线程的操作。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java中NIO与传统IO]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/java-nio.html</url>
      <content type="html"><![CDATA[<p><strong>感性认识：</strong></p>
<p><strong>传统的</strong>socket IO中，<strong>需要为每个连接创建一个线程</strong>，当并发的连接数量非常巨大时，<strong>线程所占用的栈内存和CPU线程切换的开销</strong>将非常巨大。使用<strong>NIO</strong>，不再需要为每个线程创建单独的线程，可以用一个<strong>含有限数量线程的线程池</strong>，甚至一个线程来为任意数量的连接服务。由于线程数量小于连接数量，所以每个线程进行IO操作时就不能阻塞，如果阻塞的话，有些连接就得不到处理，NIO提供了这种非阻塞的能力。</p>
<a id="more"></a> 
<p>小量的线程如何同时为大量连接服务呢，答案就是<strong>就绪选择(事件驱动)</strong>。这就好比到餐厅吃饭，每来一桌客人，都有一个服务员专门为你服务，从你到餐厅到结帐走人，这样方式的好处是服务质量好，一对一的服务，VIP啊，可是缺点也很明显，成本高，如果餐厅生意好，同时来100桌客人，就需要100个服务员，那老板发工资的时候得心痛死了，这就是传统的一个连接一个线程的方式。</p>
<p>老板是什么人啊，精着呢。这老板就得捉摸怎么能用10个服务员同时为100桌客人服务呢，老板就发现，服务员在为客人服务的过程中并不是一直都忙着，客人点完菜，上完菜，吃着的这段时间，服务员就闲下来了，可是这个服务员还是被这桌客人占用着，不能为别的客人服务，用华为领导的话说，就是工作不饱满。那怎么把这段闲着的时间利用起来呢。这餐厅老板就想了一个办法，<strong>让一个服务员（前台）专门负责收集客人的需求</strong>，登记下来，比如有客人进来了、客人点菜了，客人要结帐了，都先记录下来按顺序排好。<strong>每个服务员到这里领一个需求</strong>，比如点菜，就拿着菜单帮客人点菜去了。点好菜以后，服务员马上回来，领取下一个需求，继续为别人客人服务去了。这种方式服务质量就不如一对一的服务了，当客人数据很多的时候可能需要等待。但好处也很明显，由于在客人正吃饭着的时候服务员不用闲着了，服务员这个时间内可以为其他客人服务了，原来10个服务员最多同时为10桌客人服务，现在可能为50桌，60客人服务了。</p>
<p>这种服务方式跟传统的区别有两个：</p>
<ul>
<li>1、增加了一个角色，<strong>要有一个专门负责收集客人需求的人</strong>。NIO里对应的就是Selector。</li>
<li>2、<strong>由阻塞服务方式改为非阻塞服务了</strong>，客人吃着的时候服务员不用一直侯在客人旁边了。传统的IO操作，比如read()，当没有数据可读的时候，线程一直阻塞被占用，直到数据到来。NIO中没有数据可读时，read()会立即返回0，线程不会阻塞。</li>
</ul>
<p>NIO中，客户端创建一个连接后，<strong>先要将连接注册到Selector</strong>，相当于客人进入餐厅后，告诉前台你要用餐，前台会告诉你你的桌号是几号，然后你就可能到那张桌子坐下了，SelectionKey就是桌号。当某一桌需要服务时，前台就记录哪一桌需要什么服务，比如1号桌要点菜，2号桌要结帐，服务员从前台取一条记录，根据记录提供服务，完了再来取下一条。这样服务的时间就被最有效的利用起来了。</p>
<p>具体分析： </p>
<p>一．java NIO 和阻塞I/O的区别 </p>
<p><strong>1. 阻塞I/O通信模型</strong></p>
<p>假如现在你对阻塞I/O已有了一定了解，我们知道阻塞I/O在调用InputStream.read()方法时是阻塞的，它会一直等到数据到来时（或超时）才会返回；同样，在调用ServerSocket.accept()方法时，也会一直阻塞到有客户端连接才会返回，每个客户端连接过来后，服务端都会启动一个线程去处理该客户端的请求。阻塞I/O的通信模型示意图如下：</p>
<p><img src="/images/images/java/1.jpeg" alt=""></p>
<p>如果你细细分析，一定会发现阻塞I/O存在一些缺点。根据阻塞I/O通信模型，我总结了它的两点缺点：</p>
<ul>
<li><p>1.当客户端多时，会创建大量的处理线程。且每个线程都要占用栈空间和一些CPU时间</p>
</li>
<li><p>2.阻塞可能带来频繁的上下文切换，且大部分上下文切换可能是无意义的。</p>
</li>
</ul>
<p>在这种情况下非阻塞式I/O就有了它的应用前景。</p>
<p><strong>2.java NIO原理及通信模型</strong> </p>
<p>Java NIO是在jdk1.4开始使用的，它既可以说成“新I/O”，也可以说成非阻塞式I/O。下面是java NIO的工作原理：</p>
<ul>
<li><ol>
<li>由一个专门的线程来处理所有的 IO 事件，并负责分发。 </li>
</ol>
</li>
<li><ol>
<li>事件驱动机制：事件到的时候触发，而不是同步的去监视事件。 </li>
</ol>
</li>
<li><ol>
<li>线程通讯：线程之间通过 wait,notify 等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。 </li>
</ol>
</li>
</ul>
<p>阅读过一些资料之后，下面贴出我理解的java NIO的工作原理图：<br><img src="/images/images/java/2.jpeg" alt=""></p>
<p>Java NIO的服务端只需启动一个专门的线程来处理所有的 IO 事件，这种通信模型是怎么实现的呢？呵呵，我们一起来探究它的奥秘吧。java NIO采用了双向通道（channel）进行数据传输，而不是单向的流（stream），在通道上可以注册我们感兴趣的事件。一共有以下四种事件：</p>
<pre><code>事件名    对应值
服务端接收客户端连接事件    SelectionKey.OP_ACCEPT(16)
客户端连接服务端事件    SelectionKey.OP_CONNECT(8)
读事件                    SelectionKey.OP_READ(1)
写事件                    SelectionKey.OP_WRITE(4)
</code></pre><p>服务端和客户端各自维护一个管理通道的对象，我们称之为selector，该对象能检测一个或多个通道 (channel) 上的事件。我们以服务端为例，如果服务端的selector上注册了读事件，某时刻客户端给服务端发送了一些数据，阻塞I/O这时会调用read()方法阻塞地读取数据，而NIO的服务端会在selector中添加一个读事件。服务端的处理线程会轮询地访问selector，如果访问selector时发现有感兴趣的事件到达，则处理这些事件，如果没有感兴趣的事件到达，则处理线程会一直阻塞直到感兴趣的事件到达为止。下面是我理解的java NIO的通信模型示意图：<br><img src="/images/images/java/3.jpeg" alt=""></p>
<h2 id="二．java-NIO服务端和客户端代码实现"><a href="#二．java-NIO服务端和客户端代码实现" class="headerlink" title="二．java NIO服务端和客户端代码实现"></a>二．java NIO服务端和客户端代码实现</h2><p>为了更好地理解java NIO,下面贴出服务端和客户端的简单代码实现。</p>
<p>服务端：</p>
<pre><code>package cn.nio;
import java.io.IOException;  
import java.net.InetSocketAddress;  
import java.nio.ByteBuffer;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.ServerSocketChannel;  
import java.nio.channels.SocketChannel;  
import java.util.Iterator;  

/** 
 * NIO服务端 
 * @author 小路 
 */  
public class NIOServer {  
//通道管理器  
private Selector selector;  

/** 
 * 获得一个ServerSocket通道，并对该通道做一些初始化的工作 
 * @param port  绑定的端口号 
 * @throws IOException 
 */  
public void initServer(int port) throws IOException {  
// 获得一个ServerSocket通道  
ServerSocketChannel serverChannel = ServerSocketChannel.open();  
// 设置通道为非阻塞  
serverChannel.configureBlocking(false);  
// 将该通道对应的ServerSocket绑定到port端口  
serverChannel.socket().bind(new InetSocketAddress(port));  
// 获得一个通道管理器  
this.selector = Selector.open();  
//将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_ACCEPT事件,注册该事件后，  
//当该事件到达时，selector.select()会返回，如果该事件没到达selector.select()会一直阻塞。  
serverChannel.register(selector, SelectionKey.OP_ACCEPT);  
}  

/** 
 * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理 
 * @throws IOException 
 */  
@SuppressWarnings(&quot;unchecked&quot;)  
public void listen() throws IOException {  
System.out.println(&quot;服务端启动成功！&quot;);  
// 轮询访问selector  
while (true) {  
//当注册的事件到达时，方法返回；否则,该方法会一直阻塞  
selector.select();  
// 获得selector中选中的项的迭代器，选中的项为注册的事件  
Iterator ite = this.selector.selectedKeys().iterator();  
while (ite.hasNext()) {  
SelectionKey key = (SelectionKey) ite.next();  
// 删除已选的key,以防重复处理  
ite.remove();  
// 客户端请求连接事件  
if (key.isAcceptable()) {  
ServerSocketChannel server = (ServerSocketChannel) key  
.channel();  
// 获得和客户端连接的通道  
SocketChannel channel = server.accept();  
// 设置成非阻塞  
channel.configureBlocking(false);  

//在这里可以给客户端发送信息哦  
channel.write(ByteBuffer.wrap(new String(&quot;向客户端发送了一条信息&quot;).getBytes()));  
//在和客户端连接成功之后，为了可以接收到客户端的信息，需要给通道设置读的权限。  
channel.register(this.selector, SelectionKey.OP_READ);  

// 获得了可读的事件  
} else if (key.isReadable()) {  
read(key);  
}  

}  

}  
}  
/** 
 * 处理读取客户端发来的信息 的事件 
 * @param key 
 * @throws IOException  
 */  
public void read(SelectionKey key) throws IOException{  
// 服务器可读取消息:得到事件发生的Socket通道  
SocketChannel channel = (SocketChannel) key.channel();  
// 创建读取的缓冲区  
ByteBuffer buffer = ByteBuffer.allocate(10);  
channel.read(buffer);  
byte[] data = buffer.array();  
String msg = new String(data).trim();  
System.out.println(&quot;服务端收到信息：&quot;+msg);  
ByteBuffer outBuffer = ByteBuffer.wrap(msg.getBytes());  
channel.write(outBuffer);// 将消息回送给客户端  
}  

/** 
 * 启动服务端测试 
 * @throws IOException  
 */  
public static void main(String[] args) throws IOException {  
NIOServer server = new NIOServer();  
server.initServer(8000);  
server.listen();  
}  

}  
</code></pre><p>客户端：<br>    package cn.nio;  </p>
<pre><code>import java.io.IOException;  
import java.net.InetSocketAddress;  
import java.nio.ByteBuffer;  
import java.nio.channels.SelectionKey;  
import java.nio.channels.Selector;  
import java.nio.channels.SocketChannel;  
import java.util.Iterator;  

/** 
 * NIO客户端 
 * @author 小路 
 */  
public class NIOClient {  
//通道管理器  
private Selector selector;  

/** 
 * 获得一个Socket通道，并对该通道做一些初始化的工作 
 * @param ip 连接的服务器的ip 
 * @param port  连接的服务器的端口号  
 * @throws IOException 
 */  
public void initClient(String ip,int port) throws IOException {  
// 获得一个Socket通道  
SocketChannel channel = SocketChannel.open();  
// 设置通道为非阻塞  
channel.configureBlocking(false);  
// 获得一个通道管理器  
this.selector = Selector.open();  

// 客户端连接服务器,其实方法执行并没有实现连接，需要在listen（）方法中调  
//用channel.finishConnect();才能完成连接  
channel.connect(new InetSocketAddress(ip,port));  
//将通道管理器和该通道绑定，并为该通道注册SelectionKey.OP_CONNECT事件。  
channel.register(selector, SelectionKey.OP_CONNECT);  
}  

/** 
 * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理 
 * @throws IOException 
 */  
@SuppressWarnings(&quot;unchecked&quot;)  
public void listen() throws IOException {  
// 轮询访问selector  
while (true) {  
selector.select();  
// 获得selector中选中的项的迭代器  
Iterator ite = this.selector.selectedKeys().iterator();  
while (ite.hasNext()) {  
SelectionKey key = (SelectionKey) ite.next();  
// 删除已选的key,以防重复处理  
ite.remove();  
// 连接事件发生  
if (key.isConnectable()) {  
SocketChannel channel = (SocketChannel) key  
.channel();  
// 如果正在连接，则完成连接  
if(channel.isConnectionPending()){  
channel.finishConnect();  

}  
// 设置成非阻塞  
channel.configureBlocking(false);  

//在这里可以给服务端发送信息哦  
channel.write(ByteBuffer.wrap(new String(&quot;向服务端发送了一条信息&quot;).getBytes()));  
//在和服务端连接成功之后，为了可以接收到服务端的信息，需要给通道设置读的权限。  
channel.register(this.selector, SelectionKey.OP_READ);  

// 获得了可读的事件  
} else if (key.isReadable()) {  
read(key);  
}  

}  

}  
}  
/** 
 * 处理读取服务端发来的信息 的事件 
 * @param key 
 * @throws IOException  
 */  
public void read(SelectionKey key) throws IOException{  
//和服务端的read方法一样  
}  


/** 
 * 启动客户端测试 
 * @throws IOException  
 */  
public static void main(String[] args) throws IOException {  
NIOClient client = new NIOClient();  
client.initClient(&quot;localhost&quot;,8000);  
client.listen();  
}  

}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[如何评价『黑客与画家』]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/how-to-evaluate-the-hackers-and-painters.html</url>
      <content type="html"><![CDATA[<p>传送门：<a href="http://t.cn/zlg4njc" target="_blank" rel="external">黑客与画家:硅谷创业之父Paul Graham文集</a></p>
<p>一本好的书，让我们收获的不单单是某种技巧，或者某种方法论，<br><strong>他教给我们的是一种严密的思维方式，是一种学会把自己的眼光放得更加长远的决策习惯，他促使我们养成独立思考的习惯。</strong><br>他没有送给我们一条大鱼，却把捕捉大鱼的方法交给了我们， <strong>授人以鱼，不如授人以渔</strong>。<br><a id="more"></a><br>我一直觉得把一个我们所熟知的很普通的问题讲的非常透彻而且非常清楚是一种相当了不起的能力，<br>保罗·格雷尔姆 不仅把问题讲的非常透彻，而且还非常有趣，<br>让我们在读的时候感觉趣味盎然，这一点是非常不容易的。</p>
<p>很多的互联网从业者想必早就听说过这本书，而且大部分人应该都已经阅读过这本书了，<br>所以我就简单的从其他的角度来谈一下我读完本书的一些感想，希望对大家有所帮助。</p>
<p>在阅读「为什么书呆子不受欢迎」这章时，我想到了这么一句话，「<strong>你的时间在哪里，你的成就就在哪里</strong>」。<br>生活中的我们，总是喜欢羡慕那些成功人士，我们总觉得那些成功人士与我们普通人不一样，<br>他们必然懂得某种通往成功的诀窍，他们生下来就与周围的人们有所不同。<br>我们也总是希望能从这些成功人士那里获得某些珍贵的建议，获得那些能使人最终功成名就的万用妙方。<br>在武侠小说里面， <strong>渴望成为武林高手的人，都希望得到一本有着盖世神功的武林秘籍。</strong><br>因为这秘籍一旦得手，只要依葫芦画瓢，就可大功告成。 </p>
<p>但是世事又怎会如此简单，也永远不会有这样或者那样的武林秘诀。<br><strong>所谓的成功人士不过是把自己的时间投入到那些他们感兴趣的领域里面罢了。</strong><br>其实， <strong>我们每一个人也许都是我们所投入时间的那个领域的成功人士。</strong><br>有的同学，可能在学校里没有把时间投入学习中，但是呢，投入了很多的时间在游戏领域，每天花费大量的时间去玩游戏，<br>看游戏讲解视频，研究游戏的战略，思考游戏的玩法，在这个游戏里面，他就是王者；<br>有的人呢，可能喜欢计算机，他喜欢与程序打交道，他希望了解计算机是如何思考的，于是最终他就成了黑客。</p>
<p>画家能够把画画的比我们更好，只是因为他把他的时间都投入到里面罢了，田径运动员跑的比我们更快，<br>同样只不过因为他把他的时间都投入到跑步里面罢了。<br><strong>书呆子也并非不想让自己不受欢迎，他们只是更愿意把时间投入到让自己聪明上去罢了。</strong><br>我们每一个人，都可以自己去决定把自己的时间投入到哪个领域，我们所投入的时间最终也会成就我们。</p>
<p>在阅读本书的其他章节的时候，我更加深刻的发觉，黑客们，其实与我们并没有多大的不同，<br><strong>他们只是比我们普通人更加崇尚分享、开放和民主，他们对任何被禁止的东西都怀有特别强烈的好奇心，他们喜欢去思考那些似乎不应该被思考的问题，他们相信计算机将会深刻的改变人们的生活。</strong></p>
<p>虽然这是一本讲述黑客的书，不过个人觉得每个人都应该看看。<br>如同译者阮一峰所言：未来的人类生活不仅是人与人的互动，而且更多的将是人与计算机的互动。<br>想要把握这个时代，就必须理解计算机。<br>理解计算机的关键，则是要理解计算机背后的人。<br>表面上这是一个机器的时代，但是实际上机器的设计者决定了我们的时代。<br><strong>程序员的审美决定了你看到的软件界面，程序员的爱好决定了你有什么样的软件可以使用。</strong></p>
<p>如果你想要进一步了解作者的话，下面这两个链接可以帮助你：</p>
<ul>
<li>作者博客主页： <a href="http://www.paulgraham.com" target="_blank" rel="external">http://www.paulgraham.com</a></li>
<li>Wiki 百科上关于他的介绍： <a href="http://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer)" target="_blank" rel="external">http://en.wikipedia.org/wiki/Paul_Graham_(computer_programmer)</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android消息推送方式]]></title>
      <url>http://www.ezlippi.com/blog/2014/11/android-push.html</url>
      <content type="html"><![CDATA[<p>当我们开发需要和服务器交互的应用程序时，基本上都需要获取服务器端的数据，比如《地震及时通》就需要及时获取服务器上最新的地震信息。要获取服务器上不定时更新的信息一般来说有两种方法，第一种是客户端使用<strong>Pull（拉）</strong>的方式，隔一段时间就去服务器上获取信息，看是否有更新的信息出现。第二种就是服务器使用<strong>Push（推送）</strong>的方式，当服务器端有新信息了，则把最新的信息Push到客户端上。<br>虽然Pull和Push两种方式都能实现获取服务器端更新信息的功能，但是明显来说<strong>Push is better than pull</strong>。<br><strong>因为Pull方式更费客户端的网络流量，更主要的是费电量。</strong><br><a id="more"></a><br>在开发Android和iPhone应用程序时，我们往往需要从服务器不定的向手机客户端即时推送各种通知消息，iPhone上已经有了比较简单的和完美的推送通知解决方案，可是Android平台上实现起来却相对比较麻烦，最近利用几天的时间对Android的推送通知服务进行初步的研究。<br>在Android手机平台上，Google提供了<strong>C2DM（Cloud to Device Messaging）</strong>服务，起初我就是准备采用这个服务来实现自己手机上的推送功能。 </p>
<p><strong>Android Cloud to Device Messaging (C2DM)</strong>是一个用来帮助开发者从服务器向Android应用程序发送数据的服务。该服务提供了一个简单的、轻量级的机制，允许服务器可以通知移动应用程序直接与服务器进行通信，以便于从服务器获取应用程序更新和用户数据。C2DM服务负责处理诸如消息排队等事务并向运行于目标设备上的应用程序分发这些消息。 </p>
<p>下面是C2DM操作过程示例图:<br><img src="/images/images/image001.png" alt=""></p>
<p>几种常见的方案： </p>
<ul>
<li>1）<strong>轮询(Pull)</strong>：应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。 </li>
</ul>
<ul>
<li>2）<strong>SMS(Push)</strong>：在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图。这是一个不错的想法，我就见过采用这个方案的应用程序。这个方案的好处是，可以实现完全的实时操作。但是问题是这个方案的成本相对比较高，你很难找到免费的短消息发送网关，关于这个方案的实现。 </li>
</ul>
<ul>
<li>3）<strong>持久连接(Push)</strong>：这个方案可以解决由轮询带来的性能问题，但是还是会消耗手机的电池。Apple的推送服务之所以工作的很好，是因为每一台手机仅仅保持一个与服务器之间的连接，事实上C2DM也是这么工作的。不过这个方案也存在不足，就是我们很难在手机上实现一个可靠的服务。Android操作系统允许在低内存情况下杀死系统服务，所以你的通知服务很可能被操作系统Kill掉了。 </li>
</ul>
<p>前两个方案存在明显的不足，第三个方案也有不足，不过我们可以通过良好的设计来弥补，以便于让该方案可以有效的工作。毕竟，我们要知道GMail，GTalk以及GoogleVoice都可以实现实时更新的。 </p>
<p><strong>采用MQTT协议实现Android推送 </strong></p>
<p>MQTT是一个轻量级的消息发布/订阅协议，它是实现基于手机客户端的消息推送服务器的理想解决方案。</p>
<p>wmqtt.jar 是IBM提供的MQTT协议的实现。你可以从如下站点下载它。你可以将该jar包加入你自己的Android应用程序中。 </p>
<p>Really Small Message Broker (RSMB) ，他是一个简单的MQTT代理，同样由IBM提供。缺省打开1883端口，应用程序当中，它负责接收来自服务器的消息并将其转发给指定的移动设备。 </p>
<p>　架构如下图所示：<br><img src="/images/images/111.gif" alt=""></p>
<p><strong>RSMB实现推送功能</strong></p>
<p><code>Really Small Message Broker (RSMB)</code> ，他是一个简单的MQTT代理，同样由IBM提供，其查看地址是：<a href="http://www.alphaworks.ibm.com/tech/rsmb。缺省打开1883端口，应用程序当中，它负责接收来自服务器的消息并将其转发给指定的移动设备。" target="_blank" rel="external">http://www.alphaworks.ibm.com/tech/rsmb。缺省打开1883端口，应用程序当中，它负责接收来自服务器的消息并将其转发给指定的移动设备。</a></p>
<p>SAM是一个针对MQTT写的PHP库。我们可以从这个<a href="http://pecl.php.net/package/sam/download/0.2.0地址下载它" target="_blank" rel="external">http://pecl.php.net/package/sam/download/0.2.0地址下载它</a>.<br>send_mqtt.php是一个通过POST接收消息并且通过SAM将消息发送给RSMB的PHP脚本。 </p>
<p><strong>采用XMPP协议实现Android推送 </strong></p>
<p>这是我在项目中采用的方案。事实上Google官方的C2DM服务器底层也是采用XMPP协议进行的封装。<br><strong>XMPP(可扩展通讯和表示协议)是基于可扩展标记语言（XML）的协议</strong>，它用于即时消息（IM）以及在线探测。这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息。 </p>
<p>androidpn是一个基于XMPP协议的java开源<strong>Android push notification</strong>实现。它包含了完整的客户端和服务器端。经过源代码研究我发现，该服务器端基本是在另外一个开源工程<strong>openfire</strong>基础上修改实现的，不过比较郁闷的是androidpn的文档是由韩语写的，所以整个研究过程基本都是读源码。 </p>
<p>androidpn实现如下图所示：<br>！<a href="/images/images/222.gif"></a></p>
<p>androidpn客户端需要用到一个基于java的<strong>开源XMPP协议包asmack</strong>，这个包同样也是基于openfire下的另外一个开源项目smack，不过我们不需要自己编译，可以直接把androidpn客户端里面的<strong>asmack.jar</strong>拿来使用。客户端利用asmack中提供的XMPPConnection类与服务器建立持久连接，并通过该连接进行用户注册和登录认证，同样也是通过这条连接，接收服务器发送的通知。 </p>
<p>androidpn服务器端也是java语言实现的，基于openfire开源工程，不过它的Web部分采用的是spring框架，这一点与openfire是不同的。<br>服务器架构如下：</p>
<p>Androidpn服务器包含两个部分，一个是<strong>侦听在5222端口上的XMPP服务</strong>，负责与客户端的XMPPConnection类进行通信，作用是用户注册和身份认证，并发送推送通知消息。另外一部分是Web服务器，采用一个轻量级的HTTP服务器，负责接收用户的Web请求。<br>服务器架构如下： </p>
<p>！<a href="/images/images/333.gif"></a></p>
<p>最上层包含四个组成部分，分别是<code>SessionManager，Auth Manager，PresenceManager以及Notification Manager</code>。<code>SessionManager</code>负责管理客户端与服务器之间的会话，<code>Auth Manager</code>负责客户端用户认证管理，<code>Presence Manager</code>负责管理客户端用户的登录状态<code>NotificationManager</code>负责实现服务器向客户端推送消息功能。 </p>
<p>这个解决方案的最大优势就是简单，我们不需要象C2DM那样依赖操作系统版本，也不会担心某一天Google服务器不可用。利用XMPP协议我们还可以进一步的对协议进行扩展，实现更为完善的功能。 </p>
<p>采用这个方案，我们目前只能发送文字消息，不过对于推送来说一般足够了，因为我们不能指望通过推送得到所有的数据，一般情况下，利用推送只是告诉手机端服务器发生了某些改变，当客户端收到通知以后，应该主动到服务器获取最新的数据，这样才是推送服务的完整实现。 </p>
<h2 id="XMpp协议简介"><a href="#XMpp协议简介" class="headerlink" title="XMpp协议简介"></a>XMpp协议简介</h2><p>XMPP协议，它是一种基于XML的传递协议，具有很强的灵活性和可扩展性。它的特点是将复杂性从客户端转移到了服务器端。在网上可以找到很多的XMPP资料，这里就不在赘述了，不然越扯越多。总之，XMPP主要显著的优点主要有以下几个方面：</p>
<ul>
<li>1、 <strong>分布式</strong>  任何人都可以运行自己的XMPP服务器，它没有主服务器</li>
<li>2、 <strong>安全性很高</strong>。使用SASL及TLS等技术的可靠安全性</li>
<li>3、 <strong>开发性</strong> 它是开源的，易于进行学习和了解</li>
<li>4、 <strong>跨平台 </strong> 毋庸置疑，使用的XML进行传输的</li>
</ul>
<p>说完优点，我们言归正传，基于XMPP协议的java开发有一个开源框架，那就是smack，它主要封装了一些XMPP的实现。而如果把它直接用在Android上是不行的，因为android缺少了一些java的类库，于是一个改进版的asmack诞生了，它是专门为android而改进的android smack。而另外一个开源框架的诞生，则是对在引用smack的基础上实现和服务器端的持久连接，以实现服务器对客户端的推送，那就是android push notification，简称androidpn。</p>
<p>Androidpn在客户端集成了asmack。这样就可以很容易的简立一个和服务器端的基于xmpp协议的socket连接。Androidpn的客户端中，进行管理连接的类是XmppManager，它主要用来管理连接的信息，比如XMPP的端口、IP、登录的用户名密码，以及对连接的维护。为什么还有用户名和密码？这不得不提到XMPP的具体细节。整个服务器端和客户端的通信是基于一个session（会话）过程，会话开始，首先会指定服务器的端口号，然后把上述提到的信息发送到服务器端，怎么发送消息的呢？以<stream>根节点的方式开始传递，只有在服务器和客户端关闭的时候才会发送它的结束标记</stream>。客户端通过XMPP协议只用做的就是接收消息，而所有其它的操作都交给服务器，比如管理连接、消息保存等等，这样就很大程度的减轻了客户端的负担。那么客户端和服务器端的消息回应是如何实现的？如要通过一个ID来标识，具体细节可以去查看XMPP协议。</p>
<p>一旦注册绑定后，服务器端就和客户端建立了连接，客户端只用负责去接收消息。所以当我们应用Androidpn的时候，客户端会非常的简单。而在服务器端，Androidpn又做了什么呢？</p>
<p>服务器端的展示方面，androidpn主要用到的技术是<strong>Spring和Hibernate</strong>。主要是用来展示用户状态和发送信息用的，这方面的技术已经比较成熟，就不再细说了，主要要说的还是XMPP的管理。在服务器端的源码中一个<code>org.androidpn.server.xmpp.net.Connection</code>类，主要是代表一个服务器上的XMPP连接，注意只是一个，它可以确保在服务器关闭的时候，发送一个标记到客户端，告知连接断开，需重新连接。</p>
<p><code>org.androidpn.server.xmpp.session.SessionManager</code>主要用户管理所有会话，比如连接断开，删除session以及建立连接，添加session等等。</p>
<p>而<strong>在管理Socket连接的时候，androidpn采用了MINA框架来进行管理，</strong>MINA<a href="https://mina.apache.org/" target="_blank" rel="external">https://mina.apache.org/</a>的优点就是改变了我们传统的管理socket的方式，比如没建立一个socket开一个线程，而MINA可以实现多个线程管理N多个用户。在处理高并发的推送上无疑是有巨大的好处的。</p>
<p>合理的利用监听器来管理session，也是androidpn的优点。在安全性方面，制定了TLS(安全传输层)策略，并却采用了安全认证，这些方面都做的不错。</p>
<p>当然，不可避免的30秒钟的心跳包还是必不可少的。</p>
<p>总之，用Androidpn好处有以下方面：采用完全开放的XMPP协议进行数据传输（QQ，MSN，GTalk等都是采用的这种协议）；良好的框架支持（专门为android 而产生的推送框架asmack，以及很好的管理socket的框架MINA，都是很成熟的产品）；完全开放的源代码（我们可以在androidpn的基础上进行修改，来满足我们的任何需求变更）；大大的减少了客户端的代码，降低了android的开发难度。缺点不言而喻，使用了太多的框架，如果想要改一些具体的实现，可能会迁移发动全身。不过如果你个懒人的话，完全满足你的需求了。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Androidpn 消息推送总结]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/androidDP-project.html</url>
      <content type="html"><![CDATA[<p>Androidpn 开源项目托管地址：<a href="http://sourceforge.net/projects/androidpn/" target="_blank" rel="external">http://sourceforge.net/projects/androidpn/</a></p>
<p>Androidpn 开源项目自身描述：This is an open source project to provide push notification support for Android, a xmpp based notification server and a client tool kit.<br><a id="more"></a></p>
<h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>在程序的入口 DemoAppActivity 中设置通知的 icon 并开启消息接收服务，代码如下：</p>
<pre><code>Number：1-1 
ServiceManager serviceManager = new ServiceManager(this);
serviceManager.setNotificationIcon(R.drawable.notification);
serviceManager.startService();
</code></pre><p>在上面的代码中可以看到程序对 ServiceManager 进行了初始化操作，在 ServiceManager 类的构造函数中我们可以看到程序对传递过来的 context 进行了判断，如果这个 context 是一个 Activity 实例，紧接着会获取对应的包名和类名。之后再去加载 res/raw/androidpn.properties 配置文件中的参数信息，并将读取到的信息和之前从 context 中获取的包名和类名一起存入首选项中。</p>
<pre><code>Number：2-1 
public ServiceManager(Context context) {
this.context = context;

if (context instanceof Activity) {
Activity callbackActivity = (Activity) context;
callbackActivityPackageName = callbackActivity.getPackageName();
callbackActivityClassName = callbackActivity.getClass().getName();
}

props = loadProperties();
apiKey = props.getProperty(&quot;apiKey&quot;, &quot;&quot;);
xmppHost = props.getProperty(&quot;xmppHost&quot;, &quot;127.0.0.1&quot;);
xmppPort = props.getProperty(&quot;xmppPort&quot;, &quot;5222&quot;);

sharedPrefs = context.getSharedPreferences(Constants.SHARED_PREFERENCE_NAME, Context.MODE_PRIVATE);
Editor editor = sharedPrefs.edit();
editor.putString(Constants.API_KEY, apiKey);
editor.putString(Constants.VERSION, version);
editor.putString(Constants.XMPP_HOST, xmppHost);
editor.putInt(Constants.XMPP_PORT, Integer.parseInt(xmppPort));
editor.putString(Constants.CALLBACK_ACTIVITY_PACKAGE_NAME, callbackActivityPackageName);
editor.putString(Constants.CALLBACK_ACTIVITY_CLASS_NAME, callbackActivityClassName);
editor.commit();
}
</code></pre><p>完成上述操作之后，紧接着调用 <code>ServiceManager.startService()</code> 方法来开启服务，实际上 ServiceManager 只是一个普通的类，方法 ServiceManager.startService() 只是开启一个子线程来开启真正的服务类 NotificationService ，许多人认为开一个线程不停的去开启服务会不会消耗相当一部分资源？答案是不会的，因为服务的生命周期决定了onCreate() 方法在服务被创建时调用，该方法只会被调用一次，无论调用多少次 startService() 方法，服务也只被创建一次，细心的读者会发现 Androidpn 的作者在 NotificationService 类的 <code>onStart(Intent intent, int startId)</code> 方法中没有做任何事，而是在onCreate() 方法中完成了诸多操作。</p>
<pre><code>Number：3-1
public void startService() {
Thread serviceThread = new Thread(new Runnable() {
public void run() {
Intent intent = NotificationService.getIntent();
context.startService(intent);
}
});
serviceThread.start();
}
</code></pre><p>下面我们来看 NotificationService 类的onCreate() 方法中都完成什么操作？</p>
<pre><code>Number：4-1
public void onCreate() {
telephonyManager = (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);
sharedPrefs = getSharedPreferences(Constants.SHARED_PREFERENCE_NAME, Context.MODE_PRIVATE);

deviceId = telephonyManager.getDeviceId();
Editor editor = sharedPrefs.edit();
editor.putString(Constants.DEVICE_ID, deviceId);
editor.commit();

if (deviceId == null || deviceId.trim().length() == 0 || deviceId.matches(&quot;0+&quot;)) {
if (sharedPrefs.contains(&quot;EMULATOR_DEVICE_ID&quot;)) {
deviceId = sharedPrefs.getString(Constants.EMULATOR_DEVICE_ID, &quot;&quot;);
} else {
deviceId = (new StringBuilder(&quot;EMU&quot;)).append((new Random(System.currentTimeMillis())).nextLong()).toString();
editor.putString(Constants.EMULATOR_DEVICE_ID, deviceId);
editor.commit();
}
}
xmppManager = new XmppManager(this);
taskSubmitter.submit(new Runnable() {
public void run() {
NotificationService.this.start();
}
});
}
</code></pre><p>在上面的方法中作者获取了设备号并将设备号存入了首选项中，同时还对在模拟器下运行的情况做了处理，这些操作是次要的。真正的核心的操作是 taskSubmitter 里调用了NotificationService.this.start()，这里的 NotificationService.this 完成了 NotificationService 的实例化，我们可以看到 NotificationService 类的构造方法中完成了 NotificationReceiver、ConnectivityReceiver、PhoneStateChangeListener、Executors、TaskSubmitter、TaskTracker 等类的实例化。</p>
<pre><code>Number：5-1
public NotificationService() {
notificationReceiver = new NotificationReceiver();
connectivityReceiver = new ConnectivityReceiver(this);
phoneStateListener = new PhoneStateChangeListener(this);
executorService = Executors.newSingleThreadExecutor();
taskSubmitter = new TaskSubmitter(this);
taskTracker = new TaskTracker(this);
}
</code></pre><p>NotificationService 的实例化完成后调用的start() 方法中注册了一个广播接收者 NotificationReceiver 用来处理从服务器推送过来的消息；同时还注册了一个广播接收者来监听网络连接状况，如果有网络连接，则执行 xmppManager.connect()，如果没有网络连接，则执行 xmppManager.disconnect()。但是在start() 方法中最终还是会执行 xmppManager.connect()。</p>
<pre><code>Number：6-1
private void start() {
registerNotificationReceiver();
registerConnectivityReceiver();
xmppManager.connect();
}
</code></pre><p>再来看看 xmppManager.connect() 方法中都做了些什么？程序在这个方法中提交了一个登录任务：submitLoginTask()，在提交的登录任务中又提交了一个注册任务：submitRegisterTask()，同时将新建的登录任务添加到任务集合中并交由 TaskTracker 来对添加的任务进行监视，此时 TaskTracker 的计数加一。</p>
<pre><code>Number：7-1
public void connect() {
 submitLoginTask();
}

Number：7-2
private void submitLoginTask() {
 submitRegisterTask();
 addTask(new LoginTask());
}
</code></pre><p>下面继续来看新添加的登录任务 new LoginTask() 具体做了什么？看 Number：8-2 代码，程序在登录任务线程的 run() 方法中首先去判断当前客户端是否已经经过身份验证，验证身份的代码请看 Number：8-1 。</p>
<p>如果没有通过身份验证：xmppManager 会获取当前连并接携带着从首选项中读取的 username 和password 执行登录操作，登录成功后 xmppManager 会在登录成功的连接上添加连接监听器<code>PersistentConnectionListener</code>，这个监听器可以监听连接关闭和和连接错误，并在连接错误的情况下执行重连操作。接下来会在当前连接上添加包过滤器 PacketFilter packetFilter 和包监听器 <code>NotificationPacketListener packetListener</code>，包过滤器用来校验从服务器发送过来的数据包是否符合 NotificationIQ 格式，打开 NotificationIQ 类我们可以看到这个类中定义了数据包中需要封装的信息：id、apiKey、title、message、uri。包监听器则是用来真正处理从服务器发过来的数据。</p>
<p>请看 Number：8-3 代码，在 NotificationPacketListener 类的 <code>processPacket(Packet packet)</code> 方法中程序首先会判断获得的数据包是否是 NotificationIQ 的一个实例，如果是程序会调用 NotificationIQ 的<code>getChildElementXML()</code> 方法将数据包中携带的信息拼装为一个字符串进行判断动作是否为发送广播，如果动作为发送广播，程序会将数据包的信息填充到 Intent 中并发送广播，注意这个广播中填充到 Intent 的动作名称 Constants.ACTION_SHOW_NOTIFICATION 为显示广播，这个动作被另一个广播接收者 NotificationReceiver (该广播接收者在之前的<code>NotificationService 的start()</code> 方法中已经注册)所监听。</p>
<p>另外需要注意的是，如果客户端在登录过程中出现INVALID_CREDENTIALS_ERROR_CODE = “401” 错误，在 Number：8-2 的代码中我们可以看到程序执行了 <code>xmppManager.reregisterAccount()</code> 操作和 <code>xmppManager.startReconnectionThread()</code>操作。在 <code>xmppManager.reregisterAccount()</code> 操作中程序会删除保存在首选项中的 username 和password 并重新提交登录任务 submitLoginTask()，在这个登录任务中依次再嵌套执行注册、连接任务。这些任务执行完毕之后程序继续调用 xmppManager.startReconnectionThread() 执行重连操作。如果客户端在登录过程中出现不可预知的错误，在 Number：8-2 的代码中我们可以看到程序执直接调用 <code>xmppManager.startReconnectionThread()</code> 来执行重连操作。</p>
<p>如果已经通过身份验证：意味着客户端已经登录成功，程序直接调用 xmppManager.runTask() 方法来执行之前添加到任务集合中的任务 new LoginTask()，同时 TaskTracker 的计数减一。</p>
<p>Number：8-1<br>private boolean isAuthenticated() {<br>return connection != null &amp;&amp; connection.isConnected() &amp;&amp; connection.isAuthenticated();<br>}</p>
<pre><code>Number：8-2
private class LoginTask implements Runnable {
final XmppManager xmppManager;
private LoginTask() {
this.xmppManager = XmppManager.this;
}
public void run() {
if (!xmppManager.isAuthenticated()) {
Log.d(LOGTAG, &quot;username=&quot; + username);
Log.d(LOGTAG, &quot;password=&quot; + password);
try {
xmppManager.getConnection().login(xmppManager.getUsername(), xmppManager.getPassword(), XMPP_RESOURCE_NAME);
Log.d(LOGTAG, &quot;Loggedn in successfully&quot;);
if (xmppManager.getConnectionListener() != null) {
xmppManager.getConnection().addConnectionListener(xmppManager.getConnectionListener());
}
PacketFilter packetFilter = new PacketTypeFilter(NotificationIQ.class);
PacketListener packetListener = xmppManager.getNotificationPacketListener();
connection.addPacketListener(packetListener, packetFilter);
xmppManager.runTask();
} catch (XMPPException e) {
Log.e(LOGTAG, &quot;LoginTask.run()... xmpp error&quot;);
Log.e(LOGTAG, &quot;Failed to login to xmpp server. Caused by: &quot; + e.getMessage());
String INVALID_CREDENTIALS_ERROR_CODE = &quot;401&quot;;
String errorMessage = e.getMessage();
if (errorMessage != null &amp;&amp; errorMessage.contains(INVALID_CREDENTIALS_ERROR_CODE)) {
xmppManager.reregisterAccount();
return;
}
xmppManager.startReconnectionThread();
} catch (Exception e) {
Log.e(LOGTAG, &quot;LoginTask.run()... other error&quot;);
Log.e(LOGTAG, &quot;Failed to login to xmpp server. Caused by: &quot; + e.getMessage());
xmppManager.startReconnectionThread();
}
} else {
Log.i(LOGTAG, &quot;Logged in already&quot;);
xmppManager.runTask();
}
}
}


Number：8-3
public class NotificationPacketListener implements PacketListener {

private static final String LOGTAG = LogUtil.makeLogTag(NotificationPacketListener.class);

private final XmppManager xmppManager;

public NotificationPacketListener(XmppManager xmppManager) {
this.xmppManager = xmppManager;
}

public void processPacket(Packet packet) {
Log.d(LOGTAG, &quot;NotificationPacketListener.processPacket()...&quot;);
Log.d(LOGTAG, &quot;packet.toXML()=&quot; + packet.toXML());

if (packet instanceof NotificationIQ) {
NotificationIQ notification = (NotificationIQ) packet;

if (notification.getChildElementXML().contains(&quot;androidpn:iq:notification&quot;)) {
String notificationId = notification.getId();
String notificationApiKey = notification.getApiKey();
String notificationTitle = notification.getTitle();
String notificationMessage = notification.getMessage();
String notificationUri = notification.getUri();

Intent intent = new Intent(Constants.ACTION_SHOW_NOTIFICATION);
intent.putExtra(Constants.NOTIFICATION_ID, notificationId);
intent.putExtra(Constants.NOTIFICATION_API_KEY, notificationApiKey);
intent.putExtra(Constants.NOTIFICATION_TITLE, notificationTitle);
intent.putExtra(Constants.NOTIFICATION_MESSAGE, notificationMessage);
intent.putExtra(Constants.NOTIFICATION_URI, notificationUri);

xmppManager.getContext().sendBroadcast(intent);
}
}
}
}


Number：8-4
public void reregisterAccount() {
removeAccount();
submitLoginTask();
runTask();
}
</code></pre><p>NotificationReceiver 在接收到NotificationPacketListener 中发出的广播后，先判断Intent 中携带的动作和自己所收听的动作是否一致，如果一致，则继续从Intent 中取出Intent 所携带的信息并调用 Notifier 的<code>notify(String notificationId, String apiKey, String title, String message, String uri)</code> 来发送通知。</p>
<pre><code>Number：9-1
public final class NotificationReceiver extends BroadcastReceiver {

private static final String LOGTAG = LogUtil.makeLogTag(NotificationReceiver.class);

public NotificationReceiver() {
}

public void onReceive(Context context, Intent intent) {
Log.d(LOGTAG, &quot;NotificationReceiver.onReceive()...&quot;);
String action = intent.getAction();
Log.d(LOGTAG, &quot;action=&quot; + action);

if (Constants.ACTION_SHOW_NOTIFICATION.equals(action)) {
String notificationId = intent.getStringExtra(Constants.NOTIFICATION_ID);
String notificationApiKey = intent.getStringExtra(Constants.NOTIFICATION_API_KEY);
String notificationTitle = intent.getStringExtra(Constants.NOTIFICATION_TITLE);
String notificationMessage = intent.getStringExtra(Constants.NOTIFICATION_MESSAGE);
String notificationUri = intent.getStringExtra(Constants.NOTIFICATION_URI);

Notifier notifier = new Notifier(context);
notifier.notify(notificationId, notificationApiKey, notificationTitle, notificationMessage, notificationUri);
}
}
}
</code></pre><p>Notifier 在发送通知之前会先去首选项中读取用户的配置信息，如果配置信息中<code>Constants.SETTINGS_NOTIFICATION_ENABLED</code> 的值为 true，然后开始组装通知并为通知进行参数配置，这些操作完成后再调用 NotificationManager 将组装好的通知发送出去。至此，在客户端已经注册的前提下，执行的登录、接收服务器数据包、发送广播、发送通知的流程就结束了，添加在当前连接上的NotificationPacketListener 会一直监听从服务器发送过来的数据包并重复执行数据包解析、发送广播、发送通知的操作。</p>
<p>但是需要注意的是从代码 Number：7-1 至代码 Number：9-1 的流程是以客户端已经完成注册为前提的；如果客户端是第一次执行消息推送的服务，显然不会直接进入到登录的逻辑中来，让我们继续跳到 Number：7-2 中的岔路口，程序在提交登录任务的内部嵌套着提交了一个注册任务 submitRegisterTask()，继续来看这个注册任务做了什么操作。在这个注册任务中继续将新建的注册任务添加到任务集合中并交由 TaskTracker 来对添加的任务进行监视，此时 TaskTracker 的计数加一；与此同时内嵌提交了一个连接任务<code>submitConnectTask()</code>。</p>
<pre><code>Number：10-1
private void submitRegisterTask() {
submitConnectTask();
addTask(new RegisterTask());
}
</code></pre><p>先来看登录任务中做了什么操作？参看代码 Number：11-1。</p>
<p>如果没有注册：则使用UUID生成2个随机数作为 username 和 password，同时实例化 Registration，将创建的包过滤器和包监听器添加到当前连接上，然后使用 Registration 实例将生成的 username 和 password 作为属性添加到 Registration 实例上，再由当前连接调用<code>connection.sendPacket(registration)</code> 向服务器发送数据包执行注册操作。创建的包监听器会监听并处理服务器会送的数据包，PacketListener 在接收到服务器会送的数据包后，同样会判断数据包的格式是否符合包过滤器中定义的格式，只有格式匹配的情况下进行后续处理。在格式匹配的情况下，程序继续进行判断：如果服务器返回信息的类型是 <code>IQ.Type.ERROR</code> 则进行报错处理；如果服务器返回信息的类型是 <code>IQ.Type.RESULT</code>证明在服务器注册成功，这时程序会将 username 和 password 存储到首选项中，之后程序直接调用 <code>xmppManager.runTask()</code>方法来执行之前添加到任务集合中的任务 <code>new LoginTask()</code>，同时 TaskTracker 的计数减一。</p>
<p>如果已经注册：意味着首选项中已经有了配置信息，程序直接调用 <code>xmppManager.runTask()</code>方法来执行之前添加到任务集合中的任务 <code>new LoginTask()</code>，同时 TaskTracker 的计数减一。</p>
<pre><code>Number：11-1
private class RegisterTask implements Runnable {

final XmppManager xmppManager;
private RegisterTask() {
    xmppManager = XmppManager.this;
}

public void run() {
    if (!xmppManager.isRegistered()) {
        final String newUsername = newRandomUUID();
        final String newPassword = newRandomUUID();

        Registration registration = new Registration();
        PacketFilter packetFilter = new AndFilter(new PacketIDFilter(registration.getPacketID()), new PacketTypeFilter(IQ.class));

        PacketListener packetListener = new PacketListener() {

            public void processPacket(Packet packet) {
                Log.d(&quot;RegisterTask.PacketListener&quot;, &quot;processPacket().....&quot;);
                Log.d(&quot;RegisterTask.PacketListener&quot;, &quot;packet=&quot; + packet.toXML());
                if (packet instanceof IQ) {
                    IQ response = (IQ) packet;
                    if (response.getType() == IQ.Type.ERROR) {
                        if (!response.getError().toString().contains(&quot;409&quot;)) {
                            Log.e(LOGTAG, &quot;Unknown error while registering XMPP account! &quot; + response.getError().getCondition());
                        }
                    } else if (response.getType() == IQ.Type.RESULT) {
                        xmppManager.setUsername(newUsername);
                        xmppManager.setPassword(newPassword);
                        Log.d(LOGTAG, &quot;username=&quot; + newUsername);
                        Log.d(LOGTAG, &quot;password=&quot; + newPassword);
                        Editor editor = sharedPrefs.edit();
                        editor.putString(Constants.XMPP_USERNAME, newUsername);
                        editor.putString(Constants.XMPP_PASSWORD, newPassword);
                        editor.commit();
                        Log.i(LOGTAG, &quot;Account registered successfully&quot;);
                        xmppManager.runTask();
                    }
                }
            }
        };
        connection.addPacketListener(packetListener, packetFilter);
        registration.setType(IQ.Type.SET);
        registration.addAttribute(&quot;username&quot;, newUsername);
        registration.addAttribute(&quot;password&quot;, newPassword);
        connection.sendPacket(registration);
    } else {
        Log.i(LOGTAG, &quot;Account registered already&quot;);
        xmppManager.runTask();
    }
}
</code></pre><p>}</p>
<p>至此，在客户端已经连接到服务器的前提下，执行的注册、登录、接收服务器数据包、发送广播、发送通知的流程就结束了，添加在当前连接上的 <code>NotificationPacketListener</code> 会一直监听从服务器发送过来的数据包并重复执行数据包解析、发送广播、发送通知的操作。</p>
<p>同样需要注意的是从代码 Number：10-1 至代码 Number：11-1 的流程是以客户端已经连接到服务器为前提的；如果客户端是第一次执行消息推送的服务，显然也不会直接进入到注册的逻辑中来，让我们继续跳到 Number：10-1 中的岔路口，程序在提交注册任务的内部嵌套着提交了一个连接任务 <code>submitConnectTask()</code>，继续来看这个连接任务做了什么操作。在这个连接任务中程序直接将新建的连接任务添加到任务集合中并交由 TaskTracker 来对添加的任务进行监视，此时 TaskTracker 的计数加一。</p>
<pre><code>Number：12-1
private void submitConnectTask() {
addTask(new ConnectTask());
}
</code></pre><p>继续来看连接任务中做了什么操作？参看代码 Number：13-1。</p>
<p>如果没有连接到服务器：程序会从首选项中读取 xmppHost 和 xmppPort 并使用 XMPPConnection 通过配置信息实例化一个连接，然后再由该连接执行连接操作。连接成功后，程序调用<code>xmppManager.runTask()</code>方法来执行之前添加到任务集合中的任务 <code>new RegisterTask()</code>，同时 TaskTracker 的计数减一。</p>
<p>如果已经连接到服务器：程序直接调用<code>xmppManager.runTask()</code> 方法来执行之前添加到任务集合中的任务 new RegisterTask()，同时 TaskTracker 的计数减一。</p>
<pre><code>Number：13-1
private class ConnectTask implements Runnable {

final XmppManager xmppManager;

private ConnectTask() {
    this.xmppManager = XmppManager.this;
}

public void run() {
    if (!xmppManager.isConnected()) {
        // Create the configuration for this new connection
        ConnectionConfiguration connConfig = new ConnectionConfiguration(xmppHost, xmppPort);
        connConfig.setSecurityMode(SecurityMode.required);
        connConfig.setSASLAuthenticationEnabled(false);
        connConfig.setCompressionEnabled(false);

        XMPPConnection connection = new XMPPConnection(connConfig);
        xmppManager.setConnection(connection);

        try {
            // Connect to the server
            connection.connect();
            Log.i(LOGTAG, &quot;XMPP connected successfully&quot;);
            // packet provider
            ProviderManager.getInstance().addIQProvider(&quot;notification&quot;, &quot;androidpn:iq:notification&quot;, new NotificationIQProvider());
        } catch (XMPPException e) {
            Log.e(LOGTAG, &quot;XMPP connection failed&quot;, e);
        }
        xmppManager.runTask();
    } else {
        Log.i(LOGTAG, &quot;XMPP connected already&quot;);
        xmppManager.runTask();
    }
}
</code></pre><p>}</p>
<p>至此，在客户端执行的连接、注册、登录、接收服务器数据包、发送广播、发送通知的流程就结束了，添加在当前连接上的 <code>NotificationPacketListener</code>会一直监听从服务器发送过来的数据包并重复执行数据包解析、发送广播、发送通知的操作。</p>
<hr>
<h2 id="二、后续问题"><a href="#二、后续问题" class="headerlink" title="二、后续问题"></a>二、后续问题</h2><p>▐ 关于服务器重启客户端自动重连服务器的问题？</p>
<p>▐ 在 XmppManager 的 <code>addTask(Runnable runnable)</code> 方法中添加 <code>runTask()</code>方法即可解决。</p>
<pre><code>private void addTask(Runnable runnable) {
taskTracker.increase();
synchronized (taskList) {
    if (taskList.isEmpty() &amp;&amp; !running) {
        running = true;
        futureTask = taskSubmitter.submit(runnable);
        if (futureTask == null) {
            taskTracker.decrease();
        }
    } else {
        /**
         * runTask(); 解决服务器端重启后,客户端不能成功连接  Androidpn 服务器
         */
        runTask();

        taskList.add(runnable);
    }
}
</code></pre><p>}</p>
<p>▐ 关于使用设备ID或 MAC替换源码中的 UUID作为 username 和 password 带来的问题？</p>
<p>如果把客户端随机生成的UUID代码，替换为设备的ID或者MAC作为用户名，服务器端会出现重复插入的错误。</p>
<p>把客户端的数据清除(或卸载后重新安装)，那么 SharedPreferences 里的数据也会被清除，然而服务器端又有我们手机的设备 ID，这时客户端启动程序从首选项中读取不到 username 和 password 会重新拿着相同的设备 ID 提交给服务器进行注册，这时服务器端就会出现重复插入的问题。</p>
<p>▐ 在服务器端保存用户信息的时候，检查数据库中是否存在该用户。</p>
<p>▐ Android 消息推送的其他途径</p>
<p>▐ 极光推送</p>
<p>网站参考地址 : <a href="http://www.jpush.cn/" target="_blank" rel="external">http://www.jpush.cn/</a></p>
<p>▐ Google Cloud Messaging for Android</p>
<p>网站参考地址 : <a href="http://developer.android.com/google/gcm/index.html" target="_blank" rel="external">http://developer.android.com/google/gcm/index.html</a></p>
<p>▐ MQTT 协议推送</p>
<p>客户端下载地址 : <a href="https://github.com/tokudu/AndroidPushNotificationsDemo" target="_blank" rel="external">https://github.com/tokudu/AndroidPushNotificationsDemo</a></p>
<p>服务器下载地址 : <a href="https://github.com/tokudu/PhpMQTTClient" target="_blank" rel="external">https://github.com/tokudu/PhpMQTTClient</a></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XMPP协议分析-具体分析]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/xmpp-analise.html</url>
      <content type="html"><![CDATA[<p>通过WireShark抓包来具体分析XMPP协议，下面用人人桌面版演示了，XMPP客户端从登录到获取新鲜事的过程，通过分析具体的数据包能够更容易的理解协议。<br><a id="more"></a><br><strong>Step1.TCP三次握手建立连接</strong><br><img src="/images/images/openfire/xmpp2.jpeg" alt=""><br>图1.xmpp客户端使用5222端口，设置SYN请求连接</p>
<p><img src="/images/images/openfire/xmpp3.jpeg" alt=""><br>图2.服务器返回ACK，确认请求，同样设置SYN请求连接</p>
<p><img src="/images/images/openfire/xmpp4.jpeg" alt=""><br>图3.客户端确认服务器连接请求，连接建立完毕。</p>
<p><strong>Step2.客户端请求，服务器响应。</strong></p>
<p><img src="/images/images/openfire/xmpp5.jpeg" alt=""><br>图4.客户端发送Jabber/x Request请求，</p>
<p><strong>客户端初始化流给服务器</strong></p>
<p><img src="/images/images/openfire/xmpp6.jpeg" alt=""><br>图5.服务器返回Jabber/x Response，服务器发送一个流标签给客户端作为应答</p>
<p><img src="/images/images/openfire/xmpp7.jpeg" alt=""><br>图5.5服务器发送 STARTTLS 范围给客户端（包括验证机制和任何其他流特性）</p>
<p><img src="/images/images/openfire/xmpp8.jpeg" alt=""><br>图6.客户端发送请求，发送，请求使用传输层加密协议[TLS]</p>
<p><img src="/images/images/openfire/xmpp9.jpeg" alt=""><br>图7.服务器端响应，返回元素，确认传输加密</p>
<p><img src="/images/images/openfire/xmpp10.jpeg" alt=""><br>图8.之后的请求，数据均已经加密</p>
<p><img src="/images/images/openfire/xmpp11.jpeg" alt=""><br>图9.之后的响应，返回数据也是加密的</p>
<p>这次抓包分析，可以看到，xml文档的安全性有了一定的保障，加密过的数据无法看到。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Smack开发手册]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/how%20to%20use%20smack.html</url>
      <content type="html"><![CDATA[<p>这篇文章翻译自Smack的官方文档，<a href="http://www.igniterealtime.org/builds/smack/docs/latest/documentation/" target="_blank" rel="external">http://www.igniterealtime.org/builds/smack/docs/latest/documentation/</a>，转载请注明出处。</p>
<p>Smack是一个为使用XMPP服务器聊天和发送即时消息交流而提供的库。<br><a id="more"></a> </p>
<h2 id="Smack的主要优势："><a href="#Smack的主要优势：" class="headerlink" title="Smack的主要优势："></a>Smack的主要优势：</h2><ol>
<li>使用简单且拥有强大的API。向用户发送一条文本消息只需用一下三行代码即可完成</li>
</ol>
<pre><code>XMPPConnection connection = new XMPPConnection(&quot;jabber.org&quot;);
connection.login(&quot;mtucker&quot;, &quot;password&quot;);
connection.createChat(&quot;jsmith@jivesoftware.com&quot;).sendMessage(&quot;Howdy!;
</code></pre><ol>
<li>不像其它库那样，强制你在信息报级（packet level）编码。Smack提供智能的、更高级别的结构，例如：Chat和GroupChat类，这写能让你的程序效率更高。</li>
</ol>
<ul>
<li>你不需要熟悉XMPP  XML格式，甚至不熟XML。</li>
</ul>
<ol>
<li><p>提供简单的机器到机器的通讯。Smack允许你对每一条消息设置任何数字的属性，包括Java对象的属性。</p>
</li>
<li><p>Apache许可的开放源码，你可将其用于商业的和非商业的应用。</p>
</li>
</ol>
<h2 id="关于XMPP"><a href="#关于XMPP" class="headerlink" title="关于XMPP"></a>关于XMPP</h2><p>XMPP (eXtensible Messaging and Presence Protocol)是一个开放的，</p>
<p>如何使用本文档<br>本文档假定你已经熟悉XMPP即时消息的主要特征。我们推荐你在阅读该文档时打开Javadoc API作为参考。</p>
<p><strong>开始Smack</strong></p>
<p>本文档将向你介绍Smack API，并大概介绍几个重要的类和概念。<br>必备的条件<br>你只需要有JDK 1.2或之后的版本1和已经内嵌在smack..jar文件中的XML分析器，不需要第三部分库。<br>1JDK 1.2 and 1.3的用户若想使用SSL连接必须在他的类路径下有JSSE库。</p>
<p><strong>建立一个连接</strong></p>
<p>XMPPConnection类是为XMPP服务器建立连接的类。若要创建SSL连接，需使用SSLXMPPConnection类，以下是创建连接的例子。</p>
<pre><code>// Create a connection to the jabber.org server.
XMPPConnection conn1 = new XMPPConnection(&quot;jabber.org&quot;);

// Create a connection to the jabber.org server on a specific port.
XMPPConnection conn2 = new XMPPConnection(&quot;jabber.org&quot;, 5222);

// Create an SSL connection to jabber.org.
XMPPConnection connection = new SSLXMPPConnection(&quot;jabber.org&quot;);
</code></pre><p>如果创建了一个连接，你应该使用<code>XMPPConnection.login(String username, String password)</code>方法（参数为用户名和密码）进行登陆。一旦登陆成功，你就可以通过创建一个新的Chat 或GroupChat对象与其它用户聊天。</p>
<hr>
<h2 id="使用花名册（Working-with-the-Roster）"><a href="#使用花名册（Working-with-the-Roster）" class="headerlink" title="使用花名册（Working with the Roster）"></a>使用花名册（Working with the Roster）</h2><ul>
<li><p>花名册让你很清楚的知道其它可用的用户。用户可以被分成像“朋友”、“合作者”这样的组，从而知道其它的用户在线还是离线。</p>
</li>
<li><p>可以使用XMPPConnection.getRoster()方法检索花名册。你可以用花名册（roster）类查找花名册的所有条目，它们所属的组以及每个条目当前呈现的状态。</p>
</li>
</ul>
<p><strong>读、写信息包（Reading and Writing Packets）</strong></p>
<ul>
<li><p>从客户端发送到XMPP的每一条消息称为一个信息包，并作为XML发送。The org.jivesoftware.smack.packet包含封装了三个XMPP允许的、不同的基本包类型(message, presence, and IQ)的类。像Chat和GroupChat这样的类提供更高级别的结构，它可以自动的创建和发送信息包，当然你也可以直接创建和发送信息包。以下代码是一个将你的当前状态改为“隐身“，从而不被别人看到的例子：</p>
<p> // Create a new presence. Pass in false to indicate we’re unavailable.<br> Presence presence = new Presence(Presence.Type.UNAVAILABLE);<br> presence.setStatus(“Gone fishing”);<br> // Send the packet (assume we have a XMPPConnection instance called “con”).<br> con.sendPacket(presence);</p>
</li>
</ul>
<p>Smack提供以下两种方法阅读收到的信息包：PacketListener和PacketCollector。它们都使用PacketFilter的实例来决定应该处理哪个信息包。信息包监听器（packet listener）用于事件类型的设计，而信息包收集器（packet collector）有一个信息包的结果队列，你可以对其实施polling和blocking操作。所以，信息包监听器在你收到任何一个信息包，且你想对其进行操作时是有用的，而信息包收集器在你想等待某个特殊的信息包时是有用的。信息包收集器和监听器可以通过XMPPConnection的实例来创建。</p>
<hr>
<h1 id="Messaging-Basics"><a href="#Messaging-Basics" class="headerlink" title="Messaging Basics"></a>Messaging Basics</h1><h2 id="Messaging-using-Chat-and-GroupChat"><a href="#Messaging-using-Chat-and-GroupChat" class="headerlink" title="Messaging using Chat and GroupChat"></a>Messaging using Chat and GroupChat</h2><p>互相发送消息是即时通讯的核心，以下是两个在收发消息是用的类：</p>
<ol>
<li>org.jivesoftware.smack.Chat – 用于两个人之间发送消息</li>
<li>org.jivesoftware.smack.GroupChat –用于加入聊天室，很多人之间相互发送消息。</li>
</ol>
<p>Chat和GroupChat类都用org.jivesoftware.smack.packet .Message信息包类发送消息。在某些情况下，也许你希望绕过更高级别的Chat和GroupChat类直接发送和接受消息。<br>聊天（Chat）<br>聊天时在两个用户间创建了一个新的线程（使用一个线程ID）。以下程序片示例了如何如何与一个用户进行开始聊天并发送一段文本消息：</p>
<pre><code>// Assume we&apos;ve created an XMPPConnection name &quot;connection&quot;.
Chat newChat = connection.createChat(&quot;jsmith@jivesoftware.com&quot;);
newChat.sendMessage(&quot;Howdy!&quot;);
</code></pre><p>Chat.sendMessage(String)方法可以很方便的创建一个消息对象，方法体使用字符串类型的参数，然后发送消息。如果想在发送消息前对消息设置额外的只，可以使用Chat.createMessage() and Chat.sendMessage(Message)方法，如下例所示：</p>
<pre><code>// Assume we&apos;ve created an XMPPConnection name &quot;connection&quot;.
Chat newChat = connection.createChat(&quot;jsmith@jivesoftware.com&quot;);
Message newMessage = newChat.createMessage();
newMessage.setBody(&quot;Howdy!&quot;);
message.setProperty(&quot;favoriteColor&quot;, &quot;red&quot;);
newChat.sendMessage(newMessage);
</code></pre><p>使用Chat对象可以轻松的收听其它聊天者的回复。以下程序片是parrot-bot，它映射会其它用户类型的所有事情：</p>
<pre><code>// Assume we&apos;ve created an XMPPConnection name &quot;connection&quot;.
Chat newChat = connection.createChat(&quot;jsmith@jivesoftware.com&quot;);
newMessage.setBody(&quot;Hi, I&apos;m an annoying parrot-bot! Type something back to me.&quot;);
while (true) {
// Wait for the next message the user types to us.
Message message = newChat.nextMessage();
// Send back the same text the other user sent us.
newChat.sendMessage(message.getBody());
}
</code></pre><p>以上代码使用Chat.nextMessage()方法获得下一条消息，它必需一直等待直到收到下一条消息。也有其它的方法可以等待特定的时间来接受下一条消息，或者你也可以增加一个监听器，它可以在每次收到消息时通知你。</p>
<p><strong>群聊（GroupChat）</strong></p>
<p>群聊在通过一个服务器连接到聊天室，你可以向一组人发送消息或接收他们的消息。在你能接收和发送消息前，你必须使用一个昵称登陆到聊天室。以下程序段可以连接到一个聊天室并发送消息：</p>
<pre><code>// Assume we&apos;ve created an XMPPConnection name &quot;connection&quot;.
GroupChat newGroupChat = connection.createGroupChat(&quot;test@jivesoftware.com&quot;);
// Join the group chat using the nickname &quot;jsmith&quot;.
newGroupChat.join(&quot;jsmith&quot;);
// Send a message to all the other people in the chat room.
newGroupChat.sendMessage(&quot;Howdy!&quot;);
</code></pre><p>群聊时收发消息和私聊时工作原理大体一致。同样，也有方法可以获得聊天室里其它用户的列表。</p>
<hr>
<h2 id="Roster-and-Presence"><a href="#Roster-and-Presence" class="headerlink" title="Roster and  Presence"></a>Roster and  Presence</h2><p>花名册让你很清楚的知道其它可用的用户。用户可以被分成像“朋友”、“合作者”这样的组。其它的即使通讯系统将花名册作为好友列表、联系列表等。</p>
<pre><code>**当你成功登陆服务器后，可以使用XMPPConnection.getRoster()获得Roster类的实例。**
</code></pre><p><strong>花名册条目（Roster Entries）</strong></p>
<p>花名册里的每一个用户都以一条花名册条目的形式呈现，包括以下几部分：</p>
<ol>
<li>一个XMPP地址(例如：jsmith@example.com).</li>
<li><p>分配给你的用户名 (例如： “Joe”).<br>该条目在花名册中所属组的列表。如果该条目不属于任何一个组，将被称为“尚未分类的条目。<br>以下程序段可以打印出花名册中的所有条目：</p>
<p> Roster roster = con.getRoster();<br> for (Iterator i=roster.getEntries(); i.hasNext(); ) {<br> System.out.println(i.next());<br> }</p>
</li>
</ol>
<p>也有获得个人条目、尚未分类条目的列表、一个或者所有组的方法。</p>
<p><strong>呈现（Presence）</strong></p>
<p>花名册中的每一个条目都有相关的呈现方式。Roster.getPresence(String user)方法将通过用户的状态或当用户不在线或不同意将其在线状态显示出来时使用空对象（null）返回一个Presence对象。</p>
<p>注意：一般情况下，用户是否同意显示其状态依赖于用户所在的花名册，但这不是在所有情况下都成立的。</p>
<p>用户也有一个在线或离线的状态，如果用户在线，他们的显示信息中将会有一些扩展的信息，例如他当前正在做什么，是否希望被打扰等等，详细内容可以参看Presence类。</p>
<p><strong>Listening for Roster and Presence Changes</strong></p>
<p>Roster类的典型用途是用树状形式显示组和每一个条目以及它的当前状态。如下图所示是 Exodus XMPP客户端的花名册。</p>
<p>显示的信息很可能会经常改变，也有可能是花名册的条目被改变甚至被删除。为了监视花名册的改变和显示的信息，应该使用一个花名册监听器（RosterListener）。以下代码使用Roster（它可以打印出花名册中的任何变化）注册了一个RosterListener。标准的客户端应该使用相似的代码更新花名册的用户信息（roster UI）以正确显示变化的信息。</p>
<pre><code>final Roster roster = con.getRoster();
roster.addRosterListener(new RosterListener() {
public void rosterModified() {
// Ignore event for this example.
}

public void presenceChanged(String user) {
// If the presence is unavailable then &quot;null&quot; will be printed,
// which is fine for this example.
System.out.println(&quot;Presence changed: &quot; + roster.getPresence(user));
}
});
</code></pre><p><strong>向花名册中添加条目（Adding Entries to the Roster）</strong></p>
<p>花名册和显示使用基于许可的模型，这要求用户在加入别人的花名册前必须得到允许。这样，确保只有被允许的人才可以看到自己所显示的信息，从而保护了用户的隐私。因此，在你想添加一个新的条目，且对方没有接受你的请求前，该条目将处于等待状态。</p>
<p>如果另一个用户请求同意显示，从而你他们可以将你加入他们的花名册，你必须接受或拒绝请求。Smack通过以下三种方式之一操作同意显示请求：</p>
<ol>
<li>自动接受所有的同意显示请求。</li>
<li>自动拒绝所有的同意显示请求。</li>
<li>手动处理同意显示请求。</li>
</ol>
<p>可以使用Roster.setSubscriptionMode(int subscriptionMode)方法设置模式。简单的客户通常使用一个自动接受或拒绝同意显示请求的模式，而用更多特征的用户应该使用手动处理同意显示请求的模式，并让终端用户接受或拒绝每一个请求。如果使用手动模式，应该声明一个信息包监听器（PacketListener）来监听有Presence.Type.SUBSCRIBE类型的显示信息包。</p>
<p><strong>处理收到的信息包(Processing Incoming Packets)</strong><br>Smack提供一个使用以下两个结构的灵活框架来处理收到的信息包：</p>
<p>org.jivesoftware.smack.PacketCollector – 一个允许你同步的等待新的信息包的类</p>
<p>org.jivesoftware.smack.PacketListener – 一个异步的通知你收到信息包的接口</p>
<p>信息包监听器（packet listener）用于事件类型的设计，而信息包收集器（packet collector）有一个信息包的结果队列，你可以对其实施polling和blocking操作。所以，信息包监听器在你收到任何一个信息包，且你想对其进行操作时是有用的，而信息包收集器在你想等待某个特殊的信息包时是有用的。信息包收集器和监听器可以通过<br>XMPPConnection的实例来创建。</p>
<p>由org.jivesoftware.smack.filter.PacketFilter接口来决定哪个特殊的信息包将被转交给信息包收集器（PacketCollector）或信息包监听器（PacketListener）。可以在org.jivesoftware.smack.filter包中找到许多预先定义的过滤器。<br>以下代码阐释了如何注册一个信息包收集器（packet collector）和信息包监听器（packet listener）：</p>
<pre><code>// Create a packet filter to listen for new messages from a particular
// user. We use an AndFilter to combine two other filters.
PacketFilter filter = new AndFilter(new PacketTypeFilter(Message.class),
new FromContainsFilter(&quot;mary@jivesoftware.com&quot;));
// Assume we&apos;ve created an XMPPConnection name &quot;connection&quot;.

// First, register a packet collector using the filter we created.
PacketCollector myCollector = connection.createPacketCollector(filter);
// Normally, you&apos;d do something with the collector, like wait for new packets.

// Next, create a packet listener. We use an anonymous inner class for brevity.
PacketListener myListener = new PacketListener() {
public void processPacket(Packet packet) {
// Do something with the incoming packet here.
}
};
// Register the listener.
connection.addPacketListener(myListener, filter);
</code></pre><p><strong>标准信息包过滤器（Standard Packet Filters）</strong></p>
<p>Smack包含一套丰富的信息包过滤器，你也可以通过信息包过滤器接口（PacketFilter interface）编写程序来创建自己的过滤器。缺省的过滤器集包括：</p>
<ul>
<li>PacketTypeFilter – 某个特殊的类类型的信息包过滤器</li>
<li>PacketIDFilter – 拥有特殊的信息包ID（packet ID）的过滤器</li>
<li>ThreadFilter – 拥有特殊线程ID（thread ID）的信息包的过滤器</li>
<li>ToContainsFilter –发送到某个特殊地址的信息包的过滤器</li>
<li>FromContainsFilter –发送到某个特殊地址的信息包的过滤器  </li>
<li>PacketExtensionFilter – 拥有特殊的信息包扩展的信息包的过滤器</li>
<li>AndFilter –对两个过滤器实施逻辑与操作的过滤器</li>
<li>OrFilter –对两个过滤器实施逻辑或操作的过滤器</li>
<li>NotFilter –对一个过滤器实施逻辑非操作的过滤器</li>
</ul>
<p>Provider Architecture: Packet Extensions and Custom IQ’s<br>Smack提供的体系是堵塞自定义的XML信息包扩展和IQ包分析器的系统（The Smack provider architecture is a system for plugging in custom XML parsing of packet extensions and IQ packets）。标准的Smack扩展（Smack Extensions）是使用提供者的体系结构搭建的。存在以下两种类型的提供者：</p>
<ul>
<li><p>IQProvider –将IQ请求（ IQ requests）解析成Java对象（Java objects）</p>
</li>
<li><p>PacketExtension – 将附属在信息包上的XML子文档解析成信息包扩展实例（PacketExtension instances）</p>
</li>
</ul>
<p><strong>IQProvider</strong></p>
<p>默认情况下，Smack致知道如何处理只有类似以下几个名字空间的子信息包的IQ信息包（IQ packets）：</p>
<ul>
<li>jabber:iq:auth</li>
<li>jabber:iq:roster</li>
<li>jabber:iq:register</li>
</ul>
<p>因为许多IQ类型是XMPP及其扩展部分的一部分，所以提供一个可插入的IQ分析机制。IQ Providers被程序自动的注册或通过创建在你的JAR 文件的META-INF目录下创建一个mack.providers文件。该文件是一个包含一个或多个iqProvider条目（iqProvider entries）的XML文档，如下例所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;smackProviders&gt;
 &lt;iqProvider&gt;
 &lt;elementName&gt;query&lt;/elementName&gt;
 &lt;namespace&gt;jabber:iq:time&lt;/namespace&gt;
 &lt;className&gt;org.jivesoftware.smack.packet.Time&lt;/className&gt;
 &lt;/iqProvider&gt;
&lt;/smackProviders&gt;
</code></pre><p>每一个IQ provider都和一个元素名（element name）和名字空间（ namespace）相联系。在上面的例子中，元素名是query，名字空间是abber:iq:time。如果有多重提供者条目（multiple provider entries）尝试注册并控制相同的名字空间，那么从类路径（classpath）载入的第一个条目将有优先权。</p>
<p>IQ provider类可以实现IQProvide接口，或者继承IQ类。在前面的例子中，每一个IQProvider负责解析原始的XML流从而创建一个IQ实例。在下面的例子中，bean introspection将被用于尝试自动使用在IQ packet XML中发现的值设置IQ实例的属性。一个XMPP时间信息包如下所示：<br>    <iq type="result" to="joe@example.com" from="mary@example.com" id="time_1"><br>    <query xmlns="jabber:iq:time"><br>    <utc>20020910T17:58:35</utc><br>    <tz>MDT</tz><br>    <display>Tue Sep 10 12:58:35 2002</display><br>    </query><br>    </iq></p>
<p>为了让这个信息包自动的映射成上面的providers file中所列的时间对象（Time object），它必须有以下几个方法：setUtc(String), setTz(String), 和 setDisplay(String)。自动检查（introspection）的服务将试着自动的将字符串值转化成a boolean, int, long, float, double,或 Class 类型。转化成何种类型由IQ实例的需要来决定。</p>
<p><strong>PacketExtensionProvider</strong></p>
<p>信息包插件提供者（Packet extension providers）为信息包提供一个可插入的系统，这些信息包是一个IQ, message和presence packets的自定义名字空间的子元素。每一个插件提供者（extension provider）使用一个元素名（element name）和名字空间（namespace）在smack.providers文件中注册，如下例所示：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot;?&gt;
&lt;smackProviders&gt;
&lt;extensionProvider&gt;
&lt;elementName&gt;x&lt;/elementName&gt;
&lt;namespace&gt;jabber:iq:event&lt;/namespace&gt;
&lt;className&gt;org.jivesoftware.smack.packet.MessageEvent&lt;/className&gt;
&lt;/extensionProvider&gt;
&lt;/smackProviders&gt;
</code></pre><p>如果有多重提供者条目（multiple provider entries）尝试注册并控制相同的名字空间，那么从类路径（classpath）载入的第一个条目将有优先权。</p>
<p>一旦在一个信息包中发现信息包插件，解析器将传递到正确的提供者。每一个提供者可以实现PacketExtensionProvider接口或者是一个标准的Java Bean。在前面的例子中，每一个插件提供者（extension provider）负责解析原始的XML流去构造一个实例。在下面的例子中，bean introspection将被用于尝试自动使用在信息包插件子元素（packet extension sub-element）中的值设置类的属性。</p>
<p>当一个插件提供者（extension provider）没有用元素名（element name）和名字空间（namespace）对注册是，Smack将存储所有在缺省信息包插件（DefaultPacketExtension）对象中的最高级别元素（top-level elements），并匹配到信息包上。</p>
<p><strong>信息包属性（Packet Properties）</strong></p>
<p>Smack提供简单的机制来将任意的属性附加到信息包上。每一个属性有个字符串类型的名字和一个值，这个值或者是Java原始数据类型（int, long, float, double, boolean）的，或者是任何可序列化的对象（Serializable object）（当一个java对象实现了Serializable接口时，它就是可序列化的）。</p>
<p><strong>使用API（Using the API）</strong></p>
<p>所有主要对象都有属性支持，例如消息对象（Message objects）。以下代码阐释了如何设置属性：</p>
<pre><code>Message message = chat.createMessage();
// Add a Color object as a property.
message.setProperty(&quot;favoriteColor&quot;, new Color(0, 0, 255));
// Add an int as a property.
message.setProperty(&quot;favoriteNumber&quot;, 4);
chat.sendMessage(message);
</code></pre><p>获得这些相同的属性要用到以下的代码：</p>
<pre><code>Message message = chat.nextMessage();
// Get a Color object property.
Color favoriteColor = (Color)message.getProperty(&quot;favoriteColor&quot;);
// Get an int property. Note that properties are always returned as
// Objects, so we must cast the value to an Integer, then convert
// it to an int.
int favoriteNumber = ((Integer)message.getProperty(&quot;favoriteNumber&quot;)).intValue();
</code></pre><p><strong>将对象作为属性（Objects as Properties）</strong></p>
<p>将对象作为属性值是改变数据的一个非常有力和简单的方法。但是，你应该记住以下几点：</p>
<ul>
<li>信息包插件（Packet extensions）是向XMPP增加额外数据的更权威的方式。使用属性在某种情况下也许会比较方便，但是，Smack将会控制XML。</li>
<li>当你将Java对象（Java object）作为属性发送时，只有在客户机运行的Java能够解释数据。所以，可以考虑使用一系列的原始值来传递数据。</li>
<li>作为属性值发送的对象必须实现序列化接口（Serialiable）。</li>
<li>除此之外，发送者和接受者都必须由相同版本的类，否则在反序列化（de-serializing the object）对象时将发生序列化异常。</li>
<li>序列化的对象将会非常大，将会占用很多的服务器资源和带宽。</li>
</ul>
<p><strong>XML格式（XML Format）</strong></p>
<p>当前的用于发送属性的XML格式不是标准的，所以可能不会得到使用Smack的客户的认可。XML如下所示（为了更清晰添加了注释）：</p>
<pre><code>&lt;!-- All properties are in a x block. --&gt;
&lt;properties xmlns=&quot;http://www.jivesoftware.com/xmlns/xmpp/properties&quot;&gt;
&lt;!-- First, a property named &quot;prop1&quot; that&apos;s an integer. --&gt;
&lt;property&gt;
&lt;name&gt;prop1&lt;/name&gt;
&lt;value type=&quot;integer&quot;&gt;123&lt;/value&gt;
&lt;property&gt;
&lt;!-- Next, a Java object that&apos;s been serialized and then converted
 from binary data to base-64 encoded text. --&gt; 
&lt;property&gt;
&lt;name&gt;blah2&lt;/name&gt;
&lt;value type=&quot;java-object&quot;&gt;adf612fna9nab&lt;/value&gt;
&lt;property&gt;
&lt;/properties&gt;
</code></pre><p>当前支持的数据类型有：integer, long, float, double, boolean, string, 和java-object。</p>
<p><strong>使用Smack调试（Debugging with Smack）</strong></p>
<p>Smack包含两个内置的调试控制台，他们允许你在服务器和客户机建跟踪XML的踪迹。简单的调试器（lite debugger）是smack.jar的一部分，加强的调试器（enhanced debugger）包含在（smackx-debug.jar）中。</p>
<p>可以用两种不同的方法激活调试模式：</p>
<p>1．在创建连接前加入以下一行代码：</p>
<pre><code>XMPPConnection.DEBUG_ENABLED = true;
</code></pre><p>2．将Java的系统属性smack.debugEnabled设置为true。这一系统属性可通过下一命令行设置：</p>
<pre><code>java -Dsmack.debugEnabled=true SomeApp
</code></pre><p>在你的应用程序中，如果你想明确的禁用调试模式，包括使用命令行参数，则在打开新的连接前在你的应用程序中添加以下一行代码：</p>
<pre><code>XMPPConnection.DEBUG_ENABLED = false;
</code></pre><p>Smack使用一下的逻辑来决定使用哪个调制控制台：</p>
<ol>
<li><p>它将首先尝试使用Java系统属性smack.debuggerClass 所指定的调试类（debugger class）。如果你需要开发自己的调试器 I，可以实现SmackDebugger 接口然后使用下面的命令行设置系统属性：</p>
<p>java -Dsmack.debuggerClass=my.company.com.MyDebugger SomeApp</p>
</li>
<li><p>如果第一步失败了，Smack就会尝试使用增强的调试器（enhanced debugger）。 文件 smackx-debug.jar 包含，因此你要把jar文件放到类路径（classpath）下。如果空间确定你只是想要配置smack.jar文件，这种情况下增强的调试器（enhanced debugger）将不可用。</p>
</li>
<li><p>最后一种是前面两种都失败后使用简单的调试器（ite debugger）。在你的内存很小的时候，简单的调试器（ite debugger）是一个很好的选择。</p>
</li>
</ol>
<p><strong>增强的调试器（enhanced debugger）</strong></p>
<p>当调试模式可用时，将出现一个包含每一个创建的连接的标签调试窗口，该窗口包含以下信息：</p>
<ul>
<li>连接标签（Connection tabs） -每一个标签显示连接相关的调试信息</li>
<li>Smack信息标签（Smack info tab） -显示关于Smack的信息 (例如： Smack的版本（Smack version）, 安装的组件（installed components）,等等)。</li>
<li>连接标签包含以下信息:</li>
<li>所有的信息包（All Packets） -显示由Smack解析的发送和收到的信息包的信息。</li>
<li>未经处理的发送信息包（Raw Sent Packets） -未经处理的XML traffic（raw XML traffic）由Smack生成并发送至服务器 。</li>
<li>未经处理的接收信息包（Raw Received Packets） –未经处理的XML traffic（raw XML traffic）由服务器发送给客户机。</li>
<li>Ad-hoc 消息（Ad-hoc message） -允许发送各种类型的ad-hoc信息包（ad-hoc packets）。</li>
</ul>
<p><strong>信息—显示连接状态和统计信息。</strong></p>
<p>简单的调试器（Lite Debugger ）<br>当调试模式可用时，每创建一个连接将出现调试窗口，该窗口包含以下信息：</p>
<p>客户端的流量（Client Traffic） (红色的文本) –未经处理的XML traffic（raw XML traffic）由Smack生成并发送至服务器 。</p>
<p>服务器端的流量（Server Traffic）(蓝色的文本) –未经处理的XML traffic（raw XML traffic）由服务器发送给客户机。</p>
<p>解释的信息包（Interpreted Packets）(绿色的文本) – 显示来自服务器的由Smack解析的XML信息包（XML packets）</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[AndroidPN消息推送]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/androidDP-introduction.html</url>
      <content type="html"><![CDATA[<p>Androidpn是韩国Sehwan No写的开源消息推送项目，很多大公司都用这个消息推送方式构建自己的消息推送服务，缺点是导致客户端比较耗电。通信机制分别由客户端和服务器完成。</p>
<p>客户端采用基于java的XMPP协议包asmack（该包依赖于openfire下的开源项目smack）。通过该协议包提供的XMPPConnetcion类与服务器建立持久连接，并通过该连接进行用户注册和登录认证，以及接受服务器消息。<br><a id="more"></a><br>   服务器是基于开源的openfire工程，采用java语言实现和Spring框架提供Web服务。主要有两个部分，一个是侦听在5222端口上的XMPP服务，负责与客户端的XMPPConnection类进行通信，作用是用户注册和身份认证，并推送消息。另外是Web服务器，采用一个轻量级的HTTP服务器，负责接收用户的Web请求。</p>
<p>   整个基于XMPP的通信中，服务器端和客户端的通信是基于一个session（会话）过程，会话开始，首先客户端会指定端口号，然后把准备的连接信息发送到服务器端，客户端通过XMPP协议做的只有接收消息，其他的管理连接和保存消息等都由服务器负责。消息的传递是以根节点<stream>为起始，以</stream>为结束。</p>
<p>   服务器和客户端建立Tcp连接过程如下。首先，建立会话协商，Client 准备connecting to server (127.0.0.1:5222)。其次，服务器询问Client所支持的安全认证。再者，Client发送给服务器要注册的用户。然后，Client根据服务器的要求提交用户信息。最后，Client关闭注册的STREAM元素。</p>
<hr>
<h1 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h1><p>Client这边包含有消息的收发，解析以及持久连接的发起，重连等功能呢，十分强大，我们开发时完全不用管底层的连接，也不用担心断线，可以专注于业务部分的开发。</p>
<h2 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h2><p>XmppManager是Client的主控制器，主要用来管理连接信息，包括XMPP端口、IP地址、登录的用户名和密码，以及对连接的维护。</p>
<h2 id="消息解析处理"><a href="#消息解析处理" class="headerlink" title="消息解析处理"></a>消息解析处理</h2><p>NotificationIQ、NotificationPackerListener以及NotificationIQProvider三个类负责对收到的Notification格式的消息进行解析和处理。</p>
<h2 id="手机状态监听"><a href="#手机状态监听" class="headerlink" title="手机状态监听"></a>手机状态监听</h2><p>PersistentConnetcionListener、PhoneStateChangeListener以及ReconnectionThread三个类负责监听手机状态和断线重连。</p>
<p>同时，代码结构也很简单。去除android的Service和BroadCast类以及一些工具类和常量类不谈：</p>
<p>1.NotificationIQ,NotificationIQProvider,NotificationPacketListener三个类负责对收到的Notification格式的消息进行解析和处理，</p>
<p>2.XmppManager是主控制器，NotificationService通过这个类，在后台维护androidpn连接。</p>
<p>3.PersistentConnectionListener，PhoneStateChangeListener，ReconnectionThread.java三个类则负责监听手机的状态并进行断线重连。</p>
<p>我们自定义消息时需要定义3个类：在NotificationIQ中定义消息的实体，在NotificationIQProvider中将消息转化为NotificationIQ实体，在NotificationPacketListener中对实体进行处理，具体的实现可参考NotificationIQ,NotificationIQProvider,NotificationPacketListener三个类。在定义这些类之后，还需要在XmppManager中将这3个类中注册到connection中，代码如下：</p>
<pre><code>connection.connect();
Log.i(LOGTAG, &quot;XMPP connected successfully&quot;);
// packet provider
ProviderManager.getInstance().addIQProvider(&quot;message&quot;,
Constants.NOTIFICATION_NAMESPACE,
new NotificationIQProvider());
//packet filter
PacketFilter packetFilter = new PacketTypeFilter(
NotificationIQ.class);
// packet listener
PacketListener packetListener = xmppManager.getNotificationPacketListener();
connection.addPacketListener(packetListener, packetFilter);
</code></pre><p>需要注意的是，注册NotificationIQProvider时，传入的namespace需要和服务端组装消息时使用的namespace一致，才能正确的收到。</p>
<h2 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h2><p>Client在与服务器建立connection后，首先会提交注册任务，在Androidpn项目中，用户注册是采用UUID（通用唯一标识码）来实现的，其每次登录都会利用这个UUID.randomUUID()来产生一个用户名和密码，而且不会重复。</p>
<p>注册方法根据Server的格式要求组装注册消息，发送到服务器，同时使用在connection中添加监听，来获取服务器返回的消息packet。Client会根据消息的类型来判断是否注册成功。</p>
<p>服务端收到Client的注册请求，会通过路由类router来转发到相应的Handler处理，router首先会读取Client发来包Packet的Namespace部分，根据XMPP RFC协议注册packet的namespace为jabber:iq:register，授权packet的namespace为jabber:iq:auth，由此转发到IQRegisterHandler处理注册请求。</p>
<p>如果注册成功，Client会把相应的用户名、密码通过SharePerence保存在Client的共享文件AndroidpnClient中。此外，AndroidpnClient还保存了当前应用的包名、类名、服务器地址、端口、客户端版本、设备ID等。</p>
<h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p>Client的登录是在注册之后进行的，在Client的XmppManager类中，建立连接的时候首先会提交登录任务，然而在提交登录任务的时候都有一个submitRegisterTask()方法，可知，每次登录都会首先提交一个注册任务。</p>
<p>登录的时候，要先通过isAuthenticated()方法判断是否授权，授权处理同样会通过connection发送到服务端，服务端会根据packet的namespace部分进行解析，然后路由类router会根据namespace转发到IQAuthHandler处理。</p>
<p>Client收到服务端返回的消息packet，会使用connection的监听器异步接收消息，并通过XmppManager的context的sendBroadcast(Intentintent)以广播发送出去。</p>
<p>基于tomcat的项目源码<a href="http://pan.baidu.com/s/1kTDUQWJ" target="_blank" rel="external">http://pan.baidu.com/s/1kTDUQWJ</a></p>
<hr>
<h1 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h1><p>服务端架构依赖spring、mina框架，spring完成java Ben管理，mina完成网络通信。另外，服务端还通过jetty潜入了Admin Console Web界面功能。对于spring的依赖导致要把androidpn-server整合潜入项目中时，要考虑和自己项目本身spring环境的整合问题，可能要改造androidpn-server源代码，具体要看项目中spring的环境。对于mina的依赖不存在这个问题，因为mina是类库型框架，而spring是容器型框架。androidpn-server对jetty的使用不是可选的，而是和jetty绑定的，所以要不使用jetty就必须对androidpn-server的源代码进行改造。</p>
<p>另外，对数据的存储使用hibernate框架，androidpn-server在使用hibernate时配置通过ehcache实现二级缓存。官方默认使用的数据库是HSQLDB数据库，你可以改用其他数据库。HSQLDB是用java语言实现的数据库，对其使用请自己学习。Androidpn-server通过In-Process模式（作为应用程序的一部分潜入应用程序）使用HSQLDB的。</p>
<p>  服务器主要由以下几个包组成：</p>
<ul>
<li><p>org.androidpn.server.xmpp异常类型定义，包含程序入口类XmppServer。</p>
</li>
<li><p>org.androidpn.server.util加载配置文件，获取主机和端口等信息。</p>
</li>
<li><p>org.androidpn.server.xmpp.codec是XMPP协议的XML文件解析包，server  </p>
</li>
</ul>
<p>收到和发送的消息都要通过这个包来进行xmpp协议编码和解码。</p>
<ul>
<li><p>org.androidpn.server.xmpp.handler负责对不同类型的消息进行处理</p>
</li>
<li><p>org.androidpn.server.xmpp.net负责维护与client之间的持久连接，并实现了一些传输方式供发送xmpp消息时使用。</p>
</li>
<li><p>org.androidpn.server.xmpp.ssl是对连接进行ssl认证的工具包。</p>
</li>
<li><p>org.androidpn.server.xmpp.router包负责将收到的信息包发送到相应的handler进行处理，是一个路由包。</p>
</li>
<li><p>org.androidpn.server.xmpp.presence里面只包含PresenceManager类，用来维护client的在线状态。</p>
</li>
<li><p>org.androidpn.server.xmpp.push包里面的NotificationManager类包含有向client发送消息的接口。</p>
<p><strong>服务器中使用ServerStarter类启动服务，服务启动后使用XmppServer来管理连接、加载配置等。</strong></p>
</li>
</ul>
<p>服务器接收处理消息流程</p>
<p>① connection接收到来着Client的packet，使用包codec解码。</p>
<p>② 路由包router根据packet的namespace等信息，将packet路由到相应的Handler。</p>
<p>③ Handler开始处理。</p>
<p>开发中只要根据client发送消息的格式，定义自己的router和handler类，然后在PacketRouter中注册router，在IQRouter中注册handler即可。</p>
<p><strong>服务器发送消息的流程</strong></p>
<p>① 使用NotificationManager接口的push方法。</p>
<p>② 使用SessionManager在Session集合查找相应的client连接。</p>
<p>③ 定义和组装XMPP消息，通过session向client发送。</p>
<p>在这个流程中我们需要修改的是步骤3，也就是需要定义和组装自己的xmpp消息，以便于将适当的信息传到客户端并便于客户端解析。一个简单的消息组装例子如下：</p>
<pre><code>private IQ  createMessageIQ(String title, String message, String userId,String json) {
Element notification =  DocumentHelper.createElement(QName.get(
&quot;message&quot;,  INQURIE_NAMESPACE));
notification.addElement(&quot;title&quot;).setText(title);
notification.addElement(&quot;text&quot;).setText(message);
notification.addElement(&quot;userId&quot;).setText(userId);
notification.addElement(&quot;json&quot;).setText(json);
IQ iq = new IQ();
iq.setType(IQ.Type.set);
iq.setChildElement(notification);
return iq;
}
</code></pre><p>要注意的是在创建element的时候，传入的namespace要和client解析使用的namespace相匹配。</p>
<p><strong>独立部署使用</strong></p>
<p>独立部署使用不需要对androidpn-server源代码进行任何改造，目录结构见上图，只需要修改好配置文件即可，配置文件在conf文件夹下，下面对需要注意的配置项进行说明，其他配置项目使用默认配置就可。</p>
<p>对于config.properties的配置说明如下：</p>
<p>apiKey=1234567890 #暂时发现没什么用处</p>
<p>admin.console.host=127.0.0.1 #web管理控制界面jetty服务监听的地址</p>
<p>admin.console.port=7070 #web管理控制界面jetty服务监听的端口</p>
<p>对于spring-config.xml的配置说明：</p>
<pre><code>&lt;bean id=&quot;ioAcceptor&quot; class=&quot;org.apache.mina.transport.socket.nio.NioSocketAcceptor&quot;init-method=&quot;bind&quot; destroy-method=&quot;unbind&quot;&gt;

&lt;property name=&quot;defaultLocalAddress&quot; value=&quot;:5222&quot; /&gt; &lt;!--mina Socekt服务端监听端口，客户端配置和此配置一致--&gt;

&lt;property name=&quot;handler&quot; ref=&quot;xmppHandler&quot; /&gt;

&lt;property name=&quot;filterChainBuilder&quot; ref=&quot;filterChainBuilder&quot; /&gt;

&lt;property name=&quot;reuseAddress&quot; value=&quot;true&quot; /&gt;

&lt;/bean&gt;
</code></pre><p>启动脚本在bin下，windowns和linux的脚本都有，需要配置系统环境变量JAVA_HOME，或者修改启动脚本将JAVA_HOME指定为你本机的具体地址，运行run脚本androidpn启动成功，通过浏览器访问<a href="http://127.0.0.1:7070/就可看到console界面。" target="_blank" rel="external">http://127.0.0.1:7070/就可看到console界面。</a></p>
<p>其他项目通过http方式将需要发送的消息提交给androidpn-server服务，由androidpn-server完成客户端消息推送。</p>
<p>具体应用可以通过程序代码编写方式访问<a href="http://192.168.1.24:7070/notification.do地址，将需要的参数以post方式提交。" target="_blank" rel="external">http://192.168.1.24:7070/notification.do地址，将需要的参数以post方式提交。</a></p>
<p>嵌入项目使用<br>若要将androidpn作为应用程序的一部分潜入项目中使用，需要对androidpn-server源代码进行改造。</p>
<p><strong>情况一：若你的项目中没有用到spring</strong></p>
<p>这种情况不用考虑androidpn的spring和你项目中spring配置的融合问题，直接因为spring就可以了，配置文件使用androidpn默认配置文件名称spring-config.xml。配置文件都放在classpath下。</p>
<p>需要在config.properties配置文件中增加配置server.home.dir选项，值指向一个目录，如：server.home.dir=F:\android\download\androidpn-server-0.5.0，该目录下要有子目录conf\security，目录下要放两个文件keystore和truststore，用来进行SSL安全传输用的密钥和证书，利用androdpn-server自带的就可以。</p>
<p>接下来就是修改org.androidpn.server.xmpp. XmppServer类，将启动admin console的代码注释掉，如下截图红框框住的部分。如果你需要启动admin console的话，需要将原始androidpn中console文件夹放到合适的路径下，这个还没有试。</p>
<p><strong>Androidpn-server主启动类</strong></p>
<p>org.androidpn.server.xmpp.XmppServer修改完后，你就可以在你的应用程序这样调用：</p>
<p>XmppServerserver = XmppServer.getInstance();</p>
<p>这样XmppServer通过加载spring启动了mina监听服务，这时手机客户端应用已经可以连接服务端了。</p>
<p>你的应用程序需要推送消息时，实例化</p>
<p>org.androidpn.server.xmpp.push.NotificationManager，调用其提供的sendBroadcast和sendNotifcationToUser方法，如下代码调用：</p>
<pre><code>NotificationManager notificationManager = new NotificationManager();
notificationManager.sendBroadcast(&quot;1234567890&quot;, &quot;Hello&quot;,&quot;Hello BalanceJia!&quot;, &quot;uri&quot;);
或
notificationManager.sendNotifcationToUser(apiKey,username, title, message, uri);
</code></pre><p><strong>情况二：若你的项目中用到spring</strong></p>
<p>和你的项目中spring配置融合，需要注意spring容器不能重复启动的问题。所以要将androidpn-server的spring配置增加到你的spring配置中，需要修改XmppServer启动spring的地方，另外androidpn-server spring中配置的ben名字和你项目中的本名字不能重复，因为androidpn-server中用到的ben  id有：dataSource、dataSource、transactionManager、userDao、userService。还有数据源冲突的问题。</p>
<p><strong>情况三：基于tomcat部署</strong></p>
<p>1.依据ServerStart类写一个servlet，在servlet中启动时创建XmppServer实例。然后在web.xml中配置为自启动。</p>
<p>2.将androidpn自带的配置目录conf拷贝到WEB-INF下面，并且把spring-config.xml文件从conf目录移动到WEB-INF目录。</p>
<p>3.修改默认的spring-config.xml文件，在文件schema的头部<beans>下面加入如下内容<import resource="applicationContext.xml">，其中，加载顺序会默认先加载applicationContext文件，然后会加载spring-config文件后面的内容。</import></beans></p>
<p>原因是spring-config文件中有个<bean id="xmppHandler" ...="">组件会在web服务启动的时候加载，该组件也会初始化XmppServer，导致与servlet的加载发生冲突。</bean></p>
<p>由于未使用使用hibernate-cfg.xml文件，需要在spring-config文件加入如下内容：</p>
<pre><code>&lt;bean id=&quot;sessionFactory&quot;
   class=&quot;org.springframework.orm.hibernate3.LocalSessionFactoryBean&quot;&gt;
   &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt;
   &lt;property name=&quot;mappingResources&quot; &gt;
  &lt;list&gt;
&lt;value&gt;org/androidpn/server/model/User.hbm.xml&lt;/value&gt;
  &lt;/list&gt;
&lt;/property&gt;
&lt;property name=&quot;hibernateProperties&quot;&gt;
   &lt;props&gt;
 &lt;prop key=&quot;hibernate.dialect&quot;&gt;
  org.hibernate.dialect.SQLServerDialect
 &lt;/prop&gt;
 &lt;prop key=&quot;hibernate.show_sql&quot;&gt;true&lt;/prop&gt;
 &lt;prop key=&quot;hibernate.hbm2ddl.auto&quot;&gt;update&lt;/prop&gt;
  &lt;/props&gt;
 &lt;/property&gt;
 &lt;/bean&gt;
</code></pre><p>在spring-config.xml文件中，配置组件<bean: id="ioAcceptor">的listenrPort属性</bean:></p>
<pre><code>&lt;bean id=&quot;listenrPort&quot; class=&quot;java.net.InetSocketAddress&quot;&gt;
 &lt;constructor-arg value=&quot;localhost&quot;/&gt;
 &lt;constructor-arg value=&quot;5222&quot;/&gt;
&lt;/bean&gt;
</code></pre><p>此外，Androidpn默认采用spring-mvc方式配置，所以需要修改action指向。修改org.androidpn.server.console.controller包下面的三个类，改为继承自struct2的ActionSupport方式，并修改默认的调用方法，然后配置struct.xml文件。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[XMPP协议分析-原理]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/xmpp.html</url>
      <content type="html"><![CDATA[<h1 id="XMPP协议简介"><a href="#XMPP协议简介" class="headerlink" title="XMPP协议简介"></a>XMPP协议简介</h1><p>XMPP协议（Extensible Messaging and PresenceProtocol，可扩展消息处理现场协议）是一种基于XML的协议，目的是为了解决及时通信标准而提出来的，最早是在Jabber上实现的。它继承了在XML环境中灵活的发展性。因此，基于XMPP的应用具有超强的可扩展性。并且XML很易穿过防火墙，所以用XMPP构建的应用不易受到防火墙的阻碍。利用XMPP作为通用的传输机制，不同组织内的不同应用都可以进行有效的通信。<br><a id="more"></a></p>
<h2 id="XMPP协议特点"><a href="#XMPP协议特点" class="headerlink" title="XMPP协议特点"></a>XMPP协议特点</h2><ol>
<li><p>所有XMPP信息都是以XML为基础的，信息交换的事实标准，扩展性强</p>
</li>
<li><p>XMPP系统是一个分布式系统，每台服务器控制自己的资源，但是如果需要，它能与外在的系统进行通信。XMPP服务器利用开放的XML协议来进行S2S(Serverto Server)通信，就像在C2S(Client to Server)一样。相比之下，大多数的IM系统使用了只是支持C2S/S2C通信的协议，因此Jabber/XMPP服务器具有更大的灵活性。</p>
</li>
<li><p>XMPP协议是公开的，程序则开放源代码。定义了客户端和服务器端的交互要经由XML流。普通消息类型（message），如改变状态(presence)，传递消息内容或查询/更新(info/quey)应用则用每个指定的命名空间(namespace)来建立。</p>
</li>
<li><p>状态(Presence)在整个持久连接中。通过持久连接的有效维持，XMPP协议一直有在网络中维持存在和可用信息的能力。</p>
</li>
<li><p>XMPP允许建立并行的TCP套接字连接对所有连接上的客户端和服务器端。一旦建立连接，则只有当状态改变，例如存在的改变，通过这个连接传输数据。既然这个连接是持久的，那么设置、认证、状态查找功能都不用每次都重复执行。这种持久的套接字的连接使得XMPP能够更有效的支持高级的具有存在能力的应用在带宽和处理资源的使用中。</p>
</li>
<li><p>Jabber/XMPP系统是模块化的，而且Jabber/XMPP的设计强调如何实现可伸缩性、安全性和可扩展性。</p>
</li>
</ol>
<h2 id="XMPP协议分析"><a href="#XMPP协议分析" class="headerlink" title="XMPP协议分析"></a>XMPP协议分析</h2><pre><code>XMPP中定义了三个角色：客户端，服务器，网关。
</code></pre><p>通信能够在这三者的任意两个之间双向发生。服务器同时承担了客户端信息记录，连接管理和信息的路由功能。网关承担着与异构即时通信系统的互联互通，异构系统可以包括SMS<br>（短信），MSN，ICQ等。基本的网络形式是单客户端通过TCP/IP连接到单服务器，然后在之上传输XML。</p>
<p>XMPP的基本网络结构如下：</p>
<pre><code>C1----S1---S2---C3
|
C2----+--G1===FN1===FC1
</code></pre><p>符号表示：C1,C2,C3=XMPP客户端；S1,S2=XMPP；服务端G1=在XMPP和使用外部消息网络（非XMPP）的协议之间转换的网；FN1=外部消息网络；FC1=外部消息网络的客户端。</p>
<p><strong>（1）服务器</strong></p>
<p>服务系统是XMPP通信的智能提取层，它主要负责：管理来自其他个体的会话连接或者XML流（streams）和来自客户端、服务器、其他个体的认证发送在XML流实体之中的适当的XML地址节点。大多数XMPP服务都允许存储一些客户端数据（比如联系人列表），在这种情况下，服务直接面向这个客户端处理XML数据，而不是其他个体。</p>
<p><strong>（2）客户端</strong></p>
<p>大多数客户端是通过TCP直接连接，并且使用XMPP获得服务器提供全部-12-第2章Jabber协议原理及其应用功能和其他服务。许多资源通过认证的客户端也许同时连接到服务器，定义在XMPP地址的每个资源是不同的（比如<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#111;&#x3a;&#110;&#x6f;&#x64;&#101;&#x40;&#x64;&#x6f;&#x6d;&#97;&#105;&#x6e;&#x2f;&#104;&#111;&#x6d;&#x65;">&#110;&#x6f;&#x64;&#101;&#x40;&#x64;&#x6f;&#x6d;&#97;&#105;&#x6e;&#x2f;&#104;&#111;&#x6d;&#x65;</a>和<a href="&#109;&#x61;&#x69;&#108;&#x74;&#111;&#x3a;&#x6e;&#x6f;&#x64;&#x65;&#64;&#100;&#x6f;&#x6d;&#97;&#105;&#110;&#47;&#119;&#111;&#x72;&#107;">&#x6e;&#x6f;&#x64;&#x65;&#64;&#100;&#x6f;&#x6d;&#97;&#105;&#110;&#47;&#119;&#111;&#x72;&#107;</a>）建议服务器和客户端采用的端中是5222。</p>
<p><strong>（3）网关</strong><br>它的主要功能是将XMPP协议转换成外部消息(non-XMPP)系统使用的协议,也将返回的数据转换成XMPP。这些通信是基于网关和服务器，基于网关和外部消息系统之间的。</p>
<h2 id="XMPP消息格式"><a href="#XMPP消息格式" class="headerlink" title="XMPP消息格式"></a>XMPP消息格式</h2><p>Jabber/XMPP系统使用XML流在不同实体之间相互传输数据。在两个实体的连接期间，XML流将从一个实体传送到另一个实体。在实体间，有三个顶层的XML元素:<message>，<presence>和<iq>。每一个都包含属性和子节点。下面将分别描述这些元素。</iq></presence></message></p>
<p><strong>1)消息(message)元素：</strong></p>
<p>一个即时消息系统最基本的功能就是能够在两个用户之间实时交换消息，<message>元素就提供了这个功能。每条消息都有一个或多个属性和子元素。属性“from”和“to”分别表示了消息发送者和接收者的地址。<message>也可以包含一个“type”属性，这给接收者一个提示，这个消息是什么样的消息。表3-1给出了“type”属性的可能取值。<message>中也可以包含“id”属性，用来唯一的标识一个输出消息的响应。</message></message></message></p>
<p><strong>2)状态(presence)元素:</strong></p>
<p><presence>元素用来传递一个用户的存在状态的感知信息。用户可以是“available”，要么是“unavailable”，“Hide”等。当用户连接到即时消息服务器后，好友发给他的消息就立即被传递。如果用户没有连接到服务器，好友发给他的消息将被服务器存储起来直到用户连接到服务器。用户通过即时消息客户端自己控制可用性。但是，如果用户断开了同服务器的连接，服务器将发送给订阅了这个用户的存在信息的用户通知他们用户已经不可用。<presence>还包含了两个子元素：<show>和<status>。<status>包含了一个对<show>的文本描述。</show></status></status></show></presence></presence></p>
<p><strong>3)IQ(Info&lt;Query)元素</strong></p>
<p>IQ元素是Jabber/XMPP消息协议的第三个顶层元素。IQ代表”Info/Query”，用来发送和获取实体之间的信息。IQ消息是通过“请求/响应”机制在实体间进行交换的。IQ元素用于不同的目的，它们之间通过不同的命名空间来加以区分。在Jabber/XMPP消息协议里有许多的命名空间，但最常用的命名空间是：”jabber:iq:register”,”jabber:iq:auth”,”jabber:iq:roster”。</p>
<p>上面描述了Jabber协议的三个顶层节点。通过这种格式Jabber消息不仅可以是简单的文本（text），而且可以携带复杂的数据和各种格式的文件，也就是说Jabber不仅可以用在人与人之间的交流，而且可以实现软件与软件或软件与人之间的交流。Jabber的这种功能大大扩展了即时通信的应用范围。</p>
<h2 id="XMPP工作机制"><a href="#XMPP工作机制" class="headerlink" title="XMPP工作机制"></a>XMPP工作机制</h2><p>例如:一个终端名字是Remeo，通过服务器montague.lit与其他的用户相连，其他的用户通过服务器juliet@capulet.lit建立连接。</p>
<p>第一步Romeo开始通过发送一个stream包与服务器montague.lit取得联系，这一步包含了鉴权，登录等等。</p>
<p>第二步Romeo获取了他的联系人列表，通过向服务器montague.lit发送<iq>字段请求，按照下面的协议。</iq></p>
<pre><code>&lt;iq type=‘get’from=‘romeo@montague.lit/pda’&gt;
&lt;query xmlns=‘jabber:iq:roster’/&gt;
&lt;/iq&gt;

&lt;iq type=‘result’to=‘romeo@montague.lit/pda’&gt;
&lt;query xmlns=‘jabber:iq:roster’&gt;
&lt;item jid=‘juliet@capulet.lit’/&gt;&lt;item jid=‘mercutio@shakespeare.lit’/&gt;
&lt;item jid=‘benvolio@shakespeare.lit’/&gt;
&lt;/query&gt;
&lt;/iq&gt;
</code></pre><p>第三步Romeo发送了一个presence请求到服务器montague.lit，然后会将这个信息广播到他的所有好友。</p>
<pre><code>&lt;presence from=‘romeo@montague.lit/pda’/&gt;
&lt;presence from=‘romeo@montague.lit/pda’to=‘juliet@capulet.lit’/&gt;
&lt;presence from=‘romeo@montague.lit/pda’to=‘mercutio@shakespeare.lit’
/&gt;
&lt;presence from=‘romeo@montague.lit/pda’to=‘benvolio@shakespeare.lit’
/&gt;
</code></pre><p>第四步如果Romeo的联系人都在线，就会将presence回复给Romeo，告知自己的状态。</p>
<pre><code>&lt;presence to=‘romeo@montague.lit/pda’from=‘juliet@capulet.lit/balcony’/&gt;
&lt;presence to=‘romeo@montague.lit/pda’from=‘juliet@capulet.lit/chamber’/&gt;
&lt;presence to=‘romeo@montague.lit/pda’from=‘mercutio@shakespeare.lit/home’/&gt;
</code></pre><p>第五步Romeo和Juliet开始交换信息，进行聊天。</p>
<pre><code>&lt;message from=‘romeo@montague.lit/pda’to=‘juliet@capulet.lit’&gt;
&lt;body&gt;hi!&lt;/body&gt;
&lt;/message&gt;

&lt;message from=‘juliet@capulet.lit/balcony’to=‘romeo@montague.lit/pda’
  &gt; 
&lt;body&gt;hi yourself!&lt;/body&gt;
&lt;/message&gt;
</code></pre><p>以文档的观点来看，客户端或服务器发送的所有XML文本连缀在一起，从<stream>到</stream>构成了一个完整的XML文档。其中的stream标签就是所谓的XML Stream。在<stream>与</stream>中间的那些<message>…</message>这样的XML元素就是所谓的XML Stanza（XML节）。XMPP核心协议通信的基本模式就是先建立一个stream，然后协商一堆安全之类的东西，中间通信过程就是客户端发送XML Stanza，一个接一个的。服务器根据客户端发送的信息以及程序的逻辑，发送XML Stanza给客户端。但是这个过程并不是一问一答的，任何时候都有可能从一个方发信给另外一方。通信的最后阶段是关闭流，关闭TCP/IP连接。</p>
<p><img src="/images/images/openfire/xmpp1.jpeg" alt=""></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用Jfreechart生成曲线显示到JSP中]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/jsp-jfreechart.html</url>
      <content type="html"><![CDATA[<p>项目中需要弄一个服务器，从数据库中读取数据，然后根据http请求显示制定的数据在曲线中，这里用到一个曲线库，<a href="http://www.jfree.org/jfreechart/" target="_blank" rel="external">Jfreechart</a>，用java写的，用来生成柱状图，饼状图，时间序列等。<br>整个流程如下：<br><img src="/images/images/chart.png" alt=""><br><a id="more"></a><br>jsp代码如下：</p>
<pre><code>&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot;%&gt;
&lt;%@ page import=&quot;java.awt.*,
java.util.List,
javax.swing.JPanel,
org.jfree.chart.ChartFactory,
org.jfree.chart.ChartPanel,
org.jfree.chart.JFreeChart,
org.jfree.chart.axis.DateAxis,
org.jfree.chart.plot.XYPlot,
org.jfree.chart.renderer.xy.XYItemRenderer,
org.jfree.chart.renderer.xy.XYLineAndShapeRenderer,
org.jfree.data.time.*,
org.jfree.data.time.TimeSeries,
org.jfree.data.time.TimeSeriesCollection,
org.jfree.data.xy.XYDataset&quot;%&gt;
&lt;%@ page import=&quot;org.jfree.chart.ChartUtilities&quot;%&gt;
&lt;%@ page import=&quot;java.util.*&quot;%&gt;
&lt;%@ page import = &quot;com.lippi.medic.server.*&quot;%&gt;
&lt;%@ page import = &quot;java.io.*&quot; %&gt;

&lt;html&gt;
&lt;body&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html&quot; charset=&quot;utf-8&quot;&gt;
&lt;h1 align=&quot;center&quot;&gt;
&lt;font font-size=&quot;5&quot; color=&quot;black&quot;&gt;欢迎访问肌电信号数据库&lt;/font&gt;
&lt;/h1&gt;
&lt;%
 //创建时序图对象
 TimeSeries timeSeries = new TimeSeries(&quot;肌电信号&quot;);
 //这里的logs是从servlet中设置的request属性值
 List&lt;MedicLogs&gt; logs = (List)request.getAttribute(&quot;logs&quot;);
 Iterator&lt;MedicLogs&gt; iterator = logs.iterator();
         while(iterator.hasNext()){
             MedicLogs log = iterator.next();
             Minute minute = new Minute(log.getCreateDate());
             double data = log.getData();
             timeSeries.add(minute, data);
         }
 TimeSeriesCollection collection = new TimeSeriesCollection();
 collection.addSeries(timeSeries);
 collection.setDomainIsPointsInTime(true);

 JFreeChart chart = ChartFactory.createTimeSeriesChart(&quot;肌电信号&quot;,&quot;时间&quot;,
                        &quot;幅值&quot;, collection,true,true,false);
 chart.setBackgroundPaint(Color.white);//设置曲线图背景色
 XYPlot plot = (XYPlot) chart.getPlot();
 XYLineAndShapeRenderer renderer = (XYLineAndShapeRenderer)plot.getRenderer();
 plot.setBackgroundPaint(Color.white);//设置网格背景颜色
 plot.setDomainGridlinePaint(Color.pink);//设置网格竖线颜色
 plot.setRangeGridlinePaint(Color.pink);//设置网格横线颜色
 renderer.setBaseShapesVisible(true);//设置曲线是否显示数据点
 final File file = new File(&quot;/home/lippi/apache-tomcat-8.0.11/webapps/medicdatabase/chart.png&quot;);
 ChartUtilities.saveChartAsPNG(file, chart, 500, 300);
 %&gt;
 &lt;h1 align=&quot;center&quot;&gt;
&lt;IMG SRC=&quot;chart.png&quot; WIDTH=&quot;600&quot; HEIGHT=&quot;400&quot; BORDER=&quot;0&quot; USEMAP=&quot;#chart&quot;&gt;

&lt;br&gt;&lt;br&gt;

&lt;form action=&quot;display.do&quot; method=&quot;post&quot;&gt;
    &lt;input type=&quot;submit&quot; name=&quot;back&quot; value=&quot;载入前5000条数据&quot; &gt;

    &lt;input type=&quot;submit&quot; name=&quot;forward&quot; value=&quot;载入后5000条数据&quot; &gt;
&lt;/form&gt;
&lt;/h1&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><p>附上Jsp代码的转换和编译过程：</p>
<ol>
<li>客户第一次请求这个jsp，容器尝试将jsp页面转换成一个servlet类的java代码</li>
<li>容器把java源文件编译成.class文件</li>
<li>web容器加载新生成的servlet类</li>
<li>容器实例化servlet，并调用servlet的jspInit()方法,此时对象成为一个完整的servlet</li>
<li>容器创建一个新线程来处理客户的请求，servlet的_jspService()方法运行</li>
<li>最终servlet向客户发回一个响应，或者把请求转发到另一个web应用组件，比如这个例子中的jsp。</li>
</ol>
<p>编译这个jsp代码需要用到两个jar文件，jfreechart-1.0.18.jar和jcommon-1.0.22.jar，把他们放到WEB-INF的lib文件夹下。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[当我们打开网页时发生了什么]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/how-http-works.html</url>
      <content type="html"><![CDATA[<p>简单地来说，当我们在浏览器上输入URL的敲下回车的时候。</p>
<ol>
<li>浏览器需要查找域名[domain]的IP，从不同的缓存直至DNS服 务器。</li>
<li>浏览器会给web服务器发送一个HTTP请求</li>
<li>服务器“处理”请求</li>
<li>服务器发回一个HTTP响应</li>
<li>浏览器渲染HTML到页面。<br>比如我们从<a href="http://www.joes-hardware.com:80/power-tools.html" target="_blank" rel="external">http://www.joes-hardware.com:80/power-tools.html</a>获取资源的时候，整个过程如下图所示：<br><img src="/images/images/http/1.jpeg" alt=""><br>开始时我们输入的是URI(统一资源标识符,Uniform Resource Identifier)，我们用的比较多的是URI的一个子集叫统一资源定位符(URL,Uniform Resource Locator)。<a id="more"></a>    
URL组成</li>
</ol>
<hr>
<p>  网址算是URL的一个俗称，让我们来看看一个URL的组成，以HTTP版IOT中的URL为例。<br>大多数URL都建立在这个通用格式</p>
<pre><code>&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frgs&gt;
</code></pre><p>各个部分的介绍如下表：<br><img src="/images/images/http/0.jpeg" alt=""><br>以一个实际例子来说：<br>当我们在浏览器中输入<a href="http://b.phodal.com/athome/1" target="_blank" rel="external">http://b.phodal.com/athome/1</a>按下回车</p>
<p>开始之前，我们需要标出URL的80端口以及json文件的全称，那么上面的网址就会变成</p>
<p><a href="http://b.phodal.com:80/athome/1.json" target="_blank" rel="external">http://b.phodal.com:80/athome/1.json</a></p>
<p>那么对于这个URL的就有下面几部分组成</p>
<ul>
<li><strong>http:</strong>// http说的是这个URL用的是HTTP协议，至于//是一个分隔符，用法和C语言中的;一样。这样的协议还可以是coap,https,ftp等等。</li>
<li><strong>b</strong> 是子域名，一个域名在允许的情况下可以有不限数量的子域名。</li>
<li><strong>phodal.com</strong> 代表了一个URL是phodal.com下面的域名</li>
<li><ul>
<li><strong>80</strong> 80是指80端口，http默认的都是80，对于一个不是80端<br>口的URL应该是这样的<a href="http://iot-coap.phodal.com:8896/" target="_blank" rel="external">http://iot-coap.phodal.com:8896/</a></li>
</ul>
</li>
<li><strong>athome</strong> 指的是虚拟目录部分，或者文件路径</li>
<li><strong>1.json</strong>看上去就是一个文件名，然而也代表着这是一个资源。</li>
</ul>
<p>对就一个稍微复杂点的例子就是<br><a href="http://designiot.phodal.com/#%E4%BD%A0%E6%89%80%E6%B2%A1%E6%9C%89%E6%B7%B1%E5%85%A5%E7%9A%84http" target="_blank" rel="external">http://designiot.phodal.com/#你所没有深入的http</a></p>
<p>这里的#后面是片段部分（frag），如果你打开这个URL就会发现会直接跳转到相应的片段，对就于下面这样的一个例子来说</p>
<p><a href="http://www.phodal.com/search;sales=false/?q=iot&amp;type=blog" target="_blank" rel="external">http://www.phodal.com/search;sales=false/?q=iot&amp;type=blog</a><br><strong>;</strong>后面是<strong>参数部分</strong>，以便正确的与服务器进行交互<br><strong>?</strong>后面的q=iot&amp;type=blog的部分是<strong>查询字符串</strong>，通常用于查询或者、搜索。</p>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>http客户端向http服务器发送请求报文，请求报文格式如下：<br>请求行<br>首部<br>空行<br>主体部分</p>
<pre><code>&lt;method&gt;&lt;request-URL&gt;&lt;version&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre><p>响应报文的格式如下：<br>响应行<br>首部<br>空行<br>主体</p>
<pre><code>&lt;version&gt;&lt;status&gt;&lt;reason-phase&gt;
&lt;headers&gt;

&lt;entity-body&gt;
</code></pre><ul>
<li>方法method，常见的有get和post，是客户端希望服务器对资源执行的动作</li>
<li>请求URL。所请求资源的完整URL或者相对路径</li>
<li>版本version，报文使用的http版本，比如HTTP1.1</li>
<li>首部header，向请求报文和响应报文添加了一些信息，本质上都是一些名/值对的列表。</li>
<li>状态码（status）描述请求过程发生的情况，比如200，表示OK</li>
<li>原因短语(reason-phase),数字状态码的可读版本</li>
<li><p>实体的主体部分(entity-body)<br>一个可能的请求报文图下：</p>
<p>  GET /java/2014/08/02/java-multithread.html HTTP1.1<br>  Accept:text/html<br>  Host: www.lippiouyangonline.info</p>
<p>可能的响应报文如下：</p>
<p>  HTTP/1.1 200 OK<br>  content-type: text/plain<br>  content-length: 19</p>
<p>  Hi,I’m a message!<br>下面是一个POST方法示例：<br><img src="/images/images/http/2.jpeg" alt=""></p>
</li>
</ul>
<h2 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h2><p>几乎所有的HTTP通信都是由TCP/IP承载的，HTTP要传送一个报文，会以流的形式将报文数据内容通过一条打开的TCP连接按序传输。TCP收到数据流后会将数据流切成小段的数据块，并将段封装在IP分组中，通道因特网进行传输，每个IP分组包括：</p>
<pre><code>1. 一个IP分组首部(通常为20字节)
2. 一个TCP段首部(通常为20字节)
3. 一个TCP数据块(0个或者多个字节)
</code></pre><p>IP首部包括源和目的的的IP地址，长度和其他一些标记，TCP首部包括TCP端口号和控制标记。 端口号和电话分机很类似，就像公司的总机号码能将你接到前台，分机号码帮你找到正确的联系人。IP地址可能将你链接的正确的计算机，端口号将你连接到正确的应用程序上去，端口号就是一个数字，HTTP的默认端口号为80。<br>TCP连接是通过4个值来识别的：<br><code>&lt;源IP地址、源端口号、目地IP地址、目地端口号&gt;</code>这4个值唯一定义了一条TCP连接。<br> 一个TCP分组如下：<br>  <img src="/images/images/http/3.jpeg" alt=""><br>一个典型的TCP客户端和服务器的通信过程如下：<br> <img src="/images/images/http/4.jpeg" alt=""></p>
<p>待续…<br>参考书目：HTTP权威指南</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[值得推荐的android开源框架]]></title>
      <url>http://www.ezlippi.com/blog/2014/10/android-opensource.html</url>
      <content type="html"><![CDATA[<h2 id="1、volley"><a href="#1、volley" class="headerlink" title="1、volley"></a>1、volley</h2><p>项目地址<a href="https://github.com/smanikandan14/Volley-demo" target="_blank" rel="external">https://github.com/smanikandan14/Volley-demo</a></p>
<ul>
<li>(1)  JSON，图像等的异步下载；</li>
<li>(2)  网络请求的排序（scheduling）</li>
<li>(3)  网络请求的优先级处理</li>
<li>(4)  缓存</li>
<li>(5)  多级别取消请求</li>
<li>(6)  和Activity和生命周期的联动（Activity结束时同时取消所有网络请求）<a id="more"></a>
<h2 id="2、android-async-http"><a href="#2、android-async-http" class="headerlink" title="2、android-async-http"></a>2、android-async-http</h2>项目地址：<a href="https://github.com/loopj/android-async-http" target="_blank" rel="external">https://github.com/loopj/android-async-http</a></li>
</ul>
<p>文档介绍：<a href="http://loopj.com/android-async-http/" target="_blank" rel="external">http://loopj.com/android-async-http/ </a></p>
<ul>
<li>(1) 在匿名回调中处理请求结果</li>
<li>(2) 在UI线程外进行http请求</li>
<li>(3) 文件断点上传</li>
<li>(4) 智能重试</li>
<li>(5) 默认gzip压缩</li>
<li>(6) 支持解析成Json格式</li>
<li>(7) 可将Cookies持久化到SharedPreferences</li>
</ul>
<h2 id="3、Afinal框架"><a href="#3、Afinal框架" class="headerlink" title="3、Afinal框架"></a>3、Afinal框架</h2><p>项目地址：<a href="https://github.com/yangfuhai/afinal" target="_blank" rel="external">https://github.com/yangfuhai/afinal</a></p>
<p>主要有四大模块：</p>
<ul>
<li>(1) 数据库模块：android中的orm框架，使用了线程池对sqlite进行操作。<ul>
<li>(2) 注解模块：android中的ioc框架，完全注解方式就可以进行UI绑定和事件绑定。无需findViewById和setClickListener等。</li>
<li>(3) 网络模块：通过httpclient进行封装http数据请求，支持ajax方式加载，支持下载、上传文件功能。</li>
<li>(4) 图片缓存模块：通过FinalBitmap，imageview加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。</li>
</ul>
</li>
</ul>
<p>FinalBitmap可以配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等。FinalBitmap的内存管理使用lru算法，<br>没有使用弱引用（android2.3以后google已经不建议使用弱引用，android2.3后强行回收软引用和弱引用，详情查看android官方文档），<br>更好的管理bitmap内存。</p>
<p>FinalBitmap可以自定义下载器，用来扩展其他协议显示网络图片，比如ftp等。同时可以自定义bitmap显示器，<br>在imageview显示图片的时候播放动画等（默认是渐变动画显示）。</p>
<h2 id="4、xUtils框架"><a href="#4、xUtils框架" class="headerlink" title="4、xUtils框架"></a>4、xUtils框架</h2><p>项目地址：<a href="https://github.com/wyouflf/xUtils" target="_blank" rel="external">https://github.com/wyouflf/xUtils</a></p>
<p>主要有四大模块：</p>
<p> (1) 数据库模块：android中的orm框架，一行代码就可以进行增删改查；</p>
<ul>
<li>支持事务，默认关闭；</li>
<li>可通过注解自定义表名，列名，外键，唯一性约束，NOT NULL约束，CHECK约束等（需要混淆的时候请注解表名和列名）；</li>
<li>支持绑定外键，保存实体时外键关联实体自动保存或更新；</li>
<li>自动加载外键关联实体，支持延时加载；</li>
<li>支持链式表达查询，更直观的查询语义，参考下面的介绍或sample中的例子. </li>
</ul>
<p> (2) 注解模块：android中的ioc框架，完全注解方式就可以进行UI，资源和事件绑定；</p>
<ul>
<li>新的事件绑定方式，使用混淆工具混淆后仍可正常工作；</li>
<li>目前支持常用的20种事件绑定，参见ViewCommonEventListener类和包com.lidroid.xutils.view.annotation.event。</li>
</ul>
<p>(3) 网络模块：支持同步，异步方式的请求；</p>
<ul>
<li>支持大文件上传，上传大文件不会oom；</li>
<li>支持GET，POST，PUT，MOVE，COPY，DELETE，HEAD，OPTIONS，TRACE，CONNECT请求；</li>
<li>下载支持301/302重定向，支持设置是否根据Content-Disposition重命名下载的文件；</li>
<li><p>返回文本内容的请求(默认只启用了GET请求)支持缓存，可设置默认过期时间和针对当前请求的过期时间。  </p>
<p>(4) 图片缓存模块：加载bitmap的时候无需考虑bitmap加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象；</p>
</li>
<li><p>支持加载网络图片和本地图片；</p>
</li>
<li>内存管理使用lru算法，更好的管理bitmap内存；</li>
<li>可配置线程加载线程数量，缓存大小，缓存路径，加载显示动画等…</li>
</ul>
<h2 id="5、ThinkAndroid"><a href="#5、ThinkAndroid" class="headerlink" title="5、ThinkAndroid"></a>5、ThinkAndroid</h2><p>项目地址：<a href="https://github.com/white-cat/ThinkAndroid" target="_blank" rel="external">https://github.com/white-cat/ThinkAndroid</a></p>
<p>主要有以下模块：</p>
<ul>
<li>(1)  MVC模块：实现视图与模型的分离。</li>
<li>(2)  ioc模块：android中的ioc模块，完全注解方式就可以进行UI绑定、res中的资源的读取、以及对象的初始化。 </li>
<li>(3)  数据库模块：android中的orm框架，使用了线程池对sqlite进行操作。  </li>
<li>(4)  http模块：通过httpclient进行封装http数据请求，支持异步及同步方式加载。</li>
<li>(5)  缓存模块：通过简单的配置及设计可以很好的实现缓存，对缓存可以随意的配置</li>
<li>(6)  图片缓存模块：imageview加载图片的时候无需考虑图片加载过程中出现的oom和android容器快速滑动时候出现的图片错位等现象。</li>
<li>(7)  配置器模块：可以对简易的实现配对配置的操作，目前配置文件可以支持Preference、Properties对配置进行存取。</li>
<li>(8)  日志打印模块：可以较快的轻易的是实现日志打印，支持日志打印的扩展，目前支持对sdcard写入本地打印、以及控制台打印</li>
<li>(9)  下载器模块:可以简单的实现多线程下载、后台下载、断点续传、对下载进行控制、如开始、暂停、删除等等。</li>
<li>(10) 网络状态检测模块：当网络状态改变时，对其进行检</li>
</ul>
<h2 id="6、LoonAndroid"><a href="#6、LoonAndroid" class="headerlink" title="6、LoonAndroid"></a>6、LoonAndroid</h2><p>项目地址：<a href="https://github.com/gdpancheng/LoonAndroid" target="_blank" rel="external">https://github.com/gdpancheng/LoonAndroid</a></p>
<p>主要有以下模块：</p>
<ul>
<li>(1)  自动注入框架（只需要继承框架内的application既可）<ul>
<li>(2)  图片加载框架（多重缓存，自动回收，最大限度保证内存的安全性）</li>
<li>(3)  网络请求模块（继承了基本上现在所有的http请求）</li>
<li>(4)  eventbus（集成一个开源的框架）</li>
<li>(5)  验证框架（集成开源框架）</li>
<li>(6)  json解析（支持解析成集合或者对象）</li>
<li>(7)  数据库（不知道是哪位写的 忘记了）</li>
<li>(8)  多线程断点下载（自动判断是否支持多线程，判断是否是重定向）</li>
<li>(9)  自动更新模块</li>
<li>(10) 一系列工具类</li>
</ul>
</li>
</ul>
<p>其中的 volley扩展性非常好，个人比较喜欢的风格。其他如 android-async-http、Afinal 也相当不错。 </p>
<h2 id="7、AndroidAnnotations"><a href="#7、AndroidAnnotations" class="headerlink" title="7、AndroidAnnotations"></a>7、AndroidAnnotations</h2><p>项目地址：</p>
<p><a href="http://androidannotations.org/" target="_blank" rel="external">AndroidAnnotations首页</a></p>
<p><a href="https://github.com/excilys/androidannotations/wiki" target="_blank" rel="external">github上的项目地址</a></p>
<p>主要有以下特点：</p>
<ul>
<li>使用依赖注入(DI)、控制反转(IOC)来简化开发过程</li>
<li>简化的线程模型（Simplified  threading model)  </li>
<li>事件绑定（Event binding）</li>
<li>REST Client</li>
<li>No Magic  </li>
<li>类似框架：<a href="http://jakewharton.github.io/butterknife/" target="_blank" rel="external">Bufferknife</a></li>
</ul>
<h2 id="8、RoboGuice"><a href="#8、RoboGuice" class="headerlink" title="8、RoboGuice"></a>8、RoboGuice</h2><p>项目地址：<a href="https://github.com/roboguice/roboguice" target="_blank" rel="external">https://github.com/roboguice/roboguice</a></p>
<p>RoboGuice 使得进行Android开发更加方便，使得开发变得更加简单也更有乐趣。当你调用getIntent().getExtras()是不是经常检查是否为null？RoboGuice可以帮助你。想想调用findViewById()并映射到TextView确实有必要么？RoboGuice也可以帮你。</p>
<p>RoboGuice 可以帮助解决这类的判断工作。你再也不用记住，是通过调用bindService获取一个用户service，调用getSystemService获取一个系统service。注入你的view、service、或者其他对象，然后让RoboGuice来处理剩下的事宜。</p>
<p>RoboGuice 精简了你的应用代码。更少的代码意味着bug也会更少。也使得阅读代码更加容易，不在纠缠于Android平台的各种特性，而是关注于应用实际的业务逻辑。</p>
<p>没什么很难的，你所需要做的仅仅是配置RoboGuice。</p>
<p>##　9、Dagger ##</p>
<p>项目地址<a href="https://github.com/square/dagger" target="_blank" rel="external">https://github.com/square/dagger</a></p>
<p>android的依赖注入框架（DI框架），感觉跟Spring 的IOC差不多吧。这个框架它的好处是它没有采用反射技术（Spring是用反射的）,而是用预编译技术，因为基于反射的DI非常地耗用资源（空间，时间）</p>
<h2 id="10、Fresco"><a href="#10、Fresco" class="headerlink" title="10、Fresco　"></a>10、Fresco　</h2><p>中文文档<a href="http://fresco-cn.org/" target="_blank" rel="external">http://fresco-cn.org/</a><br>项目地址<a href="https://github.com/facebook/fresco" target="_blank" rel="external">https://github.com/facebook/fresco</a></p>
<p>Fresco 是一个强大的图片加载组件。</p>
<p>Fresco 中设计有一个叫做 image pipeline 的模块。它负责从网络，从本地文件系统，本地资源加载图片。为了最大限度节省空间和CPU时间，它含有3级缓存设计（2级内存，1级文件）。</p>
<p>Fresco 中设计有一个叫做 Drawees 模块，方便地显示loading图，当图片不再显示在屏幕上时，及时地释放内存和空间占用。</p>
<p>特性：</p>
<ul>
<li>内存管理</li>
<li>图片的渐进式呈现</li>
<li>支持加载Gif图，支持WebP格式</li>
</ul>
<h2 id="11、ActiveAndroid"><a href="#11、ActiveAndroid" class="headerlink" title="11、ActiveAndroid"></a>11、ActiveAndroid</h2><p>项目地址：<a href="https://github.com/pardom/ActiveAndroid" target="_blank" rel="external">https://github.com/pardom/ActiveAndroid</a></p>
<p>ActiveAndroid是一个活跃的记录风格的ORM（对象关系映射）库。ActiveAndroid可以让您保存和检索的SQLite数据库记录而没有写一个SQL语句。每个数据库记录被整齐包裹成一个model类,像保存方法（）和delete（）。</p>
<h2 id="12、Android-Universal-Image-Loader"><a href="#12、Android-Universal-Image-Loader" class="headerlink" title="12、Android-Universal-Image-Loader"></a>12、Android-Universal-Image-Loader</h2><p>项目地址：<a href="https://github.com/nostra13/Android-Universal-Image-Loader" target="_blank" rel="external">https://github.com/nostra13/Android-Universal-Image-Loader</a></p>
<p>Android-Universal-Image-Loader是一个开源的UI组件程序，该项目的目的是提供一个可重复使用的仪器为异步图像加载，缓存和显示。所以，如果你的程序里需要这个功能的话，那么不妨试试它。因为已经封装好了一些类和方法。我们 可以直接拿来用了。而不用重复去写了。其实，写一个这方面的程序还是比较麻烦的，要考虑多线程，缓存，内存溢出等很多方面。但是，你也可以参考这个例子来自己写出更好的程序。 </p>
<h2 id="12、KJFrameForAndroid"><a href="#12、KJFrameForAndroid" class="headerlink" title="12、KJFrameForAndroid"></a>12、KJFrameForAndroid</h2><p>项目地址：<a href="https://github.com/kymjs/KJFrameForAndroid" target="_blank" rel="external">https://github.com/kymjs/KJFrameForAndroid</a><br>一个强大的Android开发库，KJFrameForAndroid的设计思想是通过封装Android原生SDK中复杂的复杂操作而达到简化Android应用级开发，最终实现快速而又安全的开发APP。功能包含</p>
<ul>
<li>数据库： javabean直接转换为sqlite表存储  </li>
<li>Activity继承链：用最快捷的方法实现MVC分层  </li>
<li>KJHttp：自带缓存功能的网络请求库，同时可选用HttpurlConnection(默认)或HttpClient实现</li>
<li>KJBitmap：加载网络图片只需要一行代码，使用内存+磁盘双缓存，完美适配任何版本系统不会出现OOM。</li>
</ul>
<h2 id="13、CJFrameForAndroid"><a href="#13、CJFrameForAndroid" class="headerlink" title="13、CJFrameForAndroid"></a>13、CJFrameForAndroid</h2><p>项目地址：<a href="https://github.com/kymjs/CJFrameForAndroid" target="_blank" rel="external">https://github.com/kymjs/CJFrameForAndroid</a><br>一个完善的Android插件化开发框架的开源实现，只需要一行代码就可以启动一个存在于asset目录或sd卡上的没有安装的apk。<br>对于插件apk没有任何的编码限制。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[关于返回 Null 值的问题]]></title>
      <url>http://www.ezlippi.com/blog/2014/09/returning-null.html</url>
      <content type="html"><![CDATA[<p>原文： <a href="http://zdsbs.blogspot.com/2009/08/returning-null.html" target="_blank" rel="external">Returning Null</a></p>
<p>译文： <a href="http://www.aqee.net/returning-null/" target="_blank" rel="external">关于返回 Null 值的问题</a></p>
<hr>
<p>我总感觉一个方法返回 <code>null</code> 值有问题。<br>当读了 Misko Hevery 关于 <a href="http://misko.hevery.com/2009/07/31/how-to-think-about-oo/" target="_blank" rel="external">how to think about OO</a>的博客文章后，又让我想起这个问题。</p>
<p>我感觉返回 <code>null</code> 值是有问题的，它大量的被使用在一个方法有不同的返回类型时。<br>简单的用谷歌搜索一下“returning null”，你就会发现有建议把返回类型做成一个null对象。<br>返回一个 <code>Null</code> 对象在某些情况下是合适的，但并不适合当你需要向客户端传送两种不同的东西的情形。<br><a id="more"></a><br>用 Misko 重构的一段代码来说明这个问题。<br>他重构的是一段登录代码(我非常喜欢他的过程)，这段代码大概是这个样子：</p>
<pre><code>Cookie login(Ldap ldap) {
    if ( ldap.auth(user, password) )
      return new Cookie(user);
    return null;
}
</code></pre><p>从这段代码，可以看出两种情况(从结构上讲)</p>
<ol>
<li>如果认证通过, 客户端会被通知验证成功, 生成一个新的 Cookie</li>
<li>如果认证失败, 则通过返回的null值通知客户端</li>
</ol>
<p>客户端的方法应该是什么样的？</p>
<pre><code>public void authenticateUser(User user) {
    Cookie userCookie = user.login(ldap);
    if (userCookie == null) {
        //notify someone that auth failed
    } eles {
        //register them as logged in
    }
}
</code></pre><p>我们在两个地方做了相同的事情，只是在语法上有稍微的不同，每个地方，我们都要检查验证是否成功。<br>如果我们使用 IoC（反向控制）模式，或“Tell Don’t Ask”模式或“Hollywood原则”，会如何？</p>
<pre><code>Cookie login(Ldap ldap, AuthenticationRegistry authenticationRegistry) {
    if ( ldap.auth(user, password) )
        authenticationRegistry.authSucceeded(new Cookie(user));
    authenticationRegistry.authFailed(user);
}
</code></pre><p>客户端：</p>
<pre><code>public void authenticateUser(User user) {
    user.login(ldap,this);
}

public void authSucceeded(Cookie cookie) {
    //register them as logged in
}

public void authFailed(User user) {
    //register them as auth failed
}
</code></pre><p>新代码稍微有点复杂，但我感觉它很清晰，实现的更直接。<br>现在我们的两个实体能够相互通信，我们定义了它们通信的方式。<br>我喜欢 Misko 的重构，我只是更进了一步。<br>好坏可以再讨论，但我想，如果你遇到了这种需要返回两种情况的方法时，IoC 是你应该的选择。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[为什么 jdk 中把 String 类设计成 final]]></title>
      <url>http://www.ezlippi.com/blog/2014/08/why-jdk-string-is-final.html</url>
      <content type="html"><![CDATA[<h2 id="最佳答案："><a href="#最佳答案：" class="headerlink" title="最佳答案："></a>最佳答案：</h2><p>主要是为了 “ 效率 ” 和 “ 安全性 ” 的缘故。<br>若 String 允许被继承, 由于它的高度被使用率, 可能会降低程序的性能，所以 String 被定义成 final。<br><a id="more"></a></p>
<h2 id="其它答案一："><a href="#其它答案一：" class="headerlink" title="其它答案一："></a>其它答案一：</h2><p>String 和其他基本类型不同 , 他是个对象类型.<br>既然是对象类型 , 如果是在静态方法下是必须调用静态方法或值的 , 如果是非静态的方法 , 就必须要实例化. </p>
<p>main 函数是个 static 的.<br>所以 <strong>String 要能像其他的基本类型一样直接被调用</strong>.<br>这也是为什么在 main 函数下使用 String 类型不会报告错误的原因.. </p>
<p>一下就解释了两个心里的疑问.. </p>
<p>以前一直觉得奇怪 , <strong>为什么 String 是对象类型在 main 函数下却是不需要实例化的</strong>.<br>再次佩服 java 设计人员想得真周到. </p>
<h2 id="其它答案二："><a href="#其它答案二：" class="headerlink" title="其它答案二："></a>其它答案二：</h2><p>当定义 String 类型的静态字段（也成类字段），可以用静态变量（非 final）代替常量（final）加快程序速度。<br>反之，对于原始数据类型，例如 int，也成立。 </p>
<p>例如，你可能创建一个如下的 String 对象： </p>
<pre><code>private static final String x = &quot;example&quot;; 
</code></pre><p>对于这个静态常量（由 final 关键字标识），你使用常量的每个时候都会创建一个临时的 String 对象。<br>在字节代码中，编译器去掉 ”x”，代替它的是字符串 “example”, 以致每次引用 ”x” 时 VM 都会进行一次哈希表查询。 </p>
<p>相比之下，度于静态变量 ( 非 final 关键字 )，字符串只创建一次。<br>仅当初始化 “x” 时， VM 才进行哈希表查询。 </p>
<h2 id="还有另一个解释"><a href="#还有另一个解释" class="headerlink" title="还有另一个解释 :"></a>还有另一个解释 :</h2><p><strong>带有 final 修饰符的类是不可派生的</strong>。<br>在 java 核心 API 中，有许多应用 final 的例子，例如 java.lang.String。<br>为 String 类指定 final 防止了人们覆盖 length() 方法。 </p>
<p>另外，如果指定一个类为 final，则该类所有的方法都是 final。<br>java 编译器会寻找机会内联（inline）所有的 final 方法（这和具体的编译器实现有关）。<br>此举能够使性能平均提高 50%。 </p>
<p>示例： </p>
<pre><code>public class Test { 
    public static void main(String[] args)  { 
        //  
    } 
} 
</code></pre><p>如果 String 不是 final 那么就可以继承 </p>
<pre><code>public class String2 extends String{ 
   //.. 
   //... 
} 
</code></pre><p>那我们的 main 也就可以写成 </p>
<pre><code>public class Test { 
    public static void main(String2[] args)  { // 注意此处 
        //  
    } 
} 
</code></pre><p>英文参考： <a href="http://forums.sun.com/thread.jspa?threadID=636414" target="_blank" rel="external">http://forums.sun.com/thread.jspa?threadID=636414</a></p>
<h3 id="另外补充一点："><a href="#另外补充一点：" class="headerlink" title="另外补充一点："></a>另外补充一点：</h3><p>作用就是 final的类不能被继承，不能让别人继承有什么好处? </p>
<p>意义就在于，安全性，如此这般：</p>
<p>java 自出生那天起就是“为人民服务”，这也就是为什么java做不了病毒，也不一定非得是病毒，反正总之就是为了安全，<br>人家java的开发者目的就是不想让 java干这类危险的事儿，java并不是操作系统本地语言，<br>换句话说java必须借助操作系统本身的力量才能做事，JDK中提供的好多核心类比如 String，这类的类的内部好多方法的实现都不是java编程语言本身编写的，<br>好多方法都是调用的操作系统本地的API，这就是著名的“本地方法调用”，也只有这样才能做事，这种类是非常底层的，<br>和操作系统交流频繁的，那么如果这种类可以被继承的话，如果我们再把它的方法重写了，往操作系统内部写入一段具有恶意攻击性质的代码什么的，<br>这不就成了核心病毒了么？ </p>
<p>上面所述是最重要的，另外一个方面，上面2位老兄说的也都很对，<br>就是不希望别人改，这个类就像一个工具一样，类的提供者给我们提供了，<br>就希望我们直接用就完了，不想让我们随便能改，其实说白了还是安全性，<br>如果随便能改了，那么java编写的程序肯定就很不稳定，你可以保证自己不乱改，<br>但是将来一个项目好多人来做，管不了别人，再说有时候万一疏忽了呢？他也不是估计的，<br>所以这个安全性是很重要的，java和C++相比，优点之一就包括这一点；</p>
<p>原因绝对不只有这么多，因为如果这些个核心的类都能被随便操作的话，那是很恐怖的，会出现好多好多未知的错误，莫名其妙的错误…. </p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[处理并发之二：libevent的eventbuffer]]></title>
      <url>http://www.ezlippi.com/blog/2014/08/libevent.html</url>
      <content type="html"><![CDATA[<p> bufferevent这个结构体</p>
<pre><code>struct bufferevent {
    struct event_base *ev_base;  
    const struct bufferevent_ops *be_ops;  
    struct event ev_read;  
    struct event ev_write;  
    struct evbuffer *input;  
    struct evbuffer *output;                                                                                  
    bufferevent_data_cb readcb;                                                                                                                 bufferevent_data_cb writecb;                                                                                         bufferevent_event_cb errorcb;  
    }  
</code></pre><a id="more"></a>
<p>可以看出struct bufferevent内置了两个event（读/写）和对应的缓冲区。当有数据被读入(input)的时候，readcb被调用，当output被输出完成的时候，writecb被调用，当网络I/O出现错误，如链接中断，超时或其他错误时，errorcb被调用。<br>使用bufferevent的过程：</p>
<p><strong>1. 设置sock为非阻塞的</strong></p>
<pre><code>eg:  evutil_make_socket_nonblocking(fd);  
</code></pre><p><strong>2. 使用bufferevent_socket_new创建一个structbufferevent *bev，关联该sockfd，托管给event_base</strong></p>
<p>函数原型为：</p>
<blockquote>
<p>   struct bufferevent <em> bufferevent_socket_new(struct event_base
</em>base, evutil_socket_t fd,  int options)<br>            eg:  struct bufferevent *bev;<br>            bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);</p>
</blockquote>
<p><strong>3. 设置读写对应的回调函数</strong></p>
<p>函数原型为：</p>
<blockquote>
<p>void bufferevent_setcb(struct bufferevent <em>bufev,<br>bufferevent_data_cb readcb, bufferevent_data_cb writecb,<br>bufferevent_event_cb eventcb, void </em>cbarg)   eg.<br>bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);</p>
</blockquote>
<p><strong>4. 启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的</strong></p>
<p>函数原型：</p>
<blockquote>
<pre><code>int bufferevent_enable(struct bufferevent *bufev, short event)       eg.
</code></pre><p>bufferevent_enable(bev, EV_READ|EV_WRITE);</p>
</blockquote>
<p><strong>5. 进入bufferevent_setcb回调函数：</strong></p>
<p> 在readcb里面从input中读取数据，处理完毕后填充到output中；     writecb对于服务端程序，只需要readcb就可以了，可以置为NULL；     errorcb用于处理一些错误信息。</p>
<p>针对这些使用过程进入源码进行分析：</p>
<p><strong>1. bufferevent_socket_new</strong>     </p>
<ul>
<li>在bufferevent_init_common中调用evbuffer_new()初始化input和output</li>
<li>在event_assign中初始化bufferevent中的ev_read和ev_write事件。</li>
<li>在evbuffer_add_cb中给output添加了一个callback bufferevent_socket_outbuf_cb</li>
</ul>
<p><strong>2. bufferevent_setcb</strong></p>
<pre><code>该函数的作用主要是赋值，把该函数后面的参数，赋值给第一个参数struct bufferevent *bufev定义的变量
</code></pre><p><strong>3. bufferevent_enable</strong></p>
<p>调用event_add将读写事件加入到事件监听队列中。</p>
<p>对bufferevent常用的几个函数进行分析：</p>
<blockquote>
<pre><code>char *evbuffer_readln(struct evbuffer*buffer, size_t *n_read_out,enum
</code></pre><p>evbuffer_eol_style eol_style);</p>
</blockquote>
<p>含义：Read a single line from an evbuffer.<br>    返回值：读到的一行内容</p>
<blockquote>
<p>int evbuffer_add(struct evbuffer <em>buf,const void </em>data, size_t<br>datlen);</p>
</blockquote>
<pre><code>含义：将数据添加到evbuffer的结尾
返回值：成功返回0，失败返回-1
</code></pre><blockquote>
<p>int evbuffer_remove(struct evbuffer<em>buf, void </em>data, size_t datlen);</p>
</blockquote>
<p>含义：从evbuffer读取数据到data<br>返回值：成功返回0，失败返回-1</p>
<blockquote>
<p>size_t evbuffer_get_length(const structevbuffer *buf);</p>
</blockquote>
<p>含义：返回evbuffer中存储的字节长度<br>    暂时先分析到这里，下面是代码，客户端发送消息：HTTP/1.0, Client 0 send Message:<br>    Request: Hello Server! over，服务端一条消息收完成后，会回复：Response ok! Hello Client!<br>    服务端从bufferevent中取出消息是按行取的。代码可能有不完善的地方，由于才疏学浅，研究时间短（3天），希望高手提出宝贵意见。</p>
<p>buffer_server.c</p>
<pre><code>#include &lt;netinet/in.h&gt;  
#include &lt;sys/socket.h&gt;  
#include &lt;fcntl.h&gt;             
#include &lt;event2/event.h&gt;  
#include &lt;event2/buffer.h&gt;  
#include &lt;event2/bufferevent.h&gt;                
#include &lt;assert.h&gt;  
#include &lt;unistd.h&gt;  
#include &lt;string.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;errno.h&gt;  
   void do_read(evutil_socket_t fd, short events, void *arg);  
   //struct bufferevent内建了两个event(read/write)和对应的缓冲区(struct evbuffer *input, *output)，并提供相应的函数用来操作缓冲区(或者直接操作bufferevent)   

   //接收到数据后，判断是不一样一条消息的结束，结束标志为&quot;over&quot;字符

void readcb(struct bufferevent *bev, void *ctx)  
{     
    printf(&quot;called readcb!\n&quot;);           
    struct evbuffer *input, *output;  
    char *request_line;  
    size_t len;  
    //其实就是取出bufferevent中的input  
    input = bufferevent_get_input(bev);
    //其实就是取出bufferevent中的output 
    output = bufferevent_get_output(bev);                          
    size_t input_len = evbuffer_get_length(input);                                      
    printf(&quot;input_len: %d\n&quot;, input_len);  
    size_t output_len = evbuffer_get_length(output);                                             
    printf(&quot;output_len: %d\n&quot;, output_len);                                                                                               
    while(1){                                                                                                                            
        //从evbuffer前面取出一行，用一个新分配的空字符结束        
        //的字符串返回这一行,EVBUFFER_EOL_CRLF表示行尾是一个可选的回车，后随一个换行符
        request_line = evbuffer_readln(input, &amp;len, EVBUFFER_EOL_CRLF);
        if(NULL == request_line){         
            printf(&quot;The first line has not arrived yet.\n&quot;);                                                                                                                     
            free(request_line);//之所以要进行free是因为 line = mm_malloc(n_to_copy+1))，在这里进行了malloc                                                                                                                      
            break;                                                                                                                                        
        } else {                                                                                                                                                                     
                printf(&quot;Get one line date: %s\n&quot;, request_line);                                                                                          
                //用于判断是不是一条消息的结束                                                                                                                       
                if(strstr(request_line, &quot;over&quot;) != NULL)                    {                                                                                                                                                                                                                                                         
                    char *response = &quot;Response ok! Hello Client!\r\n&quot;;                                                                                                                                                                   
                    //Adds data to an event buffer  
                    evbuffer_add(output, response, strlen(response));

                    printf(&quot;服务端接收一条数据完成，回复客户端一条消息: %s\n&quot;, response);                                                                                                                                                                                                 
                    free(request_line);                                                                                                                                                                                             
                    break;                                                                                                                                                                                                                       
                    }                                                                                                                 
                }                                                                            
        free(request_line);                                                                               
        }                                                   
        size_t input_len1 = evbuffer_get_length(input);                                                         
        printf(&quot;input_len1: %d\n&quot;, input_len1);                                                             
        size_t output_len1 = evbuffer_get_length(output);                                                                  
        printf(&quot;output_len1: %d\n\n&quot;, output_len1);  
}         

void errorcb(struct bufferevent *bev, short error, void *ctx)  
{  
    if (error &amp; BEV_EVENT_EOF) { 
        /* connection has been closed, do any clean up here */        
        printf(&quot;connection closed\n&quot;);  
        }else if (error &amp; BEV_EVENT_ERROR){                        
            /* check errno to see what error occurred */  
            printf(&quot;some other error\n&quot;);  
            } else if (error &amp; BEV_EVENT_TIMEOUT) 
                /* must be a timeout event handle, handle it */  
                printf(&quot;Timed out\n&quot;);  
                  }  
    bufferevent_free(bev);   
}

void do_accept(evutil_socket_t listener, short event, void *arg)  
{
    struct event_base *base = arg;  
    struct sockaddr_storage ss;  
    socklen_t slen = sizeof(ss);  
    int fd = accept(listener, (struct sockaddr*)&amp;ss, &amp;slen);  
    if (fd &lt; 0){
        perror(&quot;accept&quot;);  
    }else if (fd &gt; FD_SETSIZE){  
        close(fd);  
     }else {
         struct bufferevent *bev;
         evutil_make_socket_nonblocking(fd);                                                                                                                           
         //使用bufferevent_socket_new创建一个struct bufferevent*bev，
         //关联该sockfd，托管给event_base                                                               
         //BEV_OPT_CLOSE_ON_FREE表示释放bufferevent时关闭底层传输端口。
         //这将关闭底层套接字，释放底层bufferevent等。                                                                   
         bev = bufferevent_socket_new(base, fd, BEV_OPT_CLOSE_ON_FREE);                                                                                                                                       
         //设置读写对应的回调函数  
         bufferevent_setcb(bev, readcb, NULL, errorcb, NULL);  
         bufferevent_setwatermark(bev, EV_READ, 0, MAX_LINE);                                                                                                                                                      
         //启用读写事件,其实是调用了event_add将相应读写事件加入事件监听队列poll。
         //正如文档所说，如果相应事件不置为true，bufferevent是不会读写数据的                                                                                       
         bufferevent_enable(bev, EV_READ|EV_WRITE);                                                                          
     }  
}     

void run(void){      
    evutil_socket_t listener;           
    struct sockaddr_in sin;  
    struct event_base *base;  
    struct event *listener_event;                
    base = event_base_new();  
    if (!base)  
    return; 
     sin.sin_family = AF_INET;  
     sin.sin_addr.s_addr = 0;              
     sin.sin_port = htons(8000);                                                                       
     listener = socket(AF_INET, SOCK_STREAM, 0);  
     evutil_make_socket_nonblocking(listener);          

    #ifndef WIN32{                    


int one = 1;                                                                        
setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, 
&amp;one, sizeof(one));  
}    
#endif  
if(bind(listener, (struct sockaddr*)&amp;sin, sizeof(sin)) &lt; 0){                                                                                                                                        
    perror(&quot;bind&quot;);                                                                                   
    return;                                                                                      
}                                                          
if (listen(listener, 16)&lt;0){                                                                                                                                             
    perror(&quot;listen&quot;);                                                                                                                                                  
    return;     
}                                            

listener_event = event_new(base, listener, EV_READ|EV_PERSIST, do_accept, (void*)base);
event_add(listener_event, NULL);                                                                                                                                                                  
event_base_dispatch(base);  
}  
int main(int argc, char **argv){          
    setvbuf(stdout, NULL, _IONBF, 0);       
    run();  
    return 0; 
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[处理并发之一：LINUX Epoll机制介绍]]></title>
      <url>http://www.ezlippi.com/blog/2014/08/linux-epoll.html</url>
      <content type="html"><![CDATA[<p>Epoll可是当前在Linux下开发大规模并发网络程序的热门人选，Epoll 在Linux2.6内核中正式引入，和select相似，其实都I/O多路复用技术而已，并没有什么神秘的。</p>
<p>其实在Linux下设计并发网络程序，向来不缺少方法，比如典型的Apache模型（Process Per Connection，简称PPC），TPC（Thread Per Connection）模型，以及select模型和poll模型，那为何还要再引入Epoll这个东东呢？那还是有得说说的…<br><a id="more"></a></p>
<h2 id="2-常用模型的缺点"><a href="#2-常用模型的缺点" class="headerlink" title="2. 常用模型的缺点"></a>2. 常用模型的缺点</h2><p>如果不摆出来其他模型的缺点，怎么能对比出Epoll的优点呢。</p>
<h3 id="2-1-PPC-TPC模型"><a href="#2-1-PPC-TPC模型" class="headerlink" title="2.1 PPC/TPC模型"></a>2.1 PPC/TPC模型</h3><p>这两种模型思想类似，就是让每一个到来的连接一边自己做事去，别再来烦我。只是PPC是为它开了一个进程，而TPC开了一个线程。可是别烦我是有代价的，它要时间和空间啊，连接多了之后，那么多的进程/线程切换，这开销就上来了；因此这类模型能接受的最大连接数都不会高，一般在几百个左右。</p>
<h3 id="2-2-select模型"><a href="#2-2-select模型" class="headerlink" title="2.2 select模型"></a>2.2 select模型</h3><ol>
<li><p>最大并发数限制，因为一个进程所打开的FD（文件描述符）是有限制的，由FD_SETSIZE设置，默认值是1024/2048，因此Select模型的最大并发数就被相应限制了。自己改改这个FD_SETSIZE？想法虽好，可是先看看下面吧…</p>
</li>
<li><p>效率问题，select每次调用都会线性扫描全部的FD集合，这样效率就会呈现线性下降，把FD_SETSIZE改大的后果就是，大家都慢慢来，什么？都超时了？？！！</p>
</li>
<li><p>内核/用户空间 内存拷贝问题，如何让内核把FD消息通知给用户空间呢？在这个问题上select采取了内存拷贝方法。</p>
</li>
</ol>
<h3 id="2-3-poll模型"><a href="#2-3-poll模型" class="headerlink" title="2.3 poll模型"></a>2.3 poll模型</h3><p>基本上效率和select是相同的，select缺点的2和3它都没有改掉。</p>
<h2 id="3-Epoll的提升"><a href="#3-Epoll的提升" class="headerlink" title="3.Epoll的提升"></a>3.Epoll的提升</h2><p>把其他模型逐个批判了一下，再来看看Epoll的改进之处吧，其实把select的缺点反过来那就是Epoll的优点了。</p>
<p>3.1. Epoll没有最大并发连接的限制，上限是最大可以打开文件的数目，这个数字一般远大于2048, 一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。</p>
<p>3.2. 效率提升，Epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll。</p>
<p>3.3. 内存拷贝，Epoll在这点上使用了“共享内存”，这个内存拷贝也省略了。</p>
<h2 id="4-Epoll为什么高效"><a href="#4-Epoll为什么高效" class="headerlink" title="4. Epoll为什么高效"></a>4. Epoll为什么高效</h2><p>Epoll的高效和其数据结构的设计是密不可分的，这个下面就会提到。</p>
<p>首先回忆一下select模型，当有I/O事件到来时，select通知应用程序有事件到了快去处理，而应用程序必须轮询所有的FD集合，测试每个FD是否有事件发生，并处理事件；代码像下面这样：</p>
<pre><code>int res = select(maxfd+1, &amp;readfds, NULL, NULL, 120);
if(res &gt; 0)

{
    for(int i = 0; i &lt; MAX_CONNECTION; i++)
    {
        if(FD_ISSET(allConnection[i],&amp;readfds))
        {
            handleEvent(allConnection[i]);
        }
    }
}
// if(res == 0) handle timeout, res &lt; 0 handle error
</code></pre><p>Epoll不仅会告诉应用程序有I/0事件到来，还会告诉应用程序相关的信息，这些信息是应用程序填充的，因此根据这些信息应用程序就能直接定位到事件，而不必遍历整个FD集合。</p>
<pre><code>intres = epoll_wait(epfd, events, 20, 120);

for(int i = 0; i &lt; res;i++)
{
    handleEvent(events[n]);
}
</code></pre><h2 id="5-Epoll关键数据结构"><a href="#5-Epoll关键数据结构" class="headerlink" title="5. Epoll关键数据结构"></a>5. Epoll关键数据结构</h2><p>前面提到Epoll速度快和其数据结构密不可分，其关键数据结构就是：</p>
<pre><code>struct epoll_event {

    __uint32_t events;      // Epoll events

    epoll_data_t data;      // User datavariable

};

typedef union epoll_data {

    void *ptr;

   int fd;

    __uint32_t u32;

    __uint64_t u64;

} epoll_data_t;
</code></pre><p>结构体epoll_event 被用于注册所感兴趣的事件和回传所发生待处理的事件.<br>其中epoll_data 联合体用来保存触发事件的某个文件描述符相关的数据.<br>例如一个client连接到服务器，服务器通过调用accept函数可以得到于这个client对应的socket文件描述符，可以把这文件描述符赋给epoll_data的fd字段以便后面的读写操作在这个文件描述符上进行。epoll_event 结构体的events字段是表示感兴趣的事件和被触发的事件可能的取值为： </p>
<ul>
<li>EPOLLIN ：表示对应的文件描述符可以读；</li>
<li>EPOLLOUT：表示对应的文件描述符可以写；</li>
<li>EPOLLPRI：表示对应的文件描述符有紧急的数据可读</li>
<li>EPOLLERR：表示对应的文件描述符发生错误；</li>
<li>EPOLLHUP：表示对应的文件描述符被挂断；</li>
<li>EPOLLET：表示对应的文件描述符有事件发生；</li>
</ul>
<p><strong>ET和LT模式</strong><br>LT(level triggered)是缺省的工作方式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的，所以，这种模式编程出错误可能性要小一点。传统的select/poll都是这种模型的代表。</p>
<p>ET (edge-triggered)是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了（比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作（从而导致它再次变成未就绪），内核不会发送更多的通知(only once)，不过在TCP协议中，ET模式的加速效用仍需要更多的benchmark确认。<br>ET和LT的区别在于LT事件不会丢弃，而是只要读buffer里面有数据可以让用户读，则不断的通知你。而ET则只在事件发生之时通知。可以简单理解为LT是水平触发，而ET则为边缘触发。<br>ET模式仅当状态发生变化的时候才获得通知,这里所谓的状态的变化并不包括缓冲区中还有未处理的数据,也就是说,如果要采用ET模式,需要一直read/write直到出错为止,很多人反映为什么采用ET模式只接收了一部分数据就再也得不到通知了,大多因为这样;而LT模式是只要有数据没有处理就会一直通知下去的.</p>
<h2 id="6-使用Epoll"><a href="#6-使用Epoll" class="headerlink" title="6. 使用Epoll"></a>6. 使用Epoll</h2><p>既然Epoll相比select这么好，那么用起来如何呢？会不会很繁琐啊…先看看下面的三个函数吧，就知道Epoll的易用了。</p>
<pre><code>int epoll_create(int size);
</code></pre><p>生成一个Epoll专用的文件描述符，其实是申请一个内核空间，用来存放你想关注的socket fd上是否发生以及发生了什么事件。size就是你在这个Epoll fd上能关注的最大socket fd数，大小自定，只要内存足够。</p>
<pre><code>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
</code></pre><p>epoll的事件注册函数，它不同与select()是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型。第一个参数是epoll_create()的返回值，第二个参数表示动作，用三个宏来表示：</p>
<ul>
<li>EPOLL_CTL_ADD：注册新的fd到epfd中；</li>
<li>EPOLL_CTL_MOD：修改已经注册的fd的监听事件；</li>
<li>EPOLL_CTL_DEL：从epfd中删除一个fd；</li>
</ul>
<p>第三个参数是需要监听的fd，第四个参数是告诉内核需要监听什么事</p>
<pre><code>int epoll_wait(int epfd,struct epoll_event * events,int maxevents,int timeout);
</code></pre><p>等待I/O事件的发生；参数说明：</p>
<ul>
<li>epfd:由epoll_create() 生成的Epoll专用的文件描述符；</li>
<li>epoll_event:用于回传代处理事件的数组；</li>
<li>maxevents:每次能处理的事件数；</li>
<li>timeout:等待I/O事件发生的超时值；</li>
<li>返回发生事件数。</li>
</ul>
<hr>
<hr>
<h2 id="测试程序"><a href="#测试程序" class="headerlink" title="测试程序"></a>测试程序</h2><p>首先对服务端和客户端做下说明：<br>我想实现的是客户端和服务端并发的程序，客户端通过配置并发数，说明有多少个用户去连接服务端。<br>客户端会发送消息：”Client: i send message Hello Server!”，其中i表示哪一个客户端；收到消息：”Recv Server Msg Content:%s\n”。<br>例如：<br>发送：Client: 1 send message “Hello Server!”<br>接收：Recv Derver Msg Content:Hello, client fd: 6<br>服务端收到后给客户端回复消息：”Hello, client fd: i”，其中i表示服务端接收的fd,用户区别是哪一个客户端。接收客户端消息：”Terminal Received Msg Content:%s\n”<br>例如：<br>发送：Hello, client fd: 6<br>接收：Terminal Received Msg Content:Client: 1 send message “Hello Server!”<br>备注：这里在接收到消息后，直接打印出消息，如果需要对消息进行处理（如果消息处理比较占用时间，不能立即返回，可以将该消息放入一个队列中，然后开启一个线程从队列中取消息进行处理，这样的话不会因为消息处理而阻塞epoll）。libenent好像对这种有2中处理方式，一个就是回调，要求回调函数，不占用太多的时间，基本能立即返回，另一种好像也是一个队列实现的，这个还需要研究。<br>服务端代码说明：<br>服务端在绑定监听后，开启了一个线程，用于负责接收客户端连接，加入到epoll中，这样只要accept到客户端的连接，就将其add EPOLLIN到epoll中，然后进入循环调用epoll_wait，监听到读事件，接收数据，并将事件修改为EPOLLOUT；反之监听到写事件，发送数据，并将事件修改为EPOLLIN。<br><strong>服务器代码：</strong></p>
<pre><code>//cepollserver.h  
#ifndef  C_EPOLL_SERVER_H  
#define  C_EPOLL_SERVER_H  

#include &lt;sys/epoll.h&gt;  
#include &lt;sys/socket.h&gt;  
#include &lt;netinet/in.h&gt;  
#include &lt;fcntl.h&gt;  
#include &lt;arpa/inet.h&gt;  
#include &lt;stdio.h&gt;  
#include &lt;stdlib.h&gt;  
#include &lt;iostream&gt;  
#include &lt;pthread.h&gt;  

#define _MAX_SOCKFD_COUNT 65535  

class CEpollServer  
{  
        public:  
                CEpollServer();  
                ~CEpollServer();  

                bool InitServer(const char* chIp, int iPort);  
                void Listen();  
                static void ListenThread( void* lpVoid );  
                void Run();  

        private:  
                int        m_iEpollFd;  
                int        m_isock;  
                pthread_t       m_ListenThreadId;// 监听线程句柄  

};  

#endif  

   #include &quot;cepollserver.h&quot;  

using namespace std;  

CEpollServer::CEpollServer()  
{  
}  

CEpollServer::~CEpollServer()  
{  
    close(m_isock);  
}  

bool CEpollServer::InitServer(const char* pIp, int iPort)  
{  
    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  

    //设置非阻塞模式  
    int opts = O_NONBLOCK;  
    if(fcntl(m_iEpollFd,F_SETFL,opts)&lt;0)  
    {  
        printf(&quot;设置非阻塞模式失败!\n&quot;);  
        return false;  
    }  

    m_isock = socket(AF_INET,SOCK_STREAM,0);  
    if ( 0 &gt; m_isock )  
    {  
        printf(&quot;socket error!\n&quot;);  
        return false;  
　　}  
　　  
　　sockaddr_in listen_addr;  
　　    listen_addr.sin_family=AF_INET;  
　　    listen_addr.sin_port=htons ( iPort );  
　　    listen_addr.sin_addr.s_addr=htonl(INADDR_ANY);  
　　    listen_addr.sin_addr.s_addr=inet_addr(pIp);  
　　  
　　    int ireuseadd_on = 1;//支持端口复用  
　　    setsockopt(m_isock, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, sizeof(ireuseadd_on) );  
　　  
　　    if ( bind ( m_isock, ( sockaddr * ) &amp;listen_addr,sizeof ( listen_addr ) ) !=0 )  
　　    {  
　　        printf(&quot;bind error\n&quot;);  
　　        return false;  
　　    }  
　　  
　　    if ( listen ( m_isock, 20) &lt;0 )  
　　    {  
　　        printf(&quot;listen error!\n&quot;);  
　　        return false;  
　　    }  
　　    else  
　　    {  
　　        printf(&quot;服务端监听中...\n&quot;);  
　　    }  
　　  
　　    // 监听线程，此线程负责接收客户端连接，加入到epoll中  
　　    if ( pthread_create( &amp;m_ListenThreadId, 0, ( void * ( * ) ( void * ) ) ListenThread, this ) != 0 )  
　　    {  
　　        printf(&quot;Server 监听线程创建失败!!!&quot;);  
　　        return false;  
　　    }  
　　}  
　　// 监听线程  
　　void CEpollServer::ListenThread( void* lpVoid )  
　　{  
　　    CEpollServer *pTerminalServer = (CEpollServer*)lpVoid;  
　　    sockaddr_in remote_addr;  
　　    int len = sizeof (remote_addr);  
　　    while ( true )  
　　    {  
　　        int client_socket = accept (pTerminalServer-&gt;m_isock, ( sockaddr * ) &amp;remote_addr,(socklen_t*)&amp;len );  
　　        if ( client_socket &lt; 0 )  
　　        {  
　　            printf(&quot;Server Accept失败!, client_socket: %d\n&quot;, client_socket);  
　　            continue;  
　　        }  
　　        else  
　　        {  
　　            struct epoll_event    ev;  
　　            ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  
　　            ev.data.fd = client_socket;     //记录socket句柄  
　　            epoll_ctl(pTerminalServer-&gt;m_iEpollFd, EPOLL_CTL_ADD, client_socket, &amp;ev);  
　　        }  
　　    }  
　　}  
　　  
　　void CEpollServer::Run()  
　　{  
　　    while ( true )  
　　    {  
　　        struct epoll_event    events[_MAX_SOCKFD_COUNT];  
　　        int nfds = epoll_wait( m_iEpollFd, events,  _MAX_SOCKFD_COUNT, -1 );  
　　        for (int i = 0; i &lt; nfds; i++)  
　　        {  
　　            int client_socket = events[i].data.fd;  
　　            char buffer[1024];//每次收发的字节数小于1024字节  
　　            memset(buffer, 0, 1024);  
　　            if (events[i].events &amp; EPOLLIN)//监听到读事件，接收数据  
　　            {  
　　                int rev_size = recv(events[i].data.fd,buffer, 1024,0);  
　　                if( rev_size &lt;= 0 )  
　　                {  
　　                    cout &lt;&lt; &quot;recv error: recv size: &quot; &lt;&lt; rev_size &lt;&lt; endl;  
　　                    struct epoll_event event_del;  
　　                    event_del.data.fd = events[i].data.fd;  
　　                    event_del.events = 0;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del);  
　　                }  
　　                else  
　　                {  
　　                    printf(&quot;Terminal Received Msg Content:%s\n&quot;,buffer);  
　　                    struct epoll_event    ev;  
　　                    ev.events = EPOLLOUT | EPOLLERR | EPOLLHUP;  
　　                    ev.data.fd = client_socket;     //记录socket句柄  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev);  
　　                }  
　　            }  
　　else if(events[i].events &amp; EPOLLOUT)//监听到写事件，发送数据  
　　            {  
　　                char sendbuff[1024];  
　　                sprintf(sendbuff, &quot;Hello, client fd: %d\n&quot;, client_socket);  
　　                int sendsize = send(client_socket, sendbuff, strlen(sendbuff)+1, MSG_NOSIGNAL);  
　　                if(sendsize &lt;= 0)  
　　                {  
　　                    struct epoll_event event_del;  
　　                    event_del.data.fd = events[i].data.fd;  
　　                    event_del.events = 0;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del);  
　　                }  
　　                else  
　　                {  
　　                    printf(&quot;Server reply msg ok! buffer: %s\n&quot;, sendbuff);  
　　                    struct epoll_event    ev;  
　　                    ev.events = EPOLLIN | EPOLLERR | EPOLLHUP;  
　　                    ev.data.fd = client_socket;     //记录socket句柄  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, client_socket, &amp;ev);  
　　                }  
　　            }  
　　            else  
　　            {  
　　                cout &lt;&lt; &quot;EPOLL ERROR\n&quot; &lt;&lt;endl;  
　　                epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, events[i].data.fd, &amp;events[i]);  
　　            }  
　　        }  
　　    }  
　　}  
</code></pre><p><strong>客户端代码：</strong><br>说明：测试是两个并发进行测试，每一个客户端都是一个长连接。代码中在连接服务器（ConnectToServer）时将用户ID和socketid关联起来。用户ID和socketid是一一对应的关系。</p>
<pre><code>    #ifndef _DEFINE_EPOLLCLIENT_H_  
    #define _DEFINE_EPOLLCLIENT_H_  
    #define _MAX_SOCKFD_COUNT 65535  

    #include&lt;iostream&gt;  
    #include &lt;sys/epoll.h&gt;  
    #include &lt;sys/socket.h&gt;  
    #include &lt;netinet/in.h&gt;  
    #include &lt;fcntl.h&gt;  
    #include &lt;arpa/inet.h&gt;  
    #include &lt;errno.h&gt;  
    #include &lt;sys/ioctl.h&gt;  
    #include &lt;sys/time.h&gt;  
    #include &lt;string&gt;  

    using namespace std;  

    /** 
     * @brief 用户状态 
     */  
    typedef enum _EPOLL_USER_STATUS_EM  
    {  
            FREE = 0,  
            CONNECT_OK = 1,//连接成功  
            SEND_OK = 2,//发送成功  
            RECV_OK = 3,//接收成功  
    }EPOLL_USER_STATUS_EM;  

    /*@brief 
     *@CEpollClient class 用户状态结构体 
     */  
    struct UserStatus  
    {  
            EPOLL_USER_STATUS_EM iUserStatus;//用户状态  
            int iSockFd;//用户状态关联的socketfd  
            char cSendbuff[1024];//发送的数据内容  
            int iBuffLen;//发送数据内容的长度  
            unsigned int uEpollEvents;//Epoll events  
    };  

    class CEpollClient  
    {  
            public:  

                    /** 
                     * @brief 
                     * 函数名:CEpollClient 
                     * 描述:构造函数 
                     * @param [in] iUserCount  
                     * @param [in] pIP IP地址 
                     * @param [in] iPort 端口号 
                     * @return 无返回 
                     */  
                    CEpollClient(int iUserCount, const char* pIP, int iPort);  

    /** 
                     * @brief 
                     * 函数名:CEpollClient 
                     * 描述:析构函数 
                     * @return 无返回 
                     */  
                    ~CEpollClient();  

                    /** 
                     * @brief 
                     * 函数名:RunFun 
                     * 描述:对外提供的接口，运行epoll类 
                     * @return 无返回值 
                     */  
                    int RunFun();  

            private:  

                    /** 
                     * @brief 
                     * 函数名:ConnectToServer 
                     * 描述:连接到服务器 
                     * @param [in] iUserId 用户ID 
                     * @param [in] pServerIp 连接的服务器IP 
                     * @param [in] uServerPort 连接的服务器端口号 
                     * @return 成功返回socketfd,失败返回的socketfd为-1 
                     */  
                    int ConnectToServer(int iUserId,const char *pServerIp,unsigned short uServerPort);  

    /** 
                     * @brief 
                     * 函数名:SendToServerData 
                     * 描述:给服务器发送用户(iUserId)的数据 
                     * @param [in] iUserId 用户ID 
                     * @return 成功返回发送数据长度 
                     */  
                    int SendToServerData(int iUserId);  

                    /** 
                     * @brief 
                     * 函数名:RecvFromServer 
                     * 描述:接收用户回复消息 
                     * @param [in] iUserId 用户ID 
                     * @param [in] pRecvBuff 接收的数据内容 
                     * @param [in] iBuffLen 接收的数据长度 
                     * @return 成功返回接收的数据长度，失败返回长度为-1 
                     */  
                    int RecvFromServer(int iUserid,char *pRecvBuff,int iBuffLen);  

                    /** 
                     * @brief 
                     * 函数名:CloseUser 
                     * 描述:关闭用户 
                     * @param [in] iUserId 用户ID 
                     * @return 成功返回true 
                     */  
                    bool CloseUser(int iUserId);  

    /** 
                     * @brief 
                     * 函数名:DelEpoll 
                     * 描述:删除epoll事件 
                     * @param [in] iSockFd socket FD 
                     * @return 成功返回true 
                     */  
                    bool DelEpoll(int iSockFd);  
            private:  

                    int    m_iUserCount;//用户数量；  
                    struct UserStatus *m_pAllUserStatus;//用户状态数组  
                    int    m_iEpollFd;//需要创建epollfd  
                    int    m_iSockFd_UserId[_MAX_SOCKFD_COUNT];//将用户ID和socketid关联起来  
                    int    m_iPort;//端口号  
                    char   m_ip[100];//IP地址  
    };  

    #endif  
    #include &quot;cepollclient.h&quot;  

CEpollClient::CEpollClient(int iUserCount, const char* pIP, int iPort)  
{  
    strcpy(m_ip, pIP);  
    m_iPort = iPort;  
    m_iUserCount = iUserCount;  
    m_iEpollFd = epoll_create(_MAX_SOCKFD_COUNT);  
    m_pAllUserStatus = (struct UserStatus*)malloc(iUserCount*sizeof(struct UserStatus));  
    for(int iuserid=0; iuserid&lt;iUserCount ; iuserid++)  
    {  
        m_pAllUserStatus[iuserid].iUserStatus = FREE;  
        sprintf(m_pAllUserStatus[iuserid].cSendbuff, &quot;Client: %d send message \&quot;Hello Server!\&quot;\r\n&quot;, iuserid);  
        m_pAllUserStatus[iuserid].iBuffLen = strlen(m_pAllUserStatus[iuserid].cSendbuff) + 1;  
        m_pAllUserStatus[iuserid].iSockFd = -1;  
    }  
    memset(m_iSockFd_UserId, 0xFF, sizeof(m_iSockFd_UserId));  
}  

CEpollClient::~CEpollClient()  
{  
    free(m_pAllUserStatus);  
}  
int CEpollClient::ConnectToServer(int iUserId,const char *pServerIp,unsigned short uServerPort)  
{  
    if( (m_pAllUserStatus[iUserId].iSockFd = socket(AF_INET,SOCK_STREAM,0) ) &lt; 0 )  
    {  
        cout &lt;&lt;&quot;[CEpollClient error]: init socket fail, reason is:&quot;&lt;&lt;strerror(errno)&lt;&lt;&quot;,errno is:&quot;&lt;&lt;errno&lt;&lt;endl;  
        m_pAllUserStatus[iUserId].iSockFd = -1;  
        return  m_pAllUserStatus[iUserId].iSockFd;  
    }  

    struct sockaddr_in addr;  
    bzero(&amp;addr, sizeof(addr));  
    addr.sin_family = AF_INET;  
    addr.sin_port = htons(uServerPort);  
    addr.sin_addr.s_addr = inet_addr(pServerIp);  

    int ireuseadd_on = 1;//支持端口复用  
    setsockopt(m_pAllUserStatus[iUserId].iSockFd, SOL_SOCKET, SO_REUSEADDR, &amp;ireuseadd_on, sizeof(ireuseadd_on));  

    unsigned long ul = 1;  
    ioctl(m_pAllUserStatus[iUserId].iSockFd, FIONBIO, &amp;ul); //设置为非阻塞模式  

    connect(m_pAllUserStatus[iUserId].iSockFd, (const sockaddr*)&amp;addr, sizeof(addr));  
    m_pAllUserStatus[iUserId].iUserStatus = CONNECT_OK;  
    m_pAllUserStatus[iUserId].iSockFd = m_pAllUserStatus[iUserId].iSockFd;  

    return m_pAllUserStatus[iUserId].iSockFd;  
}  
int CEpollClient::SendToServerData(int iUserId)  
{  
    sleep(1);//此处控制发送频率，避免狂打日志，正常使用中需要去掉  
    int isendsize = -1;  
    if( CONNECT_OK == m_pAllUserStatus[iUserId].iUserStatus || RECV_OK == m_pAllUserStatus[iUserId].iUserStatus)  
    {  
        isendsize = send(m_pAllUserStatus[iUserId].iSockFd, m_pAllUserStatus[iUserId].cSendbuff, m_pAllUserStatus[iUserId  
].iBuffLen, MSG_NOSIGNAL);  
        if(isendsize &lt; 0)  
        {  
            cout &lt;&lt;&quot;[CEpollClient error]: SendToServerData, send fail, reason is:&quot;&lt;&lt;strerror(errno)&lt;&lt;&quot;,errno is:&quot;&lt;&lt;errno&lt;  
&lt;endl;  
        }  
        else  
        {  
            printf(&quot;[CEpollClient info]: iUserId: %d Send Msg Content:%s\n&quot;, iUserId, m_pAllUserStatus[iUserId].cSendbuff  
);  
            m_pAllUserStatus[iUserId].iUserStatus = SEND_OK;  
        }  
    }  
    return isendsize;  
}  
int CEpollClient::RecvFromServer(int iUserId,char *pRecvBuff,int iBuffLen)  
{  
    int irecvsize = -1;  
    if(SEND_OK == m_pAllUserStatus[iUserId].iUserStatus)  
    {  
        irecvsize = recv(m_pAllUserStatus[iUserId].iSockFd, pRecvBuff, iBuffLen, 0);  
        if(0 &gt; irecvsize)  
        {  
            cout &lt;&lt;&quot;[CEpollClient error]: iUserId: &quot; &lt;&lt; iUserId &lt;&lt; &quot;RecvFromServer, recv fail, reason is:&quot;&lt;&lt;strerror(errn  
o)&lt;&lt;&quot;,errno is:&quot;&lt;&lt;errno&lt;&lt;endl;  
        }  
        else if(0 == irecvsize)  
        {  
            cout &lt;&lt;&quot;[warning:] iUserId: &quot;&lt;&lt; iUserId &lt;&lt; &quot;RecvFromServer, STB收到数据为0，表示对方断开连接,irecvsize:&quot;&lt;&lt;ire  
cvsize&lt;&lt;&quot;,iSockFd:&quot;&lt;&lt; m_pAllUserStatus[iUserId].iSockFd &lt;&lt; endl;  
        }  
        else  
        {  
            printf(&quot;Recv Server Msg Content:%s\n&quot;, pRecvBuff);  
            m_pAllUserStatus[iUserId].iUserStatus = RECV_OK;  
        }  
    }  
    return irecvsize;  
}  

bool CEpollClient::CloseUser(int iUserId)  
{  
    close(m_pAllUserStatus[iUserId].iSockFd);  
    m_pAllUserStatus[iUserId].iUserStatus = FREE;  
    m_pAllUserStatus[iUserId].iSockFd = -1;  
    return true;  
}  

int CEpollClient::RunFun()  
{  
    int isocketfd = -1;  
    for(int iuserid=0; iuserid&lt;m_iUserCount; iuserid++)  
    {  
        struct epoll_event event;  
        isocketfd = ConnectToServer(iuserid, m_ip, m_iPort);  
        if(isocketfd &lt; 0)  
            cout &lt;&lt;&quot;[CEpollClient error]: RunFun, connect fail&quot; &lt;&lt;endl;  
        m_iSockFd_UserId[isocketfd] = iuserid;//将用户ID和socketid关联起来  

        event.data.fd = isocketfd;  
        event.events = EPOLLIN|EPOLLOUT|EPOLLERR|EPOLLHUP;  

        m_pAllUserStatus[iuserid].uEpollEvents = event.events;  
        epoll_ctl(m_iEpollFd, EPOLL_CTL_ADD, event.data.fd, &amp;event);  
　　}  
　　while(1)  
　　    {  
　　        struct epoll_event events[_MAX_SOCKFD_COUNT];  
　　        char buffer[1024];  
　　        memset(buffer,0,1024);  
　　        int nfds = epoll_wait(m_iEpollFd, events, _MAX_SOCKFD_COUNT, 100 );//等待epoll事件的产生  
　　        for (int ifd=0; ifd&lt;nfds; ifd++)//处理所发生的所有事件  
　　        {  
　　            struct epoll_event event_nfds;  
　　            int iclientsockfd = events[ifd].data.fd;  
　　            cout &lt;&lt; &quot;events[ifd].data.fd: &quot; &lt;&lt; events[ifd].data.fd &lt;&lt; endl;  
　　            int iuserid = m_iSockFd_UserId[iclientsockfd];//根据socketfd得到用户ID  
　　            if( events[ifd].events &amp; EPOLLOUT )  
　　            {  
　　                int iret = SendToServerData(iuserid);  
　　                if( 0 &lt; iret )  
　　                {  
　　                    event_nfds.events = EPOLLIN|EPOLLERR|EPOLLHUP;  
　　                    event_nfds.data.fd = iclientsockfd;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds);  
　　                }  
　　                else  
　　                {  
　　                    cout &lt;&lt;&quot;[CEpollClient error:] EpollWait, SendToServerData fail, send iret:&quot;&lt;&lt;iret&lt;&lt;&quot;,iuserid:&quot;&lt;&lt;iuser  
　　id&lt;&lt;&quot;,fd:&quot;&lt;&lt;events[ifd].data.fd&lt;&lt;endl;  
　　                    DelEpoll(events[ifd].data.fd);  
　　                    CloseUser(iuserid);  
　　                }  
　　            }  
　　else if( events[ifd].events &amp; EPOLLIN )//监听到读事件，接收数据  
　　            {  
　　                int ilen = RecvFromServer(iuserid, buffer, 1024);  
　　                if(0 &gt; ilen)  
　　                {  
　　                    cout &lt;&lt;&quot;[CEpollClient error]: RunFun, recv fail, reason is:&quot;&lt;&lt;strerror(errno)&lt;&lt;&quot;,errno is:&quot;&lt;&lt;errno&lt;&lt;e  
　　ndl;  
　　                    DelEpoll(events[ifd].data.fd);  
　　                    CloseUser(iuserid);  
　　                }  
　　                else if(0 == ilen)  
　　                {  
　　                    cout &lt;&lt;&quot;[CEpollClient warning:] server disconnect,ilen:&quot;&lt;&lt;ilen&lt;&lt;&quot;,iuserid:&quot;&lt;&lt;iuserid&lt;&lt;&quot;,fd:&quot;&lt;&lt;events[  
　　ifd].data.fd&lt;&lt;endl;  
　　                    DelEpoll(events[ifd].data.fd);  
　　                    CloseUser(iuserid);  
　　                }  
　　                else  
　　                {  
　　                    m_iSockFd_UserId[iclientsockfd] = iuserid;//将socketfd和用户ID关联起来  
　　                    event_nfds.data.fd = iclientsockfd;  
　　                    event_nfds.events = EPOLLOUT|EPOLLERR|EPOLLHUP;  
　　                    epoll_ctl(m_iEpollFd, EPOLL_CTL_MOD, event_nfds.data.fd, &amp;event_nfds);  
　　                }  
　　            }  
　　            else  
　　            {  
　　                cout &lt;&lt;&quot;[CEpollClient error:] other epoll error&quot;&lt;&lt;endl;  
　　                DelEpoll(events[ifd].data.fd);  
　　                CloseUser(iuserid);  
　　            }  
　　        }  
　　}  
　　}  
　　  
　　bool CEpollClient::DelEpoll(int iSockFd)  
　　{  
　　    bool bret = false;  
　　    struct epoll_event event_del;  
　　    if(0 &lt; iSockFd)  
　　    {  
　　        event_del.data.fd = iSockFd;  
　　        event_del.events = 0;  
　　        if( 0 == epoll_ctl(m_iEpollFd, EPOLL_CTL_DEL, event_del.data.fd, &amp;event_del) )  
　　        {  
　　            bret = true;  
　　        }  
　　        else  
　　        {  
　　            cout &lt;&lt;&quot;[SimulateStb error:] DelEpoll,epoll_ctl error,iSockFd:&quot;&lt;&lt;iSockFd&lt;&lt;endl;  
　　        }  
　　        m_iSockFd_UserId[iSockFd] = -1;  
　　    }  
　　    else  
　　    {  
　　        bret = true;  
　　  
　　    }  
　　    return bret;  
　　}  
　　
</code></pre><p>服务器主程序：</p>
<pre><code>#include &lt;iostream&gt;  
#include &quot;cepollserver.h&quot;  

using namespace std;  

int main()  
{  
        CEpollServer  theApp;  
        theApp.InitServer(&quot;127.0.0.1&quot;, 8000);  
        theApp.Run();  

        return 0;  
}  
</code></pre><p>客户端主程序：</p>
<pre><code>    　#include &quot;cepollclient.h&quot;  

int main(int argc, char *argv[])  
{  
        CEpollClient *pCEpollClient = new CEpollClient(2, &quot;127.0.0.1&quot;, 8000);  
        if(NULL == pCEpollClient)  
        {  
                cout&lt;&lt;&quot;[epollclient error]:main init&quot;&lt;&lt;&quot;Init CEpollClient fail&quot;&lt;&lt;endl;  
        }  

        pCEpollClient-&gt;RunFun();  

        if(NULL != pCEpollClient)  
        {  
                delete pCEpollClient;  
                pCEpollClient = NULL;  
        }  

        return 0;  
}  
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java编程的78条黄金法则]]></title>
      <url>http://www.ezlippi.com/blog/2014/08/78-golden-rules-of-the-java-programming.html</url>
      <content type="html"><![CDATA[<p>整理自网络，如果你知道原作者，请通知我。</p>
<hr>
<h2 id="创建和销毁对象"><a href="#创建和销毁对象" class="headerlink" title="创建和销毁对象"></a>创建和销毁对象</h2><p>1、考虑用静态工厂方法（返回类的实例的静态方法）代替构造器<br><br>2、遇到多个构造器参数时要考虑用构造器<br><br>3、用私有构造器或者枚举类型强化Singleton属性<br><br>4、通过私有构造器强化不可实例化的能力<br><br>5、避免创建不必要的对象<br><br>6、消除过期的对象引用<br><br>7、避免使用终结（final）方法<br><br><a id="more"></a></p>
<h2 id="对于所有对象都通用的方法"><a href="#对于所有对象都通用的方法" class="headerlink" title="对于所有对象都通用的方法"></a>对于所有对象都通用的方法</h2><p>8、覆盖equals时请遵守通用约定<br><br>9、覆盖equals时总要覆盖hashCode<br><br>10、始终要覆盖toString<br><br>11、谨慎地覆盖clone<br><br>12、考虑实现Comparable接口<br></p>
<h2 id="类和接口"><a href="#类和接口" class="headerlink" title="类和接口"></a>类和接口</h2><p>13、使类和成员的可访问性最小化<br><br>14、在公有类中使用访问方法而非公有域<br><br>15、使可变性最小化<br><br>16、复合优于继承<br><br>17、要么为继承为设计，并提供文档说明，要么就禁止继承<br><br>18、接口优于抽象类<br><br>19、接口只用于定义类型<br><br>20、类层次优于标签类<br><br>21、用函数对象表示策略<br><br>22、优先考虑静态成员类<br></p>
<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>23、不要在新代码中采用原生态类型<br><br>24、消除非受检警告<br><br>25、列表优先于数组<br><br>26、优先考虑泛型<br><br>27、优先考虑泛型方法<br><br>28、采用有限制通配符来提升API的灵活性<br><br>29、优先考虑类型安全的异构造器<br></p>
<h2 id="枚举和注解"><a href="#枚举和注解" class="headerlink" title="枚举和注解"></a>枚举和注解</h2><p>30、用enum带起int常量<br><br>31、用实例域代替序数<br><br>32、用EnumSet代替位域<br><br>33、用EnumMap代替序数索引<br><br>34、用接口模拟可伸缩的枚举<br><br>35、注解优先于命名模式<br><br>36、坚持使用Override注解<br><br>37、用标记接口定义类型<br></p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>38、检查参数的有效性<br><br>39、必要时进行保护性拷贝<br><br>40、谨慎设计方法签名<br><br>41、慎用重载<br><br>42、慎用可变参数<br><br>43、返回零长度的数组或者集合，而不是null<br><br>44、为所有导出的API元素编写文档注释<br></p>
<h2 id="通用程序设计"><a href="#通用程序设计" class="headerlink" title="通用程序设计"></a>通用程序设计</h2><p>45、将局部变量的作用域最小化<br><br>46、for-each循环优先于传统的for循环<br><br>47、了解和使用类库<br><br>48、如果需要精确的答案，请避免使用float和double<br><br>49、基本类型优先于装箱基本类型<br><br>50、如果其他类型更适合，则尽量避免使用字符串<br><br>51、当心字符串链接的性能<br><br>52、通过接口引用对象<br><br>53、接口优先于反射机制<br><br>54、谨慎使用本地方法<br><br>55、谨慎进行优化<br><br>56、遵守普遍接受的命名惯例<br></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>57、只针对异常的情况才使用异常<br><br>58、对可恢复的情况使用受检异常，对编程错误使用运行时异常<br><br>59、避免不必要地使用受检的异常<br><br>60、优先使用标准的异常<br><br>61、抛出与抽象相对应的异常<br><br>62、每个方法抛出的异常都要有文档<br><br>63、在细节消息中包含捕获失败的信息<br><br>64、努力使失败包含原子性<br><br>65、不要忽略异常<br></p>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><p>66、同步访问共享的可变数据<br><br>67、避免过度同步<br><br>68、executor和task优先于线程<br><br>69、并发工具优先于wait和notify<br><br>70、线程安全性的文档化<br><br>71、慎用延迟初始化<br><br>72、不要依赖于线程调度器<br><br>73、避免使用线程组<br></p>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>74、谨慎的实现Seriallizable接口<br><br>75、考虑使用自定义的序列化形式<br><br>76、保护性的编写readObject方法<br><br>77、对于实例控制，枚举类型优先于readResolve<br><br>78、考虑用序列化代理代替序列化实例<br></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[java并发和多线程]]></title>
      <url>http://www.ezlippi.com/blog/2014/08/java-multithread.html</url>
      <content type="html"><![CDATA[<p>注：本文的内容翻译自<a href="http://tutorials.jenkov.com/java-concurrency/deadlock.html" target="_blank" rel="external">http://tutorials.jenkov.com/java-concurrency/deadlock.html</a></p>
<p>在过去单CPU时代，单任务在一个时间点只能执行单一程序。之后发展到多任务阶段，计算机能在同一时间点并行执行多任务或多进程。虽然并不是真正意义上的“同一时间点”，而是多个任务或进程共享一个CPU，并交由操作系统来完成多任务间对CPU的运行切换，以使得每个任务都有机会获得一定的时间片运行。</p>
<p>随着多任务对软件开发者带来的新挑战，程序不在能假设独占所有的CPU时间、所有的内存和其他计算机资源。一个好的程序榜样是在其不再使用这些资源时对其进行释放，以使得其他程序能有机会使用这些资源。<br><a id="more"></a><br>再后来发展到多线程技术，使得在一个程序内部能拥有多个线程并行执行。一个线程的执行可以被认为是一个CPU在执行该程序。当一个程序运行在多线程下，就好像有多个CPU在同时执行该程序。</p>
<p>多线程比多任务更加有挑战。多线程是在同一个程序内部并行执行，因此会对相同的内存空间进行并发读写操作。这可能是在单线程程序中从来不会遇到的问题。其中的一些错误也未必会在单CPU机器上出现，因为两个线程从来不会得到真正的并行执行。然而，更现代的计算机伴随着多核CPU的出现，也就意味着不同的线程能被不同的CPU核得到真正意义的并行执行。<br>本文将会介绍java多线程编程的一些要点：</p>
<p>##如何创建并运行java线程</p>
<p>###创建Thread的子类</p>
<p>创建Thread子类的一个实例并重写run方法，run方法会在调用start()方法之后被执行。例子如下：</p>
<pre><code>public class MyThread extends Thread {
   public void run(){
     System.out.println(&quot;MyThread running&quot;);
   }
}
</code></pre><p>可以用如下方式创建并运行上述Thread子类</p>
<pre><code>MyThread myThread = new MyThread();
myTread.start();
</code></pre><p>一旦线程启动后start方法就会立即返回，而不会等待到run方法执行完毕才返回。就好像run方法是在另外一个cpu上执行一样。当run方法执行后，将会打印出字符串MyThread running。</p>
<p>你也可以如下创建一个Thread的匿名子类：</p>
<pre><code>Thread thread = new Thread(){
   public void run(){
     System.out.println(&quot;Thread Running&quot;);
   }
};
thread.start();
</code></pre><p>当新的线程的run方法执行以后，计算机将会打印出字符串”Thread Running”。</p>
<p>###实现Runnable接口</p>
<p>第二种编写线程执行代码的方式是新建一个实现了java.lang.Runnable接口的类的实例，实例中的方法可以被线程调用。下面给出例子：</p>
<pre><code>public class MyRunnable implements Runnable {
   public void run(){
    System.out.println(&quot;MyRunnable running&quot;);
   }
}
</code></pre><p>为了使线程能够执行run()方法，需要在Thread类的构造函数中传入 MyRunnable的实例对象。示例如下：</p>
<pre><code>Thread thread = new Thread(new MyRunnable());
thread.start();
</code></pre><p>当线程运行时，它将会调用实现了Runnable接口的run方法。上例中将会打印出”MyRunnable running”。</p>
<p>同样，也可以创建一个实现了Runnable接口的匿名类，如下所示：</p>
<pre><code>Runnable myRunnable = new Runnable(){
   public void run(){
     System.out.println(&quot;Runnable running&quot;);
   }
}
Thread thread = new Thread(myRunnable);
thread.start();
</code></pre><p>##java同步块<br>ava中的同步块用synchronized标记。同步块在Java中是同步在某个对象上。所有同步在一个对象上的同步块在同时只能被一个线程进入并执行操作。所有其他等待进入该同步块的线程将被阻塞，直到执行该同步块中的线程退出。</p>
<p>有四种不同的同步块：</p>
<ol>
<li>实例方法 </li>
<li>静态方法 </li>
<li>实例方法中的同步块 </li>
<li>静态方法中的同步块</li>
</ol>
<p>上述同步块都同步在不同对象上。实际需要那种同步块视具体情况而定。</p>
<p><strong>实例方法同步</strong></p>
<p>下面是一个同步的实例方法：</p>
<pre><code>public synchronized void add(int value){
this.count += value;
 }
</code></pre><p>注意在方法声明中同步（synchronized ）关键字。这告诉Java该方法是同步的。</p>
<p>Java实例方法同步是同步在拥有该方法的对象上。这样，每个实例其方法同步都同步在不同的对象上，即该方法所属的实例。只有一个线程能够在实例方法同步块中运行。如果有多个实例存在，那么一个线程一次可以在一个实例同步块中执行操作。一个实例一个线程。</p>
<p><strong>静态方法同步</strong></p>
<p>静态方法同步和实例方法同步方法一样，也使用synchronized 关键字。Java静态方法同步如下示例：</p>
<pre><code>public static synchronized void add(int value){
 count += value;
 }
</code></pre><p>同样，这里synchronized 关键字告诉Java这个方法是同步的。</p>
<p>静态方法的同步是指同步在该方法所在的类对象上。因为在Java虚拟机中一个类只能对应一个类对象，所以同时只允许一个线程执行同一个类中的静态同步方法。</p>
<p>对于不同类中的静态同步方法，一个线程可以执行每个类中的静态同步方法而无需等待。不管类中的那个静态同步方法被调用，一个类只能由一个线程同时执行。</p>
<p><strong>实例方法中的同步块</strong></p>
<p>有时你不需要同步整个方法，而是同步方法中的一部分。Java可以对方法的一部分进行同步。</p>
<p>在非同步的Java方法中的同步块的例子如下所示：</p>
<pre><code>public void add(int value){
    synchronized(this){
       this.count += value;
    }
  }
</code></pre><p>示例使用Java同步块构造器来标记一块代码是同步的。该代码在执行时和同步方法一样。</p>
<p>注意Java同步块构造器用括号将对象括起来。在上例中，使用了“this”，即为调用add方法的实例本身。在同步构造器中用括号括起来的对象叫做监视器对象。上述代码使用监视器对象同步，同步实例方法使用调用方法本身的实例作为监视器对象。</p>
<p>一次只有一个线程能够在同步于同一个监视器对象的Java方法内执行。</p>
<p>下面两个例子都同步他们所调用的实例对象上，因此他们在同步的执行效果上是等效的。</p>
<pre><code>public class MyClass {
   public synchronized void log1(String msg1, String msg2){
      log.writeln(msg1);
      log.writeln(msg2);
   }

   public void log2(String msg1, String msg2){
      synchronized(this){
         log.writeln(msg1);
         log.writeln(msg2);
      }
   }
 }
</code></pre><p>在上例中，每次只有一个线程能够在两个同步块中任意一个方法内执行。</p>
<p>如果第二个同步块不是同步在this实例对象上，那么两个方法可以被线程同时执行。</p>
<p><strong>静态方法中的同步块</strong></p>
<p>和上面类似，下面是两个静态方法同步的例子。这些方法同步在该方法所属的类对象上。</p>
<pre><code>public class MyClass {
    public static synchronized void log1(String msg1, String msg2){
       log.writeln(msg1);
       log.writeln(msg2);
    }
    public static void log2(String msg1, String msg2){
       synchronized(MyClass.class){
          log.writeln(msg1);
          log.writeln(msg2);
       }
    }
  }
</code></pre><p>这两个方法不允许同时被线程访问。</p>
<p>如果第二个同步块不是同步在MyClass.class这个对象上。那么这两个方法可以同时被线程访问。</p>
<p>##Java同步实例</p>
<p>在下面例子中，启动了两个线程，都调用Counter类同一个实例的add方法。因为同步在该方法所属的实例上，所以同时只能有一个线程访问该方法。</p>
<pre><code>public class Counter{
     long count = 0;
     public synchronized void add(long value){
       this.count += value;
     }
  }
  public class CounterThread extends Thread{

     protected Counter counter = null;

     public CounterThread(Counter counter){
        this.counter = counter;
     }

     public void run() {
    for(int i=0; i&lt;10; i++){
           counter.add(i);
        }
     }
  }
  public class Example {
    public static void main(String[] args){
      Counter counter = new Counter();
      Thread  threadA = new CounterThread(counter);
      Thread  threadB = new CounterThread(counter);
      threadA.start();
      threadB.start();
    }
  }
</code></pre><p>创建了两个线程。他们的构造器引用同一个Counter实例。Counter.add方法是同步在实例上，是因为add方法是实例方法并且被标记上synchronized关键字。因此每次只允许一个线程调用该方法。另外一个线程必须要等到第一个线程退出add()方法时，才能继续执行方法。</p>
<p>如果两个线程引用了两个不同的Counter实例，那么他们可以同时调用add()方法。这些方法调用了不同的对象，因此这些方法也就同步在不同的对象上。这些方法调用将不会被阻塞。如下面这个例子所示：</p>
<pre><code>public class Example {
   public static void main(String[] args){
     Counter counterA = new Counter();
     Counter counterB = new Counter();
     Thread  threadA = new CounterThread(counterA);
     Thread  threadB = new CounterThread(counterB);
     threadA.start();
     threadB.start();
   }
 }
</code></pre><p>注意这两个线程，threadA和threadB，不再引用同一个counter实例。CounterA和counterB的add方法同步在他们所属的对象上。调用counterA的add方法将不会阻塞调用counterB的add方法。</p>
<p>##线程间通信<br>线程通信的目标是使线程间能够互相发送信号。另一方面，线程通信使线程能够等待其他线程的信号。</p>
<p>例如，线程B可以等待线程A的一个信号，这个信号会通知线程B数据已经准备好了。本文将讲解以下几个JAVA线程间通信的主题：</p>
<p>1、通过共享对象通信<br>       2、忙等待<br>       3、wait(),notify()和notifyAll()<br>       4、丢失的信号<br>       5、假唤醒<br>       6、多线程等待相同信号<br>       7、不要对常量字符串或全局对象调用wait()</p>
<p><strong>1、通过共享对象通信</strong><br>线程间发送信号的一个简单方式是在共享对象的变量里设置信号值。线程A在一个同步块里设置boolean型成员变量hasDataToProcess为true，线程B也在同步块里读取hasDataToProcess这个成员变量。这个简单的例子使用了一个持有信号的对象，并提供了set和check方法:</p>
<pre><code>public class MySignal{

  protected boolean hasDataToProcess = false;

  public synchronized boolean hasDataToProcess(){
    return this.hasDataToProcess;
  }
  public synchronized void setHasDataToProcess(boolean hasData){
    this.hasDataToProcess = hasData;
  }
}
</code></pre><p>线程A和B必须获得指向一个MySignal共享实例的引用，以便进行通信。如果它们持有的引用指向不同的MySingal实例，那么彼此将不能检测到对方的信号。需要处理的数据可以存放在一个共享缓存区里，它和MySignal实例是分开存放的。</p>
<p><strong>2、忙等待(Busy Wait)</strong><br>准备处理数据的线程B正在等待数据变为可用。换句话说，它在等待线程A的一个信号，这个信号使hasDataToProcess()返回true。线程B运行在一个循环里，以等待这个信号：</p>
<pre><code>protected MySignal sharedSignal = ...
...
while(!sharedSignal.hasDataToProcess()){
  //do nothing... busy waiting
}
</code></pre><p><strong>3、wait(),notify()和notifyAll()</strong><br>忙等待没有对运行等待线程的CPU进行有效的利用，除非平均等待时间非常短。否则，让等待线程进入睡眠或者非运行状态更为明智，直到它接收到它等待的信号。</p>
<p>Java有一个内建的等待机制来允许线程在等待信号的时候变为非运行状态。java.lang.Object 类定义了三个方法，wait()、notify()和notifyAll()来实现这个等待机制。</p>
<p>一个线程一旦调用了任意对象的wait()方法，就会变为非运行状态，直到另一个线程调用了同一个对象的notify()方法。为了调用wait()或者notify()，线程必须先获得那个对象的锁。也就是说，线程必须在同步块里调用wait()或者notify()。以下是MySingal的修改版本——使用了wait()和notify()的MyWaitNotify：</p>
<pre><code>public class MonitorObject{
}
public class MyWaitNotify{
  MonitorObject myMonitorObject = new MonitorObject();
  public void doWait(){
    synchronized(myMonitorObject){
      try{
        myMonitorObject.wait();
      } catch(InterruptedException e){...}
    }
  }
  public void doNotify(){
    synchronized(myMonitorObject){
      myMonitorObject.notify();
    }
  }
}
</code></pre><p>等待线程将调用doWait()，而唤醒线程将调用doNotify()。当一个线程调用一个对象的notify()方法，正在等待该对象的所有线程中将有一个线程被唤醒并允许执行（校注：这个将被唤醒的线程是随机的，不可以指定唤醒哪个线程）。同时也提供了一个notifyAll()方法来唤醒正在等待一个给定对象的所有线程。</p>
<p>如你所见，不管是等待线程还是唤醒线程都在同步块里调用wait()和notify()。这是强制性的！一个线程如果没有持有对象锁，将不能调用wait()，notify()或者notifyAll()。否则，会抛出IllegalMonitorStateException异常。</p>
<p>（校注：JVM是这么实现的，当你调用wait时候它首先要检查下当前线程是否是锁的拥有者，不是则抛出IllegalMonitorStateExcept，参考JVM源码的 1422行。）</p>
<p>但是，这怎么可能？等待线程在同步块里面执行的时候，不是一直持有监视器对象（myMonitor对象）的锁吗？等待线程不能阻塞唤醒线程进入doNotify()的同步块吗？答案是：的确不能。一旦线程调用了wait()方法，它就释放了所持有的监视器对象上的锁。这将允许其他线程也可以调用wait()或者notify()。</p>
<p>一旦一个线程被唤醒，不能立刻就退出wait()的方法调用，直到调用notify()的线程退出了它自己的同步块。换句话说：被唤醒的线程必须重新获得监视器对象的锁，才可以退出wait()的方法调用，因为wait方法调用运行在同步块里面。如果多个线程被notifyAll()唤醒，那么在同一时刻将只有一个线程可以退出wait()方法，因为每个线程在退出wait()前必须获得监视器对象的锁。</p>
<p><strong>4、丢失的信号（Missed Signals）</strong><br>notify()和notifyAll()方法不会保存调用它们的方法，因为当这两个方法被调用时，有可能没有线程处于等待状态。通知信号过后便丢弃了。因此，如果一个线程先于被通知线程调用wait()前调用了notify()，等待的线程将错过这个信号。这可能是也可能不是个问题。不过，在某些情况下，这可能使等待线程永远在等待，不再醒来，因为线程错过了唤醒信号。<br>为了避免丢失信号，必须把它们保存在信号类里。在MyWaitNotify的例子中，通知信号应被存储在MyWaitNotify实例的一个成员变量里。以下是MyWaitNotify的修改版本：</p>
<pre><code>public class MyWaitNotify2{

  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;
  public void doWait(){
    synchronized(myMonitorObject){
      if(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
     //clear signal and continue running.
      wasSignalled = false;
    }
  }

  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
</code></pre><p>留意doNotify()方法在调用notify()前把wasSignalled变量设为true。同时，留意doWait()方法在调用wait()前会检查wasSignalled变量。事实上，如果没有信号在前一次doWait()调用和这次doWait()调用之间的时间段里被接收到，它将只调用wait()。</p>
<p>（校注：为了避免信号丢失， 用一个变量来保存是否被通知过。在notify前，设置自己已经被通知过。在wait后，设置自己没有被通知过，需要等待通知。）</p>
<p><strong>5、假唤醒</strong><br>由于莫名其妙的原因，线程有可能在没有调用过notify()和notifyAll()的情况下醒来。这就是所谓的假唤醒（spurious wakeups）。无端端地醒过来了。</p>
<p>如果在MyWaitNotify2的doWait()方法里发生了假唤醒，等待线程即使没有收到正确的信号，也能够执行后续的操作。这可能导致你的应用程序出现严重问题。</p>
<p>为了防止假唤醒，保存信号的成员变量将在一个while循环里接受检查，而不是在if表达式里。这样的一个while循环叫做自旋锁（校注：这种做法要慎重，目前的JVM实现自旋会消耗CPU，如果长时间不调用doNotify方法，doWait方法会一直自旋，CPU会消耗太大）。被唤醒的线程会自旋直到自旋锁(while循环)里的条件变为false。以下MyWaitNotify2的修改版本展示了这点：</p>
<pre><code>public class MyWaitNotify3{
  MonitorObject myMonitorObject = new MonitorObject();
  boolean wasSignalled = false;
  public void doWait(){
    synchronized(myMonitorObject){
      while(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }
  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
</code></pre><p>留意wait()方法是在while循环里，而不在if表达式里。如果等待线程没有收到信号就唤醒，wasSignalled变量将变为false,while循环会再执行一次，促使醒来的线程回到等待状态。</p>
<p><strong>6、多个线程等待相同信号</strong><br>如果你有多个线程在等待，被notifyAll()唤醒，但只有一个被允许继续执行，使用while循环也是个好方法。每次只有一个线程可以获得监视器对象锁，意味着只有一个线程可以退出wait()调用并清除wasSignalled标志（设为false）。一旦这个线程退出doWait()的同步块，其他线程退出wait()调用，并在while循环里检查wasSignalled变量值。但是，这个标志已经被第一个唤醒的线程清除了，所以其余醒来的线程将回到等待状态，直到下次信号到来。</p>
<p><strong>7、不要在字符串常量或全局对象中调用wait()</strong><br>（校注：这里说的字符串常量指的是值为常量的变量）</p>
<p>本文早期的一个版本在MyWaitNotify例子里使用字符串常量（””）作为管程对象。以下是那个例子：</p>
<pre><code>public class MyWaitNotify{
  String myMonitorObject = &quot;&quot;;
  boolean wasSignalled = false;
  public void doWait(){
    synchronized(myMonitorObject){
      while(!wasSignalled){
        try{
          myMonitorObject.wait();
         } catch(InterruptedException e){...}
      }
      //clear signal and continue running.
      wasSignalled = false;
    }
  }
  public void doNotify(){
    synchronized(myMonitorObject){
      wasSignalled = true;
      myMonitorObject.notify();
    }
  }
}
</code></pre><p>在空字符串作为锁的同步块(或者其他常量字符串)里调用wait()和notify()产生的问题是，JVM/编译器内部会把常量字符串转换成同一个对象。这意味着，即使你有2个不同的MyWaitNotify实例，它们都引用了相同的空字符串实例。同时也意味着存在这样的风险：在第一个MyWaitNotify实例上调用doWait()的线程会被在第二个MyWaitNotify实例上调用doNotify()的线程唤醒。这种情况可以画成以下这张图：</p>
<p>起初这可能不像个大问题。毕竟，如果doNotify()在第二个MyWaitNotify实例上被调用，真正发生的事不外乎线程A和B被错误的唤醒了 。这个被唤醒的线程（A或者B）将在while循环里检查信号值，然后回到等待状态，因为doNotify()并没有在第一个MyWaitNotify实例上调用，而这个正是它要等待的实例。这种情况相当于引发了一次假唤醒。线程A或者B在信号值没有更新的情况下唤醒。但是代码处理了这种情况，所以线程回到了等待状态。记住，即使4个线程在相同的共享字符串实例上调用wait()和notify()，doWait()和doNotify()里的信号还会被2个MyWaitNotify实例分别保存。在MyWaitNotify1上的一次doNotify()调用可能唤醒MyWaitNotify2的线程，但是信号值只会保存在MyWaitNotify1里。</p>
<p>问题在于，由于doNotify()仅调用了notify()而不是notifyAll()，即使有4个线程在相同的字符串（空字符串）实例上等待，只能有一个线程被唤醒。所以，如果线程A或B被发给C或D的信号唤醒，它会检查自己的信号值，看看有没有信号被接收到，然后回到等待状态。而C和D都没被唤醒来检查它们实际上接收到的信号值，这样信号便丢失了。这种情况相当于前面所说的丢失信号的问题。C和D被发送过信号，只是都不能对信号作出回应。</p>
<p>如果doNotify()方法调用notifyAll()，而非notify()，所有等待线程都会被唤醒并依次检查信号值。线程A和B将回到等待状态，但是C或D只有一个线程注意到信号，并退出doWait()方法调用。C或D中的另一个将回到等待状态，因为获得信号的线程在退出doWait()的过程中清除了信号值(置为false)。</p>
<p>看过上面这段后，你可能会设法使用notifyAll()来代替notify()，但是这在性能上是个坏主意。在只有一个线程能对信号进行响应的情况下，没有理由每次都去唤醒所有线程。</p>
<p>所以：在wait()/notify()机制中，不要使用全局对象，字符串常量等。应该使用对应唯一的对象。例如，每一个MyWaitNotify3的实例（前一节的例子）拥有一个属于自己的监视器对象，而不是在空字符串上调用wait()/notify()。</p>
<p>校注：</p>
<p>管程 (英语：Monitors，也称为监视器) 是对多个工作线程实现互斥访问共享资源的对象或模块。这些共享资源一般是硬件设备或一群变量。管程实现了在一个时间点，最多只有一个线程在执行它的某个子程序。与那些通过修改数据结构实现互斥访问的并发程序设计相比，管程很大程度上简化了程序设计。</p>
<p>##死锁</p>
<p>死锁是两个或更多线程阻塞着等待其它处于死锁状态的线程所持有的锁。死锁通常发生在多个线程同时但以不同的顺序请求同一组锁的时候。</p>
<p>例如，如果线程1锁住了A，然后尝试对B进行加锁，同时线程2已经锁住了B，接着尝试对A进行加锁，这时死锁就发生了。线程1永远得不到B，线程2也永远得不到A，并且它们永远也不会知道发生了这样的事情。为了得到彼此的对象（A和B），它们将永远阻塞下去。这种情况就是一个死锁。</p>
<p>该情况如下：</p>
<pre><code>Thread 1  locks A, waits for B
Thread 2  locks B, waits for A
</code></pre><p>这里有一个TreeNode类的例子，它调用了不同实例的synchronized方法：</p>
<pre><code>public class TreeNode {
    TreeNode parent   = null; 
    List children = new ArrayList();

    public synchronized void addChild(TreeNode child){
        if(!this.children.contains(child)) {
            this.children.add(child);
            child.setParentOnly(this);
        }
    }
    public synchronized void addChildOnly(TreeNode child){
        if(!this.children.contains(child){
            this.children.add(child);
        }
    }
    public synchronized void setParent(TreeNode parent){
        this.parent = parent;
        parent.addChildOnly(this);
    }
    public synchronized void setParentOnly(TreeNode parent){
        this.parent = parent;
    }
}
</code></pre><p>如果线程1调用parent.addChild(child)方法的同时有另外一个线程2调用child.setParent(parent)方法，两个线程中的parent表示的是同一个对象，child亦然，此时就会发生死锁。下面的伪代码说明了这个过程：</p>
<pre><code>Thread 1: parent.addChild(child); //locks parent
          --&gt; child.setParentOnly(parent);

Thread 2: child.setParent(parent); //locks child
          --&gt; parent.addChildOnly()
</code></pre><p>首先线程1调用parent.addChild(child)。因为addChild()是同步的，所以线程1会对parent对象加锁以不让其它线程访问该对象。</p>
<p>然后线程2调用child.setParent(parent)。因为setParent()是同步的，所以线程2会对child对象加锁以不让其它线程访问该对象。</p>
<p>现在child和parent对象被两个不同的线程锁住了。接下来线程1尝试调用child.setParentOnly()方法，但是由于child对象现在被线程2锁住的，所以该调用会被阻塞。线程2也尝试调用parent.addChildOnly()，但是由于parent对象现在被线程1锁住，导致线程2也阻塞在该方法处。现在两个线程都被阻塞并等待着获取另外一个线程所持有的锁。</p>
<p>注意：像上文描述的，这两个线程需要同时调用parent.addChild(child)和child.setParent(parent)方法，并且是同一个parent对象和同一个child对象，才有可能发生死锁。上面的代码可能运行一段时间才会出现死锁。</p>
<p>这些线程需要同时获得锁。举个例子，如果线程1稍微领先线程2，然后成功地锁住了A和B两个对象，那么线程2就会在尝试对B加锁的时候被阻塞，这样死锁就不会发生。因为线程调度通常是不可预测的，因此没有一个办法可以准确预测什么时候死锁会发生，仅仅是可能会发生。</p>
<p><strong>更复杂的死锁</strong></p>
<p>死锁可能不止包含2个线程，这让检测死锁变得更加困难。下面是4个线程发生死锁的例子：</p>
<pre><code>Thread 1  locks A, waits for B
Thread 2  locks B, waits for C
Thread 3  locks C, waits for D
Thread 4  locks D, waits for A
</code></pre><p>线程1等待线程2，线程2等待线程3，线程3等待线程4，线程4等待线程1。</p>
<p><strong>数据库的死锁</strong></p>
<p>更加复杂的死锁场景发生在数据库事务中。一个数据库事务可能由多条SQL更新请求组成。当在一个事务中更新一条记录，这条记录就会被锁住避免其他事务的更新请求，直到第一个事务结束。同一个事务中每一个更新请求都可能会锁住一些记录。</p>
<p>当多个事务同时需要对一些相同的记录做更新操作时，就很有可能发生死锁，例如：</p>
<pre><code>Transaction 1, request 1, locks record 1 for update
Transaction 2, request 1, locks record 2 for update
Transaction 1, request 2, tries to lock record 2 for update.
Transaction 2, request 2, tries to lock record 1 for update.
</code></pre><p>因为锁发生在不同的请求中，并且对于一个事务来说不可能提前知道所有它需要的锁，因此很难检测和避免数据库事务中的死锁。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Android UI线程和子线程、Service通信]]></title>
      <url>http://www.ezlippi.com/blog/2014/07/android-UI-Thread.html</url>
      <content type="html"><![CDATA[<p>关于Service最基本的用法自然就是如何启动一个Service了，启动Service的方法和启动Activity很类似，都需要借助Intent来实现，下面我们就通过一个具体的例子来看一下。</p>
<p>新建一个Android项目，项目名就叫ServiceTest，这里我选择使用4.0的API。</p>
<p>然后新建一个MyService继承自Service，并重写父类的onCreate()、onStartCommand()和onDestroy()方法，如下所示：<br><a id="more"></a><br>[java] </p>
<pre><code>public class MyService extends Service {  

    public static final String TAG = &quot;MyService&quot;;  

    @Override  
    public void onCreate() {  
        super.onCreate();  
        Log.d(TAG, &quot;onCreate() executed&quot;);  
    }  

    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        Log.d(TAG, &quot;onStartCommand() executed&quot;);  
        return super.onStartCommand(intent, flags, startId);  
    }  

    @Override  
    public void onDestroy() {  
        super.onDestroy();  
        Log.d(TAG, &quot;onDestroy() executed&quot;);  
    }  

    @Override  
    public IBinder onBind(Intent intent) {  
        return null;  
    }  

}  
</code></pre><p>可以看到，我们只是在onCreate()、onStartCommand()和onDestroy()方法中分别打印了一句话，并没有进行其它任何的操作。<br>然后打开或新建activity_main.xml作为程序的主布局文件，代码如下所示：</p>
<p>[html] </p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot; &gt;  

    &lt;Button  
        android:id=&quot;@+id/start_service&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Start Service&quot; /&gt;  

    &lt;Button  
        android:id=&quot;@+id/stop_service&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;wrap_content&quot;  
        android:text=&quot;Stop Service&quot; /&gt;  

&lt;/LinearLayout&gt;  
</code></pre><p>我们在布局文件中加入了两个按钮，一个用于启动Service，一个用于停止Service。<br>然后打开或新建MainActivity作为程序的主Activity，在里面加入启动Service和停止Service的逻辑，代码如下所示：</p>
<p>[java] </p>
<pre><code>public class MainActivity extends Activity implements OnClickListener {  

    private Button startService;  

    private Button stopService;  

    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        startService = (Button) findViewById(R.id.start_service);  
        stopService = (Button) findViewById(R.id.stop_service);  
        startService.setOnClickListener(this);  
        stopService.setOnClickListener(this);  
    }  

    @Override  
    public void onClick(View v) {  
        switch (v.getId()) {  
        case R.id.start_service:  
            Intent startIntent = new Intent(this, MyService.class);  
            startService(startIntent);  
            break;  
        case R.id.stop_service:  
            Intent stopIntent = new Intent(this, MyService.class);  
            stopService(stopIntent);  
            break;  
        default:  
            break;  
        }  
    }  

}  
</code></pre><p>可以看到，在Start Service按钮的点击事件里，我们构建出了一个Intent对象，并调用startService()方法来启动MyService。然后在Stop Serivce按钮的点击事件里，我们同样构建出了一个Intent对象，并调用stopService()方法来停止MyService。代码的逻辑非常简单，相信不需要我再多做解释了吧。<br>另外需要注意，项目中的每一个Service都必须在AndroidManifest.xml中注册才行，所以还需要编辑AndroidManifest.xml文件，代码如下所示：</p>
<p>[html] </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    package=&quot;com.example.servicetest&quot;  
    android:versionCode=&quot;1&quot;  
    android:versionName=&quot;1.0&quot; &gt;  

    &lt;uses-sdk  
        android:minSdkVersion=&quot;14&quot;  
        android:targetSdkVersion=&quot;17&quot; /&gt;  

    &lt;application  
        android:allowBackup=&quot;true&quot;  
        android:icon=&quot;@drawable/ic_launcher&quot;  
        android:label=&quot;@string/app_name&quot;  
        android:theme=&quot;@style/AppTheme&quot; &gt;  

    ……  

        &lt;service android:name=&quot;com.example.servicetest.MyService&quot; &gt;  
        &lt;/service&gt;  
    &lt;/application&gt;  

&lt;/manifest&gt; 
</code></pre><p>这样的话，一个简单的带有Service功能的程序就写好了，当启动一个Service的时候，会调用该Service中的onCreate()和onStartCommand()方法。</p>
<p>那么如果我再点击一次Start Service按钮呢？<br>这次只有onStartCommand()方法执行了，onCreate()方法并没有执行，为什么会这样呢？这是由于onCreate()方法只会在Service第一次被创建的时候调用，如果当前Service已经被创建过了，不管怎样调用startService()方法，onCreate()方法都不会再执行。因此你可以再多点击几次StartService按钮试一次，每次都只会有onStartCommand()方法。</p>
<p>我们还可以到手机的应用程序管理界面来检查一下MyService是不是正在运行，<br>，MyService确实是正在运行的，即使它的内部并没有执行任何的逻辑。</p>
<p>回到ServiceTest程序，然后点击一下Stop Service按钮就可以将MyService停止掉了。</p>
<p>##Service和Activity通信<br>上面我们学习了Service的基本用法，启动Service之后，就可以在onCreate()或onStartCommand()方法里去执行一些具体的逻辑了。不过这样的话Service和Activity的关系并不大，只是Activity通知了Service一下：“你可以启动了。”然后Service就去忙自己的事情了。那么有没有什么办法能让它们俩的关联更多一些呢？比如说在Activity中可以指定让Service去执行什么任务。当然可以，只需要让Activity和Service建立关联就好了。</p>
<p>观察MyService中的代码，你会发现一直有一个onBind()方法我们都没有使用到，这个方法其实就是用于和Activity建立关联的，修改MyService中的代码，如下所示：</p>
<p>[java] </p>
<pre><code>public class MyService extends Service {  

    public static final String TAG = &quot;MyService&quot;;  

    private MyBinder mBinder = new MyBinder();  

    @Override  
    public void onCreate() {  
        super.onCreate();  
        Log.d(TAG, &quot;onCreate() executed&quot;);  
    }  

    @Override  
    public int onStartCommand(Intent intent, int flags, int startId) {  
        Log.d(TAG, &quot;onStartCommand() executed&quot;);  
        return super.onStartCommand(intent, flags, startId);  
    }  

    @Override  
    public void onDestroy() {  
        super.onDestroy();  
        Log.d(TAG, &quot;onDestroy() executed&quot;);  
    }  

    @Override  
    public IBinder onBind(Intent intent) {  
        return mBinder;  
    }  

    class MyBinder extends Binder {  

        public void startDownload() {  
            Log.d(&quot;TAG&quot;, &quot;startDownload() executed&quot;);  
            // 执行具体的下载任务  
        }  

    }  

}  
</code></pre><p>这里我们新增了一个MyBinder类继承自Binder类，然后在MyBinder中添加了一个startDownload()方法用于在后台执行下载任务，当然这里并不是真正地去下载某个东西，只是做个测试，所以startDownload()方法只是打印了一行日志。<br>然后修改activity_main.xml中的代码，在布局文件中添加用于绑定Service和取消绑定Service的按钮：</p>
<p>[html] </p>
<pre><code>    &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
        android:layout_width=&quot;match_parent&quot;  
        android:layout_height=&quot;match_parent&quot;  
        android:orientation=&quot;vertical&quot; &gt;  

        &lt;Button  
            android:id=&quot;@+id/start_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Start Service&quot; /&gt;  

        &lt;Button  
            android:id=&quot;@+id/stop_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Stop Service&quot; /&gt;  

        &lt;Button  
            android:id=&quot;@+id/bind_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Bind Service&quot; /&gt;  

        &lt;Button   
            android:id=&quot;@+id/unbind_service&quot;  
            android:layout_width=&quot;match_parent&quot;  
            android:layout_height=&quot;wrap_content&quot;  
            android:text=&quot;Unbind Service&quot;  
            /&gt;  

    &lt;/LinearLayout&gt;  

接下来再修改MainActivity中的代码，让MainActivity和MyService之间建立关联，代码如下所示：
[java] 
public class MainActivity extends Activity implements OnClickListener {  

    private Button startService;  

    private Button stopService;  

    private Button bindService;  

    private Button unbindService;  

    private MyService.MyBinder myBinder;  

    private ServiceConnection connection = new ServiceConnection() {  

        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  

        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myBinder = (MyService.MyBinder) service;  
            myBinder.startDownload();  
        }  
    };  

    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        startService = (Button) findViewById(R.id.start_service);  
        stopService = (Button) findViewById(R.id.stop_service);  
        bindService = (Button) findViewById(R.id.bind_service);  
        unbindService = (Button) findViewById(R.id.unbind_service);  
        startService.setOnClickListener(this);  
        stopService.setOnClickListener(this);  
        bindService.setOnClickListener(this);  
        unbindService.setOnClickListener(this);  
    }  

    @Override  
    public void onClick(View v) {  
        switch (v.getId()) {  
        case R.id.start_service:  
            Intent startIntent = new Intent(this, MyService.class);  
            startService(startIntent);  
            break;  
        case R.id.stop_service:  
            Intent stopIntent = new Intent(this, MyService.class);  
            stopService(stopIntent);  
            break;  
        case R.id.bind_service:  
            Intent bindIntent = new Intent(this, MyService.class);  
            bindService(bindIntent, connection, BIND_AUTO_CREATE);  
            break;  
        case R.id.unbind_service:  
            unbindService(connection);  
            break;  
        default:  
            break;  
        }  
    }  

}  
</code></pre><p>可以看到，这里我们首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，这两个方法分别会在Activity与Service建立关联和解除关联的时候调用。在onServiceConnected()方法中，我们又通过向下转型得到了MyBinder的实例，有了这个实例，Activity和Service之间的关系就变得非常紧密了。现在我们可以在Activity中根据具体的场景来调用MyBinder中的任何public方法，即实现了Activity指挥Service干什么Service就去干什么的功能。<br>当然，现在Activity和Service其实还没关联起来了呢，这个功能是在Bind Service按钮的点击事件里完成的。可以看到，这里我们仍然是构建出了一个Intent对象，然后调用bindService()方法将Activity和Service进行绑定。bindService()方法接收三个参数，第一个参数就是刚刚构建出的Intent对象，第二个参数是前面创建出的ServiceConnection的实例，第三个参数是一个标志位，这里传入BIND_AUTO_CREATE表示在Activity和Service建立关联后自动创建Service，这会使得MyService中的onCreate()方法得到执行，但onStartCommand()方法不会执行。</p>
<p>然后如何我们想解除Activity和Service之间的关联怎么办呢？调用一下unbindService()方法就可以了，这也是Unbind Service按钮的点击事件里实现的逻辑。</p>
<p>现在让我们重新运行一下程序吧，在MainActivity中点击一下Bind Service按钮，LogCat里的打印日志如下图所示：</p>
<p>另外需要注意，任何一个Service在整个应用程序范围内都是通用的，即MyService不仅可以和MainActivity建立关联，还可以和任何一个Activity建立关联，而且在建立关联时它们都可以获取到相同的MyBinder实例。</p>
<p>##如何销毁Service<br>在Service的基本用法这一部分，我们介绍了销毁Service最简单的一种情况，点击Start Service按钮启动Service，再点击Stop Service按钮停止Service，这样MyService就被销毁了。<br>那么如果我们是点击的Bind Service按钮呢？由于在绑定Service的时候指定的标志位是BIND_AUTO_CREATE，说明点击Bind Service按钮的时候Service也会被创建，这时应该怎么销毁Service呢？其实也很简单，点击一下Unbind Service按钮，将Activity和Service的关联解除就可以了。</p>
<p>先点击一下Bind Service按钮，再点击一下Unbind Service按钮。</p>
<p>以上这两种销毁的方式都很好理解。那么如果我们既点击了Start Service按钮，又点击了Bind Service按钮会怎么样呢？这个时候你会发现，不管你是单独点击Stop Service按钮还是Unbind Service按钮，Service都不会被销毁，必要将两个按钮都点击一下，Service才会被销毁。也就是说，点击Stop Service按钮只会让Service停止，点击Unbind Service按钮只会让Service和Activity解除关联，一个Service必须要在既没有和任何Activity关联又处理停止状态的时候才会被销毁。</p>
<p>为了证实一下，我们在Stop Service和Unbind Service按钮的点击事件里面加入一行打印日志：</p>
<p>[java] </p>
<pre><code>public void onClick(View v) {  
    switch (v.getId()) {  
    case R.id.start_service:  
        Intent startIntent = new Intent(this, MyService.class);  
        startService(startIntent);  
        break;  
    case R.id.stop_service:  
        Log.d(&quot;MyService&quot;, &quot;click Stop Service button&quot;);  
        Intent stopIntent = new Intent(this, MyService.class);  
        stopService(stopIntent);  
        break;  
    case R.id.bind_service:  
        Intent bindIntent = new Intent(this, MyService.class);  
        bindService(bindIntent, connection, BIND_AUTO_CREATE);  
        break;  
    case R.id.unbind_service:  
        Log.d(&quot;MyService&quot;, &quot;click Unbind Service button&quot;);  
        unbindService(connection);  
        break;  
    default:  
        break;  
    }  
}  
</code></pre><p>然后重新运行程序，先点击一下Start Service按钮，再点击一下Bind Service按钮，这样就将Service启动起来，并和Activity建立了关联。然后点击Stop Service按钮后Service并不会销毁，再点击一下Unbind Service按钮，Service就会销毁了。<br>我们应该始终记得在Service的onDestroy()方法里去清理掉那些不再使用的资源，防止在Service被销毁后还会有一些不再使用的对象仍占用着内存。</p>
<p>##Service和Thread的关系<br>不少Android初学者都可能会有这样的疑惑，Service和Thread到底有什么关系呢？什么时候应该用Service，什么时候又应该用Thread？答案可能会有点让你吃惊，因为Service和Thread之间没有任何关系！</p>
<p>之所以有不少人会把它们联系起来，主要就是因为Service的后台概念。Thread我们大家都知道，是用于开启一个子线程，在这里去执行一些耗时操作就不会阻塞主线程的运行。而Service我们最初理解的时候，总会觉得它是用来处理一些后台任务的，一些比较耗时的操作也可以放在这里运行，这就会让人产生混淆了。但是，如果我告诉你Service其实是运行在主线程里的，你还会觉得它和Thread有什么关系吗？让我们看一下这个残酷的事实吧。</p>
<p>在MainActivity的onCreate()方法里加入一行打印当前线程id的语句：</p>
<p>[java] </p>
<pre><code>Log.d(&quot;MyService&quot;, &quot;MainActivity thread id is &quot; + Thread.currentThread().getId());  
</code></pre><p>然后在MyService的onCreate()方法里也加入一行打印当前线程id的语句：<br>[java] </p>
<pre><code>Log.d(&quot;MyService&quot;, &quot;MyService thread id is &quot; + Thread.currentThread().getId());  
</code></pre><p>现在重新运行一下程序，并点击Start Service按钮，会看到如下打印日志：</p>
<p>可以看到，它们的线程id完全是一样的，由此证实了Service确实是运行在主线程里的，也就是说如果你在Service里编写了非常耗时的代码，程序必定会出现ANR的。</p>
<p>你可能会惊呼，这不是坑爹么！？那我要Service又有何用呢？其实大家不要把后台和子线程联系在一起就行了，这是两个完全不同的概念。Android的后台就是指，它的运行是完全不依赖UI的。即使Activity被销毁，或者程序被关闭，只要进程还在，Service就可以继续运行。比如说一些应用程序，始终需要与服务器之间始终保持着心跳连接，就可以使用Service来实现。你可能又会问，前面不是刚刚验证过Service是运行在主线程里的么？在这里一直执行着心跳连接，难道就不会阻塞主线程的运行吗？当然会，但是我们可以在Service中再创建一个子线程，然后在这里去处理耗时逻辑就没问题了。</p>
<p>额，既然在Service里也要创建一个子线程，那为什么不直接在Activity里创建呢？这是因为Activity很难对Thread进行控制，当Activity被销毁之后，就没有任何其它的办法可以再重新获取到之前创建的子线程的实例。而且在一个Activity中创建的子线程，另一个Activity无法对其进行操作。但是Service就不同了，所有的Activity都可以与Service进行关联，然后可以很方便地操作其中的方法，即使Activity被销毁了，之后只要重新与Service建立关联，就又能够获取到原有的Service中Binder的实例。因此，使用Service来处理后台任务，Activity就可以放心地finish，完全不需要担心无法对后台任务进行控制的情况。</p>
<p>一个比较标准的Service就可以写成：</p>
<p>[java] </p>
<pre><code>@Override  
public int onStartCommand(Intent intent, int flags, int startId) {  
    new Thread(new Runnable() {  
        @Override  
        public void run() {  
            // 开始执行后台任务  
        }  
    }).start();  
    return super.onStartCommand(intent, flags, startId);  
}  

class MyBinder extends Binder {  

    public void startDownload() {  
        new Thread(new Runnable() {  
            @Override  
            public void run() {  
                // 执行具体的下载任务  
            }  
        }).start();  
    }  

} 
</code></pre><p>##创建前台Service<br>Service几乎都是在后台运行的，一直以来它都是默默地做着辛苦的工作。但是Service的系统优先级还是比较低的，当系统出现内存不足情况时，就有可能会回收掉正在后台运行的Service。如果你希望Service可以一直保持运行状态，而不会由于系统内存不足的原因导致被回收，就可以考虑使用前台Service。前台Service和普通Service最大的区别就在于，它会一直有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。当然有时候你也可能不仅仅是为了防止Service被回收才使用前台Service，有些项目由于特殊的需求会要求必须使用前台Service，比如说墨迹天气，它的Service在后台更新天气数据的同时，还会在系统状态栏一直显示当前天气的信息</p>
<p>那么我们就来看一下如何才能创建一个前台Service吧，其实并不复杂，修改MyService中的代码，如下所示：</p>
<p>[java] </p>
<pre><code>public class MyService extends Service {  

    public static final String TAG = &quot;MyService&quot;;  

    private MyBinder mBinder = new MyBinder();  

    @Override  
    public void onCreate() {  
        super.onCreate();  
        Notification notification = new Notification(R.drawable.ic_launcher,  
                &quot;有通知到来&quot;, System.currentTimeMillis());  
        Intent notificationIntent = new Intent(this, MainActivity.class);  
        PendingIntent pendingIntent = PendingIntent.getActivity(this, 0,  
                notificationIntent, 0);  
        notification.setLatestEventInfo(this, &quot;这是通知的标题&quot;, &quot;这是通知的内容&quot;,  
                pendingIntent);  
        **startForeground(1, notification);**  
        Log.d(TAG, &quot;onCreate() executed&quot;);  
    }  

    .........  

}  
</code></pre><p>这里只是修改了MyService中onCreate()方法的代码。可以看到，我们首先创建了一个Notification对象，然后调用了它的setLatestEventInfo()方法来为通知初始化布局和数据，并在这里设置了点击通知后就打开MainActivity。然后调用startForeground()方法就可以让MyService变成一个前台Service，并会将通知的图片显示出来。<br>现在重新运行一下程序，并点击Start Service或Bind Service按钮，MyService就会以前台Service的模式启动了，并且在系统状态栏会弹出一个通栏图标，下拉状态栏后可以看到通知的详细内容。</p>
<hr>
<p>介绍远程Service的用法，如果将MyService转换成一个远程Service，还会不会有ANR的情况呢？让我们来动手尝试一下吧。</p>
<p>将一个普通的Service转换成远程Service其实非常简单，只需要在注册Service的时候将它的android:process属性指定成:remote就可以了，代码如下所示：</p>
<p>[html] </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    package=&quot;com.example.servicetest&quot;  
    android:versionCode=&quot;1&quot;  
    android:versionName=&quot;1.0&quot; &gt;  

    ......  

    &lt;service  
        android:name=&quot;com.example.servicetest.MyService&quot;  
        android:process=&quot;:remote&quot; &gt;  
    &lt;/service&gt;  

&lt;/manifest&gt;  
</code></pre><p>现在重新运行程序，并点击一下Start Service按钮，你会看到控制台立刻打印了onCreate() executed的信息，而且主界面并没有阻塞住，也不会出现ANR。大概过了一分钟后，又会看到onStartCommand() executed打印了出来。<br>为什么将MyService转换成远程Service后就不会导致程序ANR了呢？这是由于，使用了远程Service后，MyService已经在另外一个进程当中运行了，所以只会阻塞该进程中的主线程，并不会影响到当前的应用程序。<br>为了证实一下MyService现在确实已经运行在另外一个进程当中了，我们分别在MainActivity的onCreate()方法和MyService的onCreate()方法里加入一行日志，打印出各自所在的进程id，如下所示：</p>
<p>[java] </p>
<pre><code>Log.d(&quot;TAG&quot;, &quot;process id is &quot; + Process.myPid());  
</code></pre><p>再次重新运行程序，然后点击一下Start Service按钮，打印结果如下图所示：</p>
<p>可以看到，不仅仅是进程id不同了，就连应用程序包名也不一样了，MyService中打印的那条日志，包名后面还跟上了:remote标识。</p>
<p>那既然远程Service这么好用，干脆以后我们把所有的Service都转换成远程Service吧，还省得再开启线程了。其实不然，远程Service非但不好用，甚至可以称得上是较为难用。一般情况下如果可以不使用远程Service，就尽量不要使用它。</p>
<p>下面就来看一下它的弊端吧，首先将MyService的onCreate()方法中让线程睡眠的代码去除掉，然后重新运行程序，并点击一下Bind Service按钮，你会发现程序崩溃了！为什么点击Start Service按钮程序就不会崩溃，而点击Bind Service按钮就会崩溃呢？这是由于在Bind Service按钮的点击事件里面我们会让MainActivity和MyService建立关联，但是目前MyService已经是一个远程Service了，Activity和Service运行在两个不同的进程当中，这时就不能再使用传统的建立关联的方式，程序也就崩溃了。</p>
<p>那么如何才能让Activity与一个远程Service建立关联呢？这就要使用AIDL来进行跨进程通信了（IPC）。</p>
<p><code>AIDL（Android Interface Definition</code> Language）是Android接口定义语言的意思，它可以用于让某个Service与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个Service的功能。</p>
<p>下面我们就来一步步地看一下AIDL的用法到底是怎样的。首先需要新建一个AIDL文件，在这个文件中定义好Activity需要与Service进行通信的方法。新建MyAIDLService.aidl文件，代码如下所示：</p>
<p>[java]</p>
<pre><code>package com.example.servicetest;  
interface MyAIDLService {  
    int plus(int a, int b);  
    String toUpperCase(String str);  
}  
</code></pre><p>点击保存之后，gen目录下就会生成一个对应的Java文件，如下图所示：</p>
<p>然后修改MyService中的代码，在里面实现我们刚刚定义好的MyAIDLService接口，如下所示：</p>
<p>[java] </p>
<pre><code>public class MyService extends Service {  

    ......  

    @Override  
    public IBinder onBind(Intent intent) {  
        return mBinder;  
    }  

    MyAIDLService.Stub mBinder = new Stub() {  

        @Override  
        public String toUpperCase(String str) throws RemoteException {  
            if (str != null) {  
                return str.toUpperCase();  
            }  
            return null;  
        }  

        @Override  
        public int plus(int a, int b) throws RemoteException {  
            return a + b;  
        }  
    };  

}  
</code></pre><p>这里先是对MyAIDLService.Stub进行了实现，重写里了toUpperCase()和plus()这两个方法。这两个方法的作用分别是将一个字符串全部转换成大写格式，以及将两个传入的整数进行相加。然后在onBind()方法中将MyAIDLService.Stub的实现返回。这里为什么可以这样写呢？因为Stub其实就是Binder的子类，所以在onBind()方法中可以直接返回Stub的实现。<br>接下来修改MainActivity中的代码，如下所示：</p>
<p>[java] </p>
<pre><code>public class MainActivity extends Activity implements OnClickListener {  

    private Button startService;  

    private Button stopService;  

    private Button bindService;  

    private Button unbindService;  

    private MyAIDLService myAIDLService;  

    private ServiceConnection connection = new ServiceConnection() {  

        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  

        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myAIDLService = MyAIDLService.Stub.asInterface(service);  
            try {  
                int result = myAIDLService.plus(3, 5);  
                String upperStr = myAIDLService.toUpperCase(&quot;hello world&quot;);  
                Log.d(&quot;TAG&quot;, &quot;result is &quot; + result);  
                Log.d(&quot;TAG&quot;, &quot;upperStr is &quot; + upperStr);  
            } catch (RemoteException e) {  
                e.printStackTrace();  
            }  
        }  
    };  

    ......  

} 
</code></pre><p>我们只是修改了ServiceConnection中的代码。可以看到，这里首先使用了MyAIDLService.Stub.asInterface()方法将传入的IBinder对象传换成了MyAIDLService对象，接下来就可以调用在MyAIDLService.aidl文件中定义的所有接口了。这里我们先是调用了plus()方法，并传入了3和5作为参数，然后又调用了toUpperCase()方法，并传入hello world字符串作为参数，最后将调用方法的返回结果打印出来。<br>现在重新运行程序，并点击一下Bind Service按钮，可以看到打印日志如下所示：</p>
<p>由此可见，我们确实已经成功实现跨进程通信了，在一个进程中访问到了另外一个进程中的方法。</p>
<p>不过你也可以看出，目前的跨进程通信其实并没有什么实质上的作用，因为这只是在一个Activity里调用了同一个应用程序的Service里的方法。而跨进程通信的真正意义是为了让一个应用程序去访问另一个应用程序中的Service，以实现共享Service的功能。那么下面我们自然要学习一下，如何才能在其它的应用程序中调用到MyService里的方法。</p>
<p>在上一篇文章中我们已经知道，如果想要让Activity与Service之间建立关联，需要调用bindService()方法，并将Intent作为参数传递进去，在Intent里指定好要绑定的Service，示例代码如下：</p>
<p>[java] </p>
<pre><code>Intent bindIntent = new Intent(this, MyService.class);  
bindService(bindIntent, connection, BIND_AUTO_CREATE);  
</code></pre><p>这里在构建Intent的时候是使用MyService.class来指定要绑定哪一个Service的，但是在另一个应用程序中去绑定Service的时候并没有MyService这个类，这时就必须使用到隐式Intent了。现在修改AndroidManifest.xml中的代码，给MyService加上一个action，如下所示：<br>[html] </p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    package=&quot;com.example.servicetest&quot;  
    android:versionCode=&quot;1&quot;  
    android:versionName=&quot;1.0&quot; &gt;  

    ......  

    &lt;service  
        android:name=&quot;com.example.servicetest.MyService&quot;  
        android:process=&quot;:remote&quot; &gt;  
        &lt;intent-filter&gt;  
            &lt;action android:name=&quot;com.example.servicetest.MyAIDLService&quot;/&gt;  
        &lt;/intent-filter&gt;  
    &lt;/service&gt;  

&lt;/manifest&gt;  
</code></pre><p>这就说明，MyService可以响应带有com.example.servicetest.MyAIDLService这个action的Intent。</p>
<p>现在重新运行一下程序，这样就把远程Service端的工作全部完成了。<br>然后创建一个新的Android项目，起名为ClientTest，我们就尝试在这个程序中远程调用MyService中的方法。</p>
<p>ClientTest中的Activity如果想要和MyService建立关联其实也不难，首先需要将MyAIDLService.aidl文件从ServiceTest项目中拷贝过来，注意要将原有的包路径一起拷贝过来，完成后项目的结构如下图所示：</p>
<p>然后打开或新建activity_main.xml，在布局文件中也加入一个Bind Service按钮：</p>
<p>[html] </p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:layout_width=&quot;match_parent&quot;  
    android:layout_height=&quot;match_parent&quot;  
    android:orientation=&quot;vertical&quot;  
     &gt;  

   &lt;Button   
       android:id=&quot;@+id/bind_service&quot;  
       android:layout_width=&quot;match_parent&quot;  
       android:layout_height=&quot;wrap_content&quot;  
       android:text=&quot;Bind Service&quot;  
       /&gt;  

&lt;/LinearLayout&gt;  
</code></pre><p>接下来打开或新建MainActivity，在其中加入和MyService建立关联的代码，如下所示：<br>[java]</p>
<pre><code>public class MainActivity extends Activity {  

    private MyAIDLService myAIDLService;  

    private ServiceConnection connection = new ServiceConnection() {  

        @Override  
        public void onServiceDisconnected(ComponentName name) {  
        }  

        @Override  
        public void onServiceConnected(ComponentName name, IBinder service) {  
            myAIDLService = MyAIDLService.Stub.asInterface(service);  
            try {  
                int result = myAIDLService.plus(50, 50);  
                String upperStr = myAIDLService.toUpperCase(&quot;comes from ClientTest&quot;);  
                Log.d(&quot;TAG&quot;, &quot;result is &quot; + result);  
                Log.d(&quot;TAG&quot;, &quot;upperStr is &quot; + upperStr);  
            } catch (RemoteException e) {  
                e.printStackTrace();  
            }  
        }  
    };  

    @Override  
    protected void onCreate(Bundle savedInstanceState) {  
        super.onCreate(savedInstanceState);  
        setContentView(R.layout.activity_main);  
        Button bindService = (Button) findViewById(R.id.bind_service);  
        bindService.setOnClickListener(new OnClickListener() {  
            @Override  
            public void onClick(View v) {  
                Intent intent = new Intent(&quot;com.example.servicetest.MyAIDLService&quot;);  
                bindService(intent, connection, BIND_AUTO_CREATE);  
            }  
        });  
    }  

} 
</code></pre><p>这部分代码大家一定会非常眼熟吧？没错，这和在ServiceTest的MainActivity中的代码几乎是完全相同的，只是在让Activity和Service建立关联的时候我们使用了隐式Intent，将Intent的action指定成了com.example.servicetest.MyAIDLService。<br>在当前Activity和MyService建立关联之后，我们仍然是调用了plus()和toUpperCase()这两个方法，远程的MyService会对传入的参数进行处理并返回结果，然后将结果打印出来。</p>
<p>这样的话，ClientTest中的代码也就全部完成了，现在运行一下这个项目，然后点击Bind Service按钮，此时就会去和远程的MyService建立关联，观察LogCat中的打印信息如下所示：</p>
<p>不用我说，大家都已经看出，我们的跨进程通信功能已经完美实现了。</p>
<p>不过还有一点需要说明的是，由于这是在不同的进程之间传递数据，Android对这类数据的格式支持是非常有限的，基本上只能传递Java的基本数据类型、字符串、List或Map等。那么如果我想传递一个自定义的类该怎么办呢？这就必须要让这个类去实现Parcelable接口，并且要给这个类也定义一个同名的AIDL文件。这部分内容并不复杂，而且和Service关系不大，所以就不再详细进行讲解了，感兴趣的朋友可以自己去查阅一下相关的资料</p>
<hr>
<p>##主线程和子线程通信</p>
<p>###一、Handler的定义:<br>主要接受子线程发送的数据, 并用此数据配合主线程更新UI.<br>解释: 当应用程序启动时，Android首先会开启一个主线程 (也就是UI线程) , 主线程为管理界面中的UI控件，进行事件分发, 比如说, 你要是点击一个 Button, Android会分发事件到Button上，来响应你的操作。  如果此时需要一个耗时的操作，例如: 联网读取数据，或者读取本地较大的一个文件的时候，你不能把这些操作放在主线程中，如果你放在主线程中的话，界面会出现假死现象, 如果5秒钟还没有完成的话，会收到Android系统的一个错误提示  “强制关闭”.  这个时候我们需要把这些耗时的操作，放在一个子线程中,因为子线程涉及到UI更新，Android主线程是线程不安全的，也就是说，更新UI只能在主线程中更新，子线程中操作是危险的. 这个时候，Handler就出现了来解决这个复杂的问题，由于Handler运行在主线程中(UI线程中)，它与子线程可以通过Message对象来传递数据，这个时候，Handler就承担着接受子线程传过来的(子线程用sedMessage()方法传弟)Message对象，(里面包含数据)  , 把这些消息放入主线程队列中，配合主线程进行更新UI。</p>
<p>###二、Handler一些特点<br>handler可以分发Message对象和Runnable对象到主线程中, 每个Handler实例,都会绑定到创建他的线程中(一般是位于主线程),<br>它有两个作用:</p>
<ol>
<li>安排消息或Runnable 在某个主线程中某个地方执行,</li>
<li>安排一个动作在不同的线程中执行</li>
</ol>
<pre><code>Handler中分发消息的一些方法
post(Runnable)
postAtTime(Runnable,long)
postDelayed(Runnable long)
sendEmptyMessage(int)
sendMessage(Message)
sendMessageAtTime(Message,long)
sendMessageDelayed(Message,long)
以上post类方法允许你排列一个Runnable对象到主线程队列中,
sendMessage类方法, 允许你安排一个带数据的Message对象到队列中，等待更新.
</code></pre><p>###三、Handler实例<br>      (1) 子类需要继承Handler类，并重写handleMessage(Message msg) 方法, 用于接受线程数据<br>      以下为一个实例，它实现的功能为 : 通过线程修改界面Button的内容</p>
<pre><code>1 public class MyHandlerActivity extends Activity {
 2     Button button;
 3     MyHandler myHandler;
 4 
 5     protected void onCreate(Bundle savedInstanceState) {
 6         super.onCreate(savedInstanceState);
 7         setContentView(R.layout.handlertest);
 8 
 9         button = (Button) findViewById(R.id.button);
10         myHandler = new MyHandler();
11         // 当创建一个新的Handler实例时, 它会绑定到当前线程和消息的队列中,开始分发数据
12         // Handler有两个作用, (1) : 定时执行Message和Runnalbe 对象
13         // (2): 让一个动作,在不同的线程中执行.
14 
15         // 它安排消息,用以下方法
16         // post(Runnable)
17         // postAtTime(Runnable,long)
18         // postDelayed(Runnable,long)
19         // sendEmptyMessage(int)
20         // sendMessage(Message);
21         // sendMessageAtTime(Message,long)
22         // sendMessageDelayed(Message,long)
23       
24         // 以上方法以 post开头的允许你处理Runnable对象
25         //sendMessage()允许你处理Message对象(Message里可以包含数据,)
26 
27         MyThread m = new MyThread();
28         new Thread(m).start();
29     }
30 
31     /**
32     * 接受消息,处理消息 ,此Handler会与当前主线程一块运行
33     * */
34 
35     class MyHandler extends Handler {
36         public MyHandler() {
37         }
38 
39         public MyHandler(Looper L) {
40             super(L);
41         }
42 
43         // 子类必须重写此方法,接受数据
44         @Override
45         public void handleMessage(Message msg) {
46             // TODO Auto-generated method stub
47             Log.d(&quot;MyHandler&quot;, &quot;handleMessage......&quot;);
48             super.handleMessage(msg);
49             // 此处可以更新UI
50             Bundle b = msg.getData();
51             String color = b.getString(&quot;color&quot;);
52             MyHandlerActivity.this.button.append(color);
53 
54         }
55     }
56 
57     class MyThread implements Runnable {
58         public void run() {
59 
60             try {
61                 Thread.sleep(10000);
62             } catch (InterruptedException e) {
63                 // TODO Auto-generated catch block
64                 e.printStackTrace();
65             }
66 
67             Log.d(&quot;thread.......&quot;, &quot;mThread........&quot;);
68             Message msg = new Message();
69             Bundle b = new Bundle();// 存放数据
70             b.putString(&quot;color&quot;, &quot;我的&quot;);
71             msg.setData(b);
72 
73             MyHandlerActivity.this.myHandler.sendMessage(msg); // 向Handler发送消息,更新UI
74 
75         }
76     }
77 
78 } 
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[从android.os.NetworkOnMainThreadException引发的思考]]></title>
      <url>http://www.ezlippi.com/blog/2014/07/android-networkOnMainThreadException.html</url>
      <content type="html"><![CDATA[<p>最近在写一个网络通信的程序，运行的时候抛出了这样一个异常，<code>android.os.NetworkOnMainThreadException</code>，找了很久没发现原因，后来查了下资料才知道是android的UI线程不能直接进行网络访问的操作。<br><a id="more"></a></p>
<h2 id="什么是UI线程？"><a href="#什么是UI线程？" class="headerlink" title="什么是UI线程？"></a>什么是UI线程？</h2><blockquote>
<p>The concept and importance of the application’s main <strong>UI thread</strong> is<br>something every Android developer should understand. Each time an<br>application is launched, the system creates a thread called “main” for<br>the application. The main thread (also known as the “UI thread”) is in<br>charge of dispatching events to the appropriate views/widgets and thus<br>is very important. It’s also the thread where your application<br>interacts with running components of your application’s UI. For<br>instance, if you touch a button on the screen, the UI thread<br>dispatches the touch event to the view, which then sets its pressed<br>state and posts an invalidate request to the event queue. The UI<br>thread dequeues this request and then tells the view to redraw itself.</p>
<p>This single-thread model can yield poor performance unless Android<br>applications are implemented properly. Specifically, if the UI thread<br>was in charge of running everything in your entire application,<br>performing long operations such as network access or database queries<br>on the UI thread would block the entire user interface. No event would<br>be able to be dispatched—including drawing and touchscreen<br>events—while the long operation is underway. From the user’s<br>perspective, the application will appear to be frozen.</p>
<p>In these situations, instant feedback is vital. Studies show that <strong>0.1</strong><br>seconds is about the limit for having the user feel that the system is<br>reacting instantaneously. Anything slower than this limit will<br>probably be considered as <strong>lag</strong> (Miller 1968; Card et al. 1991). While a<br>fraction of a second might not seem harmful, even a tenth of a second<br>can be the difference between a good review and a bad review on Google<br>Play. Even worse, if the UI thread is blocked for more than about five<br>seconds, the user is presented with the notorious “application not<br>responding” (ANR) dialog and the app is force closed.</p>
</blockquote>
<hr>
<h2 id="为什么你的App-Crashes？"><a href="#为什么你的App-Crashes？" class="headerlink" title="为什么你的App Crashes？"></a>为什么你的App Crashes？</h2><p>The reason why your application crashes on Android versions 3.0 and above, but works fine on Android 2.x is because Honeycomb and Ice Cream Sandwich are much stricter about abuse against the UI Thread. For example, when an Android device running HoneyComb or above detects a network access on the UI thread, a NetworkOnMainThreadException will be thrown:</p>
<pre><code>E/AndroidRuntime(673): java.lang.RuntimeException: Unable to start activity
    ComponentInfo{com.example/com.example.ExampleActivity}:android.os.NetworkOnMainThreadException
</code></pre><p>在Android developer网站对NetworkOnMainThreadException是这样解释的：</p>
<blockquote>
<p>A NetworkOnMainThreadException is thrown when an application attempts<br>to perform a networking operation on its main thread. This is only<br>thrown for applications targeting the Honeycomb SDK or higher.<br>Applications targeting earlier SDK versions are allowed to do<br>networking on their main event loop threads, but it’s heavily<br>discouraged.</p>
</blockquote>
<p><strong>安卓3.0以上不允许在UI线程执行以下操作：</strong></p>
<ol>
<li>打开一个Socket连接(比如new Socket()).</li>
<li>HTTP请求(比如HTTPClient and HTTPUrlConnection).</li>
<li>尝试访问远程MySQL数据库.</li>
<li>下载文件(Downloader.downloadFile()).</li>
</ol>
<p>If you are attempting to perform any of these operations on the UI thread, you must wrap them in a worker thread. The easiest way to do this is to use of an AsyncTask, which allows you to perform asynchronous work on your user interface. An AsyncTask will perform the blocking operations in a worker thread and will publish the results on the UI thread, without requiring you to handle threads and/or handlers yourself.</p>
<h2 id="Android-AsyncTask完全解析"><a href="#Android-AsyncTask完全解析" class="headerlink" title="Android AsyncTask完全解析"></a>Android AsyncTask完全解析</h2><p>我们都知道，Android UI是线程不安全的，如果想要在子线程里进行UI操作，就需要借助Android的异步消息处理机制。</p>
<p>不过为了更加方便我们在子线程中更新UI元素，Android从1.5版本就引入了一个AsyncTask类，使用它就可以非常灵活方便地从子线程切换到UI线程，我们本篇文章的主角也就正是它了。</p>
<p>AsyncTask很早就出现在Android的API里了，所以我相信大多数朋友对它的用法都已经非常熟悉。不过今天我还是准备从AsyncTask的基本用法开始讲起，然后我们再来一起分析下AsyncTask源码，看看它是如何实现的，最后我会介绍一些关于AsyncTask你所不知道的秘密。</p>
<p>AsyncTask的基本用法<br>首先来看一下AsyncTask的基本用法，由于AsyncTask是一个抽象类，所以如果我们想使用它，就必须要创建一个子类去继承它。在继承时我们可以为AsyncTask类指定三个泛型参数，这三个参数的用途如下：</p>
<ul>
<li>Params</li>
</ul>
<p>在执行AsyncTask时需要传入的参数，可用于在后台任务中使用。</p>
<ul>
<li>Progress</li>
</ul>
<p>后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛型作为进度单位。</p>
<ul>
<li>Result</li>
</ul>
<p>当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回值类型。</p>
<p>因此，一个最简单的自定义AsyncTask就可以写成如下方式：</p>
<p>[java] </p>
<pre><code>class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {  
    ……  
}  
</code></pre><p>这里我们把AsyncTask的第一个泛型参数指定为Void，表示在执行AsyncTask的时候不需要传入参数给后台任务。第二个泛型参数指定为Integer，表示使用整型数据来作为进度显示单位。第三个泛型参数指定为Boolean，则表示使用布尔型数据来反馈执行结果。<br>当然，目前我们自定义的DownloadTask还是一个空任务，并不能进行任何实际的操作，我们还需要去重写AsyncTask中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下四个：</p>
<ul>
<li>onPreExecute()</li>
</ul>
<p>这个方法会在后台任务开始执行之间调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。</p>
<ul>
<li>doInBackground(Params…)</li>
</ul>
<p>这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过return语句来将任务的执行结果进行返回，如果AsyncTask的第三个泛型参数指定的是Void，就可以不返回任务执行结果。注意，在这个方法中是不可以进行UI操作的，如果需要更新UI元素，比如说反馈当前任务的执行进度，可以调用publishProgress(Progress…)方法来完成。</p>
<ul>
<li>onProgressUpdate(Progress…)</li>
</ul>
<p>当在后台任务中调用了publishProgress(Progress…)方法后，这个方法就很快会被调用，方法中携带的参数就是在后台任务中传递过来的。在这个方法中可以对UI进行操作，利用参数中的数值就可以对界面元素进行相应的更新。</p>
<ul>
<li>onPostExecute(Result)</li>
</ul>
<p>当后台任务执行完毕并通过return语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些UI操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。</p>
<p>因此，一个比较完整的自定义AsyncTask就可以写成如下方式：</p>
<p>[java] </p>
<pre><code>class DownloadTask extends AsyncTask&lt;Void, Integer, Boolean&gt; {  

    @Override  
protected void onPreExecute() {  
    progressDialog.show();  
}  

@Override  
protected Boolean doInBackground(Void... params) {  
    try {  
        while (true) {  
            int downloadPercent = doDownload();  
            publishProgress(downloadPercent);  
            if (downloadPercent &gt;= 100) {  
                break;  
            }  
        }  
    } catch (Exception e) {  
        return false;  
    }  
    return true;  
}  

@Override  
protected void onProgressUpdate(Integer... values) {  
    progressDialog.setMessage(&quot;当前下载进度：&quot; + values[0] + &quot;%&quot;);  
}  

@Override  
protected void onPostExecute(Boolean result) {  
    progressDialog.dismiss();  
    if (result) {  
        Toast.makeText(context, &quot;下载成功&quot;, Toast.LENGTH_SHORT).show();  
    } else {  
        Toast.makeText(context, &quot;下载失败&quot;, Toast.LENGTH_SHORT).show();  
    }  
}  
</code></pre><p>}<br>这里我们模拟了一个下载任务，在doInBackground()方法中去执行具体的下载逻辑，在onProgressUpdate()方法中显示当前的下载进度，在onPostExecute()方法中来提示任务的执行结果。如果想要启动这个任务，只需要简单地调用以下代码即可：<br>[java] </p>
<pre><code>new DownloadTask().execute();  
</code></pre><p>以上就是AsyncTask的基本用法，怎么样，是不是感觉在子线程和UI线程之间进行切换变得灵活了很多？我们并不需求去考虑什么异步消息处理机制，也不需要专门使用一个Handler来发送和接收消息，只需要调用一下publishProgress()方法就可以轻松地从子线程切换到UI线程了。<br>分析AsyncTask的源码<br>虽然AsyncTask这么简单好用，但你知道它是怎样实现的吗？那么接下来，我们就来分析一下AsyncTask的源码，对它的实现原理一探究竟。注意这里我选用的是Android 4.0的源码，如果你查看的是其它版本的源码，可能会有一些出入。</p>
<p>从之前DownloadTask的代码就可以看出，在启动某一个任务之前，要先new出它的实例，因此，我们就先来看一看AsyncTask构造函数中的源码，如下所示：</p>
<p>[java] </p>
<pre><code>public AsyncTask() {  
    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {  
        public Result call() throws Exception {  
            mTaskInvoked.set(true);  
            Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  
            return postResult(doInBackground(mParams));  
        }  
    };  
    mFuture = new FutureTask&lt;Result&gt;(mWorker) {  
        @Override  
        protected void done() {  
            try {  
                final Result result = get();  
                postResultIfNotInvoked(result);  
            } catch (InterruptedException e) {  
                android.util.Log.w(LOG_TAG, e);  
            } catch (ExecutionException e) {  
                throw new RuntimeException(&quot;An error occured while executing doInBackground()&quot;,  
                        e.getCause());  
            } catch (CancellationException e) {  
                postResultIfNotInvoked(null);  
            } catch (Throwable t) {  
                throw new RuntimeException(&quot;An error occured while executing &quot;  
                        + &quot;doInBackground()&quot;, t);  
            }  
        }  
    };  
}  
</code></pre><p>这段代码虽然看起来有点长，但实际上并没有任何具体的逻辑会得到执行，只是初始化了两个变量，mWorker和mFuture，并在初始化mFuture的时候将mWorker作为参数传入。mWorker是一个Callable对象，mFuture是一个FutureTask对象，这两个变量会暂时保存在内存中，稍后才会用到它们。<br>接着如果想要启动某一个任务，就需要调用该任务的execute()方法，因此现在我们来看一看execute()方法的源码，如下所示：</p>
<p>[java] </p>
<pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {  
    return executeOnExecutor(sDefaultExecutor, params);  
}  
</code></pre><p>简单的有点过分了，只有一行代码，仅是调用了executeOnExecutor()方法，那么具体的逻辑就应该写在这个方法里了，快跟进去瞧一瞧：<br>[java]</p>
<pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,  
        Params... params) {  
    if (mStatus != Status.PENDING) {  
        switch (mStatus) {  
            case RUNNING:  
                throw new IllegalStateException(&quot;Cannot execute task:&quot;  
                        + &quot; the task is already running.&quot;);  
            case FINISHED:  
                throw new IllegalStateException(&quot;Cannot execute task:&quot;  
                        + &quot; the task has already been executed &quot;  
                        + &quot;(a task can be executed only once)&quot;);  
        }  
    }  
    mStatus = Status.RUNNING;  
    onPreExecute();  
    mWorker.mParams = params;  
    exec.execute(mFuture);  
    return this;  
}  
</code></pre><p>果然，这里的代码看上去才正常点。可以看到，在第15行调用了onPreExecute()方法，因此证明了onPreExecute()方法会第一个得到执行。可是接下来的代码就看不明白了，怎么没见到哪里有调用doInBackground()方法呢？别着急，慢慢找总会找到的，我们看到，在第17行调用了Executor的execute()方法，并将前面初始化的mFuture对象传了进去，那么这个Executor对象又是什么呢？查看上面的execute()方法，原来是传入了一个sDefaultExecutor变量，接着找一下这个sDefaultExecutor变量是在哪里定义的，源码如下所示：<br>[java]</p>
<pre><code>public static final Executor SERIAL_EXECUTOR = new SerialExecutor();  
……  
private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;  
</code></pre><p>可以看到，这里先new出了一个SERIAL_EXECUTOR常量，然后将sDefaultExecutor的值赋值为这个常量，也就是说明，刚才在executeOnExecutor()方法中调用的execute()方法，其实也就是调用的SerialExecutor类中的execute()方法。那么我们自然要去看看SerialExecutor的源码了，如下所示：<br>[java] </p>
<pre><code>private static class SerialExecutor implements Executor {  
    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();  
    Runnable mActive;  

    public synchronized void execute(final Runnable r) {  
        mTasks.offer(new Runnable() {  
            public void run() {  
                try {  
                    r.run();  
                } finally {  
                    scheduleNext();  
                }  
            }  
        });  
        if (mActive == null) {  
            scheduleNext();  
        }  
    }  

    protected synchronized void scheduleNext() {  
        if ((mActive = mTasks.poll()) != null) {  
            THREAD_POOL_EXECUTOR.execute(mActive);  
        }  
    }  
}  
</code></pre><p>SerialExecutor类中也有一个execute()方法，这个方法里的所有逻辑就是在子线程中执行的了，注意这个方法有一个Runnable参数，那么目前这个参数的值是什么呢？当然就是mFuture对象了，也就是说在第9行我们要调用的是FutureTask类的run()方法，而在这个方法里又会去调用Sync内部类的innerRun()方法，因此我们直接来看innerRun()方法的源码：<br>[java] </p>
<pre><code>void innerRun() {  
    if (!compareAndSetState(READY, RUNNING))  
        return;  
    runner = Thread.currentThread();  
    if (getState() == RUNNING) { // recheck after setting thread  
        V result;  
        try {  
            result = callable.call();  
        } catch (Throwable ex) {  
            setException(ex);  
            return;  
        }  
        set(result);  
    } else {  
        releaseShared(0); // cancel  
    }  
} 
</code></pre><p>可以看到，在第8行调用了callable的call()方法，那么这个callable对象是什么呢？其实就是在初始化mFuture对象时传入的mWorker对象了，此时调用的call()方法，也就是一开始在AsyncTask的构造函数中指定的，我们把它单独拿出来看一下，代码如下所示：<br>[java]</p>
<pre><code>public Result call() throws Exception {  
    mTaskInvoked.set(true);  
    Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);  
    return postResult(doInBackground(mParams));  
} 
</code></pre><p>在postResult()方法的参数里面，我们终于找到了doInBackground()方法的调用处，虽然经过了很多周转，但目前的代码仍然是运行在子线程当中的，所以这也就是为什么我们可以在doInBackground()方法中去处理耗时的逻辑。接着将doInBackground()方法返回的结果传递给了postResult()方法，这个方法的源码如下所示：<br>[java] </p>
<pre><code>private Result postResult(Result result) {  
    Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT,  
            new AsyncTaskResult&lt;Result&gt;(this, result));  
    message.sendToTarget();  
    return result;  
} 
</code></pre><p>如果你已经熟悉了异步消息处理机制，这段代码对你来说一定非常简单吧。这里使用sHandler对象发出了一条消息，消息中携带了MESSAGE_POST_RESULT常量和一个表示任务执行结果的AsyncTaskResult对象。这个sHandler对象是InternalHandler类的一个实例，那么稍后这条消息肯定会在InternalHandler的handleMessage()方法中被处理。InternalHandler的源码如下所示：<br>[java] </p>
<pre><code>private static class InternalHandler extends Handler {  
    @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})  
    @Override  
    public void handleMessage(Message msg) {  
        AsyncTaskResult result = (AsyncTaskResult) msg.obj;  
        switch (msg.what) {  
            case MESSAGE_POST_RESULT:  
                // There is only one result  
                result.mTask.finish(result.mData[0]);  
                break;  
            case MESSAGE_POST_PROGRESS:  
                result.mTask.onProgressUpdate(result.mData);  
                break;  
        }  
    }  
}
</code></pre><p>这里对消息的类型进行了判断，如果这是一条MESSAGE_POST_RESULT消息，就会去执行finish()方法，如果这是一条MESSAGE_POST_PROGRESS消息，就会去执行onProgressUpdate()方法。那么finish()方法的源码如下所示：<br>[java] </p>
<pre><code>private void finish(Result result) {  
    if (isCancelled()) {  
        onCancelled(result);  
    } else {  
        onPostExecute(result);  
    }  
    mStatus = Status.FINISHED;  
}  
</code></pre><p>可以看到，如果当前任务被取消掉了，就会调用onCancelled()方法，如果没有被取消，则调用onPostExecute()方法，这样当前任务的执行就全部结束了。<br>我们注意到，在刚才InternalHandler的handleMessage()方法里，还有一种MESSAGE_POST_PROGRESS的消息类型，这种消息是用于当前进度的，调用的正是onProgressUpdate()方法，那么什么时候才会发出这样一条消息呢？相信你已经猜到了，查看publishProgress()方法的源码，如下所示：</p>
<p>[java] </p>
<pre><code>protected final void publishProgress(Progress... values) {  
    if (!isCancelled()) {  
        sHandler.obtainMessage(MESSAGE_POST_PROGRESS,  
                new AsyncTaskResult&lt;Progress&gt;(this, values)).sendToTarget();  
    }  
}
</code></pre><p>非常清晰了吧！正因如此，在doInBackground()方法中调用publishProgress()方法才可以从子线程切换到UI线程，从而完成对UI元素的更新操作。其实也没有什么神秘的，因为说到底，AsyncTask也是使用的异步消息处理机制，只是做了非常好的封装而已。<br>读到这里，相信你对AsyncTask中的每个回调方法的作用、原理、以及何时会被调用都已经搞明白了吧。</p>
<p><strong>关于AsyncTask你所不知道的秘密</strong><br>不得不说，刚才我们在分析SerialExecutor的时候，其实并没有分析的很仔细，仅仅只是关注了它会调用mFuture中的run()方法，但是至于什么时候会调用我们并没有进一步地研究。其实SerialExecutor也是AsyncTask在3.0版本以后做了最主要的修改的地方，它在AsyncTask中是以常量的形式被使用的，因此在整个应用程序中的所有AsyncTask实例都会共用同一个SerialExecutor。下面我们就来对这个类进行更加详细的分析，为了方便阅读，我把它的代码再贴出来一遍：</p>
<p>[java] </p>
<pre><code>private static class SerialExecutor implements Executor {  
    final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();  
    Runnable mActive;  

    public synchronized void execute(final Runnable r) {  
        mTasks.offer(new Runnable() {  
            public void run() {  
                try {  
                    r.run();  
                } finally {  
                    scheduleNext();  
                }  
            }  
        });  
        if (mActive == null) {  
            scheduleNext();  
        }  
    }  

    protected synchronized void scheduleNext() {  
        if ((mActive = mTasks.poll()) != null) {  
            THREAD_POOL_EXECUTOR.execute(mActive);  
        }  
    }  
} 
</code></pre><p>可以看到，SerialExecutor是使用ArrayDeque这个队列来管理Runnable对象的，如果我们一次性启动了很多个任务，首先在第一次运行execute()方法的时候，会调用ArrayDeque的offer()方法将传入的Runnable对象添加到队列的尾部，然后判断mActive对象是不是等于null，第一次运行当然是等于null了，于是会调用scheduleNext()方法。在这个方法中会从队列的头部取值，并赋值给mActive对象，然后调用THREAD_POOL_EXECUTOR去执行取出的取出的Runnable对象。之后如何又有新的任务被执行，同样还会调用offer()方法将传入的Runnable添加到队列的尾部，但是再去给mActive对象做非空检查的时候就会发现mActive对象已经不再是null了，于是就不会再调用scheduleNext()方法。<br>那么后面添加的任务岂不是永远得不到处理了？当然不是，看一看offer()方法里传入的Runnable匿名类，这里使用了一个try finally代码块，并在finally中调用了scheduleNext()方法，保证无论发生什么情况，这个方法都会被调用。也就是说，每次当一个任务执行完毕后，下一个任务才会得到执行，SerialExecutor模仿的是单一线程池的效果，如果我们快速地启动了很多任务，同一时刻只会有一个线程正在执行，其余的均处于等待状态。Android照片墙应用实现，再多的图片也不怕崩溃 这篇文章中例子的运行结果也证实了这个结论。</p>
<p>不过你可能还不知道，在Android 3.0之前是并没有SerialExecutor这个类的，那个时候是直接在AsyncTask中构建了一个sExecutor常量，并对线程池总大小，同一时刻能够运行的线程数做了规定，代码如下所示：</p>
<p>[java] </p>
<pre><code>private static final int CORE_POOL_SIZE = 5;  
private static final int MAXIMUM_POOL_SIZE = 128;  
private static final int KEEP_ALIVE = 10;  
……  
private static final ThreadPoolExecutor sExecutor = new ThreadPoolExecutor(CORE_POOL_SIZE,  
        MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sWorkQueue, sThreadFactory);  
</code></pre><p>可以看到，这里规定同一时刻能够运行的线程数为5个，线程池总大小为128。也就是说当我们启动了10个任务时，只有5个任务能够立刻执行，另外的5个任务则需要等待，当有一个任务执行完毕后，第6个任务才会启动，以此类推。而线程池中最大能存放的线程数是128个，当我们尝试去添加第129个任务时，程序就会崩溃。<br>因此在3.0版本中AsyncTask的改动还是挺大的，在3.0之前的AsyncTask可以同时有5个任务在执行，而3.0之后的AsyncTask同时只能有1个任务在执行。为什么升级之后可以同时执行的任务数反而变少了呢？这是因为更新后的AsyncTask已变得更加灵活，如果不想使用默认的线程池，还可以自由地进行配置。比如使用如下的代码来启动任务：</p>
<p>[java] </p>
<pre><code>Executor exec = new ThreadPoolExecutor(15, 200, 10,  
        TimeUnit.SECONDS, new LinkedBlockingQueue&lt;Runnable&gt;());  
new DownloadTask().executeOnExecutor(exec); 
</code></pre><p>这样就可以使用我们自定义的一个Executor来执行任务，而不是使用SerialExecutor。上述代码的效果允许在同一时刻有15个任务正在执行，并且最多能够存储200个任务。<br>好了，到这里我们就已经把关于AsyncTask的所有重要内容深入浅出地理解了一遍，相信在将来使用它的时候能够更加得心应手。</p>
<p>参考：</p>
<ol>
<li><a href="http://www.androiddesignpatterns.com/2012/06/app-force-close-honeycomb-ics.html" target="_blank" rel="external">Why Ice Cream Sandwich Crashes your App</a></li>
<li><a href="http://developer.android.com/reference/android/os/AsyncTask.html" target="_blank" rel="external">AsyncTask</a></li>
<li><a href="http://android-developers.blogspot.com/2010/07/multithreading-for-performance.html" target="_blank" rel="external">Multithreading For Performance</a></li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用jekyll在Github上搭建博客]]></title>
      <url>http://www.ezlippi.com/blog/2014/07/use-jekyll-build-blog-on-github.html</url>
      <content type="html"><![CDATA[<p>jekyll是一个使用Ruby编写的静态站点生成工具，使用Liquid模板渲染引擎，支持Markdown和Textile标记语言，并且可以为所有以 .html、.markdown、.textile扩展名结尾的文件使用YAML配置，内置语法高亮功能。</p>
<p>而Github的Pages服务可以为每个Github主机上的仓库提供静态页面服务，并且Pages服务支持jekyll。因为Github Pages有两种Pages，分别是用户页面和项目页面，所以我们可以使用用户页面来创建自己的Blog。</p>
<p>在开始前，请确保你已经有了Github账号一枚和Git的正确配置。没有的朋友可以先移步Github注册并安装配置Git。<br><a id="more"></a><br>首先，创建你的 Blog 仓库 <code>username.github.com</code>:</p>
<pre><code>$ mkdir username.github.com
$ cd username.github.com
</code></pre><p>新建一个 <code>index.html</code> 文件，像下面这样:</p>
<pre><code>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;title&gt;Hello&lt;/title&gt;
  &lt;/head&gt;

  &lt;body&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>初始化仓库、提交并push到Github:</p>
<pre><code>$ git init
$ git add .
$ git commit -a -m &apos;init commit.&apos;
$ git remote add origin
$ git push origin master
</code></pre><p>现在你打开 <code>username.github.com</code> 就可以看到刚才新建的页面了，就是这么简单。当然也可以为你的Blog仓库绑定独立域名，具体做法就是：</p>
<ol>
<li>在你的仓库中新建内容为 www.youdomain.com 的 CNAME 文件；</li>
<li>在你的域名管理页或者是DNS解析的地方，增加一个记录，记录类别为CNAME(Alias)类型.</li>
</ol>
<p><strong>Note：</strong> 如果你在CNAME中填写的是顶级域名，就得设置DNS的记录类别为A(Host)型，并设置主机为 <code>207.97.227.245</code>。详细介绍请移步Github的Pages页面。</p>
<p>接下来我们只需要按照自己的喜好设计页面。首先认识下jekyll的文件及目录配置:</p>
<pre><code>.
|-- _includes
|-- _plugins 
|-- _layout 
|   |-- default.html
|   `-- post.html
|-- _post
|   |-- yyyy-mm-dd-title.markdown
|   `-- yyyy-mm-dd-title.markdown
|-- _site
|-- _config.yml
`-- index.html
</code></pre><p><strong>_includes</strong>存放你需要在模板文件中包含的文件，你可以使用Liquid标签 <code>{‰ include file.ext ‰}</code>来引用相应的文件。</p>
<p><strong>_plugins</strong>可以增加你自己的插件</p>
<p><strong>_layout</strong>存放布局模板，请参考<a href="https://github.com/taberhuang/taberhuang.github.com/tree/master/_layouts" target="_blank" rel="external">https://github.com/taberhuang/taberhuang.github.com/tree/master/_layouts</a></p>
<p><strong>_post</strong>存放文章列表，文件命名一定要遵循 yyyy-mm-dd-title.html|markdown|textile 规则，请参考<a href="https://github.com/taberhuang/taberhuang.github.com/tree/master/_posts" target="_blank" rel="external">https://github.com/taberhuang/taberhuang.github.com/tree/master/_posts</a></p>
<p><strong>_sitejekyll</strong>自动生成的，所以可以忽略，如果你有在本地安装jekyll并预览了的话，可以使用.gitignore设置Git停止对本目录的跟踪。</p>
<p><strong>_config.yml</strong>设置经常使用的配置选项，这样在本地启动预览时就不用每次都手动输入了。</p>
<p><strong>index.html 和所有的 HTML/Markdown/Textile 文件</strong> 所有的HTML/Markdown/Textile文件都可以包含 YAML 配置，这类文件都会被jekyll解析。</p>
<p>现在你可以在自己的仓库中配置好你自己的目录及文件，也可以<code>clone</code>我的仓库，然后修改。</p>
<pre><code>$ git clone https://github.com/taberhuang/taberhuang.github.com.git
</code></pre><p>修改完后就可以<code>push</code>你的代码到Github上，看到结果了。刚才有说到本地预览，如果你想在本地预览后，确保没错误再<code>push</code>的话，就需要在本地安装jekyll，下面介绍下jekyll的安装方法。</p>
<p>一、安装Ruby运行环境和RubyGem:Windows用户只要下载 RubyInstaller。下载安装后请手动升级gem.</p>
<pre><code>$ gem update --system
</code></pre><p>二、安装DevKit。DevKit是windows平台编译和使用本地C/C++扩展包工具。用来模拟Linux平台下的 make,gcc,sh 进行编译。下载文件后，解压到 `C:\DevKit’，再通过命令行安装:</p>
<pre><code>$ cd C:\DevKit
$ ruby dk.rb init
$ ruby dk.rb install
</code></pre><p>三、安装并检查刚才的DevKit安装是否成功。如果成功安装，则DevKit也就安装成功，如果不成功，请重新安装DevKit。</p>
<pre><code>$ gem install jekyll
</code></pre><p>四、安装Rdiscount，这个是用来解析Markdown标记的解析包。如果你使用Textile的话，就是安装Kramdown。</p>
<p>  $ gem install rdiscount</p>
<p>所有的环境和依赖包都安装成功后，进入你的仓库目录，用下面的命令便可启动jekyll，并在本地预览了，预览地址默认为 <code>127.0.0.1:4000</code>，当然你也可以通过 _config.yml 配置:</p>
<pre><code>jekyll --server
</code></pre><p>是不是很爽?</p>
<p>参考及相关资料：</p>
<ul>
<li><a href="http://pages.github.com/" target="_blank" rel="external">http://pages.github.com/</a></li>
<li><a href="https://github.com/mojombo/jekyll/wiki" target="_blank" rel="external">https://github.com/mojombo/jekyll/wiki</a></li>
<li><a href="http://blog.envylabs.com/2009/08/publishing-a-blog-with-github-pages-and-jekyll/" target="_blank" rel="external">http://blog.envylabs.com/2009/08/publishing-a-blog-with-github-pages-and-jekyll/</a></li>
<li><a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">http://daringfireball.net/projects/markdown/syntax</a></li>
</ul>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[一个合格的程序员应该读过哪些书]]></title>
      <url>http://www.ezlippi.com/blog/2014/07/qualified-programmer-should-read-what-books.html</url>
      <content type="html"><![CDATA[<p>编者按：2008年8月4日，StackOverflow 网友 Bert F 发帖提问：哪本最具影响力的书，是每个程序员都应该读的？</p>
<blockquote>
<p>“如果能时光倒流，回到过去，作为一个开发人员，你可以告诉自己在职业生涯初期应该读一本，<br>你会选择哪本书呢？我希望这个书单列表内容丰富，可以涵盖很多东西。”</p>
</blockquote>
<p>很多<a href="http://coolshell.info" target="_blank" rel="external">程序员</a>响应，他们在推荐时也写下自己的评语。<br>以前就有国内网友介绍这个程序员书单，不过都是推荐数 Top 10的书。</p>
<p>其实除了前10本之外，推荐数前30左右的书籍都算经典，笔者整理编译这个问答贴，同时摘译部分推荐人的评语。<br><a id="more"></a><br>下面就按照各本书的推荐数排列。</p>
<h2 id="1、《代码大全》-史蒂夫·迈克康奈尔"><a href="#1、《代码大全》-史蒂夫·迈克康奈尔" class="headerlink" title="1、《代码大全》 史蒂夫·迈克康奈尔"></a>1、《<a href="http://t.cn/zOEs03N" target="_blank" rel="external">代码大全</a>》 史蒂夫·迈克康奈尔</h2><p>推荐数：1684</p>
<blockquote>
<p>“优秀的编程实践的百科全书，《<a href="http://t.cn/zOEs03N" target="_blank" rel="external">代码大全</a>》注重个人技术，其中所有东西加起来，<br>就是我们本能所说的“编写整洁的代码”。这本书有50页在谈论代码布局。” —— Joel Spolsky</p>
<p>对于新手来说，这本书中的观念有点高阶了。到你准备阅读此书时，你应该已经知道并实践过书中99%的观念。– esac</p>
</blockquote>
<p>Steve McConnell的原作《代码大全》(第1版)是公认的关于编程的最佳实践指南之一，<br>在过去的十多年间，本书一直在帮助开发人员编写更好的软件。</p>
<p>现在，作者将这本经典著作全新演绎，融入了最前沿的实践技术，加入了上百个崭新的代码示例，<br>充分展示了软件构建的艺术性和科学性。<br>McConnell汇集了来自研究机构、学术界以及业界日常实践的主要知识，<br>把最高效的技术和最重要的原理交织融会为这本既清晰又实用的指南。</p>
<p>无论您的经验水平如何，也不管您在怎样的开发环境中工作，也无论项目是大是小，<br>本书都将激发您的思维并帮助您构建高品质的代码。</p>
<p>《<a href="(http://t.cn/zOEs03N">代码大全（第2版）</a>)》做了全面的更新，增加了很多与时俱进的内容，包括对新语言、新的开发过程与方法论的讨论等等。</p>
<h2 id="2、《程序员修炼之道》"><a href="#2、《程序员修炼之道》" class="headerlink" title="2、《程序员修炼之道》"></a>2、《<a href="http://t.cn/zOEslD9" target="_blank" rel="external">程序员修炼之道</a>》</h2><p>推荐数：1504</p>
<p>对于那些已经学习过编程机制的程序员来说，这是一本卓越的书。<br>或许他们还是在校生，但对要自己做什么，还感觉不是很安全。</p>
<blockquote>
<p>就像草图和架构之间的差别。虽然你在学校课堂上学到的是画图，你也可以画的很漂亮，<br>但如果你觉得你不太知道从哪儿下手，如果某人要你独自画一个P2P的音乐交换网络图，那这本书就适合你了。—— Joel</p>
</blockquote>
<p>《程序员修炼之道:从小工到专家》内容简介：《程序员修炼之道》由一系列独立的部分组成，<br>涵盖的主题从个人责任、职业发展，知道用于使代码保持灵活、并且易于改编和复用的各种架构技术，<br>利用许多富有娱乐性的奇闻轶事、有思想性的例子及有趣的类比，<br>全面阐释了软件开发的许多不同方面的最佳实践和重大陷阱。</p>
<p>无论你是初学者，是有经验的程序员，还是软件项目经理，《程序员修炼之道:从小工到专家》都适合你阅读。</p>
<h2 id="3、《计算机程序的构造和解释》"><a href="#3、《计算机程序的构造和解释》" class="headerlink" title="3、《计算机程序的构造和解释》"></a>3、《<a href="http://t.cn/zOEsYcs" target="_blank" rel="external">计算机程序的构造和解释</a>》</h2><p>推荐数：916</p>
<p>就个人而言，这本书目前为止对我影响醉倒的一本编程书。</p>
<p>《代码大全》、《重构》和《设计模式》这些经典书会教给你高效的工作习惯和交易细节。<br>其他像《人件集》、《计算机编程心理学》和《人月神话》这些书会深入软件开发的心理层面。<br>其他书籍则处理算法。这些书都有自己所属的位置。</p>
<p>然而《计算机程序的构造和解释》与这些不同。<br>这是一本会启发你的书，它会燃起你编写出色程序的热情；<br>它还将教会你认识并欣赏美；<br>它会让你有种敬畏，让你难以抑制地渴望学习更多的东西。</p>
<p>其他书或许会让你成为一位更出色的程序员，但此书将一定会让你成为一名程序员。</p>
<p>同时，你将会学到其他东西，函数式编程（第三章）、惰性计算、元编程、虚拟机、解释器和编译器。</p>
<p>一些人认为此书不适合新手。<br>个人认为，虽然我并不完全认同要有一些编程经验才能读此书，但我还是一定推荐给初学者。<br>毕竟这本书是写给著名的6.001，是麻省理工学院的入门编程课程。<br>此书或许需要多做努力（尤其你在做练习的时候，你也应当如此），但这个价是对得起这本书的。</p>
<h2 id="4、《C程序设计语言》"><a href="#4、《C程序设计语言》" class="headerlink" title="4、《C程序设计语言》"></a>4、《<a href="http://t.cn/zOEsHqb" target="_blank" rel="external">C程序设计语言</a>》</h2><p>推荐数：774</p>
<blockquote>
<p>这本书简洁易读，会教给你三件事：C 编程语言；如何像程序员一样思考；底层计算模型。<br>（这对理解“底层”非常重要）—— Nathan</p>
</blockquote>
<p>《C程序设计语言》(第2版新版)讲述深入浅出，配合典型例证，通俗易懂，实用性强，<br>适合作为大专院校计算机专业或非计算机专业的C语言教材，也可以作为从事计算机相关软硬件开发的技术人员的参考书。</p>
<p>《C程序设计语言》(第2版新版)原著即为C语言的设计者之一Dennis M.Ritchie和著名的计算机科学家Brian W.Kernighan合著的<br>一本介绍C语言的权威经典著作。<br>我们现在见到的大量论述C语言程序设计的教材和专著均以此书为蓝本。<br>原著第1版中介绍的C语言成为后来广泛使用的C语言版本——标准C的基础。</p>
<p>人们熟知的“hello,world”程序就是由本书首次引入的，现在，这一程序已经成为所有程序设计语言入门的第一课。</p>
<h2 id="5、《算法导论》"><a href="#5、《算法导论》" class="headerlink" title="5、《算法导论》"></a>5、《<a href="http://t.cn/zOEsQAn" target="_blank" rel="external">算法导论</a>》</h2><p>推荐数：671</p>
<p>《代码大全》教你如何正确编程；<br>《人月神话》教你如何正确管理；<br>《设计模式》教你如何正确设计……</p>
<p>在我看来，代码只是一个工具，并非精髓。<br>开发软件的主要部分是创建新算法或重新实现现有算法。<br>其他部分则像重新组装乐高砖块或创建“管理”层。</p>
<blockquote>
<p>我依然梦想这样的工作，我的大部分时间（&gt;50%）是在写算法，其他“管理”细节则留给其他人…… —— Ran Biron</p>
</blockquote>
<ul><br><li>经典的算法书,被亚马逊网，《程序员》等评选为2006年最受读者喜爱的十大IT图书之一。</li><br><li>算法领域的标准教材，全球多所知名大学选用</li><br><li>MIT名师联手铸就，被誉为“计算机算法的圣经”</li><br><li>编写上采用了“五个一”，即一章介绍一个算法、一种设计技术、一个应用领域和一个相关话题。</li><br></ul>

<h2 id="6、《重构：改善既有代码的设计》"><a href="#6、《重构：改善既有代码的设计》" class="headerlink" title="6、《重构：改善既有代码的设计》"></a>6、《<a href="http://t.cn/zOEs8Lu" target="_blank" rel="external">重构：改善既有代码的设计</a>》</h2><p>推荐数：617</p>
<p>《重构:改善既有代码的设计》清晰地揭示了重构的过程，解释了重构的原理和最佳实践方式，<br>并给出了何时以及何地应该开始挖掘代码以求改善。<br>书中给出了70多个可行的重构，每个重构都介绍了一种经过验证的代码变换手法的动机和技术。</p>
<p>《重构:改善既有代码的设计》提出的重构准则将帮助你一次一小步地修改你的代码，从而减少了开发过程中的风险。</p>
<p>《重构:改善既有代码的设计》适合软件开发人员、项目管理人员等阅读，<br>也可作为高等院校计算机及相关专业师生的参考读物。</p>
<blockquote>
<p>我想我不得不推荐《重构》：改进现有代码的设计。—— Martin</p>
<p>我必须承认，我最喜欢的编程语录是出自这本书：任何一个傻瓜都能写出计算机能理解的程序，<br>而优秀的程序员却能写出别人能读得懂的程序。—— Martin Fowler</p>
</blockquote>
<h2 id="7、《设计模式》"><a href="#7、《设计模式》" class="headerlink" title="7、《设计模式》"></a>7、《<a href="http://t.cn/zOEs8k1" target="_blank" rel="external">设计模式</a>》</h2><p>推荐数：617</p>
<p>自1995年出版以来，本书一直名列Amazon和各大书店销售榜前列。<br>近10年后，本书仍是Addison-Wesley公司2003年最畅销的图书之一。<br>中文版销售逾4万册。</p>
<blockquote>
<p>就我而言，我认为四人帮编著的《设计模式》是一本极为有用的书。<br>虽然此书并不像其他建议一样有关“元”编程，但它强调封装诸如模式一类的优秀编程技术，<br>因而鼓励其他人提出新模式和反模式（antipatterns），并运用于编程对话中。—— Chris Jester-Young</p>
</blockquote>
<h2 id="8、《人月神话》"><a href="#8、《人月神话》" class="headerlink" title="8、《人月神话》"></a>8、《<a href="http://t.cn/zOEsR1z" target="_blank" rel="external">人月神话</a>》</h2><p>推荐数：588</p>
<p>在软件领域，很少能有像《人月神话》一样具有深远影响力并且畅销不衰的著作。</p>
<p>Brooks博士为人们管理复杂项目提供了最具洞察力的见解。<br>既有很多发人深省的观点，又有大量软件工程的实践。<br>本书内容来自Brooks博士在IBM公司System/360家族和OS/360中的项目管理经验。</p>
<p>该书英文原版一经面世，即引起业内人士的强烈反响，后又译为德、法、日、俄中等多种语言，全球销量数百万册。<br>确立了其在行业内的经典地位。</p>
<h2 id="9、《计算机程序设计艺术》"><a href="#9、《计算机程序设计艺术》" class="headerlink" title="9、《计算机程序设计艺术》"></a>9、《<a href="http://t.cn/zOEsExR" target="_blank" rel="external">计算机程序设计艺术</a>》</h2><p>推荐数：542</p>
<p>《计算机程序设计艺术》系列著作对计算机领域产生了深远的影响。<br>这一系列堪称一项浩大的工程，自1962年开始编写，计划出版7卷，目前已经出版了4卷。</p>
<p>《美国科学家》杂志曾将这套书与爱因斯坦的《相对论》等书并列称为20世纪最重要的12本物理学著作。<br>目前Knuth正将毕生精力投入到这部史诗性著作的撰写中。</p>
<blockquote>
<p>这是高德纳倾注心血写的一本书。—— Peter Coulton</p>
</blockquote>
<h2 id="10、《编译原理》（龙书）"><a href="#10、《编译原理》（龙书）" class="headerlink" title="10、《编译原理》（龙书）"></a>10、《<a href="http://t.cn/zOEsEFG" target="_blank" rel="external">编译原理</a>》（龙书）</h2><p>推荐数：462</p>
<p>我很奇怪，居然没人提到龙书。（或许已有推荐，我没有看到）。<br>我从没忘过此书的第一版封面。<br>此书让我知道了编译器是多么地神奇绝妙。- DB</p>
<h2 id="11、《深入浅出设计模式》"><a href="#11、《深入浅出设计模式》" class="headerlink" title="11、《深入浅出设计模式》"></a>11、《<a href="http://t.cn/zOnvX9N" target="_blank" rel="external">深入浅出设计模式</a>》</h2><p>推荐数：445</p>
<p>强大的写作阵容。</p>
<ul>
<li>《Head First设计模式》(中文版) 作者Eric Freeman；</li>
<li>ElElisabeth Freeman是作家、讲师和技术顾问。</li>
<li>Eric拥有耶鲁大学的计算机科学博士学位，E1isabath拥有耶鲁大学的计算机科学硕士学位。</li>
<li>Kathy Sierra(javaranch．com的创始人)FHBert Bates是畅销的HeadFirst系列书籍的创立者，也是Sun公司Java开发员认证考试的开发者。</li>
</ul>
<p>本书的产品设计应用神经生物学、认知科学，以及学习理论，这使得这本书能够将这些知识深深地印在你的脑海里，<br>不容易被遗忘。</p>
<p>本书的编写方式采用引导式教学，不直接告诉你该怎么做，而是利用故事当作引子，带领读者思考并想办法解决问题。<br>解决问题的过程中又会产生一些新的问题，再继续思考、继续解决问题，这样可以加深体会。</p>
<p>作者以大量的生活化故事当背景，例如第1章是鸭子，第2章是气象站，第3章是咖啡店，<br>书中搭配大量的插图(几乎每一页都有图)，所以阅读起来生动有趣，不会感觉到昏昏欲睡。</p>
<p>作者还利用歪歪斜斜的手写字体，增加“现场感”。<br>精心设计许多爆笑的对白，让学习过程不会太枯燥。<br>还有模式告白节目，将设计模式拟人化成节目来宾，畅谈其内在的一切。<br>每一章都有数目不等的测验题。<br>每章最后有一页要点整理，这也是精华所在，我都是利用这一页做复习。</p>
<blockquote>
<p>我知道四人帮的《设计模式》是一本标准书，但倒不如先看看这部大部头，此书更为简易。<br>一旦你了解了解了基本原则，可以去看四人帮的那本圣经了。- Calanus</p>
</blockquote>
<h2 id="12、《哥德尔、艾舍尔、巴赫书：集异璧之大成》"><a href="#12、《哥德尔、艾舍尔、巴赫书：集异璧之大成》" class="headerlink" title="12、《哥德尔、艾舍尔、巴赫书：集异璧之大成》"></a>12、《<a href="http://t.cn/zOEsu0d" target="_blank" rel="external">哥德尔、艾舍尔、巴赫书：集异璧之大成</a>》</h2><p>推荐数：437</p>
<p>如果下昂真正深入阅读，我推荐道格拉斯·侯世达（Douglas Hofstadter）的《哥德尔、艾舍尔、巴赫书》。<br>他极为深入研究了程序员每日都要面对的问题：递归、验证、证明和布尔代数。<br>这是一本很出色的读物，难度不大，偶尔有挑战，一旦你要鏖战到底，将是非常值得的。 – Jonik</p>
<h2 id="13、《代码整洁之道》"><a href="#13、《代码整洁之道》" class="headerlink" title="13、《代码整洁之道》"></a>13、《<a href="http://t.cn/zOEs3tt" target="_blank" rel="external">代码整洁之道</a>》</h2><p>推荐数：329</p>
<p>细节之中自有天地，整洁成就卓越代码</p>
<p>尽管糟糕的代码也能运行，但如果代码不整洁，会使整个开发团队泥足深陷，<br>写得不好的代码每年都要耗费难以计数的时间和资源。<br>然而这种情况并非无法避免。</p>
<p>著名软件专家RoberfC.Marlin在《代码整洁之道》中为你呈现出了革命性的视野。<br>Martin携同ObjectMetltor公司的同事，从他们有关整洁代码的最佳敏捷实践中提炼出软件技艺的价值观，<br>以飨读者，让你成为更优秀的程序员——只要你着手研读《代码整洁之道》。</p>
<p>阅读《代码整洁之道》需要你做些什么呢？你将阅读代码——大量代码。<br>《代码整洁之道》促使你思考代码中何谓正确，何谓错误。<br>更重要的是，《代码整洁之道》将促使你重新评估自己的专业价值观，以及对自己技艺的承诺。</p>
<p>从《代码整洁之道》中可以学到：</p>
<ul><br><li>好代码和糟糕的代码之间的区别；</li><br><li>如何编写好代码，如何将糟糕的代码转化为好代码；</li><br><li>如何创建好名称、好函数、好对象和好类；</li><br><li>如何格式化代码以实现其可读性的最大化；</li><br><li>如何在不妨碍代码逻辑的前提下充分实现错误处理；</li><br><li>如何进行单元测试和测试驱动开发。</li><br></ul>

<blockquote>
<p>虽然《代码整洁之道》和《代码大全》有很多共同之处，但它有更为简洁更为实际的清晰例子。 – Craig P. Motlin</p>
</blockquote>
<h2 id="14、《Effective-C-》和《More-Effective-C-》"><a href="#14、《Effective-C-》和《More-Effective-C-》" class="headerlink" title="14、《Effective C++》和《More Effective C++》"></a>14、《<a href="http://t.cn/zOEs1Mw" target="_blank" rel="external">Effective C++</a>》和《<a href="http://t.cn/zOEsBvc" target="_blank" rel="external">More Effective C++</a>》</h2><p>推荐数：297</p>
<p>在我职业生涯早期，Scott Meyer的《Effective C++》和后续的《More Effective C++》都对我的编程能力有着直接影响。<br>正如当时的一位朋友所说，这些书缩短你培养编程技能的过程，而其他人可能要花费数年。</p>
<p>去年对我影响最大的一本书是《大教堂与市集》，该书教会我很有关开源开发过程如何运作，和如何处理我代码中的Bug。 – John Channing</p>
<h2 id="15、《编程珠玑》"><a href="#15、《编程珠玑》" class="headerlink" title="15、《编程珠玑》"></a>15、《<a href="http://t.cn/zOEsBur" target="_blank" rel="external">编程珠玑</a>》</h2><p>推荐数：282</p>
<p>多年以来，当程序员们推选出最心爱的计算机图书时，《编程珠玑》总是位列前列。<br>正如自然界里珍珠出自细沙对牡蛎的磨砺，计算机科学大师Jon Bentley以其独有的洞察力和创造力，<br>从磨砺程序员的实际问题中凝结出一篇篇不朽的编程“珠玑”，<br>成为世界计算机界名刊《ACM通讯》历史上最受欢迎的专栏，<br>最终结集为两部不朽的计算机科学经典名著，影响和激励着一代又一代程序员和计算机科学工作者。</p>
<p>本书为第一卷，主要讨论计算机科学中最本质的问题：如何正确选择和高效地实现算法。</p>
<blockquote>
<p>尽管我不得不羞愧地承认，书中一半的东西我都没有理解，但我真的推荐《编程珠玑》，书中有些令人惊奇的东西。 – Matt Warren</p>
</blockquote>
<h2 id="16、《修改代码的艺术》by-Michael-Feathers"><a href="#16、《修改代码的艺术》by-Michael-Feathers" class="headerlink" title="16、《修改代码的艺术》by Michael Feathers"></a>16、《<a href="http://t.cn/zOEsgC0" target="_blank" rel="external">修改代码的艺术</a>》by Michael Feathers</h2><p>本书是继《重构》和《重构与模式》之后探讨修改代码技术的又一里程碑式的著作，<br>而且从涵盖面和深度上都超过了前两部经典。<br>书中不仅讲述面向对象语言（Java、C#和C++）代码，也有专章讨论C这样的过程式语言。</p>
<p>作者将理解、测试和修改代码的原理、技术和最新工具（自动化重构工具、单元测试框架、仿对象、集成测试框架等），<br>与解依赖技术和大量开发和设计优秀代码的原则、最佳实践相结合，许多内容非常深入，而且常常发前人所未发。</p>
<p>书中处处体现出作者独到的洞察力，以及多年开发和指导软件项目所积累的丰富经验和深厚功力。<br>通过这部集大成之作，你不仅能掌握最顶尖的修改代码技术，还可以大大提高对代码和软件开发的领悟力。</p>
<blockquote>
<p>我认为没有任何一本书能向这本书一样影响了我的编程观点。<br>它明确地告诉你如何处理其他人的代码，含蓄地教会你避免哪些（以及为什么要避免）。- Wolfbyte</p>
<p>同意。很多开发人员讨论用干净的石板来编写软件。<br>但我想几乎所有开发人员的某些时候是在吃其他开发人员的狗食。– Bernard Dy</p>
</blockquote>
<h2 id="17、《编码：隐匿在计算机软硬件背后的语言》"><a href="#17、《编码：隐匿在计算机软硬件背后的语言》" class="headerlink" title="17、《编码：隐匿在计算机软硬件背后的语言》"></a>17、《<a href="http://t.cn/zOEseyX" target="_blank" rel="external">编码：隐匿在计算机软硬件背后的语言</a>》</h2><p>这是一本讲述计算机工作原理的书。</p>
<p>不过，你千万不要因为“工作原理”之类的字眼就武断地认为，它是晦涩而难懂的。<br>作者用丰富的想象和清晰的笔墨将看似繁杂的理论阐述得通俗易懂，你丝毫不会感到枯燥和生硬。<br>更重要的是，你会因此而获得对计算机工作原理较深刻的理解。<br>这种理解不是抽象层面上的，而是具有一定深度的，这种深度甚至不逊于“电气工程师”和“程序员”的理解。</p>
<p>不管你是计算机高手，还是对这个神奇的机器充满敬畏之心的菜鸟，<br>都不妨翻阅一下《编码:隐匿在计算机软硬件背后的语言》，读一读大师的经典作品，必然会有收获。</p>
<blockquote>
<p>我推荐Charles Petzold的《编码》。<br>在这个充满工具和IDE的年代，很多复杂度已经从程序员那“抽取”走了，这本书一本开眼之作。 – hemil</p>
</blockquote>
<h2 id="18、《禅与摩托车维修艺术-Zen-and-the-Art-of-Motorcycle-Maintenance》"><a href="#18、《禅与摩托车维修艺术-Zen-and-the-Art-of-Motorcycle-Maintenance》" class="headerlink" title="18、《禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance》"></a>18、《<a href="http://t.cn/zOEsDwc" target="_blank" rel="external">禅与摩托车维修艺术 / Zen and the Art of Motorcycle Maintenance</a>》</h2><blockquote>
<p>对我影响最大的那本书是 Robert Pirsig 的《禅与摩托车维修艺术》。<br>不管你做什么事，总是要力求完美，彻底了解你手中的工具和任务，更为重要的是，<br>要有乐趣（因为如果你做事有乐趣，一切将自发引向更好的结果）。 – akr</p>
</blockquote>
<h2 id="19、《Peopleware-人件集-人性化的软件开发》"><a href="#19、《Peopleware-人件集-人性化的软件开发》" class="headerlink" title="19、《Peopleware / 人件集:人性化的软件开发》"></a>19、《<a href="http://t.cn/zOEskvE" target="_blank" rel="external">Peopleware / 人件集:人性化的软件开发</a>》</h2><blockquote>
<p>Demarco 和 Lister 表明，软件开发中的首要问题是人，并非技术。<br>他们的答案并不简单，只是令人难以置信的成功。<br>第二版新增加了八章内容。 – Eduardo Molteni</p>
</blockquote>
<h2 id="20、《Coders-at-Work-编程人生》"><a href="#20、《Coders-at-Work-编程人生》" class="headerlink" title="20、《Coders at Work / 编程人生》"></a>20、《<a href="http://t.cn/zOEskjT" target="_blank" rel="external">Coders at Work / 编程人生</a>》</h2><p>这是一本访谈笔录，记录了当今最具个人魅力的15位软件先驱的编程生涯。<br>包括DonaldKnuth、Jamie Zawinski、Joshua Bloch、Ken Thompson等在内的业界传奇人物，为我们讲述了<br>他们是怎么学习编程的，在编程过程中发现了什么以及他们对未来的看法，<br>并对诸如应该如何设计软件等长久以来一直困扰很多程序员的问题谈了自己的观点。</p>
<blockquote>
<p>一本非常有影响力的书，可以从中学到一些业界顶级人士的经验，了解他们如何思考并工作。 – Jahanzeb Farooq</p>
</blockquote>
<h2 id="21、《Surely-You’re-Joking-Mr-Feynman-别闹了，费曼先生！》"><a href="#21、《Surely-You’re-Joking-Mr-Feynman-别闹了，费曼先生！》" class="headerlink" title="21、《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》"></a>21、《Surely You’re Joking, Mr. Feynman! / 别闹了，费曼先生！》</h2><blockquote>
<p>虽然这本书可能有点偏题，但不管你信不信，这本书曾在计算机科学专业课程的阅读列表之上。<br>一个优秀的角色模型，一本有关好奇心的优秀书籍。 – mike511</p>
</blockquote>
<h2 id="22、《Effective-Java-中文版》"><a href="#22、《Effective-Java-中文版》" class="headerlink" title="22、《Effective Java 中文版》"></a>22、《<a href="http://t.cn/zOnvvoV" target="_blank" rel="external">Effective Java 中文版</a>》</h2><blockquote>
<p>此书第二版教你如何编写漂亮并高效的代码，虽然这是一本Java书，但其中有很多跨语言的理念。 – Marcio Aguiar</p>
</blockquote>
<h2 id="23、《Patterns-of-Enterprise-Application-Architecture-企业应用架构模式》"><a href="#23、《Patterns-of-Enterprise-Application-Architecture-企业应用架构模式》" class="headerlink" title="23、《Patterns of Enterprise Application Architecture / 企业应用架构模式》"></a>23、《<a href="http://t.cn/zOnvP4i" target="_blank" rel="external">Patterns of Enterprise Application Architecture / 企业应用架构模式</a>》</h2><p>很奇怪，还没人推荐 Martin Fowler 的《企业应用架构模式》- levi rosol</p>
<h2 id="24、《The-Little-Schemer》和《The-Seasoned-Schemer》-nmiranda"><a href="#24、《The-Little-Schemer》和《The-Seasoned-Schemer》-nmiranda" class="headerlink" title="24、《The Little Schemer》和《The Seasoned Schemer》 nmiranda"></a>24、《The Little Schemer》和《The Seasoned Schemer》 nmiranda</h2><p>这两本是LISP的英文书，尚无中文版。<br>美国东北大学网站上也有电子版。</p>
<h2 id="25、《交互设计之路》英文名：《The-Inmates-Are-Running-The-Asylum-Why-High-Tech-Products-Drive-Us-Crazy-and-How-to-Restore-the-Sanity》该书作者：Alan-Cooper，人称Visual-Basic之父，交互设计之父。"><a href="#25、《交互设计之路》英文名：《The-Inmates-Are-Running-The-Asylum-Why-High-Tech-Products-Drive-Us-Crazy-and-How-to-Restore-the-Sanity》该书作者：Alan-Cooper，人称Visual-Basic之父，交互设计之父。" class="headerlink" title="25、《交互设计之路》英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。"></a>25、《交互设计之路》英文名：《The Inmates Are Running The Asylum: Why High Tech Products Drive Us Crazy and How to Restore the Sanity》该书作者：Alan Cooper，人称Visual Basic之父，交互设计之父。</h2><p>本书是基于众多商务案例，讲述如何创建更好的、高客户忠诚度的软件产品和基于软件的高科技产品的书。<br>本书列举了很多真实可信的实际例子，说明目前在软件产品和基于软件的高科技产品中，普遍存在着“难用”的问题。</p>
<p>作者认为，“难用”问题是由这些产品中存在着的高度“认知摩擦”引起的，<br>而产生这个问题的根源在于现今软件开发过程中欠缺了一个为用户利益着想的前期“交互设计”阶段。<br>“难用”的产品不仅损害了用户的利益，最终也将导致企业的失败。</p>
<p>本书通过一些生动的实例，让人信服地讲述了由作者倡导的“目标导向”交互设计方法在解决“难用”问题方面的有效性，<br>证实了只有改变现有观念，才能有效地在开发过程中引入交互设计，将产品的设计引向成功。</p>
<p>本书虽然是一本面向商务人员而编写的书，但也适合于所有参与软件产品和基于软件的高科技产品开发的专业人士，<br>以及关心软件行业和高科技行业现状与发展的人士阅读。</p>
<p>他还有另一本中文版著作：《About Face 3 交互设计精髓》</p>
<h2 id="26、《Why’s-Poignant-Guide-to-Ruby-》"><a href="#26、《Why’s-Poignant-Guide-to-Ruby-》" class="headerlink" title="26、《Why’s (Poignant) Guide to Ruby 》"></a>26、《Why’s (Poignant) Guide to Ruby 》</h2><p>如果你不是程序员，阅读此书可能会很有趣，但如果你已经是个程序员，可能会有点乏味。</p>
<h2 id="27、《Unix编程艺术》"><a href="#27、《Unix编程艺术》" class="headerlink" title="27、《Unix编程艺术》"></a>27、《Unix编程艺术》</h2><blockquote>
<p>It is useful regardless operating system you use. – J.F. Sebastian</p>
<p>不管你使用什么操作系统，这本书都很有用。 – J.F. Sebastian</p>
</blockquote>
<h2 id="28、《高效程序员的45个习惯：敏捷开发修炼之道》"><a href="#28、《高效程序员的45个习惯：敏捷开发修炼之道》" class="headerlink" title="28、《高效程序员的45个习惯：敏捷开发修炼之道》"></a>28、《<a href="http://t.cn/zOnvhRM" target="_blank" rel="external">高效程序员的45个习惯：敏捷开发修炼之道</a>》</h2><p>45个习惯，分为7个方面：工作态度、学习、软件交付、反馈、编码、调试和协作。</p>
<p>每一个具体的习惯里，一开始提出一个谬论，然后展开分析，之后有正队性地提出正确的做法，并设身处地地讲出了正确做法给你个人的“切身感受”，最后列出几条注意事项，帮助你修正自己的做法（“平衡的艺术”）。</p>
<h2 id="29、《测试驱动开发》"><a href="#29、《测试驱动开发》" class="headerlink" title="29、《测试驱动开发》"></a>29、《<a href="http://t.cn/zOnvzK7" target="_blank" rel="external">测试驱动开发</a>》</h2><blockquote>
<p>前面已经提到的很多书都启发了我，并影响了我，但这本书每位程序员都应该读。<br>它向我展示了单元测试和TDD的重要性，并让我很快上手。 – Curro</p>
<p>我不关心你的代码有多好或优雅。<br>如果你没有测试，你或许就如同没有编写代码。<br>这本书得到的推荐数应该更高些。<br>人们讨论编写用户喜欢的软件，或既设计出色并健壮的高效代码，但如果你的软件有一堆bug，谈论那些东西毫无意义。– Adam Gent</p>
</blockquote>
<h2 id="30、《点石成金-访客至上的网页设计秘笈》"><a href="#30、《点石成金-访客至上的网页设计秘笈》" class="headerlink" title="30、《点石成金:访客至上的网页设计秘笈》"></a>30、《<a href="http://t.cn/zOnvZYq" target="_blank" rel="external">点石成金:访客至上的网页设计秘笈</a>》</h2><p>可用性设计是Web设计中最重要也是难度最大的一项任务。<br>《点石成金－访客至上的网页设计秘笈（原书第二版）》作者根据多年从业的经验，剖析用户的心理，<br>在用户使用的模式、为扫描进行设计、导航设计、主页布局、可用性测试等方面提出了许多独特的观点，<br>并给出了大量简单、易行的可用性设计的建议。</p>
<p>本书短小精炼，语言轻松诙谐，书中穿插大量色彩丰富的屏幕截图、趣味丛生的卡通插图以及包含大量信息的图表，<br>使枯燥的设计原理变得平易近人。</p>
<p>本书适合从事Web设计和Web开发的技术人员阅读，特别适合为如何留住访问者而苦恼的网站/网页设计人员阅读。<br>这是一本关于Web设计原则而不是Web设计技术的书。</p>
<p>本书作者是Web设计专家，具有丰富的实践经验。<br>他用幽默的语言为你揭示Web设计中重要但却容易被忽视的问题，只需几个小时，<br>你便能对照书中讲授的设计原则找到网站设计的症结所在，令你的网站焕然一新。</p>
<blockquote>
<p>取决于你所追求的目标。<br>我喜欢《代码大全》是因纯编程，《点石成金》是一本有关UI设计的卓越书籍。 – Justin Standard</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Markdown 语法 (简体中文版)]]></title>
      <url>http://www.ezlippi.com/blog/2014/07/markdown-syntax.html</url>
      <content type="html"><![CDATA[<p><strong>NOTE:</strong> This is Simplelified  Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to <a href="http://daringfireball.net/projects/markdown/syntax" target="_blank" rel="external">Markdown: Syntax</a>.</p>
<h1 id="Markdown-语法说明-简体中文版-点击查看快速入门"><a href="#Markdown-语法说明-简体中文版-点击查看快速入门" class="headerlink" title="Markdown 语法说明 (简体中文版) / (点击查看快速入门)"></a>Markdown 语法说明 (简体中文版) / (<a href="./markdown-basics.html">点击查看快速入门</a>)</h1><ul>
<li><a href="#overview">概述</a><ul>
<li><a href="#philosophy">宗旨</a></li>
<li><a href="#html">兼容 HTML</a></li>
<li><a href="#autoescape">特殊字符自动转换</a></li>
</ul>
</li>
<li><a href="#block">区块元素</a><ul>
<li><a href="#p">段落和换行</a></li>
<li><a href="#header">标题</a></li>
<li><a href="#blockquote">区块引用</a></li>
<li><a href="#list">列表</a></li>
<li><a href="#precode">代码区块</a></li>
<li><a href="#hr">分隔线</a></li>
</ul>
</li>
<li><a href="#span">区段元素</a><ul>
<li><a href="#link">链接</a></li>
<li><a href="#em">强调</a></li>
<li><a href="#code">代码</a></li>
<li><a href="#img">图片</a></li>
</ul>
</li>
<li><a href="#misc">其它</a><ul>
<li><a href="#backslash">反斜杠</a></li>
<li><a href="#autolink">自动链接</a></li>
</ul>
</li>
<li><a href="#acknowledgement">感谢</a></li>
</ul>
<hr>
<h2 id="overview">概述</h2>

<h3 id="philosophy">宗旨</h3>

<p>Markdown 的目标是实现「易读易写」。</p>
<p>可读性，无论如何，都是最重要的。一份使用 Markdown 格式撰写的文件应该可以直接以纯文本发布，并且看起来不会像是由许多标签或是格式指令所构成。Markdown 语法受到一些既有 text-to-HTML 格式的影响，包括 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a>、<a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a>、<a href="http://textism.com/tools/textile/" target="_blank" rel="external">Textile</a>、<a href="http://docutils.sourceforge.net/rst.html" target="_blank" rel="external">reStructuredText</a>、<a href="http://www.triptico.com/software/grutatxt.html" target="_blank" rel="external">Grutatext</a> 和 <a href="http://ettext.taint.org/doc/" target="_blank" rel="external">EtText</a>，而最大灵感来源其实是纯文本电子邮件的格式。</p>
<p>总之， Markdown 的语法全由一些符号所组成，这些符号经过精挑细选，其作用一目了然。比如：在文字两旁加上星号，看起来就像*强调*。Markdown 的列表看起来，嗯，就是列表。Markdown 的区块引用看起来就真的像是引用一段文字，就像你曾在电子邮件中见过的那样。</p>
<h3 id="html">兼容 HTML</h3>

<p>Markdown 语法的目标是：成为一种适用于网络的<em>书写</em>语言。</p>
<p>Markdown 不是想要取代 HTML，甚至也没有要和它相近，它的语法种类很少，只对应 HTML 标记的一小部分。Markdown 的构想<em>不是</em>要使得 HTML 文档更容易书写。在我看来， HTML 已经很容易写了。Markdown 的理念是，能让文档更容易读、写和随意改。HTML 是一种<em>发布</em>的格式，Markdown 是一种<em>书写</em>的格式。就这样，Markdown 的格式语法只涵盖纯文本可以涵盖的范围。</p>
<p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。不需要额外标注这是 HTML 或是 Markdown；只要直接加标签就可以了。</p>
<p>要制约的只有一些 HTML 区块元素――比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行与其它内容区隔开，还要求它们的开始标签与结尾标签不能用制表符或空格来缩进。Markdown 的生成器有足够智能，不会在 HTML 区块标签外加上不必要的 <code>&lt;p&gt;</code> 标签。</p>
<p>例子如下，在 Markdown 文件里加上一段 HTML 表格：</p>
<pre><code>这是一个普通段落。

&lt;table&gt;
    &lt;tr&gt;
        &lt;td&gt;Foo&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

这是另一个普通段落。
</code></pre><p>请注意，在 HTML 区块标签间的 Markdown 格式语法将不会被处理。比如，你在 HTML 区块内使用 Markdown 样式的<code>*强调*</code>会没有效果。</p>
<p>HTML 的区段（行内）标签如 <code>&lt;span&gt;</code>、<code>&lt;cite&gt;</code>、<code>&lt;del&gt;</code> 可以在 Markdown 的段落、列表或是标题里随意使用。依照个人习惯，甚至可以不用 Markdown 格式，而直接采用 HTML 标签来格式化。举例说明：如果比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签，可以直接使用这些标签，而不用 Markdown 提供的链接或是图像标签语法。</p>
<p>和处在 HTML 区块标签间不同，Markdown 语法在 HTML 区段标签间是有效的。</p>
<h3 id="autoescape">特殊字符自动转换</h3>

<p>在 HTML 文件中，有两个字符需要特殊处理： <code>&lt;</code> 和 <code>&amp;</code> 。 <code>&lt;</code> 符号用于起始标签，<code>&amp;</code> 符号则用于标记 HTML 实体，如果你只是想要显示这些字符的原型，你必须要使用实体的形式，像是 <code>&amp;lt;</code> 和 <code>&amp;amp;</code>。</p>
<p><code>&amp;</code> 字符尤其让网络文档编写者受折磨，如果你要打「<code>AT&amp;T</code>」 ，你必须要写成「<code>AT&amp;amp;T</code>」。而网址中的 <code>&amp;</code> 字符也要转换。比如你要链接到：</p>
<pre><code>http://images.google.com/images?num=30&amp;q=larry+bird
</code></pre><p>你必须要把网址转换写为：</p>
<pre><code>http://images.google.com/images?num=30&amp;amp;q=larry+bird
</code></pre><p>才能放到链接标签的 <code>href</code> 属性里。不用说也知道这很容易忽略，这也可能是 HTML 标准检验所检查到的错误中，数量最多的。</p>
<p>Markdown 让你可以自然地书写字符，需要转换的由它来处理好了。如果你使用的 <code>&amp;</code> 字符是 HTML 字符实体的一部分，它会保留原状，否则它会被转换成 <code>&amp;amp</code>;。</p>
<p>所以你如果要在文档中插入一个版权符号 <code>©</code>，你可以这样写：</p>
<pre><code>&amp;copy;
</code></pre><p>Markdown 会保留它不动。而若你写：</p>
<pre><code>AT&amp;T
</code></pre><p>Markdown 就会将它转为：</p>
<pre><code>AT&amp;amp;T
</code></pre><p>类似的状况也会发生在 <code>&lt;</code> 符号上，因为 Markdown 允许 <a href="#html">兼容 HTML</a> ，如果你是把 <code>&lt;</code> 符号作为 HTML 标签的定界符使用，那 Markdown 也不会对它做任何转换，但是如果你写：</p>
<pre><code>4 &lt; 5
</code></pre><p>Markdown 将会把它转换为：</p>
<pre><code>4 &amp;lt; 5
</code></pre><p>不过需要注意的是，code 范围内，不论是行内还是区块， <code>&lt;</code> 和 <code>&amp;</code> 两个符号都<em>一定</em>会被转换成 HTML 实体，这项特性让你可以很容易地用 Markdown 写 HTML code （和 HTML 相对而言， HTML 语法中，你要把所有的 <code>&lt;</code> 和 <code>&amp;</code> 都转换为 HTML 实体，才能在 HTML 文件里面写出 HTML code。）</p>
<hr>
<h2 id="block">区块元素</h2>


<h3 id="p">段落和换行</h3>

<p>一个 Markdown 段落是由一个或多个连续的文本行组成，它的前后要有一个以上的空行（空行的定义是显示上看起来像是空的，便会被视为空行。比方说，若某一行只包含空格和制表符，则该行也会被视为空行）。普通段落不该用空格或制表符来缩进。</p>
<p>「由一个或多个连续的文本行组成」这句话其实暗示了 Markdown 允许段落内的强迫换行（插入换行符），这个特性和其他大部分的 text-to-HTML 格式不一样（包括 Movable Type 的「Convert Line Breaks」选项），其它的格式会把每个换行符都转成 <code>&lt;br /&gt;</code> 标签。</p>
<p>如果你<em>确实</em>想要依赖 Markdown 来插入 <code>&lt;br /&gt;</code> 标签的话，在插入处先按入两个以上的空格然后回车。</p>
<p>的确，需要多费点事（多加空格）来产生 <code>&lt;br /&gt;</code> ，但是简单地「每个换行都转换为 <code>&lt;br /&gt;</code>」的方法在 Markdown 中并不适合， Markdown 中 email 式的 <a href="#blockquote">区块引用</a> 和多段落的 <a href="#list">列表</a> 在使用换行来排版的时候，不但更好用，还更方便阅读。</p>
<h3 id="header">标题</h3>

<p>Markdown 支持两种标题的语法，类 <a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和类 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。</p>
<p>类 Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），例如：</p>
<pre><code>This is an H1
=============

This is an H2
-------------
</code></pre><p>任何数量的 <code>=</code> 和 <code>-</code> 都可以有效果。</p>
<p>类 Atx 形式则是在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶，例如：</p>
<pre><code># 这是 H1

## 这是 H2

###### 这是 H6
</code></pre><p>你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 <code>#</code>，而行尾的 <code>#</code> 数量也不用和开头一样（行首的井字符数量决定标题的阶数）：</p>
<pre><code># 这是 H1 #

## 这是 H2 ##

### 这是 H3 ######
</code></pre><h3 id="blockquote">区块引用 Blockquotes</h3>

<p>Markdown 标记区块引用是使用类似 email 中用 <code>&gt;</code> 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.
&gt; 
&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
&gt; id sem consectetuer libero luctus adipiscing.
</code></pre><p>Markdown 也允许你偷懒只在整个段落的第一行最前面加上 <code>&gt;</code> ：</p>
<pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.

&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.
</code></pre><p>区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 <code>&gt;</code> ：</p>
<pre><code>&gt; This is the first level of quoting.
&gt;
&gt; &gt; This is nested blockquote.
&gt;
&gt; Back to the first level.
</code></pre><p>引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等：</p>
<pre><code>&gt; ## 这是一个标题。
&gt; 
&gt; 1.   这是第一行列表项。
&gt; 2.   这是第二行列表项。
&gt; 
&gt; 给出一些例子代码：
&gt; 
&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);
</code></pre><p>任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择<em>增加引用阶层</em>。</p>
<h3 id="list">列表</h3>

<p>Markdown 支持有序列表和无序列表。</p>
<p>无序列表使用星号、加号或是减号作为列表标记：</p>
<pre><code>*   Red
*   Green
*   Blue
</code></pre><p>等同于：</p>
<pre><code>+   Red
+   Green
+   Blue
</code></pre><p>也等同于：</p>
<pre><code>-   Red
-   Green
-   Blue
</code></pre><p>有序列表则使用数字接着一个英文句点：</p>
<pre><code>1.  Bird
2.  McHale
3.  Parish
</code></pre><p>很重要的一点是，你在列表标记上使用的数字并不会影响输出的 HTML 结果，上面的列表所产生的 HTML 标记为：</p>
<pre><code>&lt;ol&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;McHale&lt;/li&gt;
&lt;li&gt;Parish&lt;/li&gt;
&lt;/ol&gt;
</code></pre><p>如果你的列表标记写成：</p>
<pre><code>1.  Bird
1.  McHale
1.  Parish
</code></pre><p>或甚至是：</p>
<pre><code>3. Bird
1. McHale
8. Parish
</code></pre><p>你都会得到完全相同的 HTML 输出。重点在于，你可以让 Markdown 文件的列表数字和输出的结果相同，或是你懒一点，你可以完全不用在意数字的正确性。</p>
<p>如果你使用懒惰的写法，建议第一个项目最好还是从 1. 开始，因为 Markdown 未来可能会支持有序列表的 start 属性。</p>
<p>列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。</p>
<p>要让列表看起来更漂亮，你可以把内容用固定的缩进整理好：</p>
<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
    Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
    viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
    Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>但是如果你懒，那也行：</p>
<pre><code>*   Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,
viverra nec, fringilla in, laoreet vitae, risus.
*   Donec sit amet nisl. Aliquam semper ipsum sit amet velit.
Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果列表项目间用空行分开，在输出 HTML 时 Markdown 就会将项目内容用 <code>&lt;p&gt;</code><br>标签包起来，举例来说：</p>
<pre><code>*   Bird
*   Magic
</code></pre><p>会被转换为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;Bird&lt;/li&gt;
&lt;li&gt;Magic&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>但是这个：</p>
<pre><code>*   Bird

*   Magic
</code></pre><p>会被转换为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符：</p>
<pre><code>1.  This is a list item with two paragraphs. Lorem ipsum dolor
    sit amet, consectetuer adipiscing elit. Aliquam hendrerit
    mi posuere lectus.

    Vestibulum enim wisi, viverra nec, fringilla in, laoreet
    vitae, risus. Donec sit amet nisl. Aliquam semper ipsum
    sit amet velit.

2.  Suspendisse id sem consectetuer libero luctus adipiscing.
</code></pre><p>如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许：</p>
<pre><code>*   This is a list item with two paragraphs.

    This is the second paragraph in the list item. You&apos;re
only required to indent the first line. Lorem ipsum dolor
sit amet, consectetuer adipiscing elit.

*   Another item in the same list.
</code></pre><p>如果要在列表项目内放进引用，那 <code>&gt;</code> 就需要缩进：</p>
<pre><code>*   A list item with a blockquote:

    &gt; This is a blockquote
    &gt; inside a list item.
</code></pre><p>如果要放代码区块的话，该区块就需要缩进<em>两次</em>，也就是 8 个空格或是 2 个制表符：</p>
<pre><code>*   一列表项包含一个列表区块：

        &lt;代码写在这&gt;
</code></pre><p>当然，项目列表很可能会不小心产生，像是下面这样的写法：</p>
<pre><code>1986. What a great season.
</code></pre><p>换句话说，也就是在行首出现<em>数字-句点-空白</em>，要避免这样的状况，你可以在句点前面加上反斜杠。</p>
<pre><code>1986\. What a great season.
</code></pre><h3 id="precode">代码区块</h3>

<p>和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 <code>&lt;pre&gt;</code> 和 <code>&lt;code&gt;</code> 标签来把代码区块包起来。</p>
<p>要在 Markdown 中建立代码区块很简单，只要简单地缩进 4 个空格或是 1 个制表符就可以，例如，下面的输入：</p>
<pre><code>这是一个普通段落：

    这是一个代码区块。
</code></pre><p>Markdown 会转换成：</p>
<pre><code>&lt;p&gt;这是一个普通段落：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;这是一个代码区块。
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>这个每行一阶的缩进（4 个空格或是 1 个制表符），都会被移除，例如：</p>
<pre><code>Here is an example of AppleScript:

    tell application &quot;Foo&quot;
        beep
    end tell
</code></pre><p>会被转换为：</p>
<pre><code>&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot;
    beep
end tell
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>一个代码区块会一直持续到没有缩进的那一行（或是文件结尾）。</p>
<p>在代码区块里面， <code>&amp;</code> 、 <code>&lt;</code> 和 <code>&gt;</code> 会自动转成 HTML 实体，这样的方式让你非常容易使用 Markdown 插入范例用的 HTML 原始码，只需要复制贴上，再加上缩进就可以了，剩下的 Markdown 都会帮你处理，例如：</p>
<pre><code>&lt;div class=&quot;footer&quot;&gt;
    &amp;copy; 2004 Foo Corporation
&lt;/div&gt;
</code></pre><p>会被转换为：</p>
<pre><code>&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt;
    &amp;amp;copy; 2004 Foo Corporation
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre><p>代码区块中，一般的 Markdown 语法不会被转换，像是星号便只是星号，这表示你可以很容易地以 Markdown 语法撰写 Markdown 语法相关的文件。</p>
<h3 id="hr">分隔线</h3>

<p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p>
<pre><code>* * *

***

*****

- - -

---------------------------------------
</code></pre><hr>
<h2 id="span">区段元素</h2>

<h3 id="link">链接</h3>

<p>Markdown 支持两种形式的链接语法： <em>行内式</em>和<em>参考式</em>两种形式。</p>
<p>不管是哪一种，链接文字都是用 [方括号] 来标记。</p>
<p>要建立一个<em>行内式</em>的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，如果你还想要加上链接的 title 文字，只要在网址后面，用双引号把 title 文字包起来即可，例如：</p>
<pre><code>This is [an example](http://example.com/ &quot;Title&quot;) inline link.

[This link](http://example.net/) has no title attribute.
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;
an example&lt;/a&gt; inline link.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has no
title attribute.&lt;/p&gt;
</code></pre><p>如果你是要链接到同样主机的资源，你可以使用相对路径：</p>
<pre><code>See my [About](/about/) page for details.   
</code></pre><p><em>参考式</em>的链接是在链接文字的括号后面再接上另一个方括号，而在第二个方括号里面要填入用以辨识链接的标记：</p>
<pre><code>This is [an example][id] reference-style link.
</code></pre><p>你也可以选择性地在两个方括号中间加上一个空格：</p>
<pre><code>This is [an example] [id] reference-style link.
</code></pre><p>接着，在文件的任意处，你可以把这个标记的链接内容定义出来：</p>
<pre><code>[id]: http://example.com/  &quot;Optional Title Here&quot;
</code></pre><p>链接内容定义的形式为：</p>
<ul>
<li>方括号（前面可以选择性地加上至多三个空格来缩进），里面输入链接文字</li>
<li>接着一个冒号</li>
<li>接着一个以上的空格或制表符</li>
<li>接着链接的网址</li>
<li>选择性地接着 title 内容，可以用单引号、双引号或是括弧包着</li>
</ul>
<p>下面这三种链接的定义都是相同：</p>
<pre><code>[foo]: http://example.com/  &quot;Optional Title Here&quot;
[foo]: http://example.com/  &apos;Optional Title Here&apos;
[foo]: http://example.com/  (Optional Title Here)
</code></pre><p><strong>请注意：</strong>有一个已知的问题是 Markdown.pl 1.0.1 会忽略单引号包起来的链接 title。</p>
<p>链接网址也可以用方括号包起来：</p>
<pre><code>[id]: &lt;http://example.com/&gt;  &quot;Optional Title Here&quot;
</code></pre><p>你也可以把 title 属性放到下一行，也可以加一些缩进，若网址太长的话，这样会比较好看：</p>
<pre><code>[id]: http://example.com/longish/path/to/resource/here
    &quot;Optional Title Here&quot;
</code></pre><p>网址定义只有在产生链接的时候用到，并不会直接出现在文件之中。</p>
<p>链接辨别标签可以有字母、数字、空白和标点符号，但是并<em>不</em>区分大小写，因此下面两个链接是一样的：</p>
<pre><code>[link text][a]
[link text][A]
</code></pre><p><em>隐式链接标记</em>功能让你可以省略指定链接标记，这种情形下，链接标记会视为等同于链接文字，要用隐式链接标记只要在链接文字后面加上一个空的方括号，如果你要让 “Google” 链接到 google.com，你可以简化成：</p>
<pre><code>[Google][]
</code></pre><p>然后定义链接内容：</p>
<pre><code>[Google]: http://google.com/
</code></pre><p>由于链接文字可能包含空白，所以这种简化型的标记内也许包含多个单词：</p>
<pre><code>Visit [Daring Fireball][] for more information.
</code></pre><p>然后接着定义链接：</p>
<pre><code>[Daring Fireball]: http://daringfireball.net/
</code></pre><p>链接的定义可以放在文件中的任何一个地方，我比较偏好直接放在链接出现段落的后面，你也可以把它放在文件最后面，就像是注解一样。</p>
<p>下面是一个参考式链接的范例：</p>
<pre><code>I get 10 times more traffic from [Google] [1] than from
[Yahoo] [2] or [MSN] [3].

  [1]: http://google.com/        &quot;Google&quot;
  [2]: http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [3]: http://search.msn.com/    &quot;MSN Search&quot;
</code></pre><p>如果改成用链接名称的方式写：</p>
<pre><code>I get 10 times more traffic from [Google][] than from
[Yahoo][] or [MSN][].

  [google]: http://google.com/        &quot;Google&quot;
  [yahoo]:  http://search.yahoo.com/  &quot;Yahoo Search&quot;
  [msn]:    http://search.msn.com/    &quot;MSN Search&quot;
</code></pre><p>上面两种写法都会产生下面的 HTML。</p>
<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from
&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;
or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre><p>下面是用行内式写的同样一段内容的 Markdown 文件，提供作为比较之用：</p>
<pre><code>I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)
than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or
[MSN](http://search.msn.com/ &quot;MSN Search&quot;).
</code></pre><p>参考式的链接其实重点不在于它比较好写，而是它比较好读，比较一下上面的范例，使用参考式的文章本身只有 81 个字符，但是用行内形式的却会增加到 176 个字元，如果是用纯 HTML 格式来写，会有 234 个字元，在 HTML 格式中，标签比文本还要多。</p>
<p>使用 Markdown 的参考式链接，可以让文件更像是浏览器最后产生的结果，让你可以把一些标记相关的元数据移到段落文字之外，你就可以增加链接而不让文章的阅读感觉被打断。</p>
<h3 id="em">强调</h3>

<p>Markdown 使用星号（<code>*</code>）和底线（<code>_</code>）作为标记强调字词的符号，被 <code>*</code> 或 <code>_</code> 包围的字词会被转成用 <code>&lt;em&gt;</code> 标签包围，用两个 <code>*</code> 或 <code>_</code> 包起来的话，则会被转成 <code>&lt;strong&gt;</code>，例如：</p>
<pre><code>*single asterisks*

_single underscores_

**double asterisks**

__double underscores__
</code></pre><p>会转成：</p>
<pre><code>&lt;em&gt;single asterisks&lt;/em&gt;

&lt;em&gt;single underscores&lt;/em&gt;

&lt;strong&gt;double asterisks&lt;/strong&gt;

&lt;strong&gt;double underscores&lt;/strong&gt;
</code></pre><p>你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。</p>
<p>强调也可以直接插在文字中间：</p>
<pre><code>un*frigging*believable
</code></pre><p>但是<strong>如果你的 <code>*</code> 和 <code>_</code> 两边都有空白的话，它们就只会被当成普通的符号</strong>。</p>
<p>如果要在文字前后直接插入普通的星号或底线，你可以用反斜线：</p>
<pre><code>\*this text is surrounded by literal asterisks\*
</code></pre><h3 id="code">代码</h3>

<p>如果要标记一小段行内代码，你可以用反引号把它包起来（<code>` </code>），例如：</p>
<pre><code>Use the `printf()` function.
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt;
</code></pre><p>如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段：</p>
<pre><code>``There is a literal backtick (`) here.``
</code></pre><p>这段语法会产生：</p>
<pre><code>&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt;
</code></pre><p>代码区段的起始和结束端都可以放入一个空白，起始端后面一个，结束端前面一个，这样你就可以在区段的一开始就插入反引号：</p>
<pre><code>A single backtick in a code span: `` ` ``

A backtick-delimited string in a code span: `` `foo` ``
</code></pre><p>会产生：</p>
<pre><code>&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt;
</code></pre><p>在代码区段内，<code>&amp;</code> 和方括号<strong>都</strong>会被自动地转成 HTML 实体，这使得插入 HTML 原始码变得很容易，Markdown 会把下面这段：</p>
<pre><code>Please don&apos;t use any `&lt;blink&gt;` tags.
</code></pre><p>转为：</p>
<pre><code>&lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
</code></pre><p>你也可以这样写：</p>
<pre><code>`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`.
</code></pre><p>以产生：</p>
<pre><code>&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encoded
equivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt;
</code></pre><h3 id="img">图片</h3>

<p>很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。</p>
<p>Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： <em>行内式</em>和<em>参考式</em>。</p>
<p>行内式的图片语法看起来像是：</p>
<pre><code>![Alt text](/path/to/img.jpg)

![Alt text](/path/to/img.jpg &quot;Optional title&quot;)
</code></pre><p>详细叙述如下：</p>
<ul>
<li>一个惊叹号 <code>!</code></li>
<li>接着一个方括号，里面放上图片的替代文字</li>
<li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上<br>选择性的 ‘title’ 文字。</li>
</ul>
<p>参考式的图片语法则长得像这样：</p>
<pre><code>![Alt text][id]
</code></pre><p>「id」是图片参考的名称，图片参考的定义方式则和连结参考一样：</p>
<pre><code>[id]: url/to/image  &quot;Optional title attribute&quot;
</code></pre><p>到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 <code>&lt;img&gt;</code> 标签。</p>
<hr>
<h2 id="misc">其它</h2>

<h3 id="autolink">自动链接</h3>

<p>Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如：</p>
<pre><code>&lt;http://example.com/&gt;
</code></pre><p>Markdown 会转为：</p>
<pre><code>&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
</code></pre><p>邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如：</p>
<pre><code>&lt;address@example.com&gt;
</code></pre><p>Markdown 会转成：</p>
<pre><code>&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;
&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;
&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;
&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt;
</code></pre><p>在浏览器里面，这段字串（其实是 <code>&lt;a href=&quot;mailto:address@example.com&quot;&gt;address@example.com&lt;/a&gt;</code>）会变成一个可以点击的「address@example.com」链接。</p>
<p>（这种作法虽然可以糊弄不少的机器人，但并不能全部挡下来，不过总比什么都不做好些。不管怎样，公开你的信箱终究会引来广告信件的。）</p>
<h3 id="backslash">反斜杠</h3>

<p>Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果（但不用 <code>&lt;em&gt;</code> 标签），你可以在星号的前面加上反斜杠：</p>
<pre><code>\*literal asterisks\*
</code></pre><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p>
<pre><code>\   反斜线
`   反引号
*   星号
_   底线
{}  花括号
[]  方括号
()  括弧
#   井字号
+   加号
-   减号
.   英文句点
!   惊叹号
</code></pre><h2 id="acknowledgement">感谢</h2>

<p>感谢 <a href="https://twitter.com/#!/leafy7382" target="_blank" rel="external">leafy7382</a> 协助翻译，<a href="http://iamhlb.com/" target="_blank" rel="external">hlb</a>、<a href="http://twitter.com/randylien" target="_blank" rel="external">Randylien</a> 帮忙润稿，<a href="https://twitter.com/#!/ethantw" target="_blank" rel="external">ethantw</a> 的<a href="http://ethantw.net/projects/han/" target="_blank" rel="external">汉字标准格式・CSS Reset</a>， <a href="http://kidwm.net/" target="_blank" rel="external">WM</a> 回报文字错误。</p>
<p>感谢 <a href="https://github.com/fenprace" target="_blank" rel="external">fenprace</a>，<a href="https://github.com/addv" target="_blank" rel="external">addv</a>。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[markdown 快速入门]]></title>
      <url>http://www.ezlippi.com/blog/2014/07/markdown-basics.html</url>
      <content type="html"><![CDATA[<p>Markdown: Basics （快速入门） / (<a href="./markdown-syntax.html">点击查看完整语法说明</a>)</p>
<p>Getting the Gist of Markdown’s Formatting Syntax</p>
<p>此页提供了 Markdown 的简单概念， <a href="http://gitcafe.com/riku/Markdown-Syntax-CN/blob/master/syntax.md" title="Markdown Syntax" target="_blank" rel="external">语法说明</a> 页提供了完整详细的文档，说明了每项功能。但是 Markdown 其实很简单就可以上手，此页文档提供了一些范例，并且每个范例都会提供输出的 HTML 结果。</p>
<p>其实直接试试看也是一个很不错的方法， <a href="http://daringfireball.net/projects/markdown/dingus" title="Markdown Dingus" target="_blank" rel="external">Dingus</a> 是一个网页应用程序，你可以把自已编写的 Markdown 文档转成 XHTML。</p>
<h2 id="段落、标题、区块代码"><a href="#段落、标题、区块代码" class="headerlink" title="段落、标题、区块代码"></a>段落、标题、区块代码</h2><p>一个段落是由一个以上的连接的行句组成，而一个以上的空行则会划分出不同的段落（空行的定义是显示上看起来像是空行，就被视为空行，例如有一行只有空白和 tab，那该行也会被视为空行），一般的段落不需要用空白或换行缩进。</p>
<p>Markdown 支持两种标题的语法，<a href="http://docutils.sourceforge.net/mirror/setext.html" target="_blank" rel="external">Setext</a> 和 <a href="http://www.aaronsw.com/2002/atx/" target="_blank" rel="external">atx</a> 形式。Setext 形式是用底线的形式，利用 <code>=</code> （最高阶标题）和 <code>-</code> （第二阶标题），Atx 形式在行首插入 1 到 6 个 <code>#</code> ，对应到标题 1 到 6 阶。</p>
<p>区块引用则使用 email 形式的 ‘<code>&gt;</code>‘ 角括号。</p>
<p>Markdown 语法:</p>
<pre><code>A First Level Header
====================
A Second Level Header
---------------------

Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.

The quick brown fox jumped over the lazy
dog&apos;s back.
### Header 3

&gt; This is a blockquote.
&gt; 
&gt; This is the second paragraph in the blockquote.
&gt;
&gt; ## This is an H2 in a blockquote
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;h1&gt;A First Level Header&lt;/h1&gt;
&lt;h2&gt;A Second Level Header&lt;/h2&gt;
&lt;p&gt;Now is the time for all good men to come to
the aid of their country. This is just a
regular paragraph.&lt;/p&gt;
&lt;p&gt;The quick brown fox jumped over the lazy
dog&apos;s back.&lt;/p&gt;
&lt;h3&gt;Header 3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;This is a blockquote.&lt;/p&gt;
&lt;p&gt;This is the second paragraph in the blockquote.&lt;/p&gt;
&lt;h2&gt;This is an H2 in a blockquote&lt;/h2&gt;
&lt;/blockquote&gt;
</code></pre><h3 id="修辞和强调"><a href="#修辞和强调" class="headerlink" title="修辞和强调"></a>修辞和强调</h3><p>Markdown 使用星号和底线来标记需要强调的区段。</p>
<p>Markdown 语法:</p>
<pre><code>Some of these words *are emphasized*.
Some of these words _are emphasized also_.
Use two asterisks for **strong emphasis**.
Or, if you prefer, __use two underscores instead__.
</code></pre><p>输出 HTML 为:</p>
<pre><code>&lt;p&gt;Some of these words &lt;em&gt;are emphasized&lt;/em&gt;.
Some of these words &lt;em&gt;are emphasized also&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Use two asterisks for &lt;strong&gt;strong emphasis&lt;/strong&gt;.
Or, if you prefer, &lt;strong&gt;use two underscores instead&lt;/strong&gt;.&lt;/p&gt;
</code></pre><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表使用星号、加号和减号来做为列表的项目标记，这些符号是都可以使用的，使用星号：</p>
<pre><code>* Candy.
* Gum.
* Booze.
</code></pre><p>加号：</p>
<pre><code>+ Candy.
+ Gum.
+ Booze.
</code></pre><p>和减号</p>
<pre><code>- Candy.
- Gum.
- Booze.
</code></pre><p>都会输出 HTML 为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;Candy.&lt;/li&gt;
&lt;li&gt;Gum.&lt;/li&gt;
&lt;li&gt;Booze.&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>有序的列表则是使用一般的数字接着一个英文句点作为项目标记：</p>
<pre><code>1. Red
2. Green
3. Blue
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;ol&gt;
&lt;li&gt;Red&lt;/li&gt;
&lt;li&gt;Green&lt;/li&gt;
&lt;li&gt;Blue&lt;/li&gt;
&lt;/ol&gt;
</code></pre><p>如果你在项目之间插入空行，那项目的内容会用 <code>&lt;p&gt;</code> 包起来，你也可以在一个项目内放上多个段落，只要在它前面缩排 4 个空白或 1 个 tab 。</p>
<pre><code>* A list item.
With multiple paragraphs.

* Another item in the list.
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;ul&gt;
&lt;li&gt;&lt;p&gt;A list item.&lt;/p&gt;
&lt;p&gt;With multiple paragraphs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Another item in the list.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</code></pre><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>Markdown 支援两种形式的链接语法： <em>行内</em> 和 <em>参考</em> 两种形式，两种都是使用角括号来把文字转成连结。</p>
<p>行内形式是直接在后面用括号直接接上链接：</p>
<pre><code>This is an [example link](http://example.com/).
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot;&gt;
example link&lt;/a&gt;.&lt;/p&gt;
</code></pre><p>你也可以选择性的加上 title 属性：</p>
<pre><code>This is an [example link](http://example.com/ &quot;With a Title&quot;).
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;This is an &lt;a href=&quot;http://example.com/&quot; title=&quot;With a Title&quot;&gt;
example link&lt;/a&gt;.&lt;/p&gt;
</code></pre><p>参考形式的链接让你可以为链接定一个名称，之后你可以在文件的其他地方定义该链接的内容：</p>
<pre><code>I get 10 times more traffic from [Google][1] than from
[Yahoo][2] or [MSN][3].

[1]: http://google.com/ &quot;Google&quot;
[2]: http://search.yahoo.com/ &quot;Yahoo Search&quot;
[3]: http://search.msn.com/ &quot;MSN Search&quot;
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;
title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from &lt;a href=&quot;http://search.yahoo.com/&quot;
title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt; or &lt;a href=&quot;http://search.msn.com/&quot;
title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt;
</code></pre><p>title 属性是选择性的，链接名称可以用字母、数字和空格，但是不分大小写：</p>
<pre><code>I start my morning with a cup of coffee and
[The New York Times][NY Times].

[ny times]: http://www.nytimes.com/
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;I start my morning with a cup of coffee and
&lt;a href=&quot;http://www.nytimes.com/&quot;&gt;The New York Times&lt;/a&gt;.&lt;/p&gt;
</code></pre><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>图片的语法和链接很像。</p>
<p>行内形式（title 是选择性的）：</p>
<pre><code>![alt text](/path/to/img.jpg &quot;Title&quot;)
</code></pre><p>参考形式：</p>
<pre><code>![alt text][id]

[id]: /path/to/img.jpg &quot;Title&quot;
</code></pre><p>上面两种方法都会输出 HTML 为：</p>
<pre><code>&lt;img src=&quot;/path/to/img.jpg&quot; alt=&quot;alt text&quot; title=&quot;Title&quot; /&gt;
</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>在一般的段落文字中，你可以使用反引号 <code>` </code> 来标记代码区段，区段内的 <code>&amp;</code>、<code>&lt;</code> 和 <code>&gt;</code> 都会被自动的转换成 HTML 实体，这项特性让你可以很容易的在代码区段内插入 HTML 码：</p>
<pre><code>I strongly recommend against using any `&lt;blink&gt;` tags.

I wish SmartyPants used named entities like `&amp;mdash;`
instead of decimal-encoded entites like `&amp;#8212;`.
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;I strongly recommend against using any
&lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt;
&lt;p&gt;I wish SmartyPants used named entities like
&lt;code&gt;&amp;amp;mdash;&lt;/code&gt; instead of decimal-encoded
entites like &lt;code&gt;&amp;amp;#8212;&lt;/code&gt;.&lt;/p&gt;
</code></pre><p>如果要建立一个已经格式化好的代码区块，只要每行都缩进 4 个空格或是一个 tab 就可以了，而 <code>&amp;</code>、<code>&lt;</code> 和 <code>&gt;</code> 也一样会自动转成 HTML 实体。</p>
<p>Markdown 语法:</p>
<pre><code>If you want your page to validate under XHTML 1.0 Strict,
you&apos;ve got to put paragraph tags in your blockquotes:

&lt;blockquote&gt;
&lt;p&gt;For example.&lt;/p&gt;
&lt;/blockquote&gt;
</code></pre><p>输出 HTML 为：</p>
<pre><code>&lt;p&gt;If you want your page to validate under XHTML 1.0 Strict,
you&apos;ve got to put paragraph tags in your blockquotes:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;For example.&amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[C语言高级编程指南]]></title>
      <url>http://www.ezlippi.com/blog/2014/07/c-advaced-programming.html</url>
      <content type="html"><![CDATA[<h2 id="整形溢出和提升"><a href="#整形溢出和提升" class="headerlink" title="整形溢出和提升"></a>整形溢出和提升</h2><p>大部分 C 程序员都以为基本的整形操作都是安全的其实不然,看下面这个例子,<br>你觉得输出结果是什么:</p>
<pre><code>int main(int argc, char** argv) {
    long i = -1;

    if (i &lt; sizeof(i)) {
         printf(&quot;OK\n&quot;);
    }
    else {
         printf(&quot;error\n&quot;);
    }

    return 0;
}
</code></pre><a id="more"></a>
<p>当一个变量转换成无符号整形时,i的值不再是-1,而是 size_t的最大值,因<br>为sizeof操作返回的是一个 size_t类型的无符号数。<br>在C99/C11标准里写道:</p>
<blockquote>
<p>“If the operand that has unsigned integer type has rank greater or<br>equal to the rank of the type of the other operand, then the operand<br>with signed integer type is converted to the type of the operand with<br>unsigned integer type.”</p>
</blockquote>
<p>在C标准里面 size_t至少是一个 16 位的无符号整数,对于给定的架构 size_t 一般对应long,所以sizeof（int）和size_t至少相等,这就带来了可移植性的问题,C标准没有定义 short, int,long,longlong的大小,只是说明了他们的最小长度,对于 x86_64 架构,long在Linux下是64位,而在64位Windows下是32位。一般的方法是采用固定长度的类型比如定义在C99头文件stdint.h中的uint16_t,int32_t,uint_least16_t,uint_fast16_t等。</p>
<p>如果 int可以表示原始类型的所有值,那么这个操作数会转换成 int,否则<br>他会转换成 unsigned int。下面这个函数在 32 位平台返回 65536,但是在 16 位系统返回 0。</p>
<pre><code>uint32_t sum()
{
    uint16_t a = 65535;
    uint16_t b = 1;
    return a+b;
}
</code></pre><p>对于char 类型到底是 signed 还是 unsigned 取决于硬件架构和操作系统,通常<br>由特定平台的 ABI(Application Binary Interface) 指定,如果是 signed char,下面的代码输出-128 和-127,否则输出 128,129(x86 架构)。</p>
<pre><code>char c = 128;
char d = 129;
printf(&quot;%d,%d\n&quot;,c,d);
</code></pre><h2 id="内存管理和分配"><a href="#内存管理和分配" class="headerlink" title="内存管理和分配"></a>内存管理和分配</h2><p>malloc 函数分配制定字节大小的内存,对象未被初始化,如果 size 是 0 取<br>决与系统实现。malloc(0)返回一个空指针或者 unique pointer,如果 size 是表达式的运算结果,确保没有整形溢出。</p>
<blockquote>
<p>“If the size of the space requested is 0, the behavior is<br>implementation- defined: the value returned shall be either a null<br>pointer or a unique pointer.”</p>
</blockquote>
<pre><code>size_t computed_size;

if (elem_size &amp;&amp; num &gt; SIZE_MAX / elem_size) {
    errno = ENOMEM;
    err(1, &quot;overflow&quot;);
}

computed_size = elem_size*num;
</code></pre><p>malloc不会给分配的内存初始化，如果要对新分配的内存初始化，可以用calloc代替malloc,一般情况下给序列分配相等大小的元素时,用calloc来代替用表达式计算大小,calloc 会把内存初始化为 0。</p>
<p>realloc 用来对已经分配内存的对象改变大小,如果新的 size 更大,额外的空间<br>没 有 被 初 始 化 , 如 果 提 供 给 realloc 的 指 针 是 空 指 针 , realloc 就 等 效 于malloc,如果原指针非空而 new size是0,结果依赖于操作系统的具体实现。</p>
<blockquote>
<p>“In case of failure realloc shall return NULL and leave provided memory<br>object intact. Thus it is important not only to check for integer<br>overflow of size argument, but also to correctly handle object size if<br>realloc fails.”</p>
</blockquote>
<p>下面这段代码可以带你领会malloc,calloc，realloc,free的用法：</p>
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdint.h&gt;
#include &lt;malloc.h&gt;
#include &lt;errno.h&gt;

#define VECTOR_OK            0
#define VECTOR_NULL_ERROR    1
#define VECTOR_SIZE_ERROR    2
#define VECTOR_ALLOC_ERROR   3

struct vector {
    int *data;
    size_t size;
};

int create_vector(struct vector *vc, size_t num) {

    if (vc == NULL) {
        return VECTOR_NULL_ERROR;
    }

    vc-&gt;data = 0;
    vc-&gt;size = 0;

    /* check for integer and SIZE_MAX overflow */
    if (num == 0 || SIZE_MAX / num &lt; sizeof(int)) {
        errno = ENOMEM;
        return VECTOR_SIZE_ERROR;
    }

    vc-&gt;data = calloc(num, sizeof(int));

    /* calloc faild */
    if (vc-&gt;data == NULL) {
        return VECTOR_ALLOC_ERROR;
    }

    vc-&gt;size = num * sizeof(int);
    return VECTOR_OK;
}

int grow_vector(struct vector *vc) {

    void *newptr = 0;
    size_t newsize;

    if (vc == NULL) {
        return VECTOR_NULL_ERROR;
    }


    /* check for integer and SIZE_MAX overflow */
    if (vc-&gt;size == 0 || SIZE_MAX / 2 &lt; vc-&gt;size) {
        errno = ENOMEM;
        return VECTOR_SIZE_ERROR;
    }

    newsize = vc-&gt;size * 2;

    newptr = realloc(vc-&gt;data, newsize);

    /* realloc faild; vector stays intact size was not changed */
    if (newptr == NULL) {
        return VECTOR_ALLOC_ERROR;
    }

    /* upon success; update new address and size */
    vc-&gt;data = newptr;
    vc-&gt;size = newsize;
    return VECTOR_OK;
}
</code></pre><hr>
<h2 id="避免重大错误"><a href="#避免重大错误" class="headerlink" title="避免重大错误"></a>避免重大错误</h2><ol>
<li><p>使用未初始化的变量，<br>C语言要求所有变量在使用之前要初始化，使用未初始化的变量会造成为定义的行为，这和C++不同，C++保证所有变量在使用之前都得到初始化，Java<strong>尽量保证</strong>变量使用前的得到初始化，如类基本数据成员会被初始化为默认值。</p>
</li>
<li><p>free错误<br>对空指针调用 free,对不是由 malloc family 函数分配的指针调用 free,或者对<br>已经调用 free 的指针再次调用 free。<br>一开始初始化指针为NULL可以减少错误,GCC和Clang编译器有-Wuninitialized 选项来对未初始化的变量显示警告信息,另外不要将同一个指针用于静态变量和动态变量。</p>
</li>
</ol>
<blockquote>
<pre><code>char *ptr = NULL;
void nullfree(void **pptr) {
    void *ptr = *pptr;
    assert(ptr != NULL)
    free(ptr);
    *pptr = NULL;
}
</code></pre></blockquote>
<p>3.对空指针解引用，数组越界访问</p>
<p>对NULL指针或者free’d内存解引用，数组越界访问，是很明显的错误，为了消除这种错误，一般的做法就是增加数组越界检查的功能，比如Java里的array就有下标检查的功能，但是这样会带来严重的性能代价，我们要修改ABI（application binary interface），让每个指针都跟随着它的范围信息，在数值计算中cost is terrible。</p>
<p>4.违反类型规则</p>
<p>把int×指针cast成float×，然后对它解引用，在C里面会引发undefined behavior，C规定这种类型的转换需要使用memset，C++里面有个reinterpret_cast函数用于无关类型之间的转换，reinterpret_cast <new_type> (expression)</new_type></p>
<hr>
<h2 id="防止内存泄漏"><a href="#防止内存泄漏" class="headerlink" title="防止内存泄漏"></a>防止内存泄漏</h2><p>内存泄漏发生在程序不再使用的动态内存没有得到释放，这需要我们掌握动态分配对象的作用域，尤其是什么时候该调用free来释放内存，常用的集中方法如下：</p>
<ol>
<li><p>在程序启动的时候分配<br>在程序启动的时候分配需要的heap memory，程序退出时把释放的任务交给操作系统，这种方法一般适用于程序运行后马上退出的那种。</p>
</li>
<li><p>使用变长数组（VLA）<br>如果你需要一块变长大小的空间并且作用域在函数中，变长数组可以帮到你，但是也有一个限制，一个函数中的变长数组内存大小一般不超过几百字节，这个数字C标准没有明确的定义，最好是把内存分配到栈上，在栈上允许分配的最大VLA内存是SIZE_MAX，掌握目标平台的栈大小可以有效的防止栈溢出。</p>
</li>
<li><p>使用引用计数<br>引用计数是一个很好的管理内存的方法，特别是当你不希望自己定义的对象被复制时，每一次赋值把引用计数加1,每次失去引用就把引用计数减1,当引用计数等于0时，以为的对象已经不再需要了，我们需要释放对象占用的内存，由于C不提供自动的析构函数，我们必须手动释放内存，看一个例子：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

#define MAX_REF_OBJ 100
#define RC_ERROR -1

struct mem_obj_t{
    void *ptr;
    uint16_t count;
};

static struct mem_obj_t references[MAX_REF_OBJ];
static uint16_t reference_count = 0;

/* create memory object and return handle */
uint16_t create(size_t size){

    if (reference_count &gt;= MAX_REF_OBJ)
        return RC_ERROR;

if (size){
  void *ptr = calloc(1, size);

if (ptr != NULL){
    references[reference_count].ptr = ptr;
    references[reference_count].count = 0;
    return reference_count++;
                }
        }

    return RC_ERROR;
}
</code></pre></li>
</ol>
<pre><code>/* get memory object and increment reference counter */
void* retain(uint16_t handle){

if(handle &lt; reference_count &amp;&amp; handle &gt;= 0){
    references[handle].count++;
    return references[handle].ptr;
    } else {
        return NULL;
    }
}

/* decrement reference counter */
void release(uint16_t handle){
printf(&quot;release\n&quot;);

if(handle &lt; reference_count &amp;&amp; handle &gt;= 0){
    struct mem_obj_t *object = &amp;references[handle];

    if (object-&gt;count &lt;= 1){
        printf(&quot;released\n&quot;);
    free(object-&gt;ptr);
    reference_count--;
} else {
    printf(&quot;decremented\n&quot;);
    object-&gt;count--;
        }
     }
}
</code></pre><p>C++标准库有个auto_ptr智能指针，能够自动释放指针所指对象的内存，C++ boost库有个boost：：shared_ptr智能指针，内置引用计数，支持拷贝和赋值，看下面这个例子：</p>
<blockquote>
<p>“Objects of shared_ptr types have the ability of taking ownership of a pointer and share that ownership: once they take ownership, the group of owners of a pointer become responsible for its deletion when the last one of them releases that ownership.”</p>
</blockquote>
<pre><code>#include &lt;boost/smart_ptr.hpp&gt;
#include &lt;iostream&gt;
int main()
{
    // Basic useage
    boost::shared_ptr&lt;int&gt; p1(new int(10));
    std::cout &lt;&lt; &quot;ref count of p1: &quot; &lt;&lt; p1.use_count() &lt;&lt; std::endl;
    boost::shared_ptr&lt;int&gt; p2(p1); // or p2 = p1;
    std::cout &lt;&lt; &quot;ref count of p1: &quot; &lt;&lt; p1.use_count() &lt;&lt; std::endl;
    *p1 = 999;
    std::cout &lt;&lt; &quot;*p2: &quot; &lt;&lt; *p2 &lt;&lt; std::endl;
    p2.reset();
    std::cout &lt;&lt; &quot;ref count of p1: &quot; &lt;&lt; p1.use_count() &lt;&lt; std::endl;
    return 0;
}
</code></pre><p> 4.内存池，有利于减少内存碎片，看下面这个例子：</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &lt;stdint.h&gt;

struct mem_pool_t{
void* ptr;//指向内存池起始地址
size_t size;//内存池大小
size_t used;//已用内存大小
};

//create memory pool
struct mem_pool_t* create_pool(size_t size){
mem_pool_t* pool=calloc(1,sizeof(struct men_pool_t));
if(pool!=NULL){
void* mem=calloc(1,size);
if(mem!=NULL){
pool-&gt;ptr=mem;
pool-&gt;size=size;
pool-&gt;used=0;
return pool;
        }
    }
return NULL;
}

//allocate memory from pool
void* pool_alloc(mem_pool_t* pool,size_t size){
if(pool=NULL)
    return NULL;
size_t bytes_left=pool-&gt;size-pool-&gt;used;
if(size&amp;&amp;size&lt;=bytes_left){
    void* mem=pool-&gt;ptr+pool-&gt;used;
    pool-&gt;used+=size;
    return mem;
    }
return NULL；
}

／／release memory of the pool
void pool_free(mem_pool_t* pool){
if(pool!=NULL){
free(pool-&gt;ptr);
free(pool);
 }
}
</code></pre><p> 5.垃圾回收机制<br> 引用计数采用的方法是当内存不再需要时得到手动释放，垃圾回收发生在内存分配失败或者内存到达一定的水位（watermarks），实现垃圾回收最简单的一个算法是MARK AND SWEEP算法，该算法的思路是遍历所有动态分配对象的内存，标记那些还能继续使用的，回收那些没有被标记的内存。<br>    Java采用的垃圾回收机制就更复杂了，思路也是回收那些不再使用的内存，JAVA的垃圾回收和C++的析构函数又不一样，C++保证对象在使用之前得到初始化，对象超出作用域之后内存得到释放，而JAVA不能保证对象一定被析构。 </p>
<hr>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>我们一般的概念里指针和数组名是可互换的，但是在编译器里他们被不同的对待，当我们说一个对象或者表达式具有某种类型的时候我们一般是说这个对象是个左值（lvalue），当对象不是const的时候，左值是可以修改的，比如对象是复制操作符的左参数，而数组名是一个const左值，指向地一个元素的const指针，所以你不能给数组名赋值或者意图改变数组名，如果表达式是数组类型，数组名通常转换成指向地一个元素的指针。</p>
<p>但是也有例外，什么情况下数组名不是一个指针呢？<br>1.当它是sizeof操作符的操作数时，返回数组占的内存字节数<br>2.当它是取地址操作&amp;的操作数时，返回一个数组的地址</p>
<p>看下面这个例子：</p>
<pre><code>short a[] = {1,2,3};
short *pa;
short (*px)[];

void init(){
    pa = a;
    px = &amp;a;

    printf(&quot;a:%p; pa:%p; px:%p\n&quot;, a, pa, px);

    printf(&quot;a[1]:%i; pa[1]:%i (*px)[1]:%i\n&quot;, a[1], pa[1],(*px)[1]);
}
</code></pre><p>a是一个short类型数组，pa是一个指向short类型的指针，px呢？<br>px是一个指向数组类型的指针，在a被赋值给pa之前，他的值被转换成一个指向数组第一个元素的指针，下面那个a却没有转换，因为遇到的是&amp;操作符。<br>数组下标a[1]等价于<em>(a+1),和p[1]一样，也指向</em>(p+1)，但是两者还是有区别的，a是一个数组，它实际上存储的是第一个元素的地址，所以数组a是用来定位第一个元素的，而pa不一样，它就是一个指针，不是用来定位的。<br>再比如：</p>
<pre><code>int a[10];
int b[10];
int *a;
c=&amp;a[0];//c是指向数组a地一个元素的指针
c=a;//a自动转换成指向第一个元素的指针，实际上是指针拷贝
b=a;//非法的，你不能用赋值符把一个数组的所有元素赋给另一个数组
a=c;//非法的，你不能修改const指针的值
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Java编程Tips]]></title>
      <url>http://www.ezlippi.com/blog/2014/06/26-methods-to-improve-java-performance.html</url>
      <content type="html"><![CDATA[<p>原文： <a href="http://www.iteye.com/magazines/66" target="_blank" rel="external">Java编程中“为了性能”尽量要做到的一些地方</a></p>
<p>作者： <a href="http://javatgo.iteye.com/" target="_blank" rel="external">javatgo</a></p>
<hr>
<p>最近的机器内存又爆满了，除了新增机器内存外，还应该好好review一下我们的代码，有很多代码编写过于随意化，这些不好的习惯或对程序语言的不了解是应该好好打压打压了。</p>
<p>下面是参考网络资源总结的一些在Java编程中尽可能要做到的一些地方。<br><a id="more"></a></p>
<h2 id="1-尽量在合适的场合使用单例"><a href="#1-尽量在合适的场合使用单例" class="headerlink" title="1. 尽量在合适的场合使用单例"></a>1. 尽量在合适的场合使用单例</h2><p>使用单例可以减轻加载的负担，缩短加载的时间，提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>
<ol><br><li>控制资源的使用，通过线程同步来控制资源的并发访问；</li><br><li>控制实例的产生，以达到节约资源的目的；</li><br><li>控制数据共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</li><br></ol>

<h2 id="2-尽量避免随意使用静态变量"><a href="#2-尽量避免随意使用静态变量" class="headerlink" title="2. 尽量避免随意使用静态变量"></a>2. 尽量避免随意使用静态变量</h2><p>要知道，当某个对象被定义为stataic变量所引用，那么gc通常是不会回收这个对象所占有的内存，如</p>
<pre><code>public class A{  
    static B b = new B();  
}  
</code></pre><p>此时静态变量b的生命周期与A类同步，如果A类不会卸载，那么b对象会常驻内存，直到程序终止。</p>
<h2 id="3-尽量避免过多过常的创建Java对象"><a href="#3-尽量避免过多过常的创建Java对象" class="headerlink" title="3. 尽量避免过多过常的创建Java对象"></a>3. 尽量避免过多过常的创建Java对象</h2><p>尽量避免在经常调用的方法，循环中new对象，由于系统不仅要花费时间来创建对象，而且还要花时间对这些对象进行垃圾回收和处理，在我们可以控制的范围内，最大限度的重用对象，最好能用基本的数据类型或数组来替代对象。</p>
<h2 id="4-尽量使用final修饰符"><a href="#4-尽量使用final修饰符" class="headerlink" title="4. 尽量使用final修饰符"></a>4. 尽量使用final修饰符</h2><p>带有final修饰符的类是不可派生的。</p>
<p>在Java核心API中，有许多应用final的例子，例如java.lang.String。为String类指定final防止了使用者覆盖length()方法。</p>
<p>另外，如果一个类是final的，则该类所有方法都是final的。Java编译器会寻找机会内联（inline）所有的final方法（这和具体的编译器实现有关）。此举能够使性能平均提高50%。</p>
<h2 id="5-尽量使用局部变量"><a href="#5-尽量使用局部变量" class="headerlink" title="5. 尽量使用局部变量"></a>5. 尽量使用局部变量</h2><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈（Stack）中，速度较快。</p>
<p>其他变量，如静态变量、实例变量等，都在堆（Heap）中创建，速度较慢。</p>
<h2 id="6-尽量处理好包装类型和基本类型两者的使用场所"><a href="#6-尽量处理好包装类型和基本类型两者的使用场所" class="headerlink" title="6. 尽量处理好包装类型和基本类型两者的使用场所"></a>6. 尽量处理好包装类型和基本类型两者的使用场所</h2><p>虽然包装类型和基本类型在使用过程中是可以相互转换，但它们两者所产生的内存区域是完全不同的，基本类型数据产生和处理都在栈中处理，包装类型是对象，是在堆中产生实例。</p>
<p>在集合类对象，有对象方面需要的处理适用包装类型，其他的处理提倡使用基本类型。</p>
<h2 id="7-慎用synchronized，尽量减小synchronize的方法"><a href="#7-慎用synchronized，尽量减小synchronize的方法" class="headerlink" title="7. 慎用synchronized，尽量减小synchronize的方法"></a>7. 慎用synchronized，尽量减小synchronize的方法</h2><p>都知道，实现同步是要很大的系统开销作为代价的，甚至可能造成死锁，所以尽量避免无谓的同步控制。</p>
<p>synchronize方法被调用时，直接会把当前对象锁 了，在方法执行完之前其他线程无法调用当前对象的其他方法。</p>
<p>所以synchronize的方法尽量小，并且应尽量使用方法同步代替代码块同步。</p>
<h2 id="8-尽量使用StringBuilder和StringBuffer进行字符串连接"><a href="#8-尽量使用StringBuilder和StringBuffer进行字符串连接" class="headerlink" title="8. 尽量使用StringBuilder和StringBuffer进行字符串连接"></a>8. 尽量使用StringBuilder和StringBuffer进行字符串连接</h2><p>这个就不多讲了。</p>
<h2 id="9-尽量不要使用finalize方法"><a href="#9-尽量不要使用finalize方法" class="headerlink" title="9. 尽量不要使用finalize方法"></a>9. 尽量不要使用finalize方法</h2><p>实际上，将资源清理放在finalize方法中完成是非常不好的选择，由于GC的工作量很大，尤其是回收Young代内存时，大都会引起应用程序暂停，所以再选择使用finalize方法进行资源清理，会导致GC负担更大，程序运行效率更差。</p>
<h2 id="10-尽量使用基本数据类型代替对象"><a href="#10-尽量使用基本数据类型代替对象" class="headerlink" title="10. 尽量使用基本数据类型代替对象"></a>10. 尽量使用基本数据类型代替对象</h2><pre><code>String str = &quot;hello&quot;;
</code></pre><p>上面这种方式会创建一个“hello”字符串，而且JVM的字符缓存池还会缓存这个字符串；</p>
<pre><code>String str = new String(&quot;hello&quot;);
</code></pre><p>此时程序除创建字符串外，str所引用的String对象底层还包含一个char[]数组，这个char[]数组依次存放了h,e,l,l,o</p>
<h2 id="11-单线程应尽量使用HashMap、ArrayList"><a href="#11-单线程应尽量使用HashMap、ArrayList" class="headerlink" title="11. 单线程应尽量使用HashMap、ArrayList"></a>11. 单线程应尽量使用HashMap、ArrayList</h2><p>HashTable、Vector等使用了同步机制，降低了性能。</p>
<h2 id="12-尽量合理的创建HashMap"><a href="#12-尽量合理的创建HashMap" class="headerlink" title="12. 尽量合理的创建HashMap"></a>12. 尽量合理的创建HashMap</h2><p>当你要创建一个比较大的hashMap时，充分利用另一个构造函数<br>public HashMap(int initialCapacity, float loadFactor)<br>避免HashMap多次进行了hash重构,扩容是一件很耗费性能的事，在默认中initialCapacity只有16，而loadFactor是 0.75，需要多大的容量，你最好能准确的估计你所需要的最佳大小，同样的Hashtable，Vectors也是一样的道理。</p>
<h2 id="13-尽量减少对变量的重复计算"><a href="#13-尽量减少对变量的重复计算" class="headerlink" title="13. 尽量减少对变量的重复计算"></a>13. 尽量减少对变量的重复计算</h2><p>如</p>
<pre><code>for(int i=0;i&lt;list.size();i++)
</code></pre><p>应该改为</p>
<pre><code>for(int i=0,len=list.size();i&lt;len;i++)
</code></pre><p>并且在循环中应该避免使用复杂的表达式，在循环中，循环条件会被反复计算，如果不使用复杂表达式，而使循环条件值不变的话，程序将会运行的更快。 </p>
<h2 id="14-尽量避免不必要的创建"><a href="#14-尽量避免不必要的创建" class="headerlink" title="14. 尽量避免不必要的创建"></a>14. 尽量避免不必要的创建</h2><p>如</p>
<pre><code>A a = new A();
if(i==1){list.add(a);}
</code></pre><p>应该改为</p>
<pre><code>if(i==1){
A a = new A();
list.add(a);}
</code></pre><h2 id="15-尽量在finally块中释放资源"><a href="#15-尽量在finally块中释放资源" class="headerlink" title="15. 尽量在finally块中释放资源"></a>15. 尽量在finally块中释放资源</h2><p>程序中使用到的资源应当被释放，以避免资源泄漏。</p>
<p>这最好在finally块中去做。不管程序执行的结果如何，finally块总是会执行的，以确保资源的正确关闭。 </p>
<h2 id="16-尽量使用移位来代替’a-b’的操作"><a href="#16-尽量使用移位来代替’a-b’的操作" class="headerlink" title="16. 尽量使用移位来代替’a/b’的操作"></a>16. 尽量使用移位来代替’a/b’的操作</h2><p>“/“是一个代价很高的操作，使用移位的操作将会更快和更有效</p>
<p>如</p>
<pre><code>int num = a / 4;
int num = a / 8;
</code></pre><p>应该改为</p>
<pre><code>int num = a &gt;&gt; 2;
int num = a &gt;&gt; 3;
</code></pre><p>但注意的是使用移位应添加注释，因为移位操作不直观，比较难理解</p>
<h2 id="17-尽量使用移位来代替’a-b’的操作"><a href="#17-尽量使用移位来代替’a-b’的操作" class="headerlink" title="17.尽量使用移位来代替’a*b’的操作"></a>17.尽量使用移位来代替’a*b’的操作</h2><p>同样的，对于’*‘操作，使用移位的操作将会更快和更有效</p>
<p>如</p>
<pre><code>int num = a * 4;
int num = a * 8;
</code></pre><p>应该改为</p>
<pre><code>int num = a &lt;&lt; 2;
int num = a &lt;&lt; 3;
</code></pre><h2 id="18-尽量确定StringBuffer的容量"><a href="#18-尽量确定StringBuffer的容量" class="headerlink" title="18. 尽量确定StringBuffer的容量"></a>18. 尽量确定StringBuffer的容量</h2><p>StringBuffer 的构造器会创建一个默认大小（通常是16）的字符数组。在使用中，如果超出这个大小，就会重新分配内存，创建一个更大的数组，并将原先的数组复制过来，再 丢弃旧的数组。</p>
<p>在大多数情况下，你可以在创建 StringBuffer的时候指定大小，这样就避免了在容量不够的时候自动增长，以提高性能。 </p>
<p>如：</p>
<pre><code>StringBuffer buffer = new StringBuffer(1000);  
</code></pre><h2 id="19-尽量早释放无用对象的引用"><a href="#19-尽量早释放无用对象的引用" class="headerlink" title="19. 尽量早释放无用对象的引用"></a>19. 尽量早释放无用对象的引用</h2><p>大部分时，方法局部引用变量所引用的对象 会随着方法结束而变成垃圾，因此，大部分时候程序无需将局部，引用变量显式设为null。</p>
<p>例如：</p>
<pre><code>Public void test(){  
    Object obj = new Object();  
    ……  
    Obj=null;  
}  
</code></pre><p>上面这个就没必要了，随着方法test()的执行完成，程序中obj引用变量的作用域就结束了。</p>
<p>但是如果是改成下面：</p>
<pre><code>Public void test(){  
    Object obj = new Object();  
    ……  
    Obj=null;  
    //执行耗时，耗内存操作；或调用耗时，耗内存的方法  
    ……  
}  
</code></pre><p>这时候就有必要将obj赋值为null，可以尽早的释放对Object对象的引用。</p>
<h2 id="20-尽量避免使用二维数组"><a href="#20-尽量避免使用二维数组" class="headerlink" title="20. 尽量避免使用二维数组"></a>20. 尽量避免使用二维数组</h2><p>二维数据占用的内存空间比一维数组多得多，大概10倍以上。</p>
<h2 id="21-尽量避免使用split"><a href="#21-尽量避免使用split" class="headerlink" title="21. 尽量避免使用split"></a>21. 尽量避免使用split</h2><p>除非是必须的，否则应该避免使用split，split由于支持正则表达式，所以效率比较低，如果是频繁的几十，几百万的调用将会耗费大量资源，如果确实需 要频繁的调用split，可以考虑使用apache的StringUtils.split(string,char)，频繁split的可以缓存结果。</p>
<h2 id="22-ArrayList-amp-LinkedList"><a href="#22-ArrayList-amp-LinkedList" class="headerlink" title="22. ArrayList &amp; LinkedList"></a>22. ArrayList &amp; LinkedList</h2><p>一个是线性表，一个是链表，一句话，随机查询尽量使用ArrayList，ArrayList优于LinkedList，LinkedList还要移动指 针，添加删除的操作LinkedList优于ArrayList，ArrayList还要移动数据，不过这是理论性分析，事实未必如此，重要的是理解好2 者得数据结构，对症下药。</p>
<h2 id="23-尽量使用System-arraycopy-代替通过来循环复制数组"><a href="#23-尽量使用System-arraycopy-代替通过来循环复制数组" class="headerlink" title="23. 尽量使用System.arraycopy ()代替通过来循环复制数组"></a>23. 尽量使用System.arraycopy ()代替通过来循环复制数组</h2><p>System.arraycopy() 要比通过循环来复制数组快的多 </p>
<h2 id="24-尽量缓存经常使用的对象"><a href="#24-尽量缓存经常使用的对象" class="headerlink" title="24. 尽量缓存经常使用的对象"></a>24. 尽量缓存经常使用的对象</h2><p>尽可能将经常使用的对象进行缓存，可以使用数组，或HashMap的容器来进行缓存，但这种方式可能导致系统占用过多的缓存，性能下降，推荐可以使用一些第三方的开源工具，如EhCache，Oscache进行缓存，他们基本都实现了FIFO/FLU等缓存算法。</p>
<h2 id="25-尽量避免非常大的内存分配"><a href="#25-尽量避免非常大的内存分配" class="headerlink" title="25. 尽量避免非常大的内存分配"></a>25. 尽量避免非常大的内存分配</h2><p>有时候问题不是由当时的堆状态造成的，而是因为分配失败造成的。分配的内存块都必须是连续的，而随着堆越来越满，找到较大的连续块越来越困难。</p>
<h2 id="26-慎用异常"><a href="#26-慎用异常" class="headerlink" title="26. 慎用异常"></a>26. 慎用异常</h2><p>当创建一个异常时，需要收集一个栈跟踪(stack track)，这个栈跟踪用于描述异常是在何处创建的。<br>构建这些栈跟踪时需要为运行时栈做一份快照，正是这一部分开销很大。</p>
<p>当需要创建一个 Exception 时，JVM 不得不说：先别动，我想就您现在的样子存一份快照，所以暂时停止入栈和出栈操作。<br>栈跟踪不只包含运行时栈中的一两个元素，而是包含这个栈中的每一个元素。</p>
<p>如果您创建一个 Exception ，就得付出代价。好在捕获异常开销不大，因此可以使用 try-catch 将核心内容包起来。<br>从技术上讲，您甚至可以随意地抛出异常，而不用花费很大的代价。<br>招致性能损失的并不是 throw 操作——尽管在没有预先创建异常的情况下就抛出异常是有点不寻常。<br>真正要花代价的是创建异常。</p>
<p>幸运的是，好的编程习惯已教会我们，不应该不管三七二十一就抛出异常。</p>
<p>异常是为异常的情况而设计的，使用时也应该牢记这一原则。</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[在雨中]]></title>
      <url>http://www.ezlippi.com/blog/2014/06/blog/2014/06/15/in-the-rain.html.html</url>
      <content type="html"><![CDATA[<p>我的个人博客上线了．</p>
]]></content>
    </entry>
    
  
  
</search>
